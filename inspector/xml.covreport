htmlIsBooleanAttr:
  320|      1|{
  321|      1|    int i = 0;
  322|       |
  323|      2|    while (htmlBooleanAttrs[i] != NULL) {
  ------------------
  |  Branch (323:12): [True: 2, False: 0]
  ------------------
  324|      2|        if (xmlStrcasecmp((const xmlChar *)htmlBooleanAttrs[i], name) == 0)
  ------------------
  |  Branch (324:13): [True: 1, False: 1]
  ------------------
  325|      1|            return 1;
  326|      1|        i++;
  327|      1|    }
  328|      0|    return 0;
  329|      1|}

xmlSAX2InternalSubset:
  326|    570|{
  327|    570|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  328|    570|    xmlDtdPtr dtd;
  329|    570|    if (ctx == NULL) return;
  ------------------
  |  Branch (329:9): [True: 0, False: 570]
  ------------------
  330|       |
  331|    570|    if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (331:9): [True: 0, False: 570]
  ------------------
  332|      0|	return;
  333|    570|    dtd = xmlGetIntSubset(ctxt->myDoc);
  334|    570|    if (dtd != NULL) {
  ------------------
  |  Branch (334:9): [True: 0, False: 570]
  ------------------
  335|      0|	if (ctxt->html)
  ------------------
  |  Branch (335:6): [True: 0, False: 0]
  ------------------
  336|      0|	    return;
  337|      0|	xmlUnlinkNode((xmlNodePtr) dtd);
  338|      0|	xmlFreeDtd(dtd);
  339|      0|	ctxt->myDoc->intSubset = NULL;
  340|      0|    }
  341|    570|    ctxt->myDoc->intSubset =
  342|    570|	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
  343|    570|    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (343:9): [True: 0, False: 570]
  ------------------
  344|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");
  345|    570|}
xmlSAX2ExternalSubset:
  359|    537|{
  360|    537|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  361|    537|    if (ctx == NULL) return;
  ------------------
  |  Branch (361:9): [True: 0, False: 537]
  ------------------
  362|    537|    if (((ExternalID != NULL) || (SystemID != NULL)) &&
  ------------------
  |  Branch (362:10): [True: 120, False: 417]
  |  Branch (362:34): [True: 81, False: 336]
  ------------------
  363|    537|        (((ctxt->validate) || (ctxt->loadsubset != 0)) &&
  ------------------
  |  Branch (363:11): [True: 0, False: 201]
  |  Branch (363:31): [True: 201, False: 0]
  ------------------
  364|    201|	 (ctxt->wellFormed && ctxt->myDoc))) {
  ------------------
  |  Branch (364:4): [True: 201, False: 0]
  |  Branch (364:24): [True: 201, False: 0]
  ------------------
  365|       |	/*
  366|       |	 * Try to fetch and parse the external subset.
  367|       |	 */
  368|    201|	xmlParserInputPtr oldinput;
  369|    201|	int oldinputNr;
  370|    201|	int oldinputMax;
  371|    201|	xmlParserInputPtr *oldinputTab;
  372|    201|	xmlParserInputPtr input = NULL;
  373|    201|	const xmlChar *oldencoding;
  374|    201|	int oldprogressive;
  375|    201|        unsigned long consumed;
  376|    201|        size_t buffered;
  377|       |
  378|       |	/*
  379|       |	 * Ask the Entity resolver to load the damn thing
  380|       |	 */
  381|    201|	if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))
  ------------------
  |  Branch (381:6): [True: 201, False: 0]
  |  Branch (381:29): [True: 201, False: 0]
  ------------------
  382|    201|	    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,
  383|    201|	                                        SystemID);
  384|    201|	if (input == NULL) {
  ------------------
  |  Branch (384:6): [True: 138, False: 63]
  ------------------
  385|    138|	    return;
  386|    138|	}
  387|       |
  388|     63|	xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);
  389|       |
  390|       |	/*
  391|       |	 * make sure we won't destroy the main document context
  392|       |	 */
  393|     63|	oldinput = ctxt->input;
  394|     63|	oldinputNr = ctxt->inputNr;
  395|     63|	oldinputMax = ctxt->inputMax;
  396|     63|	oldinputTab = ctxt->inputTab;
  397|     63|	oldencoding = ctxt->encoding;
  398|     63|        oldprogressive = ctxt->progressive;
  399|     63|	ctxt->encoding = NULL;
  400|     63|        ctxt->progressive = 0;
  401|       |
  402|     63|	ctxt->inputTab = (xmlParserInputPtr *)
  403|     63|	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
  404|     63|	if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (404:6): [True: 0, False: 63]
  ------------------
  405|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset");
  406|      0|            xmlFreeInputStream(input);
  407|      0|	    ctxt->input = oldinput;
  408|      0|	    ctxt->inputNr = oldinputNr;
  409|      0|	    ctxt->inputMax = oldinputMax;
  410|      0|	    ctxt->inputTab = oldinputTab;
  411|      0|	    ctxt->encoding = oldencoding;
  412|      0|            ctxt->progressive = oldprogressive;
  413|      0|	    return;
  414|      0|	}
  415|     63|	ctxt->inputNr = 0;
  416|     63|	ctxt->inputMax = 5;
  417|     63|	ctxt->input = NULL;
  418|     63|	xmlPushInput(ctxt, input);
  419|       |
  420|     63|	if (input->filename == NULL)
  ------------------
  |  Branch (420:6): [True: 0, False: 63]
  ------------------
  421|      0|	    input->filename = (char *) xmlCanonicPath(SystemID);
  422|     63|	input->line = 1;
  423|     63|	input->col = 1;
  424|     63|	input->base = ctxt->input->cur;
  425|     63|	input->cur = ctxt->input->cur;
  426|     63|	input->free = NULL;
  427|       |
  428|       |	/*
  429|       |	 * let's parse that entity knowing it's an external subset.
  430|       |	 */
  431|     63|	xmlParseExternalSubset(ctxt, ExternalID, SystemID);
  432|       |
  433|       |        /*
  434|       |	 * Free up the external entities
  435|       |	 */
  436|       |
  437|     63|	while (ctxt->inputNr > 1)
  ------------------
  |  Branch (437:9): [True: 0, False: 63]
  ------------------
  438|      0|	    xmlPopInput(ctxt);
  439|       |
  440|     63|        consumed = ctxt->input->consumed;
  441|     63|        buffered = ctxt->input->cur - ctxt->input->base;
  442|     63|        if (buffered > ULONG_MAX - consumed)
  ------------------
  |  Branch (442:13): [True: 0, False: 63]
  ------------------
  443|      0|            consumed = ULONG_MAX;
  444|     63|        else
  445|     63|            consumed += buffered;
  446|     63|        if (consumed > ULONG_MAX - ctxt->sizeentities)
  ------------------
  |  Branch (446:13): [True: 0, False: 63]
  ------------------
  447|      0|            ctxt->sizeentities = ULONG_MAX;
  448|     63|        else
  449|     63|            ctxt->sizeentities += consumed;
  450|       |
  451|     63|	xmlFreeInputStream(ctxt->input);
  452|     63|        xmlFree(ctxt->inputTab);
  453|       |
  454|       |	/*
  455|       |	 * Restore the parsing context of the main entity
  456|       |	 */
  457|     63|	ctxt->input = oldinput;
  458|     63|	ctxt->inputNr = oldinputNr;
  459|     63|	ctxt->inputMax = oldinputMax;
  460|     63|	ctxt->inputTab = oldinputTab;
  461|     63|	if ((ctxt->encoding != NULL) &&
  ------------------
  |  Branch (461:6): [True: 9, False: 54]
  ------------------
  462|     63|	    ((ctxt->dict == NULL) ||
  ------------------
  |  Branch (462:7): [True: 0, False: 9]
  ------------------
  463|      9|	     (!xmlDictOwns(ctxt->dict, ctxt->encoding))))
  ------------------
  |  Branch (463:7): [True: 9, False: 0]
  ------------------
  464|      9|	    xmlFree((xmlChar *) ctxt->encoding);
  465|     63|	ctxt->encoding = oldencoding;
  466|     63|        ctxt->progressive = oldprogressive;
  467|       |	/* ctxt->wellFormed = oldwellFormed; */
  468|     63|    }
  469|    537|}
xmlSAX2ResolveEntity:
  487|    201|{
  488|    201|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  489|    201|    xmlParserInputPtr ret;
  490|    201|    xmlChar *URI;
  491|    201|    const char *base = NULL;
  492|       |
  493|    201|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (493:9): [True: 0, False: 201]
  ------------------
  494|    201|    if (ctxt->input != NULL)
  ------------------
  |  Branch (494:9): [True: 201, False: 0]
  ------------------
  495|    201|	base = ctxt->input->filename;
  496|    201|    if (base == NULL)
  ------------------
  |  Branch (496:9): [True: 67, False: 134]
  ------------------
  497|     67|	base = ctxt->directory;
  498|       |
  499|    201|    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  500|       |
  501|    201|    ret = xmlLoadExternalEntity((const char *) URI,
  502|    201|				(const char *) publicId, ctxt);
  503|    201|    if (URI != NULL)
  ------------------
  |  Branch (503:9): [True: 201, False: 0]
  ------------------
  504|    201|	xmlFree(URI);
  505|    201|    return(ret);
  506|    201|}
xmlSAX2GetEntity:
  519|   167k|{
  520|   167k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  521|   167k|    xmlEntityPtr ret = NULL;
  522|       |
  523|   167k|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (523:9): [True: 0, False: 167k]
  ------------------
  524|       |
  525|   167k|    if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (525:9): [True: 166k, False: 1.03k]
  ------------------
  526|   166k|	ret = xmlGetPredefinedEntity(name);
  527|   166k|	if (ret != NULL)
  ------------------
  |  Branch (527:6): [True: 0, False: 166k]
  ------------------
  528|      0|	    return(ret);
  529|   166k|    }
  530|   167k|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->standalone == 1)) {
  ------------------
  |  Branch (530:9): [True: 167k, False: 0]
  |  Branch (530:34): [True: 24, False: 167k]
  ------------------
  531|     24|	if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (531:6): [True: 0, False: 24]
  ------------------
  532|      0|	    ctxt->myDoc->standalone = 0;
  533|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  534|      0|	    ctxt->myDoc->standalone = 1;
  535|     24|	} else {
  536|     24|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  537|     24|	    if (ret == NULL) {
  ------------------
  |  Branch (537:10): [True: 0, False: 24]
  ------------------
  538|      0|		ctxt->myDoc->standalone = 0;
  539|      0|		ret = xmlGetDocEntity(ctxt->myDoc, name);
  540|      0|		if (ret != NULL) {
  ------------------
  |  Branch (540:7): [True: 0, False: 0]
  ------------------
  541|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
  542|      0|	 "Entity(%s) document marked standalone but requires external subset\n",
  543|      0|				   name, NULL);
  544|      0|		}
  545|      0|		ctxt->myDoc->standalone = 1;
  546|      0|	    }
  547|     24|	}
  548|   167k|    } else {
  549|   167k|	ret = xmlGetDocEntity(ctxt->myDoc, name);
  550|   167k|    }
  551|   167k|    return(ret);
  552|   167k|}
xmlSAX2GetParameterEntity:
  565|   104k|{
  566|   104k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  567|   104k|    xmlEntityPtr ret;
  568|       |
  569|   104k|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (569:9): [True: 0, False: 104k]
  ------------------
  570|       |
  571|   104k|    ret = xmlGetParameterEntity(ctxt->myDoc, name);
  572|   104k|    return(ret);
  573|   104k|}
xmlSAX2EntityDecl:
  590|  1.75k|{
  591|  1.75k|    xmlEntityPtr ent;
  592|  1.75k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  593|       |
  594|  1.75k|    if (ctx == NULL) return;
  ------------------
  |  Branch (594:9): [True: 0, False: 1.75k]
  ------------------
  595|  1.75k|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (595:9): [True: 1.23k, False: 513]
  ------------------
  596|  1.23k|	ent = xmlAddDocEntity(ctxt->myDoc, name, type, publicId,
  597|  1.23k|		              systemId, content);
  598|  1.23k|	if ((ent == NULL) && (ctxt->pedantic))
  ------------------
  |  Branch (598:6): [True: 6, False: 1.23k]
  |  Branch (598:23): [True: 0, False: 6]
  ------------------
  599|      0|	    xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,
  600|      0|	     "Entity(%s) already defined in the internal subset\n",
  601|      0|	               name);
  602|  1.23k|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (602:6): [True: 1.23k, False: 6]
  |  Branch (602:23): [True: 1.23k, False: 0]
  |  Branch (602:45): [True: 54, False: 1.17k]
  ------------------
  603|     54|	    xmlChar *URI;
  604|     54|	    const char *base = NULL;
  605|       |
  606|     54|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (606:10): [True: 54, False: 0]
  ------------------
  607|     54|		base = ctxt->input->filename;
  608|     54|	    if (base == NULL)
  ------------------
  |  Branch (608:10): [True: 18, False: 36]
  ------------------
  609|     18|		base = ctxt->directory;
  610|       |
  611|     54|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  612|     54|	    ent->URI = URI;
  613|     54|	}
  614|  1.23k|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (614:16): [True: 513, False: 0]
  ------------------
  615|    513|	ent = xmlAddDtdEntity(ctxt->myDoc, name, type, publicId,
  616|    513|		              systemId, content);
  617|    513|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (617:6): [True: 0, False: 513]
  |  Branch (617:23): [True: 0, False: 0]
  ------------------
  618|    513|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (618:6): [True: 0, False: 0]
  |  Branch (618:29): [True: 0, False: 0]
  ------------------
  619|      0|	    ctxt->sax->warning(ctxt->userData,
  620|      0|	     "Entity(%s) already defined in the external subset\n", name);
  621|    513|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (621:6): [True: 513, False: 0]
  |  Branch (621:23): [True: 513, False: 0]
  |  Branch (621:45): [True: 6, False: 507]
  ------------------
  622|      6|	    xmlChar *URI;
  623|      6|	    const char *base = NULL;
  624|       |
  625|      6|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (625:10): [True: 6, False: 0]
  ------------------
  626|      6|		base = ctxt->input->filename;
  627|      6|	    if (base == NULL)
  ------------------
  |  Branch (627:10): [True: 0, False: 6]
  ------------------
  628|      0|		base = ctxt->directory;
  629|       |
  630|      6|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  631|      6|	    ent->URI = URI;
  632|      6|	}
  633|    513|    } else {
  634|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
  635|      0|	               "SAX.xmlSAX2EntityDecl(%s) called while not in subset\n",
  636|      0|		       name, NULL);
  637|      0|    }
  638|  1.75k|}
xmlSAX2AttributeDecl:
  656|  5.83k|{
  657|  5.83k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  658|  5.83k|    xmlAttributePtr attr;
  659|  5.83k|    xmlChar *name = NULL, *prefix = NULL;
  660|       |
  661|       |    /* Avoid unused variable warning if features are disabled. */
  662|  5.83k|    (void) attr;
  663|       |
  664|  5.83k|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (664:9): [True: 0, False: 5.83k]
  |  Branch (664:27): [True: 0, False: 5.83k]
  ------------------
  665|      0|        return;
  666|       |
  667|  5.83k|    if ((xmlStrEqual(fullname, BAD_CAST "xml:id")) &&
  ------------------
  |  |   35|  5.83k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (667:9): [True: 3, False: 5.83k]
  ------------------
  668|  5.83k|        (type != XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (668:9): [True: 3, False: 0]
  ------------------
  669|       |	/*
  670|       |	 * Raise the error but keep the validity flag
  671|       |	 */
  672|      3|	int tmp = ctxt->valid;
  673|      3|	xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
  674|      3|	      "xml:id : attribute type should be ID\n", NULL, NULL);
  675|      3|	ctxt->valid = tmp;
  676|      3|    }
  677|       |    /* TODO: optimize name/prefix allocation */
  678|  5.83k|    name = xmlSplitQName(ctxt, fullname, &prefix);
  679|  5.83k|    ctxt->vctxt.valid = 1;
  680|  5.83k|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (680:9): [True: 2.69k, False: 3.14k]
  ------------------
  681|  2.69k|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,
  682|  2.69k|	       name, prefix, (xmlAttributeType) type,
  683|  2.69k|	       (xmlAttributeDefault) def, defaultValue, tree);
  684|  3.14k|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (684:14): [True: 3.14k, False: 0]
  ------------------
  685|  3.14k|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,
  686|  3.14k|	   name, prefix, (xmlAttributeType) type,
  687|  3.14k|	   (xmlAttributeDefault) def, defaultValue, tree);
  688|      0|    else {
  689|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  690|      0|	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
  691|      0|	               name, NULL);
  692|      0|	xmlFree(name);
  693|      0|	xmlFreeEnumeration(tree);
  694|      0|	return;
  695|      0|    }
  696|  5.83k|#ifdef LIBXML_VALID_ENABLED
  697|  5.83k|    if (ctxt->vctxt.valid == 0)
  ------------------
  |  Branch (697:9): [True: 18, False: 5.81k]
  ------------------
  698|     18|	ctxt->valid = 0;
  699|  5.83k|    if ((attr != NULL) && (ctxt->validate) && (ctxt->wellFormed) &&
  ------------------
  |  Branch (699:9): [True: 5.83k, False: 3]
  |  Branch (699:27): [True: 0, False: 5.83k]
  |  Branch (699:47): [True: 0, False: 0]
  ------------------
  700|  5.83k|        (ctxt->myDoc->intSubset != NULL))
  ------------------
  |  Branch (700:9): [True: 0, False: 0]
  ------------------
  701|      0|	ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,
  702|      0|	                                        attr);
  703|  5.83k|#endif /* LIBXML_VALID_ENABLED */
  704|  5.83k|    if (prefix != NULL)
  ------------------
  |  Branch (704:9): [True: 234, False: 5.60k]
  ------------------
  705|    234|	xmlFree(prefix);
  706|  5.83k|    if (name != NULL)
  ------------------
  |  Branch (706:9): [True: 5.83k, False: 0]
  ------------------
  707|  5.83k|	xmlFree(name);
  708|  5.83k|}
xmlSAX2ElementDecl:
  722|  2.33k|{
  723|  2.33k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  724|  2.33k|    xmlElementPtr elem = NULL;
  725|       |
  726|       |    /* Avoid unused variable warning if features are disabled. */
  727|  2.33k|    (void) elem;
  728|       |
  729|  2.33k|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (729:9): [True: 0, False: 2.33k]
  |  Branch (729:27): [True: 0, False: 2.33k]
  ------------------
  730|      0|        return;
  731|       |
  732|  2.33k|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (732:9): [True: 1.21k, False: 1.11k]
  ------------------
  733|  1.21k|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->intSubset,
  734|  1.21k|                                 name, (xmlElementTypeVal) type, content);
  735|  1.11k|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (735:14): [True: 1.11k, False: 0]
  ------------------
  736|  1.11k|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->extSubset,
  737|  1.11k|                                 name, (xmlElementTypeVal) type, content);
  738|      0|    else {
  739|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  740|      0|	     "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
  741|      0|	               name, NULL);
  742|      0|        return;
  743|      0|    }
  744|  2.33k|#ifdef LIBXML_VALID_ENABLED
  745|  2.33k|    if (elem == NULL)
  ------------------
  |  Branch (745:9): [True: 3, False: 2.33k]
  ------------------
  746|      3|        ctxt->valid = 0;
  747|  2.33k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (747:9): [True: 0, False: 2.33k]
  |  Branch (747:27): [True: 0, False: 0]
  ------------------
  748|  2.33k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (748:9): [True: 0, False: 0]
  |  Branch (748:24): [True: 0, False: 0]
  ------------------
  749|      0|        ctxt->valid &=
  750|      0|            xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
  751|  2.33k|#endif /* LIBXML_VALID_ENABLED */
  752|  2.33k|}
xmlSAX2UnparsedEntityDecl:
  816|      3|{
  817|      3|    xmlEntityPtr ent;
  818|      3|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  819|      3|    if (ctx == NULL) return;
  ------------------
  |  Branch (819:9): [True: 0, False: 3]
  ------------------
  820|      3|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (820:9): [True: 3, False: 0]
  ------------------
  821|      3|	ent = xmlAddDocEntity(ctxt->myDoc, name,
  822|      3|			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
  823|      3|			publicId, systemId, notationName);
  824|      3|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (824:6): [True: 0, False: 3]
  |  Branch (824:23): [True: 0, False: 0]
  ------------------
  825|      3|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (825:6): [True: 0, False: 0]
  |  Branch (825:29): [True: 0, False: 0]
  ------------------
  826|      0|	    ctxt->sax->warning(ctxt->userData,
  827|      0|	     "Entity(%s) already defined in the internal subset\n", name);
  828|      3|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (828:6): [True: 3, False: 0]
  |  Branch (828:23): [True: 3, False: 0]
  |  Branch (828:45): [True: 3, False: 0]
  ------------------
  829|      3|	    xmlChar *URI;
  830|      3|	    const char *base = NULL;
  831|       |
  832|      3|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (832:10): [True: 3, False: 0]
  ------------------
  833|      3|		base = ctxt->input->filename;
  834|      3|	    if (base == NULL)
  ------------------
  |  Branch (834:10): [True: 1, False: 2]
  ------------------
  835|      1|		base = ctxt->directory;
  836|       |
  837|      3|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  838|      3|	    ent->URI = URI;
  839|      3|	}
  840|      3|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (840:16): [True: 0, False: 0]
  ------------------
  841|      0|	ent = xmlAddDtdEntity(ctxt->myDoc, name,
  842|      0|			XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,
  843|      0|			publicId, systemId, notationName);
  844|      0|	if ((ent == NULL) && (ctxt->pedantic) &&
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  |  Branch (844:23): [True: 0, False: 0]
  ------------------
  845|      0|	    (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))
  ------------------
  |  Branch (845:6): [True: 0, False: 0]
  |  Branch (845:29): [True: 0, False: 0]
  ------------------
  846|      0|	    ctxt->sax->warning(ctxt->userData,
  847|      0|	     "Entity(%s) already defined in the external subset\n", name);
  848|      0|	if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {
  ------------------
  |  Branch (848:6): [True: 0, False: 0]
  |  Branch (848:23): [True: 0, False: 0]
  |  Branch (848:45): [True: 0, False: 0]
  ------------------
  849|      0|	    xmlChar *URI;
  850|      0|	    const char *base = NULL;
  851|       |
  852|      0|	    if (ctxt->input != NULL)
  ------------------
  |  Branch (852:10): [True: 0, False: 0]
  ------------------
  853|      0|		base = ctxt->input->filename;
  854|      0|	    if (base == NULL)
  ------------------
  |  Branch (854:10): [True: 0, False: 0]
  ------------------
  855|      0|		base = ctxt->directory;
  856|       |
  857|      0|	    URI = xmlBuildURI(systemId, (const xmlChar *) base);
  858|      0|	    ent->URI = URI;
  859|      0|	}
  860|      0|    } else {
  861|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  862|      0|	     "SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\n",
  863|      0|	               name, NULL);
  864|      0|    }
  865|      3|}
xmlSAX2SetDocumentLocator:
  877|    966|{
  878|    966|}
xmlSAX2StartDocument:
  888|    966|{
  889|    966|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|    966|    xmlDocPtr doc;
  891|       |
  892|    966|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 966]
  ------------------
  893|       |
  894|    966|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 0, False: 966]
  ------------------
  895|      0|#ifdef LIBXML_HTML_ENABLED
  896|      0|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 0, False: 0]
  ------------------
  897|      0|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      0|	    return;
  901|      0|	}
  902|      0|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|      0|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|    966|    } else {
  913|    966|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|    966|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 966, False: 0]
  ------------------
  915|    966|	    doc->properties = 0;
  916|    966|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 0, False: 966]
  ------------------
  917|      0|	        doc->properties |= XML_DOC_OLD10;
  918|    966|	    doc->parseFlags = ctxt->options;
  919|    966|	    doc->standalone = ctxt->standalone;
  920|    966|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|    966|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 966, False: 0]
  |  Branch (924:27): [True: 966, False: 0]
  ------------------
  925|    966|	    doc->dict = ctxt->dict;
  926|    966|	    xmlDictReference(doc->dict);
  927|    966|	}
  928|    966|    }
  929|    966|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 966, False: 0]
  |  Branch (929:34): [True: 966, False: 0]
  ------------------
  930|    966|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 966, False: 0]
  |  Branch (930:27): [True: 644, False: 322]
  ------------------
  931|    644|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|    644|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 644]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|    644|    }
  935|    966|}
xmlSAX2EndDocument:
  945|    873|{
  946|    873|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|    873|    xmlDocPtr doc;
  948|       |
  949|    873|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 873]
  ------------------
  950|    873|#ifdef LIBXML_VALID_ENABLED
  951|    873|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 0, False: 873]
  |  Branch (951:27): [True: 0, False: 0]
  ------------------
  952|    873|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 0, False: 0]
  |  Branch (952:24): [True: 0, False: 0]
  ------------------
  953|      0|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|    873|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|    873|    doc = ctxt->myDoc;
  957|    873|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 871, False: 2]
  |  Branch (957:26): [True: 871, False: 0]
  ------------------
  958|    871|        const xmlChar *encoding = NULL;
  959|       |
  960|    871|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|    871|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 94, False: 777]
  ------------------
  961|    871|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|    777|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 9, False: 768]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|    103|            encoding = ctxt->encoding;
  964|    768|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 729, False: 39]
  |  Branch (964:42): [True: 0, False: 729]
  ------------------
  965|      0|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  966|    768|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    768|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 768]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|    871|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 97, False: 774]
  ------------------
  971|     97|            doc->encoding = xmlStrdup(encoding);
  972|     97|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 0, False: 97]
  ------------------
  973|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|     97|        }
  975|    871|    }
  976|    873|}
xmlSAX2StartElementNs:
 2087|  42.9k|{
 2088|  42.9k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2089|  42.9k|    xmlNodePtr ret;
 2090|  42.9k|    xmlNodePtr parent;
 2091|  42.9k|    xmlNsPtr last = NULL, ns;
 2092|  42.9k|    const xmlChar *uri, *pref;
 2093|  42.9k|    xmlChar *lname = NULL;
 2094|  42.9k|    int i, j;
 2095|       |
 2096|  42.9k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2096:9): [True: 0, False: 42.9k]
  ------------------
 2097|       |    /*
 2098|       |     * First check on validity:
 2099|       |     */
 2100|  42.9k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (2100:9): [True: 0, False: 42.9k]
  |  Branch (2100:27): [True: 0, False: 0]
  ------------------
 2101|  42.9k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (2101:10): [True: 0, False: 0]
  ------------------
 2102|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (2102:4): [True: 0, False: 0]
  ------------------
 2103|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (2103:4): [True: 0, False: 0]
  ------------------
 2104|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (2104:4): [True: 0, False: 0]
  ------------------
 2105|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (2105:4): [True: 0, False: 0]
  ------------------
 2106|      0|	xmlErrValid(ctxt, XML_DTD_NO_DTD,
 2107|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 2108|      0|	ctxt->validate = 0;
 2109|      0|    }
 2110|       |
 2111|       |    /*
 2112|       |     * Take care of the rare case of an undefined namespace prefix
 2113|       |     */
 2114|  42.9k|    if ((prefix != NULL) && (URI == NULL)) {
  ------------------
  |  Branch (2114:9): [True: 1.42k, False: 41.5k]
  |  Branch (2114:29): [True: 9, False: 1.41k]
  ------------------
 2115|      9|        if (ctxt->dictNames) {
  ------------------
  |  Branch (2115:13): [True: 9, False: 0]
  ------------------
 2116|      9|	    const xmlChar *fullname;
 2117|       |
 2118|      9|	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);
 2119|      9|	    if (fullname != NULL)
  ------------------
  |  Branch (2119:10): [True: 9, False: 0]
  ------------------
 2120|      9|	        localname = fullname;
 2121|      9|	} else {
 2122|      0|	    lname = xmlBuildQName(localname, prefix, NULL, 0);
 2123|      0|	}
 2124|      9|    }
 2125|       |    /*
 2126|       |     * allocate the node
 2127|       |     */
 2128|  42.9k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2128:9): [True: 836, False: 42.1k]
  ------------------
 2129|    836|        ret = ctxt->freeElems;
 2130|    836|	ctxt->freeElems = ret->next;
 2131|    836|	ctxt->freeElemsNr--;
 2132|    836|	memset(ret, 0, sizeof(xmlNode));
 2133|    836|        ret->doc = ctxt->myDoc;
 2134|    836|	ret->type = XML_ELEMENT_NODE;
 2135|       |
 2136|    836|	if (ctxt->dictNames)
  ------------------
  |  Branch (2136:6): [True: 836, False: 0]
  ------------------
 2137|    836|	    ret->name = localname;
 2138|      0|	else {
 2139|      0|	    if (lname == NULL)
  ------------------
  |  Branch (2139:10): [True: 0, False: 0]
  ------------------
 2140|      0|		ret->name = xmlStrdup(localname);
 2141|      0|	    else
 2142|      0|	        ret->name = lname;
 2143|      0|	    if (ret->name == NULL) {
  ------------------
  |  Branch (2143:10): [True: 0, False: 0]
  ------------------
 2144|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2145|      0|                xmlFree(ret);
 2146|      0|		return;
 2147|      0|	    }
 2148|      0|	}
 2149|    836|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2149:6): [True: 0, False: 836]
  |  Branch (2149:34): [True: 0, False: 0]
  ------------------
 2150|      0|	    xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2151|  42.1k|    } else {
 2152|  42.1k|	if (ctxt->dictNames)
  ------------------
  |  Branch (2152:6): [True: 42.1k, False: 0]
  ------------------
 2153|  42.1k|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2154|  42.1k|	                               (xmlChar *) localname, NULL);
 2155|      0|	else if (lname == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 2157|      0|	else
 2158|      0|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2159|      0|	                               (xmlChar *) lname, NULL);
 2160|  42.1k|	if (ret == NULL) {
  ------------------
  |  Branch (2160:6): [True: 0, False: 42.1k]
  ------------------
 2161|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2162|      0|	    return;
 2163|      0|	}
 2164|  42.1k|    }
 2165|  42.9k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2165:9): [True: 42.9k, False: 51]
  ------------------
 2166|  42.9k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2166:6): [True: 42.9k, False: 0]
  ------------------
 2167|  42.9k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2167:10): [True: 42.9k, False: 0]
  ------------------
 2168|  42.9k|		ret->line = ctxt->input->line;
 2169|      0|	    else
 2170|      0|	        ret->line = USHRT_MAX;
 2171|  42.9k|	}
 2172|  42.9k|    }
 2173|       |
 2174|       |    /*
 2175|       |     * Build the namespace list
 2176|       |     */
 2177|  43.2k|    for (i = 0,j = 0;j < nb_namespaces;j++) {
  ------------------
  |  Branch (2177:22): [True: 309, False: 42.9k]
  ------------------
 2178|    309|        pref = namespaces[i++];
 2179|    309|	uri = namespaces[i++];
 2180|    309|	ns = xmlNewNs(NULL, uri, pref);
 2181|    309|	if (ns != NULL) {
  ------------------
  |  Branch (2181:6): [True: 309, False: 0]
  ------------------
 2182|    309|	    if (last == NULL) {
  ------------------
  |  Branch (2182:10): [True: 231, False: 78]
  ------------------
 2183|    231|	        ret->nsDef = last = ns;
 2184|    231|	    } else {
 2185|     78|	        last->next = ns;
 2186|     78|		last = ns;
 2187|     78|	    }
 2188|    309|	    if ((URI != NULL) && (prefix == pref))
  ------------------
  |  Branch (2188:10): [True: 267, False: 42]
  |  Branch (2188:27): [True: 195, False: 72]
  ------------------
 2189|    195|		ret->ns = ns;
 2190|    309|	} else {
 2191|       |            /*
 2192|       |             * any out of memory error would already have been raised
 2193|       |             * but we can't be guaranteed it's the actual error due to the
 2194|       |             * API, best is to skip in this case
 2195|       |             */
 2196|      0|	    continue;
 2197|      0|	}
 2198|       |
 2199|    309|        xmlParserNsUpdateSax(ctxt, pref, ns);
 2200|       |
 2201|    309|#ifdef LIBXML_VALID_ENABLED
 2202|    309|	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2202:6): [True: 309, False: 0]
  |  Branch (2202:23): [True: 0, False: 309]
  |  Branch (2202:41): [True: 0, False: 0]
  ------------------
 2203|    309|	    ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (2203:6): [True: 0, False: 0]
  |  Branch (2203:21): [True: 0, False: 0]
  ------------------
 2204|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 2205|      0|	                                           ret, prefix, ns, uri);
 2206|      0|	}
 2207|    309|#endif /* LIBXML_VALID_ENABLED */
 2208|    309|    }
 2209|  42.9k|    ctxt->nodemem = -1;
 2210|       |
 2211|       |    /* Initialize parent before pushing node */
 2212|  42.9k|    parent = ctxt->node;
 2213|  42.9k|    if (parent == NULL)
  ------------------
  |  Branch (2213:9): [True: 849, False: 42.1k]
  ------------------
 2214|    849|        parent = (xmlNodePtr) ctxt->myDoc;
 2215|       |
 2216|       |    /*
 2217|       |     * We are parsing a new node.
 2218|       |     */
 2219|  42.9k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (2219:9): [True: 0, False: 42.9k]
  ------------------
 2220|      0|        xmlUnlinkNode(ret);
 2221|      0|        xmlFreeNode(ret);
 2222|      0|        return;
 2223|      0|    }
 2224|       |
 2225|       |    /*
 2226|       |     * Link the child element
 2227|       |     */
 2228|  42.9k|    xmlAddChild(parent, ret);
 2229|       |
 2230|       |    /*
 2231|       |     * Insert the defaulted attributes from the DTD only if requested:
 2232|       |     */
 2233|  42.9k|    if ((nb_defaulted != 0) &&
  ------------------
  |  Branch (2233:9): [True: 1.08k, False: 41.8k]
  ------------------
 2234|  42.9k|        ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
  ------------------
  |  |  150|  1.08k|#define XML_COMPLETE_ATTRS	4
  ------------------
  |  Branch (2234:9): [True: 1.08k, False: 0]
  ------------------
 2235|  1.08k|	nb_attributes -= nb_defaulted;
 2236|       |
 2237|       |    /*
 2238|       |     * Search the namespace if it wasn't already found
 2239|       |     * Note that, if prefix is NULL, this searches for the default Ns
 2240|       |     */
 2241|  42.9k|    if ((URI != NULL) && (ret->ns == NULL)) {
  ------------------
  |  Branch (2241:9): [True: 1.73k, False: 41.2k]
  |  Branch (2241:26): [True: 1.54k, False: 195]
  ------------------
 2242|  1.54k|        ret->ns = xmlParserNsLookupSax(ctxt, prefix);
 2243|  1.54k|	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2243:6): [True: 9, False: 1.53k]
  |  Branch (2243:27): [True: 3, False: 6]
  ------------------
 2244|      3|	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 2245|      3|	}
 2246|  1.54k|	if (ret->ns == NULL) {
  ------------------
  |  Branch (2246:6): [True: 6, False: 1.53k]
  ------------------
 2247|      6|	    ns = xmlNewNs(ret, NULL, prefix);
 2248|      6|	    if (ns == NULL) {
  ------------------
  |  Branch (2248:10): [True: 0, False: 6]
  ------------------
 2249|       |
 2250|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2251|      0|		return;
 2252|      0|	    }
 2253|      6|            if (prefix != NULL)
  ------------------
  |  Branch (2253:17): [True: 3, False: 3]
  ------------------
 2254|      3|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2255|      3|                             "Namespace prefix %s was not found\n",
 2256|      3|                             prefix, NULL);
 2257|      3|            else
 2258|      3|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2259|      3|                             "Namespace default prefix was not found\n",
 2260|      3|                             NULL, NULL);
 2261|      6|	}
 2262|  1.54k|    }
 2263|       |
 2264|       |    /*
 2265|       |     * process all the other attributes
 2266|       |     */
 2267|  42.9k|    if (nb_attributes > 0) {
  ------------------
  |  Branch (2267:9): [True: 34.6k, False: 8.32k]
  ------------------
 2268|  34.6k|        xmlAttrPtr prev = NULL;
 2269|       |
 2270|  98.7k|        for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {
  ------------------
  |  Branch (2270:26): [True: 64.0k, False: 34.6k]
  ------------------
 2271|  64.0k|            xmlAttrPtr attr = NULL;
 2272|       |
 2273|       |	    /*
 2274|       |	     * Handle the rare case of an undefined attribute prefix
 2275|       |	     */
 2276|  64.0k|	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {
  ------------------
  |  Branch (2276:10): [True: 603, False: 63.4k]
  |  Branch (2276:39): [True: 0, False: 603]
  ------------------
 2277|      0|		if (ctxt->dictNames) {
  ------------------
  |  Branch (2277:7): [True: 0, False: 0]
  ------------------
 2278|      0|		    const xmlChar *fullname;
 2279|       |
 2280|      0|		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],
 2281|      0|		                              attributes[j]);
 2282|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (2282:11): [True: 0, False: 0]
  ------------------
 2283|      0|                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,
 2284|      0|                                                  attributes[j+3],
 2285|      0|                                                  attributes[j+4]);
 2286|      0|                        goto have_attr;
 2287|      0|		    }
 2288|      0|		} else {
 2289|      0|		    lname = xmlBuildQName(attributes[j], attributes[j+1],
 2290|      0|		                          NULL, 0);
 2291|      0|		    if (lname != NULL) {
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,
 2293|      0|                                                  attributes[j+3],
 2294|      0|                                                  attributes[j+4]);
 2295|      0|			xmlFree(lname);
 2296|      0|                        goto have_attr;
 2297|      0|		    }
 2298|      0|		}
 2299|      0|	    }
 2300|  64.0k|            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
 2301|  64.0k|                                      attributes[j+3], attributes[j+4]);
 2302|  64.0k|have_attr:
 2303|  64.0k|            if (attr == NULL)
  ------------------
  |  Branch (2303:17): [True: 0, False: 64.0k]
  ------------------
 2304|      0|                continue;
 2305|       |
 2306|       |            /* link at the end to preserve order */
 2307|  64.0k|            if (prev == NULL) {
  ------------------
  |  Branch (2307:17): [True: 34.6k, False: 29.4k]
  ------------------
 2308|  34.6k|                ctxt->node->properties = attr;
 2309|  34.6k|            } else {
 2310|  29.4k|                prev->next = attr;
 2311|  29.4k|                attr->prev = prev;
 2312|  29.4k|            }
 2313|       |
 2314|  64.0k|            prev = attr;
 2315|  64.0k|	}
 2316|  34.6k|    }
 2317|       |
 2318|  42.9k|#ifdef LIBXML_VALID_ENABLED
 2319|       |    /*
 2320|       |     * If it's the Document root, finish the DTD validation and
 2321|       |     * check the document root element for validity
 2322|       |     */
 2323|  42.9k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (2323:9): [True: 0, False: 42.9k]
  ------------------
 2324|  42.9k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (2324:9): [True: 0, False: 0]
  ------------------
 2325|      0|	int chk;
 2326|       |
 2327|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 2328|      0|	if (chk <= 0)
  ------------------
  |  Branch (2328:6): [True: 0, False: 0]
  ------------------
 2329|      0|	    ctxt->valid = 0;
 2330|      0|	if (chk < 0)
  ------------------
  |  Branch (2330:6): [True: 0, False: 0]
  ------------------
 2331|      0|	    ctxt->wellFormed = 0;
 2332|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 2333|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 2334|      0|    }
 2335|  42.9k|#endif /* LIBXML_VALID_ENABLED */
 2336|  42.9k|}
xmlSAX2EndElementNs:
 2353|  42.9k|{
 2354|  42.9k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2355|       |
 2356|  42.9k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2356:9): [True: 0, False: 42.9k]
  ------------------
 2357|  42.9k|    ctxt->nodemem = -1;
 2358|       |
 2359|  42.9k|#ifdef LIBXML_VALID_ENABLED
 2360|  42.9k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2360:9): [True: 0, False: 42.9k]
  |  Branch (2360:27): [True: 0, False: 0]
  ------------------
 2361|  42.9k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (2361:9): [True: 0, False: 0]
  |  Branch (2361:24): [True: 0, False: 0]
  ------------------
 2362|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 2363|      0|                                             ctxt->node);
 2364|  42.9k|#endif /* LIBXML_VALID_ENABLED */
 2365|       |
 2366|       |    /*
 2367|       |     * end of parsing of this node.
 2368|       |     */
 2369|  42.9k|    nodePop(ctxt);
 2370|  42.9k|}
xmlSAX2Reference:
 2381|      3|{
 2382|      3|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2383|      3|    xmlNodePtr ret;
 2384|       |
 2385|      3|    if (ctx == NULL) return;
  ------------------
  |  Branch (2385:9): [True: 0, False: 3]
  ------------------
 2386|      3|    ret = xmlNewReference(ctxt->myDoc, name);
 2387|      3|    if (xmlAddChild(ctxt->node, ret) == NULL) {
  ------------------
  |  Branch (2387:9): [True: 0, False: 3]
  ------------------
 2388|      0|        xmlFreeNode(ret);
 2389|      0|    }
 2390|      3|}
xmlSAX2Characters:
 2541|  55.1k|{
 2542|  55.1k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  55.1k|}
xmlSAX2ProcessingInstruction:
 2570|     63|{
 2571|     63|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2572|     63|    xmlNodePtr ret;
 2573|     63|    xmlNodePtr parent;
 2574|       |
 2575|     63|    if (ctx == NULL) return;
  ------------------
  |  Branch (2575:9): [True: 0, False: 63]
  ------------------
 2576|     63|    parent = ctxt->node;
 2577|       |
 2578|     63|    ret = xmlNewDocPI(ctxt->myDoc, target, data);
 2579|     63|    if (ret == NULL) return;
  ------------------
  |  Branch (2579:9): [True: 0, False: 63]
  ------------------
 2580|       |
 2581|     63|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2581:9): [True: 63, False: 0]
  ------------------
 2582|     63|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2582:6): [True: 63, False: 0]
  ------------------
 2583|     63|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2583:10): [True: 63, False: 0]
  ------------------
 2584|     63|		ret->line = ctxt->input->line;
 2585|      0|	    else
 2586|      0|	        ret->line = USHRT_MAX;
 2587|     63|	}
 2588|     63|    }
 2589|     63|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2589:9): [True: 0, False: 63]
  ------------------
 2590|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2591|      0|	return;
 2592|     63|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2592:16): [True: 0, False: 63]
  ------------------
 2593|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2594|      0|	return;
 2595|      0|    }
 2596|     63|    if (parent == NULL) {
  ------------------
  |  Branch (2596:9): [True: 39, False: 24]
  ------------------
 2597|     39|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2598|     39|	return;
 2599|     39|    }
 2600|     24|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2600:9): [True: 24, False: 0]
  ------------------
 2601|     24|	xmlAddChild(parent, ret);
 2602|     24|    } else {
 2603|      0|	xmlAddSibling(parent, ret);
 2604|      0|    }
 2605|     24|}
xmlSAX2Comment:
 2616|   482k|{
 2617|   482k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|   482k|    xmlNodePtr ret;
 2619|   482k|    xmlNodePtr parent;
 2620|       |
 2621|   482k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 482k]
  ------------------
 2622|   482k|    parent = ctxt->node;
 2623|   482k|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|   482k|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 482k]
  ------------------
 2625|   482k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 482k, False: 0]
  ------------------
 2626|   482k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 482k, False: 0]
  ------------------
 2627|   482k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 482k, False: 0]
  ------------------
 2628|   482k|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|   482k|	}
 2632|   482k|    }
 2633|       |
 2634|   482k|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 480k, False: 1.56k]
  ------------------
 2635|   480k|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|   480k|	return;
 2637|   480k|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 1.11k, False: 453]
  ------------------
 2638|  1.11k|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|  1.11k|	return;
 2640|  1.11k|    }
 2641|    453|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 81, False: 372]
  ------------------
 2642|     81|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|     81|	return;
 2644|     81|    }
 2645|    372|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 372, False: 0]
  ------------------
 2646|    372|	xmlAddChild(parent, ret);
 2647|    372|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|    372|}
xmlSAX2CDataBlock:
 2662|    149|{
 2663|    149|    xmlSAX2Text((xmlParserCtxtPtr) ctx, value, len, XML_CDATA_SECTION_NODE);
 2664|    149|}
xmlSAXVersion:
 2706|  1.61k|{
 2707|  1.61k|    if (hdlr == NULL) return(-1);
  ------------------
  |  Branch (2707:9): [True: 0, False: 1.61k]
  ------------------
 2708|  1.61k|    if (version == 2) {
  ------------------
  |  Branch (2708:9): [True: 1.61k, False: 0]
  ------------------
 2709|  1.61k|	hdlr->startElementNs = xmlSAX2StartElementNs;
 2710|  1.61k|	hdlr->endElementNs = xmlSAX2EndElementNs;
 2711|  1.61k|	hdlr->serror = NULL;
 2712|  1.61k|	hdlr->initialized = XML_SAX2_MAGIC;
  ------------------
  |  |  685|  1.61k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
 2713|  1.61k|#ifdef LIBXML_SAX1_ENABLED
 2714|  1.61k|    } else if (version == 1) {
  ------------------
  |  Branch (2714:16): [True: 0, False: 0]
  ------------------
 2715|      0|	hdlr->initialized = 1;
 2716|      0|#endif /* LIBXML_SAX1_ENABLED */
 2717|      0|    } else
 2718|      0|        return(-1);
 2719|  1.61k|#ifdef LIBXML_SAX1_ENABLED
 2720|  1.61k|    hdlr->startElement = xmlSAX2StartElement;
 2721|  1.61k|    hdlr->endElement = xmlSAX2EndElement;
 2722|       |#else
 2723|       |    hdlr->startElement = NULL;
 2724|       |    hdlr->endElement = NULL;
 2725|       |#endif /* LIBXML_SAX1_ENABLED */
 2726|  1.61k|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2727|  1.61k|    hdlr->externalSubset = xmlSAX2ExternalSubset;
 2728|  1.61k|    hdlr->isStandalone = xmlSAX2IsStandalone;
 2729|  1.61k|    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
 2730|  1.61k|    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
 2731|  1.61k|    hdlr->resolveEntity = xmlSAX2ResolveEntity;
 2732|  1.61k|    hdlr->getEntity = xmlSAX2GetEntity;
 2733|  1.61k|    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
 2734|  1.61k|    hdlr->entityDecl = xmlSAX2EntityDecl;
 2735|  1.61k|    hdlr->attributeDecl = xmlSAX2AttributeDecl;
 2736|  1.61k|    hdlr->elementDecl = xmlSAX2ElementDecl;
 2737|  1.61k|    hdlr->notationDecl = xmlSAX2NotationDecl;
 2738|  1.61k|    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
 2739|  1.61k|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2740|  1.61k|    hdlr->startDocument = xmlSAX2StartDocument;
 2741|  1.61k|    hdlr->endDocument = xmlSAX2EndDocument;
 2742|  1.61k|    hdlr->reference = xmlSAX2Reference;
 2743|  1.61k|    hdlr->characters = xmlSAX2Characters;
 2744|  1.61k|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2745|  1.61k|    hdlr->ignorableWhitespace = xmlSAX2Characters;
 2746|  1.61k|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2747|  1.61k|    hdlr->comment = xmlSAX2Comment;
 2748|  1.61k|    hdlr->warning = xmlParserWarning;
 2749|  1.61k|    hdlr->error = xmlParserError;
 2750|  1.61k|    hdlr->fatalError = xmlParserError;
 2751|       |
 2752|  1.61k|    return(0);
 2753|  1.61k|}
SAX2.c:xmlErrValid:
   95|      6|{
   96|      6|    xmlStructuredErrorFunc schannel = NULL;
   97|       |
   98|      6|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (98:9): [True: 6, False: 0]
  |  Branch (98:27): [True: 0, False: 6]
  ------------------
   99|      6|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (99:9): [True: 0, False: 0]
  ------------------
  100|      0|	return;
  101|      6|    if (ctxt != NULL) {
  ------------------
  |  Branch (101:9): [True: 6, False: 0]
  ------------------
  102|      6|	ctxt->errNo = error;
  103|      6|	if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|      6|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (103:6): [True: 6, False: 0]
  |  Branch (103:29): [True: 6, False: 0]
  ------------------
  104|      6|	    schannel = ctxt->sax->serror;
  105|      6|	__xmlRaiseError(schannel,
  106|      6|			ctxt->vctxt.error, ctxt->vctxt.userData,
  107|      6|			ctxt, NULL, XML_FROM_DTD, error,
  108|      6|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
  109|      6|			(const char *) str2, NULL, 0, 0,
  110|      6|			msg, (const char *) str1, (const char *) str2);
  111|      6|	ctxt->valid = 0;
  112|      6|    } else {
  113|      0|	__xmlRaiseError(schannel,
  114|      0|			NULL, NULL,
  115|      0|			ctxt, NULL, XML_FROM_DTD, error,
  116|      0|			XML_ERR_ERROR, NULL, 0, (const char *) str1,
  117|      0|			(const char *) str2, NULL, 0, 0,
  118|      0|			msg, (const char *) str1, (const char *) str2);
  119|      0|    }
  120|      6|}
SAX2.c:xmlNsWarnMsg:
  190|      6|{
  191|      6|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (191:9): [True: 6, False: 0]
  |  Branch (191:27): [True: 0, False: 6]
  ------------------
  192|      6|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (192:9): [True: 0, False: 0]
  ------------------
  193|      0|	return;
  194|      6|    if (ctxt != NULL)
  ------------------
  |  Branch (194:9): [True: 6, False: 0]
  ------------------
  195|      6|	ctxt->errNo = error;
  196|      6|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  197|      6|                    XML_ERR_WARNING, NULL, 0,
  198|      6|		    (const char *) str1, (const char *) str2,
  199|      6|		    NULL, 0, 0, msg, str1, str2);
  200|      6|}
SAX2.c:xmlSAX2AttributeNs:
 1867|  64.0k|{
 1868|  64.0k|    xmlAttrPtr ret;
 1869|  64.0k|    xmlNsPtr namespace = NULL;
 1870|  64.0k|    xmlChar *dup = NULL;
 1871|       |
 1872|       |    /*
 1873|       |     * Note: if prefix == NULL, the attribute is not in the default namespace
 1874|       |     */
 1875|  64.0k|    if (prefix != NULL) {
  ------------------
  |  Branch (1875:9): [True: 603, False: 63.4k]
  ------------------
 1876|    603|	namespace = xmlParserNsLookupSax(ctxt, prefix);
 1877|    603|	if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     45|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1877:6): [True: 45, False: 558]
  |  Branch (1877:29): [True: 45, False: 0]
  ------------------
 1878|     45|	    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);
 1879|     45|	}
 1880|    603|    }
 1881|       |
 1882|       |    /*
 1883|       |     * allocate the node
 1884|       |     */
 1885|  64.0k|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (1885:9): [True: 1.19k, False: 62.8k]
  ------------------
 1886|  1.19k|        ret = ctxt->freeAttrs;
 1887|  1.19k|	ctxt->freeAttrs = ret->next;
 1888|  1.19k|	ctxt->freeAttrsNr--;
 1889|  62.8k|    } else {
 1890|  62.8k|        ret = xmlMalloc(sizeof(*ret));
 1891|  62.8k|        if (ret == NULL) {
  ------------------
  |  Branch (1891:13): [True: 0, False: 62.8k]
  ------------------
 1892|      0|            xmlSAX2ErrMemory(ctxt, NULL);
 1893|      0|            return(NULL);
 1894|      0|        }
 1895|  62.8k|    }
 1896|       |
 1897|  64.0k|    memset(ret, 0, sizeof(xmlAttr));
 1898|  64.0k|    ret->type = XML_ATTRIBUTE_NODE;
 1899|       |
 1900|  64.0k|    ret->parent = ctxt->node;
 1901|  64.0k|    ret->doc = ctxt->myDoc;
 1902|  64.0k|    ret->ns = namespace;
 1903|       |
 1904|  64.0k|    if (ctxt->dictNames)
  ------------------
  |  Branch (1904:9): [True: 64.0k, False: 0]
  ------------------
 1905|  64.0k|        ret->name = localname;
 1906|      0|    else
 1907|      0|        ret->name = xmlStrdup(localname);
 1908|       |
 1909|  64.0k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1909:9): [True: 0, False: 64.0k]
  |  Branch (1909:37): [True: 0, False: 0]
  ------------------
 1910|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1911|       |
 1912|  64.0k|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1912:9): [True: 0, False: 64.0k]
  |  Branch (1912:41): [True: 0, False: 0]
  ------------------
 1913|      0|	xmlNodePtr tmp;
 1914|       |
 1915|       |	/*
 1916|       |	 * We know that if there is an entity reference, then
 1917|       |	 * the string has been dup'ed and terminates with 0
 1918|       |	 * otherwise with ' or "
 1919|       |	 */
 1920|      0|	if (*valueend != 0) {
  ------------------
  |  Branch (1920:6): [True: 0, False: 0]
  ------------------
 1921|      0|	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1922|      0|	    ret->children = tmp;
 1923|      0|	    ret->last = tmp;
 1924|      0|	    if (tmp != NULL) {
  ------------------
  |  Branch (1924:10): [True: 0, False: 0]
  ------------------
 1925|      0|		tmp->doc = ret->doc;
 1926|      0|		tmp->parent = (xmlNodePtr) ret;
 1927|      0|	    }
 1928|      0|	} else {
 1929|      0|	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,
 1930|      0|						    valueend - value);
 1931|      0|	    tmp = ret->children;
 1932|      0|	    while (tmp != NULL) {
  ------------------
  |  Branch (1932:13): [True: 0, False: 0]
  ------------------
 1933|      0|	        tmp->doc = ret->doc;
 1934|      0|		tmp->parent = (xmlNodePtr) ret;
 1935|      0|		if (tmp->next == NULL)
  ------------------
  |  Branch (1935:7): [True: 0, False: 0]
  ------------------
 1936|      0|		    ret->last = tmp;
 1937|      0|		tmp = tmp->next;
 1938|      0|	    }
 1939|      0|	}
 1940|  64.0k|    } else if (value != NULL) {
  ------------------
  |  Branch (1940:16): [True: 64.0k, False: 0]
  ------------------
 1941|  64.0k|	xmlNodePtr tmp;
 1942|       |
 1943|  64.0k|	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1944|  64.0k|	ret->children = tmp;
 1945|  64.0k|	ret->last = tmp;
 1946|  64.0k|	if (tmp != NULL) {
  ------------------
  |  Branch (1946:6): [True: 64.0k, False: 0]
  ------------------
 1947|  64.0k|	    tmp->doc = ret->doc;
 1948|  64.0k|	    tmp->parent = (xmlNodePtr) ret;
 1949|  64.0k|	}
 1950|  64.0k|    }
 1951|       |
 1952|  64.0k|#ifdef LIBXML_VALID_ENABLED
 1953|  64.0k|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1953:9): [True: 64.0k, False: 0]
  |  Branch (1953:26): [True: 0, False: 64.0k]
  |  Branch (1953:44): [True: 0, False: 0]
  ------------------
 1954|  64.0k|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1954:9): [True: 0, False: 0]
  |  Branch (1954:24): [True: 0, False: 0]
  ------------------
 1955|       |	/*
 1956|       |	 * If we don't substitute entities, the validation should be
 1957|       |	 * done on a value with replaced entities anyway.
 1958|       |	 */
 1959|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 0]
  ------------------
 1960|      0|	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
 1961|      0|	    if (dup == NULL) {
  ------------------
  |  Branch (1961:10): [True: 0, False: 0]
  ------------------
 1962|      0|	        if (*valueend == 0) {
  ------------------
  |  Branch (1962:14): [True: 0, False: 0]
  ------------------
 1963|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1964|      0|				    ctxt->myDoc, ctxt->node, ret, value);
 1965|      0|		} else {
 1966|       |		    /*
 1967|       |		     * That should already be normalized.
 1968|       |		     * cheaper to finally allocate here than duplicate
 1969|       |		     * entry points in the full validation code
 1970|       |		     */
 1971|      0|		    dup = xmlStrndup(value, valueend - value);
 1972|       |
 1973|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1974|      0|				    ctxt->myDoc, ctxt->node, ret, dup);
 1975|      0|		}
 1976|      0|	    } else {
 1977|       |	        /*
 1978|       |		 * dup now contains a string of the flattened attribute
 1979|       |		 * content with entities substituted. Check if we need to
 1980|       |		 * apply an extra layer of normalization.
 1981|       |		 * It need to be done twice ... it's an extra burden related
 1982|       |		 * to the ability to keep references in attributes
 1983|       |		 */
 1984|      0|		if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1984:7): [True: 0, False: 0]
  ------------------
 1985|      0|		    xmlChar *nvalnorm;
 1986|      0|		    xmlChar fn[50];
 1987|      0|		    xmlChar *fullname;
 1988|       |
 1989|      0|		    fullname = xmlBuildQName(localname, prefix, fn, 50);
 1990|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (1990:11): [True: 0, False: 0]
  ------------------
 1991|      0|			ctxt->vctxt.valid = 1;
 1992|      0|		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(
 1993|      0|			                 &ctxt->vctxt, ctxt->myDoc,
 1994|      0|					 ctxt->node, fullname, dup);
 1995|      0|			if (ctxt->vctxt.valid != 1)
  ------------------
  |  Branch (1995:8): [True: 0, False: 0]
  ------------------
 1996|      0|			    ctxt->valid = 0;
 1997|       |
 1998|      0|			if ((fullname != fn) && (fullname != localname))
  ------------------
  |  Branch (1998:8): [True: 0, False: 0]
  |  Branch (1998:28): [True: 0, False: 0]
  ------------------
 1999|      0|			    xmlFree(fullname);
 2000|      0|			if (nvalnorm != NULL) {
  ------------------
  |  Branch (2000:8): [True: 0, False: 0]
  ------------------
 2001|      0|			    xmlFree(dup);
 2002|      0|			    dup = nvalnorm;
 2003|      0|			}
 2004|      0|		    }
 2005|      0|		}
 2006|       |
 2007|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2008|      0|			        ctxt->myDoc, ctxt->node, ret, dup);
 2009|      0|	    }
 2010|      0|	} else {
 2011|       |	    /*
 2012|       |	     * if entities already have been substituted, then
 2013|       |	     * the attribute as passed is already normalized
 2014|       |	     */
 2015|      0|	    dup = xmlStrndup(value, valueend - value);
 2016|       |
 2017|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2018|      0|	                             ctxt->myDoc, ctxt->node, ret, dup);
 2019|      0|	}
 2020|      0|    } else
 2021|  64.0k|#endif /* LIBXML_VALID_ENABLED */
 2022|  64.0k|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|  64.0k|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (2022:16): [True: 64.0k, False: 3]
  ------------------
 2023|  64.0k|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (2023:11): [True: 0, False: 64.0k]
  |  Branch (2023:43): [True: 0, False: 0]
  ------------------
 2024|  64.0k|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (2024:11): [True: 64.0k, False: 0]
  |  Branch (2024:43): [True: 64.0k, False: 0]
  ------------------
 2025|       |               /* Don't create IDs containing entity references */
 2026|  64.0k|               (ret->children != NULL) &&
  ------------------
  |  Branch (2026:16): [True: 64.0k, False: 0]
  ------------------
 2027|  64.0k|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2027:16): [True: 64.0k, False: 0]
  ------------------
 2028|  64.0k|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (2028:16): [True: 64.0k, False: 0]
  ------------------
 2029|  64.0k|        xmlChar *content = ret->children->content;
 2030|       |        /*
 2031|       |	 * when validating, the ID registration is done at the attribute
 2032|       |	 * validation level. Otherwise we have to do specific handling here.
 2033|       |	 */
 2034|  64.0k|        if ((prefix == ctxt->str_xml) &&
  ------------------
  |  Branch (2034:13): [True: 45, False: 64.0k]
  ------------------
 2035|  64.0k|	           (localname[0] == 'i') && (localname[1] == 'd') &&
  ------------------
  |  Branch (2035:13): [True: 21, False: 24]
  |  Branch (2035:38): [True: 21, False: 0]
  ------------------
 2036|  64.0k|		   (localname[2] == 0)) {
  ------------------
  |  Branch (2036:6): [True: 21, False: 0]
  ------------------
 2037|       |	    /*
 2038|       |	     * Add the xml:id value
 2039|       |	     *
 2040|       |	     * Open issue: normalization of the value.
 2041|       |	     */
 2042|     21|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (2042:10): [True: 3, False: 18]
  ------------------
 2043|      3|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 2044|      3|		      "xml:id : attribute value %s is not an NCName\n",
 2045|      3|			    (const char *) content, NULL);
 2046|      3|	    }
 2047|     21|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2048|  64.0k|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2048:13): [True: 972, False: 63.0k]
  ------------------
 2049|    972|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2050|  63.0k|	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2050:13): [True: 1.98k, False: 61.0k]
  ------------------
 2051|  1.98k|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2052|  1.98k|	}
 2053|  64.0k|    }
 2054|  64.0k|    if (dup != NULL)
  ------------------
  |  Branch (2054:9): [True: 0, False: 64.0k]
  ------------------
 2055|      0|	xmlFree(dup);
 2056|       |
 2057|  64.0k|    return(ret);
 2058|  64.0k|}
SAX2.c:xmlSAX2TextNode:
 1749|   116k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|   116k|    xmlNodePtr ret;
 1751|   116k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|   116k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 515, False: 115k]
  ------------------
 1757|    515|	ret = ctxt->freeElems;
 1758|    515|	ctxt->freeElems = ret->next;
 1759|    515|	ctxt->freeElemsNr--;
 1760|   115k|    } else {
 1761|   115k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|   115k|    }
 1763|   116k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 116k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|   116k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|   116k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 116k, False: 0]
  ------------------
 1773|   116k|        xmlChar cur = str[len];
 1774|       |
 1775|   116k|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 108k, False: 7.59k]
  ------------------
 1776|   116k|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 36.1k, False: 72.2k]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|  36.1k|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|  36.1k|	    memcpy(tmp, str, len);
 1780|  36.1k|	    tmp[len] = 0;
 1781|  36.1k|	    intern = tmp;
 1782|  79.8k|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 16.8k, False: 63.0k]
  |  Branch (1782:28): [True: 9.44k, False: 7.39k]
  |  Branch (1782:44): [True: 40, False: 7.35k]
  ------------------
 1783|  16.8k|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 7.04k, False: 304]
  |  Branch (1783:23): [True: 6.91k, False: 134]
  ------------------
 1784|  16.3k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|  63.4k|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|  63.4k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   126k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 2.08k, False: 61.4k]
  |  |  |  |  ------------------
  |  |  |  |   89|  63.4k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 61.4k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 21.7k, False: 39.7k]
  |  |  |  |  ------------------
  |  |  |  |   90|   126k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 6, False: 39.7k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 22.8k, False: 933]
  |  Branch (1785:48): [True: 22.5k, False: 300]
  ------------------
 1786|  63.4k|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 22.3k, False: 185]
  ------------------
 1787|  22.3k|	    int i;
 1788|       |
 1789|   129k|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 107k, False: 21.2k]
  ------------------
 1790|   107k|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|   107k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   107k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 12.8k, False: 95.0k]
  |  |  |  |  ------------------
  |  |  |  |   89|   107k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 95.0k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 93.9k, False: 1.15k]
  |  |  |  |  ------------------
  |  |  |  |   90|   107k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.15k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|   107k|	    }
 1792|  21.2k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|  21.2k|	}
 1794|   116k|    }
 1795|   116k|skip:
 1796|   116k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|   116k|    ret->name = xmlStringText;
 1799|   116k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 42.2k, False: 73.7k]
  ------------------
 1800|  42.2k|	ret->content = xmlStrndup(str, len);
 1801|  42.2k|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 42.2k]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|  42.2k|    } else
 1807|  73.7k|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|   116k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 116k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|   116k|    return(ret);
 1812|   116k|}
SAX2.c:xmlSAX2Text:
 2404|  55.3k|{
 2405|  55.3k|    xmlNodePtr lastChild;
 2406|       |
 2407|  55.3k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 55.3k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  55.3k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 0, False: 55.3k]
  ------------------
 2415|      0|        return;
 2416|      0|    }
 2417|  55.3k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  55.3k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 11.0k, False: 44.2k]
  ------------------
 2424|  11.0k|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 11.0k, False: 87]
  ------------------
 2425|  11.0k|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|     87|        else
 2427|     87|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|  11.0k|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 11.0k, False: 0]
  ------------------
 2429|  11.0k|	    ctxt->node->children = lastChild;
 2430|  11.0k|	    ctxt->node->last = lastChild;
 2431|  11.0k|	    lastChild->parent = ctxt->node;
 2432|  11.0k|	    lastChild->doc = ctxt->node->doc;
 2433|  11.0k|	    ctxt->nodelen = len;
 2434|  11.0k|	    ctxt->nodemem = len + 1;
 2435|  11.0k|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  44.2k|    } else {
 2440|  44.2k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 44.2k, False: 0]
  ------------------
 2441|  44.2k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 3.27k, False: 40.9k]
  ------------------
 2442|  44.2k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 50, False: 3.22k]
  ------------------
 2443|  3.27k|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 3.22k, False: 0]
  ------------------
 2444|  44.2k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 3.27k, False: 40.9k]
  |  Branch (2444:24): [True: 1.85k, False: 1.41k]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|  1.85k|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 123, False: 1.73k]
  ------------------
 2453|    123|		lastChild->content = xmlStrdup(lastChild->content);
 2454|    123|		lastChild->properties = NULL;
 2455|  1.73k|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 520, False: 1.21k]
  ------------------
 2456|  1.73k|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 0, False: 520]
  ------------------
 2457|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      0|	    }
 2459|  1.85k|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 1.85k]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|  1.85k|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 1.85k]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|  1.85k|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|  1.85k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 1.85k]
  ------------------
 2468|  1.85k|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|  1.85k|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 799, False: 1.05k]
  ------------------
 2473|    799|		xmlChar *newbuf;
 2474|    799|		int size;
 2475|       |
 2476|    799|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 799]
  ------------------
 2477|      0|                       INT_MAX :
 2478|    799|                       ctxt->nodemem + len;
 2479|    799|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 799]
  ------------------
 2480|    799|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|    799|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 799]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|    799|		ctxt->nodemem = size;
 2486|    799|		lastChild->content = newbuf;
 2487|    799|	    }
 2488|  1.85k|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|  1.85k|	    ctxt->nodelen += len;
 2490|  1.85k|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  42.3k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 1.41k, False: 40.9k]
  ------------------
 2492|  1.41k|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 1.41k]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|  1.41k|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 1.41k, False: 0]
  ------------------
 2496|  1.41k|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|  1.41k|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|  1.41k|	    }
 2499|  40.9k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  40.9k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 40.9k, False: 12]
  ------------------
 2502|  40.9k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  40.9k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 40.9k, False: 0]
  ------------------
 2504|  40.9k|                    lastChild->doc = ctxt->myDoc;
 2505|  40.9k|            } else
 2506|     12|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  40.9k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 40.9k, False: 0]
  ------------------
 2508|  40.9k|		xmlAddChild(ctxt->node, lastChild);
 2509|  40.9k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 40.9k, False: 0]
  ------------------
 2510|  40.9k|		    ctxt->nodelen = len;
 2511|  40.9k|		    ctxt->nodemem = len + 1;
 2512|  40.9k|		}
 2513|  40.9k|	    }
 2514|  40.9k|	}
 2515|  44.2k|    }
 2516|       |
 2517|  55.3k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 55.3k, False: 0]
  ------------------
 2518|  55.3k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 55.1k, False: 149]
  ------------------
 2519|  55.3k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 54.9k, False: 204]
  ------------------
 2520|  55.3k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 54.9k, False: 0]
  ------------------
 2521|  54.9k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 54.9k, False: 0]
  ------------------
 2522|  54.9k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  54.9k|    }
 2529|  55.3k|}

xmlBufCreate:
  122|    316|xmlBufCreate(void) {
  123|    316|    xmlBufPtr ret;
  124|       |
  125|    316|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  126|    316|    if (ret == NULL) {
  ------------------
  |  Branch (126:9): [True: 0, False: 316]
  ------------------
  127|      0|	xmlBufMemoryError(NULL, "creating buffer");
  128|      0|        return(NULL);
  129|      0|    }
  130|    316|    ret->use = 0;
  131|    316|    ret->error = 0;
  132|    316|    ret->buffer = NULL;
  133|    316|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|    316|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    316|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  134|    316|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    316|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 316, False: 0]
  |  |  ------------------
  |  |   62|    316|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    316|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 316, False: 0]
  |  |  ------------------
  |  |   64|    316|     else buf->compat_use = INT_MAX;
  ------------------
  135|    316|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    316|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    316|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  136|    316|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  137|    316|    if (ret->content == NULL) {
  ------------------
  |  Branch (137:9): [True: 0, False: 316]
  ------------------
  138|      0|	xmlBufMemoryError(ret, "creating buffer");
  139|      0|	xmlFree(ret);
  140|      0|        return(NULL);
  141|      0|    }
  142|    316|    ret->content[0] = 0;
  143|    316|    ret->contentIO = NULL;
  144|    316|    return(ret);
  145|    316|}
xmlBufCreateSize:
  155|  11.9k|xmlBufCreateSize(size_t size) {
  156|  11.9k|    xmlBufPtr ret;
  157|       |
  158|  11.9k|    if (size == SIZE_MAX)
  ------------------
  |  |   30|  11.9k|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 11.9k]
  ------------------
  159|      0|        return(NULL);
  160|  11.9k|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|  11.9k|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 0, False: 11.9k]
  ------------------
  162|      0|	xmlBufMemoryError(NULL, "creating buffer");
  163|      0|        return(NULL);
  164|      0|    }
  165|  11.9k|    ret->use = 0;
  166|  11.9k|    ret->error = 0;
  167|  11.9k|    ret->buffer = NULL;
  168|  11.9k|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|  11.9k|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|  11.9k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|  11.9k|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 11.9k, False: 0]
  ------------------
  170|  11.9k|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|  11.9k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 11.9k, False: 0]
  |  |  ------------------
  |  |   62|  11.9k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  11.9k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 11.9k, False: 0]
  |  |  ------------------
  |  |   64|  11.9k|     else buf->compat_use = INT_MAX;
  ------------------
  171|  11.9k|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 11.9k, False: 0]
  ------------------
  172|  11.9k|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|  11.9k|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 11.9k]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|  11.9k|        ret->content[0] = 0;
  179|  11.9k|    } else
  180|      0|	ret->content = NULL;
  181|  11.9k|    ret->contentIO = NULL;
  182|  11.9k|    return(ret);
  183|  11.9k|}
xmlBufDetach:
  196|      6|xmlBufDetach(xmlBufPtr buf) {
  197|      6|    xmlChar *ret;
  198|       |
  199|      6|    if (buf == NULL)
  ------------------
  |  Branch (199:9): [True: 0, False: 6]
  ------------------
  200|      0|        return(NULL);
  201|      6|    if (buf->buffer != NULL)
  ------------------
  |  Branch (201:9): [True: 0, False: 6]
  ------------------
  202|      0|        return(NULL);
  203|      6|    if (buf->error)
  ------------------
  |  Branch (203:9): [True: 0, False: 6]
  ------------------
  204|      0|        return(NULL);
  205|       |
  206|      6|    ret = buf->content;
  207|      6|    buf->content = NULL;
  208|      6|    buf->size = 0;
  209|      6|    buf->use = 0;
  210|      6|    UPDATE_COMPAT(buf);
  ------------------
  |  |   61|      6|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 6, False: 0]
  |  |  ------------------
  |  |   62|      6|     else buf->compat_size = INT_MAX;			    \
  |  |   63|      6|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 6, False: 0]
  |  |  ------------------
  |  |   64|      6|     else buf->compat_use = INT_MAX;
  ------------------
  211|       |
  212|      6|    return ret;
  213|      6|}
xmlBufSetAllocationScheme:
  242|  12.5k|                          xmlBufferAllocationScheme scheme) {
  243|  12.5k|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 12.5k]
  |  Branch (243:26): [True: 0, False: 12.5k]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|  12.5k|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 12.5k]
  ------------------
  247|      0|        return(-1);
  248|  12.5k|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 12.5k, False: 0]
  ------------------
  249|  12.5k|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|  12.5k|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|  12.5k|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|  12.5k|	buf->alloc = scheme;
  253|  12.5k|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 12.5k]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|  12.5k|        return(0);
  256|  12.5k|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|  12.5k|}
xmlBufFree:
  276|  12.2k|xmlBufFree(xmlBufPtr buf) {
  277|  12.2k|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 12.2k]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|  12.2k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 12.2k]
  ------------------
  282|  12.2k|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|  12.2k|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 12.2k, False: 6]
  ------------------
  285|  12.2k|        xmlFree(buf->content);
  286|  12.2k|    }
  287|  12.2k|    xmlFree(buf);
  288|  12.2k|}
xmlBufShrink:
  328|  3.27k|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|  3.27k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 3.27k]
  |  Branch (329:26): [True: 0, False: 3.27k]
  ------------------
  330|  3.27k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  3.27k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 3.27k]
  |  |  ------------------
  |  |   73|  3.27k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  3.27k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 3.27k]
  |  |  ------------------
  |  |   76|  3.27k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|  3.27k|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 36, False: 3.24k]
  ------------------
  332|  3.24k|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 3.24k]
  ------------------
  333|       |
  334|  3.24k|    buf->use -= len;
  335|  3.24k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 3.24k]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|  3.24k|    } else {
  357|  3.24k|	memmove(buf->content, &buf->content[len], buf->use);
  358|  3.24k|	buf->content[buf->use] = 0;
  359|  3.24k|    }
  360|  3.24k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  3.24k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 3.24k, False: 0]
  |  |  ------------------
  |  |   62|  3.24k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  3.24k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 3.24k, False: 0]
  |  |  ------------------
  |  |   64|  3.24k|     else buf->compat_use = INT_MAX;
  ------------------
  361|  3.24k|    return(len);
  362|  3.24k|}
xmlBufGrow:
  443|  1.47M|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  1.47M|    size_t ret;
  445|       |
  446|  1.47M|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 1.47M]
  |  Branch (446:26): [True: 0, False: 1.47M]
  ------------------
  447|  1.47M|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 1.47M]
  ------------------
  448|      0|        return(0);
  449|  1.47M|    ret = xmlBufGrowInternal(buf, len);
  450|  1.47M|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 1.47M]
  ------------------
  451|      0|        return(-1);
  452|  1.47M|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 1.47M]
  ------------------
  453|  1.47M|}
xmlBufContent:
  491|  15.5k|{
  492|  15.5k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (492:9): [True: 0, False: 15.5k]
  |  Branch (492:19): [True: 0, False: 15.5k]
  ------------------
  493|      0|        return NULL;
  494|       |
  495|  15.5k|    return(buf->content);
  496|  15.5k|}
xmlBufEnd:
  509|  1.49M|{
  510|  1.49M|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 1.49M]
  |  Branch (510:19): [True: 0, False: 1.49M]
  ------------------
  511|      0|        return NULL;
  512|  1.49M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.49M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   73|  1.49M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.49M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   76|  1.49M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  1.49M|    return(&buf->content[buf->use]);
  515|  1.49M|}
xmlBufAddLen:
  529|  1.49M|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  1.49M|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 1.49M]
  |  Branch (530:26): [True: 0, False: 1.49M]
  ------------------
  531|      0|        return(-1);
  532|  1.49M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.49M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   73|  1.49M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.49M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   76|  1.49M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  1.49M|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 1.49M]
  ------------------
  534|      0|        return(-1);
  535|  1.49M|    buf->use += len;
  536|  1.49M|    buf->content[buf->use] = 0;
  537|  1.49M|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  1.49M|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 1.49M, False: 0]
  |  |  ------------------
  |  |   62|  1.49M|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  1.49M|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 1.49M, False: 0]
  |  |  ------------------
  |  |   64|  1.49M|     else buf->compat_use = INT_MAX;
  ------------------
  538|  1.49M|    return(0);
  539|  1.49M|}
xmlBufUse:
  571|   161k|{
  572|   161k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (572:9): [True: 0, False: 161k]
  |  Branch (572:19): [True: 0, False: 161k]
  ------------------
  573|      0|        return 0;
  574|   161k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|   161k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 161k]
  |  |  ------------------
  |  |   73|   161k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|   161k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 161k]
  |  |  ------------------
  |  |   76|   161k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  575|       |
  576|   161k|    return(buf->use);
  577|   161k|}
xmlBufAvail:
  593|  22.4k|{
  594|  22.4k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (594:9): [True: 0, False: 22.4k]
  |  Branch (594:19): [True: 0, False: 22.4k]
  ------------------
  595|      0|        return 0;
  596|  22.4k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  22.4k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 22.4k]
  |  |  ------------------
  |  |   73|  22.4k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  22.4k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 22.4k]
  |  |  ------------------
  |  |   76|  22.4k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  597|       |
  598|  22.4k|    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);
  ------------------
  |  Branch (598:12): [True: 22.4k, False: 0]
  ------------------
  599|  22.4k|}
xmlBufIsEmpty:
  611|     99|{
  612|     99|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 99]
  |  Branch (612:19): [True: 0, False: 99]
  ------------------
  613|      0|        return(-1);
  614|     99|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     99|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 99]
  |  |  ------------------
  |  |   73|     99|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     99|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 99]
  |  |  ------------------
  |  |   76|     99|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|     99|    return(buf->use == 0);
  617|     99|}
xmlBufResize:
  630|     48|{
  631|     48|    size_t newSize;
  632|     48|    xmlChar* rebuf = NULL;
  633|     48|    size_t start_buf;
  634|       |
  635|     48|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (635:9): [True: 0, False: 48]
  |  Branch (635:26): [True: 0, False: 48]
  ------------------
  636|      0|        return(0);
  637|     48|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|     48|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 48]
  |  |  ------------------
  |  |   73|     48|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|     48|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 48]
  |  |  ------------------
  |  |   76|     48|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  638|       |
  639|     48|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (639:9): [True: 0, False: 48]
  ------------------
  640|       |        /*
  641|       |	 * Used to provide parsing limits
  642|       |	 */
  643|      0|        if (size >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (643:13): [True: 0, False: 0]
  ------------------
  644|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  645|      0|	    return(0);
  646|      0|	}
  647|      0|    }
  648|       |
  649|       |    /* Don't resize if we don't have to */
  650|     48|    if (size < buf->size)
  ------------------
  |  Branch (650:9): [True: 0, False: 48]
  ------------------
  651|      0|        return 1;
  652|       |
  653|       |    /* figure out new size */
  654|     48|    switch (buf->alloc){
  655|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (655:2): [True: 0, False: 48]
  ------------------
  656|     48|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (656:2): [True: 48, False: 0]
  ------------------
  657|       |	    /*take care of empty case*/
  658|     48|            if (buf->size == 0) {
  ------------------
  |  Branch (658:17): [True: 0, False: 48]
  ------------------
  659|      0|                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                              newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (659:28): [True: 0, False: 0]
  ------------------
  660|     48|            } else {
  661|     48|                newSize = buf->size;
  662|     48|            }
  663|    105|	    while (size > newSize) {
  ------------------
  |  Branch (663:13): [True: 57, False: 48]
  ------------------
  664|     57|	        if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|     57|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (664:14): [True: 0, False: 57]
  ------------------
  665|      0|	            xmlBufMemoryError(buf, "growing buffer");
  666|      0|	            return 0;
  667|      0|	        }
  668|     57|	        newSize *= 2;
  669|     57|	    }
  670|     48|	    break;
  671|     48|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (671:2): [True: 0, False: 48]
  ------------------
  672|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (672:24): [True: 0, False: 0]
  ------------------
  673|      0|	    break;
  674|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (674:9): [True: 0, False: 48]
  ------------------
  675|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (675:17): [True: 0, False: 0]
  ------------------
  676|      0|                newSize = size;
  677|      0|            else {
  678|      0|                newSize = buf->size;
  679|      0|                while (size > newSize) {
  ------------------
  |  Branch (679:24): [True: 0, False: 0]
  ------------------
  680|      0|                    if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (680:25): [True: 0, False: 0]
  ------------------
  681|      0|                        xmlBufMemoryError(buf, "growing buffer");
  682|      0|                        return 0;
  683|      0|                    }
  684|      0|                    newSize *= 2;
  685|      0|                }
  686|      0|            }
  687|      0|            break;
  688|       |
  689|      0|	default:
  ------------------
  |  Branch (689:2): [True: 0, False: 48]
  ------------------
  690|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (690:24): [True: 0, False: 0]
  ------------------
  691|      0|	    break;
  692|     48|    }
  693|       |
  694|     48|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (694:9): [True: 0, False: 48]
  |  Branch (694:48): [True: 0, False: 0]
  ------------------
  695|      0|        start_buf = buf->content - buf->contentIO;
  696|       |
  697|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|       |	    /* move data back to start */
  699|      0|	    memmove(buf->contentIO, buf->content, buf->use);
  700|      0|	    buf->content = buf->contentIO;
  701|      0|	    buf->content[buf->use] = 0;
  702|      0|	    buf->size += start_buf;
  703|      0|	} else {
  704|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
  705|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (705:10): [True: 0, False: 0]
  ------------------
  706|      0|		xmlBufMemoryError(buf, "growing buffer");
  707|      0|		return 0;
  708|      0|	    }
  709|      0|	    buf->contentIO = rebuf;
  710|      0|	    buf->content = rebuf + start_buf;
  711|      0|	}
  712|     48|    } else {
  713|     48|	if (buf->content == NULL) {
  ------------------
  |  Branch (713:6): [True: 0, False: 48]
  ------------------
  714|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  715|      0|	    buf->use = 0;
  716|      0|            if (rebuf != NULL)
  ------------------
  |  Branch (716:17): [True: 0, False: 0]
  ------------------
  717|      0|	        rebuf[buf->use] = 0;
  718|     48|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (718:13): [True: 21, False: 27]
  ------------------
  719|     21|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
  720|     27|        } else {
  721|       |	    /*
  722|       |	     * if we are reallocating a buffer far from being full, it's
  723|       |	     * better to make a new allocation and copy only the used range
  724|       |	     * and free the old one.
  725|       |	     */
  726|     27|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  727|     27|	    if (rebuf != NULL) {
  ------------------
  |  Branch (727:10): [True: 27, False: 0]
  ------------------
  728|     27|		memcpy(rebuf, buf->content, buf->use);
  729|     27|		xmlFree(buf->content);
  730|     27|		rebuf[buf->use] = 0;
  731|     27|	    }
  732|     27|	}
  733|     48|	if (rebuf == NULL) {
  ------------------
  |  Branch (733:6): [True: 0, False: 48]
  ------------------
  734|      0|	    xmlBufMemoryError(buf, "growing buffer");
  735|      0|	    return 0;
  736|      0|	}
  737|     48|	buf->content = rebuf;
  738|     48|    }
  739|     48|    buf->size = newSize;
  740|     48|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|     48|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 48, False: 0]
  |  |  ------------------
  |  |   62|     48|     else buf->compat_size = INT_MAX;			    \
  |  |   63|     48|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 48, False: 0]
  |  |  ------------------
  |  |   64|     48|     else buf->compat_use = INT_MAX;
  ------------------
  741|       |
  742|     48|    return 1;
  743|     48|}
xmlBufAdd:
  758|   181k|xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  759|   181k|    size_t needSize;
  760|       |
  761|   181k|    if ((str == NULL) || (buf == NULL) || (buf->error))
  ------------------
  |  Branch (761:9): [True: 0, False: 181k]
  |  Branch (761:26): [True: 0, False: 181k]
  |  Branch (761:43): [True: 0, False: 181k]
  ------------------
  762|      0|	return -1;
  763|   181k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|   181k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 181k]
  |  |  ------------------
  |  |   73|   181k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|   181k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 181k]
  |  |  ------------------
  |  |   76|   181k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  764|       |
  765|   181k|    if (len < -1) {
  ------------------
  |  Branch (765:9): [True: 0, False: 181k]
  ------------------
  766|      0|	return -1;
  767|      0|    }
  768|   181k|    if (len == 0) return 0;
  ------------------
  |  Branch (768:9): [True: 0, False: 181k]
  ------------------
  769|       |
  770|   181k|    if (len < 0)
  ------------------
  |  Branch (770:9): [True: 1.51k, False: 179k]
  ------------------
  771|  1.51k|        len = xmlStrlen(str);
  772|       |
  773|   181k|    if (len < 0) return -1;
  ------------------
  |  Branch (773:9): [True: 0, False: 181k]
  ------------------
  774|   181k|    if (len == 0) return 0;
  ------------------
  |  Branch (774:9): [True: 0, False: 181k]
  ------------------
  775|       |
  776|       |    /* Note that both buf->size and buf->use can be zero here. */
  777|   181k|    if ((size_t) len >= buf->size - buf->use) {
  ------------------
  |  Branch (777:9): [True: 48, False: 180k]
  ------------------
  778|     48|        if ((size_t) len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|     48|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (778:13): [True: 0, False: 48]
  ------------------
  779|      0|            xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  780|      0|            return(-1);
  781|      0|        }
  782|     48|        needSize = buf->use + len + 1;
  783|     48|	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (783:6): [True: 0, False: 48]
  ------------------
  784|       |	    /*
  785|       |	     * Used to provide parsing limits
  786|       |	     */
  787|      0|	    if (needSize >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (787:10): [True: 0, False: 0]
  ------------------
  788|      0|		xmlBufMemoryError(buf, "buffer error: text too long\n");
  789|      0|		return(-1);
  790|      0|	    }
  791|      0|	}
  792|     48|        if (!xmlBufResize(buf, needSize)){
  ------------------
  |  Branch (792:13): [True: 0, False: 48]
  ------------------
  793|      0|	    xmlBufMemoryError(buf, "growing buffer");
  794|      0|            return XML_ERR_NO_MEMORY;
  795|      0|        }
  796|     48|    }
  797|       |
  798|   181k|    memmove(&buf->content[buf->use], str, len);
  799|   181k|    buf->use += len;
  800|   181k|    buf->content[buf->use] = 0;
  801|   181k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|   181k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 181k, False: 0]
  |  |  ------------------
  |  |   62|   181k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|   181k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 181k, False: 0]
  |  |  ------------------
  |  |   64|   181k|     else buf->compat_use = INT_MAX;
  ------------------
  802|   181k|    return 0;
  803|   181k|}
xmlBufCat:
  816|  1.47k|xmlBufCat(xmlBufPtr buf, const xmlChar *str) {
  817|  1.47k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (817:9): [True: 0, False: 1.47k]
  |  Branch (817:26): [True: 0, False: 1.47k]
  ------------------
  818|      0|        return(-1);
  819|  1.47k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.47k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.47k]
  |  |  ------------------
  |  |   73|  1.47k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.47k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.47k]
  |  |  ------------------
  |  |   76|  1.47k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  820|  1.47k|    if (str == NULL) return -1;
  ------------------
  |  Branch (820:9): [True: 0, False: 1.47k]
  ------------------
  821|  1.47k|    return xmlBufAdd(buf, str, -1);
  822|  1.47k|}
xmlBufCCat:
  835|    980|xmlBufCCat(xmlBufPtr buf, const char *str) {
  836|    980|    return xmlBufCat(buf, (const xmlChar *) str);
  837|    980|}
xmlBufWriteQuotedString:
  852|    490|xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string) {
  853|    490|    const xmlChar *cur, *base;
  854|    490|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (854:9): [True: 0, False: 490]
  |  Branch (854:26): [True: 0, False: 490]
  ------------------
  855|      0|        return(-1);
  856|    490|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    490|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 490]
  |  |  ------------------
  |  |   73|    490|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    490|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 490]
  |  |  ------------------
  |  |   76|    490|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  857|    490|    if (xmlStrchr(string, '\"')) {
  ------------------
  |  Branch (857:9): [True: 0, False: 490]
  ------------------
  858|      0|        if (xmlStrchr(string, '\'')) {
  ------------------
  |  Branch (858:13): [True: 0, False: 0]
  ------------------
  859|      0|	    xmlBufCCat(buf, "\"");
  860|      0|            base = cur = string;
  861|      0|            while(*cur != 0){
  ------------------
  |  Branch (861:19): [True: 0, False: 0]
  ------------------
  862|      0|                if(*cur == '"'){
  ------------------
  |  Branch (862:20): [True: 0, False: 0]
  ------------------
  863|      0|                    if (base != cur)
  ------------------
  |  Branch (863:25): [True: 0, False: 0]
  ------------------
  864|      0|                        xmlBufAdd(buf, base, cur - base);
  865|      0|                    xmlBufAdd(buf, BAD_CAST "&quot;", 6);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  866|      0|                    cur++;
  867|      0|                    base = cur;
  868|      0|                }
  869|      0|                else {
  870|      0|                    cur++;
  871|      0|                }
  872|      0|            }
  873|      0|            if (base != cur)
  ------------------
  |  Branch (873:17): [True: 0, False: 0]
  ------------------
  874|      0|                xmlBufAdd(buf, base, cur - base);
  875|      0|	    xmlBufCCat(buf, "\"");
  876|      0|	}
  877|      0|        else{
  878|      0|	    xmlBufCCat(buf, "\'");
  879|      0|            xmlBufCat(buf, string);
  880|      0|	    xmlBufCCat(buf, "\'");
  881|      0|        }
  882|    490|    } else {
  883|    490|        xmlBufCCat(buf, "\"");
  884|    490|        xmlBufCat(buf, string);
  885|    490|        xmlBufCCat(buf, "\"");
  886|    490|    }
  887|    490|    return(0);
  888|    490|}
xmlBufMergeBuffer:
  993|  1.18k|xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer) {
  994|  1.18k|    int ret = 0;
  995|       |
  996|  1.18k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (996:9): [True: 0, False: 1.18k]
  |  Branch (996:26): [True: 0, False: 1.18k]
  ------------------
  997|      0|	xmlBufferFree(buffer);
  998|      0|        return(-1);
  999|      0|    }
 1000|  1.18k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.18k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.18k]
  |  |  ------------------
  |  |   73|  1.18k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.18k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.18k]
  |  |  ------------------
  |  |   76|  1.18k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1001|  1.18k|    if ((buffer != NULL) && (buffer->content != NULL) &&
  ------------------
  |  Branch (1001:9): [True: 1.18k, False: 0]
  |  Branch (1001:29): [True: 1.18k, False: 0]
  ------------------
 1002|  1.18k|             (buffer->use > 0)) {
  ------------------
  |  Branch (1002:14): [True: 1.18k, False: 0]
  ------------------
 1003|  1.18k|        ret = xmlBufAdd(buf, buffer->content, buffer->use);
 1004|  1.18k|    }
 1005|  1.18k|    xmlBufferFree(buffer);
 1006|  1.18k|    return(ret);
 1007|  1.18k|}
xmlBufResetInput:
 1019|  1.35k|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|  1.35k|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 1.35k]
  ------------------
 1021|      0|        return(-1);
 1022|  1.35k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 0, False: 1.35k]
  |  Branch (1022:26): [True: 0, False: 1.35k]
  ------------------
 1023|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      0|        return(-1);
 1025|      0|    }
 1026|  1.35k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.35k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.35k]
  |  |  ------------------
  |  |   73|  1.35k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.35k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.35k]
  |  |  ------------------
  |  |   76|  1.35k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|  1.35k|    input->base = input->cur = buf->content;
 1028|  1.35k|    input->end = &buf->content[buf->use];
 1029|  1.35k|    return(0);
 1030|  1.35k|}
xmlBufUpdateInput:
 1044|  1.49M|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  1.49M|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 1.49M]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  1.49M|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 1.49M]
  |  Branch (1051:26): [True: 0, False: 1.49M]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  1.49M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.49M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   73|  1.49M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.49M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.49M]
  |  |  ------------------
  |  |   76|  1.49M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  1.49M|    input->base = buf->content;
 1057|  1.49M|    input->cur = input->base + pos;
 1058|  1.49M|    input->end = &buf->content[buf->use];
 1059|  1.49M|    return(0);
 1060|  1.49M|}
buf.c:xmlBufGrowInternal:
  376|  1.47M|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  1.47M|    size_t size;
  378|  1.47M|    xmlChar *newbuf;
  379|       |
  380|  1.47M|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 1.47M]
  |  Branch (380:26): [True: 0, False: 1.47M]
  ------------------
  381|  1.47M|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  1.47M|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 1.47M]
  |  |  ------------------
  |  |   73|  1.47M|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  1.47M|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 1.47M]
  |  |  ------------------
  |  |   76|  1.47M|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  1.47M|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 1.47M, False: 341]
  ------------------
  384|  1.47M|        return(buf->size - buf->use - 1);
  385|    341|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|    341|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 341]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|    341|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 275, False: 66]
  ------------------
  391|    275|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|    275|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 275]
  ------------------
  392|    275|    } else {
  393|     66|        size = buf->use + len;
  394|     66|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|     66|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 66]
  ------------------
  395|     66|    }
  396|       |
  397|    341|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 341]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|    341|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 341]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|    341|    } else {
  420|    341|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|    341|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 341]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|    341|	buf->content = newbuf;
  426|    341|    }
  427|    341|    buf->size = size;
  428|    341|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    341|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 341, False: 0]
  |  |  ------------------
  |  |   62|    341|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    341|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 341, False: 0]
  |  |  ------------------
  |  |   64|    341|     else buf->compat_use = INT_MAX;
  ------------------
  429|    341|    return(buf->size - buf->use - 1);
  430|    341|}

xmlInitializeCatalog:
 3096|      2|xmlInitializeCatalog(void) {
 3097|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3097:9): [True: 0, False: 2]
  ------------------
 3098|      0|	return;
 3099|       |
 3100|      2|    xmlInitializeCatalogData();
 3101|      2|    xmlRMutexLock(xmlCatalogMutex);
 3102|       |
 3103|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3103:9): [True: 0, False: 2]
  ------------------
 3104|      0|	xmlDebugCatalogs = 1;
 3105|       |
 3106|      2|    if (xmlDefaultCatalog == NULL) {
  ------------------
  |  Branch (3106:9): [True: 2, False: 0]
  ------------------
 3107|      2|	const char *catalogs;
 3108|      2|	char *path;
 3109|      2|	const char *cur, *paths;
 3110|      2|	xmlCatalogPtr catal;
 3111|      2|	xmlCatalogEntryPtr *nextent;
 3112|       |
 3113|      2|	catalogs = (const char *) getenv("XML_CATALOG_FILES");
 3114|      2|	if (catalogs == NULL)
  ------------------
  |  Branch (3114:6): [True: 2, False: 0]
  ------------------
 3115|       |#if defined(_WIN32) && defined(_MSC_VER)
 3116|       |    {
 3117|       |		void* hmodule;
 3118|       |		hmodule = GetModuleHandleA("libxml2.dll");
 3119|       |		if (hmodule == NULL)
 3120|       |			hmodule = GetModuleHandleA(NULL);
 3121|       |		if (hmodule != NULL) {
 3122|       |			char buf[256];
 3123|       |			unsigned long len = GetModuleFileNameA(hmodule, buf, 255);
 3124|       |			if (len != 0) {
 3125|       |				char* p = &(buf[len]);
 3126|       |				while (*p != '\\' && p > buf)
 3127|       |					p--;
 3128|       |				if (p != buf) {
 3129|       |					xmlChar* uri;
 3130|       |					strncpy(p, "\\..\\etc\\catalog", 255 - (p - buf));
 3131|       |					uri = xmlCanonicPath((const xmlChar*)buf);
 3132|       |					if (uri != NULL) {
 3133|       |						strncpy(XML_XML_DEFAULT_CATALOG, (char* )uri, 255);
 3134|       |						xmlFree(uri);
 3135|       |					}
 3136|       |				}
 3137|       |			}
 3138|       |		}
 3139|       |		catalogs = XML_XML_DEFAULT_CATALOG;
 3140|       |    }
 3141|       |#else
 3142|      2|	    catalogs = XML_XML_DEFAULT_CATALOG;
  ------------------
  |  |   70|      2|#define XML_XML_DEFAULT_CATALOG "file://" SYSCONFDIR "/xml/catalog"
  ------------------
 3143|      2|#endif
 3144|       |
 3145|      2|	catal = xmlCreateNewCatalog(XML_XML_CATALOG_TYPE,
 3146|      2|		xmlCatalogDefaultPrefer);
 3147|      2|	if (catal != NULL) {
  ------------------
  |  Branch (3147:6): [True: 2, False: 0]
  ------------------
 3148|       |	    /* the XML_CATALOG_FILES envvar is allowed to contain a
 3149|       |	       space-separated list of entries. */
 3150|      2|	    cur = catalogs;
 3151|      2|	    nextent = &catal->xml;
 3152|      4|	    while (*cur != '\0') {
  ------------------
  |  Branch (3152:13): [True: 2, False: 2]
  ------------------
 3153|      2|		while (xmlIsBlank_ch(*cur))
  ------------------
  |  |   88|      2|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 2]
  |  |  ------------------
  |  |   89|      2|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  ------------------
  |  |   90|      2|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  ------------------
  ------------------
 3154|      0|		    cur++;
 3155|      2|		if (*cur != 0) {
  ------------------
  |  Branch (3155:7): [True: 2, False: 0]
  ------------------
 3156|      2|		    paths = cur;
 3157|     68|		    while ((*cur != 0) && (!xmlIsBlank_ch(*cur)))
  ------------------
  |  |   88|     66|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  ------------------
  |  |  |  Branch (88:27): [True: 0, False: 66]
  |  |  ------------------
  |  |   89|     66|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  ------------------
  |  |  |  Branch (89:7): [True: 66, False: 0]
  |  |  |  Branch (89:23): [True: 0, False: 66]
  |  |  ------------------
  |  |   90|     66|				 ((c) == 0xd))
  |  |  ------------------
  |  |  |  Branch (90:6): [True: 0, False: 66]
  |  |  ------------------
  ------------------
  |  Branch (3157:14): [True: 66, False: 2]
  ------------------
 3158|     66|			cur++;
 3159|      2|		    path = (char *) xmlStrndup((const xmlChar *)paths, cur - paths);
 3160|      2|		    if (path != NULL) {
  ------------------
  |  Branch (3160:11): [True: 2, False: 0]
  ------------------
 3161|      2|			*nextent = xmlNewCatalogEntry(XML_CATA_CATALOG, NULL,
 3162|      2|				NULL, BAD_CAST path, xmlCatalogDefaultPrefer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
 3163|      2|			if (*nextent != NULL)
  ------------------
  |  Branch (3163:8): [True: 2, False: 0]
  ------------------
 3164|      2|			    nextent = &((*nextent)->next);
 3165|      2|			xmlFree(path);
 3166|      2|		    }
 3167|      2|		}
 3168|      2|	    }
 3169|      2|	    xmlDefaultCatalog = catal;
 3170|      2|	}
 3171|      2|    }
 3172|       |
 3173|      2|    xmlRMutexUnlock(xmlCatalogMutex);
 3174|      2|}
catalog.c:xmlCreateNewCatalog:
  406|      2|xmlCreateNewCatalog(xmlCatalogType type, xmlCatalogPrefer prefer) {
  407|      2|    xmlCatalogPtr ret;
  408|       |
  409|      2|    ret = (xmlCatalogPtr) xmlMalloc(sizeof(xmlCatalog));
  410|      2|    if (ret == NULL) {
  ------------------
  |  Branch (410:9): [True: 0, False: 2]
  ------------------
  411|      0|        xmlCatalogErrMemory("allocating catalog");
  412|      0|	return(NULL);
  413|      0|    }
  414|      2|    memset(ret, 0, sizeof(xmlCatalog));
  415|      2|    ret->type = type;
  416|      2|    ret->catalNr = 0;
  417|      2|    ret->catalMax = XML_MAX_SGML_CATA_DEPTH;
  ------------------
  |  |  144|      2|#define XML_MAX_SGML_CATA_DEPTH 10
  ------------------
  418|      2|    ret->prefer = prefer;
  419|      2|    if (ret->type == XML_SGML_CATALOG_TYPE)
  ------------------
  |  Branch (419:9): [True: 0, False: 2]
  ------------------
  420|      0|	ret->sgml = xmlHashCreate(10);
  421|      2|    return(ret);
  422|      2|}
catalog.c:xmlNewCatalogEntry:
  267|      2|	   xmlCatalogEntryPtr group) {
  268|      2|    xmlCatalogEntryPtr ret;
  269|      2|    xmlChar *normid = NULL;
  270|       |
  271|      2|    ret = (xmlCatalogEntryPtr) xmlMalloc(sizeof(xmlCatalogEntry));
  272|      2|    if (ret == NULL) {
  ------------------
  |  Branch (272:9): [True: 0, False: 2]
  ------------------
  273|      0|        xmlCatalogErrMemory("allocating catalog entry");
  274|      0|	return(NULL);
  275|      0|    }
  276|      2|    ret->next = NULL;
  277|      2|    ret->parent = NULL;
  278|      2|    ret->children = NULL;
  279|      2|    ret->type = type;
  280|      2|    if (type == XML_CATA_PUBLIC || type == XML_CATA_DELEGATE_PUBLIC) {
  ------------------
  |  Branch (280:9): [True: 0, False: 2]
  |  Branch (280:36): [True: 0, False: 2]
  ------------------
  281|      0|        normid = xmlCatalogNormalizePublic(name);
  282|      0|        if (normid != NULL)
  ------------------
  |  Branch (282:13): [True: 0, False: 0]
  ------------------
  283|      0|            name = (*normid != 0 ? normid : NULL);
  ------------------
  |  Branch (283:21): [True: 0, False: 0]
  ------------------
  284|      0|    }
  285|      2|    if (name != NULL)
  ------------------
  |  Branch (285:9): [True: 0, False: 2]
  ------------------
  286|      0|	ret->name = xmlStrdup(name);
  287|      2|    else
  288|      2|	ret->name = NULL;
  289|      2|    if (normid != NULL)
  ------------------
  |  Branch (289:9): [True: 0, False: 2]
  ------------------
  290|      0|        xmlFree(normid);
  291|      2|    if (value != NULL)
  ------------------
  |  Branch (291:9): [True: 0, False: 2]
  ------------------
  292|      0|	ret->value = xmlStrdup(value);
  293|      2|    else
  294|      2|	ret->value = NULL;
  295|      2|    if (URL == NULL)
  ------------------
  |  Branch (295:9): [True: 0, False: 2]
  ------------------
  296|      0|	URL = value;
  297|      2|    if (URL != NULL)
  ------------------
  |  Branch (297:9): [True: 2, False: 0]
  ------------------
  298|      2|	ret->URL = xmlStrdup(URL);
  299|      0|    else
  300|      0|	ret->URL = NULL;
  301|      2|    ret->prefer = prefer;
  302|      2|    ret->dealloc = 0;
  303|      2|    ret->depth = 0;
  304|      2|    ret->group = group;
  305|      2|    return(ret);
  306|      2|}
catalog.c:xmlInitializeCatalogData:
 3078|      2|xmlInitializeCatalogData(void) {
 3079|      2|    if (xmlCatalogInitialized != 0)
  ------------------
  |  Branch (3079:9): [True: 0, False: 2]
  ------------------
 3080|      0|	return;
 3081|       |
 3082|      2|    if (getenv("XML_DEBUG_CATALOG"))
  ------------------
  |  Branch (3082:9): [True: 0, False: 2]
  ------------------
 3083|      0|	xmlDebugCatalogs = 1;
 3084|      2|    xmlCatalogMutex = xmlNewRMutex();
 3085|       |
 3086|      2|    xmlCatalogInitialized = 1;
 3087|      2|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|  1.32k|xmlDictCreate(void) {
  263|  1.32k|    xmlDictPtr dict;
  264|       |
  265|  1.32k|    xmlInitParser();
  266|       |
  267|  1.32k|    dict = xmlMalloc(sizeof(xmlDict));
  268|  1.32k|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 0, False: 1.32k]
  ------------------
  269|      0|        return(NULL);
  270|  1.32k|    dict->ref_counter = 1;
  271|  1.32k|    dict->limit = 0;
  272|       |
  273|  1.32k|    dict->size = 0;
  274|  1.32k|    dict->nbElems = 0;
  275|  1.32k|    dict->table = NULL;
  276|  1.32k|    dict->strings = NULL;
  277|  1.32k|    dict->subdict = NULL;
  278|  1.32k|    dict->seed = xmlRandom();
  279|  1.32k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|  1.32k|    dict->seed = 0;
  281|  1.32k|#endif
  282|  1.32k|    return(dict);
  283|  1.32k|}
xmlDictReference:
  317|  1.96k|xmlDictReference(xmlDictPtr dict) {
  318|  1.96k|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 0, False: 1.96k]
  ------------------
  319|  1.96k|    xmlMutexLock(&xmlDictMutex);
  320|  1.96k|    dict->ref_counter++;
  321|  1.96k|    xmlMutexUnlock(&xmlDictMutex);
  322|  1.96k|    return(0);
  323|  1.96k|}
xmlDictFree:
  333|  3.28k|xmlDictFree(xmlDictPtr dict) {
  334|  3.28k|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|  3.28k|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 3.28k]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|  3.28k|    xmlMutexLock(&xmlDictMutex);
  341|  3.28k|    dict->ref_counter--;
  342|  3.28k|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 1.96k, False: 1.32k]
  ------------------
  343|  1.96k|        xmlMutexUnlock(&xmlDictMutex);
  344|  1.96k|        return;
  345|  1.96k|    }
  346|       |
  347|  1.32k|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|  1.32k|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 1.32k]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|  1.32k|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 995, False: 327]
  ------------------
  354|    995|	xmlFree(dict->table);
  355|    995|    }
  356|  1.32k|    pool = dict->strings;
  357|  2.35k|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 1.03k, False: 1.32k]
  ------------------
  358|  1.03k|        nextp = pool->next;
  359|  1.03k|	xmlFree(pool);
  360|  1.03k|	pool = nextp;
  361|  1.03k|    }
  362|  1.32k|    xmlFree(dict);
  363|  1.32k|}
xmlDictOwns:
  376|   745k|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|   745k|    xmlDictStringsPtr pool;
  378|       |
  379|   745k|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 745k]
  |  Branch (379:27): [True: 0, False: 745k]
  ------------------
  380|      0|	return(-1);
  381|   745k|    pool = dict->strings;
  382|  1.46M|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 911k, False: 550k]
  ------------------
  383|   911k|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 754k, False: 157k]
  |  Branch (383:41): [True: 195k, False: 559k]
  ------------------
  384|   195k|	    return(1);
  385|   716k|	pool = pool->next;
  386|   716k|    }
  387|   550k|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 550k]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|   550k|    return(0);
  390|   550k|}
xmlDictSetLimit:
  421|  1.32k|xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
  422|  1.32k|    size_t ret;
  423|       |
  424|  1.32k|    if (dict == NULL)
  ------------------
  |  Branch (424:9): [True: 0, False: 1.32k]
  ------------------
  425|      0|	return(0);
  426|  1.32k|    ret = dict->limit;
  427|  1.32k|    dict->limit = limit;
  428|  1.32k|    return(ret);
  429|  1.32k|}
xmlDictComputeHash:
  512|  2.07k|xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {
  513|  2.07k|    size_t len;
  514|  2.07k|    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));
  ------------------
  |  |   35|  2.07k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  515|  2.07k|}
xmlDictCombineHash:
  521|   187k|xmlDictCombineHash(unsigned v1, unsigned v2) {
  522|       |    /*
  523|       |     * The upper bit of hash values is always set, so we have to operate on
  524|       |     * 31-bit hashes here.
  525|       |     */
  526|   187k|    v1 ^= v2;
  527|   187k|    v1 += HASH_ROL31(v2, 5);
  ------------------
  |  |  517|   187k|#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))
  ------------------
  528|       |
  529|   187k|    return((v1 & 0xFFFFFFFF) | 0x80000000);
  530|   187k|}
xmlDictLookup:
  824|   210k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|   210k|    const xmlDictEntry *entry;
  826|       |
  827|   210k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|   210k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 5.60k, False: 204k]
  ------------------
  829|  5.60k|        return(NULL);
  830|   204k|    return(entry->name);
  831|   210k|}
xmlDictLookupHashed:
  845|   126k|xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {
  846|   126k|    const xmlDictEntry *entry;
  847|   126k|    xmlHashedString ret;
  848|       |
  849|   126k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  850|       |
  851|   126k|    if (entry == NULL) {
  ------------------
  |  Branch (851:9): [True: 0, False: 126k]
  ------------------
  852|      0|        ret.name = NULL;
  853|      0|        ret.hashValue = 0;
  854|   126k|    } else {
  855|   126k|        ret = *entry;
  856|   126k|    }
  857|       |
  858|   126k|    return(ret);
  859|   126k|}
xmlDictQLookup:
  894|      9|xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
  895|      9|    const xmlDictEntry *entry;
  896|       |
  897|      9|    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);
  898|      9|    if (entry == NULL)
  ------------------
  |  Branch (898:9): [True: 0, False: 9]
  ------------------
  899|      0|        return(NULL);
  900|      9|    return(entry->name);
  901|      9|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|  2.61k|xmlRandom(void) {
  952|  2.61k|#ifdef XML_THREAD_LOCAL
  953|  2.61k|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 2.61k]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|  2.61k|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|  2.61k|}
dict.c:xmlDictHashName:
  465|   333k|                size_t *plen) {
  466|   333k|    unsigned h1, h2;
  467|   333k|    size_t i;
  468|       |
  469|   333k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|   333k|    do { \
  |  |   24|   333k|        h1 = seed ^ 0x3b00; \
  |  |   25|   333k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|   333k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|   333k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|  1.92M|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 1.61M, False: 305k]
  |  Branch (471:31): [True: 1.58M, False: 28.7k]
  ------------------
  472|  1.58M|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|  1.58M|    do { \
  |  |   30|  1.58M|        h1 += ch; \
  |  |   31|  1.58M|        h1 += h1 << 3; \
  |  |   32|  1.58M|        h2 += h1; \
  |  |   33|  1.58M|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  1.58M|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  1.58M|        h2 += h2 << 2; \
  |  |   35|  1.58M|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|  1.58M|    }
  474|       |
  475|   333k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|   333k|    do { \
  |  |   40|   333k|        h1 ^= h2; \
  |  |   41|   333k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|   333k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|   333k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|   333k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|   333k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|   333k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|   333k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|   333k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|   333k|        h2 &= 0xFFFFFFFF; \
  |  |   46|   333k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|   333k|    *plen = i;
  478|   333k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|   333k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|   333k|}
dict.c:xmlDictLookupInternal:
  679|   337k|                      const xmlChar *name, int maybeLen, int update) {
  680|   337k|    xmlDictEntry *entry = NULL;
  681|   337k|    const xmlChar *ret;
  682|   337k|    unsigned hashValue;
  683|   337k|    size_t maxLen, len, plen, klen;
  684|   337k|    int found = 0;
  685|       |
  686|   337k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 337k]
  |  Branch (686:27): [True: 5.60k, False: 331k]
  ------------------
  687|  5.60k|	return(NULL);
  688|       |
  689|   331k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|  26.7k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 26.7k, False: 305k]
  ------------------
  690|       |
  691|   331k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 331k, False: 9]
  ------------------
  692|   331k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|   331k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 331k]
  ------------------
  694|      0|            return(NULL);
  695|   331k|        klen = len;
  696|   331k|    } else {
  697|      9|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|      9|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 9]
  |  Branch (698:36): [True: 0, False: 9]
  ------------------
  699|      0|            return(NULL);
  700|      9|        klen = plen + 1 + len;
  701|      9|    }
  702|       |
  703|   331k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 331k, False: 0]
  |  Branch (703:30): [True: 0, False: 331k]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|   331k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 330k, False: 995]
  ------------------
  710|   330k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|   331k|    if (found)
  ------------------
  |  Branch (711:9): [True: 315k, False: 16.6k]
  ------------------
  712|   315k|        return(entry);
  713|       |
  714|  16.6k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 16.6k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  16.6k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 16.6k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  16.6k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  16.6k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  16.6k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 1.84k, False: 14.7k]
  ------------------
  737|  1.84k|        unsigned newSize, mask, displ, pos;
  738|       |
  739|  1.84k|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 995, False: 854]
  ------------------
  740|    995|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|    995|#define MIN_HASH_SIZE 8
  ------------------
  741|    995|        } else {
  742|    854|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|    854|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 854]
  ------------------
  743|      0|                return(NULL);
  744|    854|            newSize = dict->size * 2;
  745|    854|        }
  746|  1.84k|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 1.84k]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|  1.84k|        mask = dict->size - 1;
  753|  1.84k|        displ = 0;
  754|  1.84k|        pos = hashValue & mask;
  755|  1.84k|        entry = &dict->table[pos];
  756|       |
  757|  2.19k|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 461, False: 1.73k]
  ------------------
  758|  2.19k|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 342, False: 119]
  ------------------
  759|    342|            displ++;
  760|    342|            pos++;
  761|    342|            entry++;
  762|    342|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 25, False: 317]
  ------------------
  763|     25|                entry = dict->table;
  764|    342|        }
  765|  1.84k|    }
  766|       |
  767|  16.6k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 16.6k, False: 9]
  ------------------
  768|  16.6k|        ret = xmlDictAddString(dict, name, len);
  769|      9|    else
  770|      9|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  16.6k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 16.6k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  16.6k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 4.38k, False: 12.2k]
  ------------------
  778|  4.38k|        const xmlDictEntry *end = &dict->table[dict->size];
  779|  4.38k|        const xmlDictEntry *cur = entry;
  780|       |
  781|  25.5k|        do {
  782|  25.5k|            cur++;
  783|  25.5k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 509, False: 24.9k]
  ------------------
  784|    509|                cur = dict->table;
  785|  25.5k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 21.1k, False: 4.38k]
  ------------------
  786|       |
  787|  4.38k|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 509, False: 3.87k]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|    509|            memmove(&dict->table[1], dict->table,
  793|    509|                    (char *) cur - (char *) dict->table);
  794|    509|            cur = end - 1;
  795|    509|            dict->table[0] = *cur;
  796|    509|        }
  797|       |
  798|  4.38k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|  4.38k|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  16.6k|    entry->hashValue = hashValue;
  805|  16.6k|    entry->name = ret;
  806|       |
  807|  16.6k|    dict->nbElems++;
  808|       |
  809|  16.6k|    return(entry);
  810|  16.6k|}
dict.c:xmlDictHashQName:
  484|      9|                 size_t *pplen, size_t *plen) {
  485|      9|    unsigned h1, h2;
  486|      9|    size_t i;
  487|       |
  488|      9|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|      9|    do { \
  |  |   24|      9|        h1 = seed ^ 0x3b00; \
  |  |   25|      9|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|      9|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|      9|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  489|       |
  490|  30.7k|    for (i = 0; prefix[i] != 0; i++) {
  ------------------
  |  Branch (490:17): [True: 30.7k, False: 9]
  ------------------
  491|  30.7k|        HASH_UPDATE(h1, h2, prefix[i]);
  ------------------
  |  |   29|  30.7k|    do { \
  |  |   30|  30.7k|        h1 += ch; \
  |  |   31|  30.7k|        h1 += h1 << 3; \
  |  |   32|  30.7k|        h2 += h1; \
  |  |   33|  30.7k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  30.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  30.7k|        h2 += h2 << 2; \
  |  |   35|  30.7k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  492|  30.7k|    }
  493|      9|    *pplen = i;
  494|       |
  495|      9|    HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      9|    do { \
  |  |   30|      9|        h1 += ch; \
  |  |   31|      9|        h1 += h1 << 3; \
  |  |   32|      9|        h2 += h1; \
  |  |   33|      9|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      9|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      9|        h2 += h2 << 2; \
  |  |   35|      9|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  496|       |
  497|     30|    for (i = 0; name[i] != 0; i++) {
  ------------------
  |  Branch (497:17): [True: 21, False: 9]
  ------------------
  498|     21|        HASH_UPDATE(h1, h2, name[i]);
  ------------------
  |  |   29|     21|    do { \
  |  |   30|     21|        h1 += ch; \
  |  |   31|     21|        h1 += h1 << 3; \
  |  |   32|     21|        h2 += h1; \
  |  |   33|     21|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|     21|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|     21|        h2 += h2 << 2; \
  |  |   35|     21|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  499|     21|    }
  500|      9|    *plen = i;
  501|       |
  502|      9|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|      9|    do { \
  |  |   40|      9|        h1 ^= h2; \
  |  |   41|      9|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|      9|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|      9|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|      9|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|      9|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|      9|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|      9|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|      9|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|      9|        h2 &= 0xFFFFFFFF; \
  |  |   46|      9|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  503|       |
  504|       |    /*
  505|       |     * Always set the upper bit of hash values since 0 means an unoccupied
  506|       |     * bucket.
  507|       |     */
  508|      9|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|      9|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  509|      9|}
dict.c:xmlDictFindEntry:
  549|   330k|                 int *pfound) {
  550|   330k|    xmlDictEntry *entry;
  551|   330k|    unsigned mask, pos, displ;
  552|   330k|    int found = 0;
  553|       |
  554|   330k|    mask = dict->size - 1;
  555|   330k|    pos = hashValue & mask;
  556|   330k|    entry = &dict->table[pos];
  557|       |
  558|   330k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 323k, False: 7.21k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|   323k|        displ = 0;
  565|       |
  566|   563k|        do {
  567|   563k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 315k, False: 248k]
  ------------------
  568|   315k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 315k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|   315k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 315k, False: 0]
  ------------------
  573|   315k|                                 (const char *) name, len) == 0) &&
  574|   315k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 315k, False: 0]
  ------------------
  575|   315k|                        found = 1;
  576|   315k|                        break;
  577|   315k|                    }
  578|   315k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|   315k|            }
  585|       |
  586|   248k|            displ++;
  587|   248k|            pos++;
  588|   248k|            entry++;
  589|   248k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 3.20k, False: 245k]
  ------------------
  590|  3.20k|                entry = dict->table;
  591|   248k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 244k, False: 3.62k]
  ------------------
  592|   248k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 240k, False: 4.77k]
  ------------------
  593|   323k|    }
  594|       |
  595|      0|    *pfound = found;
  596|   330k|    return(entry);
  597|   330k|}
dict.c:xmlDictGrow:
  609|  1.84k|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|  1.84k|    const xmlDictEntry *oldentry, *oldend, *end;
  611|  1.84k|    xmlDictEntry *table;
  612|  1.84k|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|  1.84k|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|  1.84k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 1.84k]
  ------------------
  616|      0|        return(-1);
  617|  1.84k|    table = xmlMalloc(size * sizeof(table[0]));
  618|  1.84k|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 1.84k]
  ------------------
  619|      0|        return(-1);
  620|  1.84k|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|  1.84k|    oldsize = dict->size;
  623|  1.84k|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 995, False: 854]
  ------------------
  624|    995|        goto done;
  625|       |
  626|    854|    oldend = &dict->table[oldsize];
  627|    854|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|    854|    oldentry = dict->table;
  637|  6.01k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 5.16k, False: 854]
  ------------------
  638|  5.16k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 5.16k]
  ------------------
  639|      0|            oldentry = dict->table;
  640|  5.16k|    }
  641|       |
  642|  19.8k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 19.0k, False: 854]
  ------------------
  643|  19.0k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 16.6k, False: 2.37k]
  ------------------
  644|  16.6k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  23.0k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 6.38k, False: 16.6k]
  ------------------
  647|  6.38k|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 291, False: 6.09k]
  ------------------
  648|    291|                    entry = table;
  649|  6.38k|            }
  650|  16.6k|            *entry = *oldentry;
  651|  16.6k|        }
  652|       |
  653|  19.0k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 854, False: 18.1k]
  ------------------
  654|    854|            oldentry = dict->table;
  655|  19.0k|    }
  656|       |
  657|    854|    xmlFree(dict->table);
  658|       |
  659|  1.84k|done:
  660|  1.84k|    dict->table = table;
  661|  1.84k|    dict->size = size;
  662|       |
  663|  1.84k|    return(0);
  664|    854|}
dict.c:xmlDictAddString:
  136|  16.6k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  16.6k|    xmlDictStringsPtr pool;
  138|  16.6k|    const xmlChar *ret;
  139|  16.6k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  16.6k|    size_t limit = 0;
  141|       |
  142|  16.6k|    pool = dict->strings;
  143|  16.6k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 15.6k, False: 1.03k]
  ------------------
  144|  15.6k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 15.5k, False: 45]
  ------------------
  145|  15.5k|	    goto found_pool;
  146|     45|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 42, False: 3]
  ------------------
  147|     45|        limit += pool->size;
  148|     45|	pool = pool->next;
  149|     45|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|  1.03k|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 1.03k, False: 0]
  ------------------
  154|  1.03k|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 1.03k, False: 0]
  |  Branch (154:34): [True: 0, False: 1.03k]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|  1.03k|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 995, False: 42]
  ------------------
  159|    995|            size = 1000;
  160|    995|        } else {
  161|     42|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|     42|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 42, False: 0]
  ------------------
  162|     42|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|     42|        }
  166|  1.03k|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 22, False: 1.01k]
  ------------------
  167|     22|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|     22|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 22, False: 0]
  ------------------
  168|     22|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|     22|        }
  172|  1.03k|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|  1.03k|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 1.03k]
  ------------------
  174|      0|	    return(NULL);
  175|  1.03k|	pool->size = size;
  176|  1.03k|	pool->nbStrings = 0;
  177|  1.03k|	pool->free = &pool->array[0];
  178|  1.03k|	pool->end = &pool->array[size];
  179|  1.03k|	pool->next = dict->strings;
  180|  1.03k|	dict->strings = pool;
  181|  1.03k|    }
  182|  16.6k|found_pool:
  183|  16.6k|    ret = pool->free;
  184|  16.6k|    memcpy(pool->free, name, namelen);
  185|  16.6k|    pool->free += namelen;
  186|  16.6k|    *(pool->free++) = 0;
  187|  16.6k|    pool->nbStrings++;
  188|  16.6k|    return(ret);
  189|  1.03k|}
dict.c:xmlDictAddQString:
  206|      9|{
  207|      9|    xmlDictStringsPtr pool;
  208|      9|    const xmlChar *ret;
  209|      9|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  210|      9|    size_t limit = 0;
  211|       |
  212|      9|    pool = dict->strings;
  213|      9|    while (pool != NULL) {
  ------------------
  |  Branch (213:12): [True: 9, False: 0]
  ------------------
  214|      9|	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)
  ------------------
  |  Branch (214:6): [True: 9, False: 0]
  ------------------
  215|      9|	    goto found_pool;
  216|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (216:6): [True: 0, False: 0]
  ------------------
  217|      0|        limit += pool->size;
  218|      0|	pool = pool->next;
  219|      0|    }
  220|       |    /*
  221|       |     * Not found, need to allocate
  222|       |     */
  223|      0|    if (pool == NULL) {
  ------------------
  |  Branch (223:9): [True: 0, False: 0]
  ------------------
  224|      0|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  |  Branch (224:34): [True: 0, False: 0]
  ------------------
  225|      0|            return(NULL);
  226|      0|        }
  227|       |
  228|      0|        if (size == 0) size = 1000;
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|	else size *= 4; /* exponential growth */
  230|      0|        if (size < 4 * (namelen + plen + 1))
  ------------------
  |  Branch (230:13): [True: 0, False: 0]
  ------------------
  231|      0|	    size = 4 * (namelen + plen + 1); /* just in case ! */
  232|      0|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  233|      0|	if (pool == NULL)
  ------------------
  |  Branch (233:6): [True: 0, False: 0]
  ------------------
  234|      0|	    return(NULL);
  235|      0|	pool->size = size;
  236|      0|	pool->nbStrings = 0;
  237|      0|	pool->free = &pool->array[0];
  238|      0|	pool->end = &pool->array[size];
  239|      0|	pool->next = dict->strings;
  240|      0|	dict->strings = pool;
  241|      0|    }
  242|      9|found_pool:
  243|      9|    ret = pool->free;
  244|      9|    memcpy(pool->free, prefix, plen);
  245|      9|    pool->free += plen;
  246|      9|    *(pool->free++) = ':';
  247|      9|    memcpy(pool->free, name, namelen);
  248|      9|    pool->free += namelen;
  249|      9|    *(pool->free++) = 0;
  250|      9|    pool->nbStrings++;
  251|      9|    return(ret);
  252|      0|}
dict.c:xoroshiro64ss:
  938|  2.61k|xoroshiro64ss(unsigned *s) {
  939|  2.61k|    unsigned s0 = s[0];
  940|  2.61k|    unsigned s1 = s[1];
  941|  2.61k|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|  2.61k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|  2.61k|    s1 ^= s0;
  944|  2.61k|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|  2.61k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|  2.61k|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|  2.61k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|  2.61k|    return(result & 0xFFFFFFFF);
  948|  2.61k|}

isolat1ToUTF8:
  284|  1.90k|              const unsigned char* in, int *inlen) {
  285|  1.90k|    unsigned char* outstart = out;
  286|  1.90k|    const unsigned char* base = in;
  287|  1.90k|    unsigned char* outend;
  288|  1.90k|    const unsigned char* inend;
  289|  1.90k|    const unsigned char* instop;
  290|       |
  291|  1.90k|    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (291:9): [True: 0, False: 1.90k]
  |  Branch (291:26): [True: 0, False: 1.90k]
  |  Branch (291:42): [True: 0, False: 1.90k]
  |  Branch (291:62): [True: 0, False: 1.90k]
  ------------------
  292|      0|	return(XML_ENC_ERR_INTERNAL);
  293|       |
  294|  1.90k|    outend = out + *outlen;
  295|  1.90k|    inend = in + (*inlen);
  296|  1.90k|    instop = inend;
  297|       |
  298|  4.19k|    while ((in < inend) && (out < outend - 1)) {
  ------------------
  |  Branch (298:12): [True: 2.28k, False: 1.90k]
  |  Branch (298:28): [True: 2.28k, False: 0]
  ------------------
  299|  2.28k|	if (*in >= 0x80) {
  ------------------
  |  Branch (299:6): [True: 381, False: 1.90k]
  ------------------
  300|    381|	    *out++ = (((*in) >>  6) & 0x1F) | 0xC0;
  301|    381|            *out++ = ((*in) & 0x3F) | 0x80;
  302|    381|	    ++in;
  303|    381|	}
  304|  2.28k|	if ((instop - in) > (outend - out)) instop = in + (outend - out);
  ------------------
  |  Branch (304:6): [True: 0, False: 2.28k]
  ------------------
  305|   564k|	while ((in < instop) && (*in < 0x80)) {
  ------------------
  |  Branch (305:9): [True: 562k, False: 1.90k]
  |  Branch (305:26): [True: 561k, False: 381]
  ------------------
  306|   561k|	    *out++ = *in++;
  307|   561k|	}
  308|  2.28k|    }
  309|  1.90k|    if ((in < inend) && (out < outend) && (*in < 0x80)) {
  ------------------
  |  Branch (309:9): [True: 0, False: 1.90k]
  |  Branch (309:25): [True: 0, False: 0]
  |  Branch (309:43): [True: 0, False: 0]
  ------------------
  310|      0|        *out++ = *in++;
  311|      0|    }
  312|  1.90k|    *outlen = out - outstart;
  313|  1.90k|    *inlen = in - base;
  314|  1.90k|    return(*outlen);
  315|  1.90k|}
UTF8Toisolat1:
  385|     78|              const unsigned char* in, int *inlen) {
  386|     78|    const unsigned char* processed = in;
  387|     78|    const unsigned char* outend;
  388|     78|    const unsigned char* outstart = out;
  389|     78|    const unsigned char* instart = in;
  390|     78|    const unsigned char* inend;
  391|     78|    unsigned int c, d;
  392|     78|    int trailing;
  393|       |
  394|     78|    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (394:9): [True: 0, False: 78]
  |  Branch (394:26): [True: 0, False: 78]
  |  Branch (394:46): [True: 0, False: 78]
  ------------------
  395|      0|        return(XML_ENC_ERR_INTERNAL);
  396|     78|    if (in == NULL) {
  ------------------
  |  Branch (396:9): [True: 12, False: 66]
  ------------------
  397|       |        /*
  398|       |	 * initialization nothing to do
  399|       |	 */
  400|     12|	*outlen = 0;
  401|     12|	*inlen = 0;
  402|     12|	return(0);
  403|     12|    }
  404|     66|    inend = in + (*inlen);
  405|     66|    outend = out + (*outlen);
  406|   217k|    while (in < inend) {
  ------------------
  |  Branch (406:12): [True: 216k, False: 66]
  ------------------
  407|   216k|	d = *in++;
  408|   216k|	if      (d < 0x80)  { c= d; trailing= 0; }
  ------------------
  |  Branch (408:11): [True: 216k, False: 452]
  ------------------
  409|    452|	else if (d < 0xC0) {
  ------------------
  |  Branch (409:11): [True: 0, False: 452]
  ------------------
  410|       |	    /* trailing byte in leading position */
  411|      0|	    *outlen = out - outstart;
  412|      0|	    *inlen = processed - instart;
  413|      0|	    return(XML_ENC_ERR_INPUT);
  414|    452|        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
  ------------------
  |  Branch (414:20): [True: 452, False: 0]
  ------------------
  415|      0|        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
  ------------------
  |  Branch (415:18): [True: 0, False: 0]
  ------------------
  416|      0|        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
  ------------------
  |  Branch (416:18): [True: 0, False: 0]
  ------------------
  417|      0|	else {
  418|       |	    /* no chance for this in IsoLat1 */
  419|      0|	    *outlen = out - outstart;
  420|      0|	    *inlen = processed - instart;
  421|      0|	    return(XML_ENC_ERR_INPUT);
  422|      0|	}
  423|       |
  424|   216k|	if (inend - in < trailing) {
  ------------------
  |  Branch (424:6): [True: 0, False: 216k]
  ------------------
  425|      0|	    break;
  426|      0|	}
  427|       |
  428|   217k|	for ( ; trailing; trailing--) {
  ------------------
  |  Branch (428:10): [True: 452, False: 216k]
  ------------------
  429|    452|	    if (in >= inend)
  ------------------
  |  Branch (429:10): [True: 0, False: 452]
  ------------------
  430|      0|		break;
  431|    452|	    if (((d= *in++) & 0xC0) != 0x80) {
  ------------------
  |  Branch (431:10): [True: 0, False: 452]
  ------------------
  432|      0|		*outlen = out - outstart;
  433|      0|		*inlen = processed - instart;
  434|      0|		return(XML_ENC_ERR_INPUT);
  435|      0|	    }
  436|    452|	    c <<= 6;
  437|    452|	    c |= d & 0x3F;
  438|    452|	}
  439|       |
  440|       |	/* assertion: c is a single UTF-4 value */
  441|   216k|	if (c <= 0xFF) {
  ------------------
  |  Branch (441:6): [True: 216k, False: 0]
  ------------------
  442|   216k|	    if (out >= outend)
  ------------------
  |  Branch (442:10): [True: 0, False: 216k]
  ------------------
  443|      0|		break;
  444|   216k|	    *out++ = c;
  445|   216k|	} else {
  446|       |	    /* no chance for this in IsoLat1 */
  447|      0|	    *outlen = out - outstart;
  448|      0|	    *inlen = processed - instart;
  449|      0|	    return(XML_ENC_ERR_INPUT);
  450|      0|	}
  451|   216k|	processed = in;
  452|   216k|    }
  453|     66|    *outlen = out - outstart;
  454|     66|    *inlen = processed - instart;
  455|     66|    return(*outlen);
  456|     66|}
xmlGetEncodingAlias:
 1003|    189|xmlGetEncodingAlias(const char *alias) {
 1004|    189|    int i;
 1005|    189|    char upper[100];
 1006|       |
 1007|    189|    if (alias == NULL)
  ------------------
  |  Branch (1007:9): [True: 0, False: 189]
  ------------------
 1008|      0|	return(NULL);
 1009|       |
 1010|    189|    if (xmlCharEncodingAliases == NULL)
  ------------------
  |  Branch (1010:9): [True: 189, False: 0]
  ------------------
 1011|    189|	return(NULL);
 1012|       |
 1013|      0|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1013:16): [True: 0, False: 0]
  ------------------
 1014|      0|        upper[i] = (char) toupper((unsigned char) alias[i]);
 1015|      0|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1015:6): [True: 0, False: 0]
  ------------------
 1016|      0|    }
 1017|      0|    upper[i] = 0;
 1018|       |
 1019|       |    /*
 1020|       |     * Walk down the list looking for a definition of the alias
 1021|       |     */
 1022|      0|    for (i = 0;i < xmlCharEncodingAliasesNb;i++) {
  ------------------
  |  Branch (1022:16): [True: 0, False: 0]
  ------------------
 1023|      0|	if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {
  ------------------
  |  Branch (1023:6): [True: 0, False: 0]
  ------------------
 1024|      0|	    return(xmlCharEncodingAliases[i].name);
 1025|      0|	}
 1026|      0|    }
 1027|      0|    return(NULL);
 1028|      0|}
xmlParseCharEncoding:
 1149|    268|{
 1150|    268|    const char *alias;
 1151|    268|    char upper[500];
 1152|    268|    int i;
 1153|       |
 1154|    268|    if (name == NULL)
  ------------------
  |  Branch (1154:9): [True: 232, False: 36]
  ------------------
 1155|    232|	return(XML_CHAR_ENCODING_NONE);
 1156|       |
 1157|       |    /*
 1158|       |     * Do the alias resolution
 1159|       |     */
 1160|     36|    alias = xmlGetEncodingAlias(name);
 1161|     36|    if (alias != NULL)
  ------------------
  |  Branch (1161:9): [True: 0, False: 36]
  ------------------
 1162|      0|	name = alias;
 1163|       |
 1164|    289|    for (i = 0;i < 499;i++) {
  ------------------
  |  Branch (1164:16): [True: 289, False: 0]
  ------------------
 1165|    289|        upper[i] = (char) toupper((unsigned char) name[i]);
 1166|    289|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1166:6): [True: 36, False: 253]
  ------------------
 1167|    289|    }
 1168|     36|    upper[i] = 0;
 1169|       |
 1170|     36|    if (!strcmp(upper, "")) return(XML_CHAR_ENCODING_NONE);
  ------------------
  |  Branch (1170:9): [True: 0, False: 36]
  ------------------
 1171|     36|    if (!strcmp(upper, "UTF-8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1171:9): [True: 15, False: 21]
  ------------------
 1172|     21|    if (!strcmp(upper, "UTF8")) return(XML_CHAR_ENCODING_UTF8);
  ------------------
  |  Branch (1172:9): [True: 0, False: 21]
  ------------------
 1173|       |
 1174|       |    /*
 1175|       |     * NOTE: if we were able to parse this, the endianness of UTF16 is
 1176|       |     *       already found and in use
 1177|       |     */
 1178|     21|    if (!strcmp(upper, "UTF-16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1178:9): [True: 0, False: 21]
  ------------------
 1179|     21|    if (!strcmp(upper, "UTF16")) return(XML_CHAR_ENCODING_UTF16LE);
  ------------------
  |  Branch (1179:9): [True: 0, False: 21]
  ------------------
 1180|       |
 1181|     21|    if (!strcmp(upper, "ISO-10646-UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1181:9): [True: 0, False: 21]
  ------------------
 1182|     21|    if (!strcmp(upper, "UCS-2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1182:9): [True: 0, False: 21]
  ------------------
 1183|     21|    if (!strcmp(upper, "UCS2")) return(XML_CHAR_ENCODING_UCS2);
  ------------------
  |  Branch (1183:9): [True: 0, False: 21]
  ------------------
 1184|       |
 1185|       |    /*
 1186|       |     * NOTE: if we were able to parse this, the endianness of UCS4 is
 1187|       |     *       already found and in use
 1188|       |     */
 1189|     21|    if (!strcmp(upper, "ISO-10646-UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1189:9): [True: 0, False: 21]
  ------------------
 1190|     21|    if (!strcmp(upper, "UCS-4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1190:9): [True: 0, False: 21]
  ------------------
 1191|     21|    if (!strcmp(upper, "UCS4")) return(XML_CHAR_ENCODING_UCS4LE);
  ------------------
  |  Branch (1191:9): [True: 0, False: 21]
  ------------------
 1192|       |
 1193|       |
 1194|     21|    if (!strcmp(upper,  "ISO-8859-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1194:9): [True: 12, False: 9]
  ------------------
 1195|      9|    if (!strcmp(upper,  "ISO-LATIN-1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1195:9): [True: 0, False: 9]
  ------------------
 1196|      9|    if (!strcmp(upper,  "ISO LATIN 1")) return(XML_CHAR_ENCODING_8859_1);
  ------------------
  |  Branch (1196:9): [True: 0, False: 9]
  ------------------
 1197|       |
 1198|      9|    if (!strcmp(upper,  "ISO-8859-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1198:9): [True: 0, False: 9]
  ------------------
 1199|      9|    if (!strcmp(upper,  "ISO-LATIN-2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1199:9): [True: 0, False: 9]
  ------------------
 1200|      9|    if (!strcmp(upper,  "ISO LATIN 2")) return(XML_CHAR_ENCODING_8859_2);
  ------------------
  |  Branch (1200:9): [True: 0, False: 9]
  ------------------
 1201|       |
 1202|      9|    if (!strcmp(upper,  "ISO-8859-3")) return(XML_CHAR_ENCODING_8859_3);
  ------------------
  |  Branch (1202:9): [True: 0, False: 9]
  ------------------
 1203|      9|    if (!strcmp(upper,  "ISO-8859-4")) return(XML_CHAR_ENCODING_8859_4);
  ------------------
  |  Branch (1203:9): [True: 0, False: 9]
  ------------------
 1204|      9|    if (!strcmp(upper,  "ISO-8859-5")) return(XML_CHAR_ENCODING_8859_5);
  ------------------
  |  Branch (1204:9): [True: 0, False: 9]
  ------------------
 1205|      9|    if (!strcmp(upper,  "ISO-8859-6")) return(XML_CHAR_ENCODING_8859_6);
  ------------------
  |  Branch (1205:9): [True: 0, False: 9]
  ------------------
 1206|      9|    if (!strcmp(upper,  "ISO-8859-7")) return(XML_CHAR_ENCODING_8859_7);
  ------------------
  |  Branch (1206:9): [True: 0, False: 9]
  ------------------
 1207|      9|    if (!strcmp(upper,  "ISO-8859-8")) return(XML_CHAR_ENCODING_8859_8);
  ------------------
  |  Branch (1207:9): [True: 0, False: 9]
  ------------------
 1208|      9|    if (!strcmp(upper,  "ISO-8859-9")) return(XML_CHAR_ENCODING_8859_9);
  ------------------
  |  Branch (1208:9): [True: 0, False: 9]
  ------------------
 1209|       |
 1210|      9|    if (!strcmp(upper, "ISO-2022-JP")) return(XML_CHAR_ENCODING_2022_JP);
  ------------------
  |  Branch (1210:9): [True: 0, False: 9]
  ------------------
 1211|      9|    if (!strcmp(upper, "SHIFT_JIS")) return(XML_CHAR_ENCODING_SHIFT_JIS);
  ------------------
  |  Branch (1211:9): [True: 0, False: 9]
  ------------------
 1212|      9|    if (!strcmp(upper, "EUC-JP")) return(XML_CHAR_ENCODING_EUC_JP);
  ------------------
  |  Branch (1212:9): [True: 1, False: 8]
  ------------------
 1213|       |
 1214|      8|    return(XML_CHAR_ENCODING_ERROR);
 1215|      9|}
xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|  11.5k|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|  11.5k|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|  11.5k|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 11.5k]
  ------------------
 1552|      0|	    return(NULL);
 1553|  11.5k|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 11.5k, False: 3]
  ------------------
 1554|  11.5k|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 11.5k]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 11.5k]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 11.5k]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      3|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 3, False: 11.5k]
  ------------------
 1562|      3|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      3|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 3]
  ------------------
 1564|      3|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      3|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 3]
  ------------------
 1566|      3|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      3|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 3, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 11.5k]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 11.5k]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 11.5k]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 11.5k]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 11.5k]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|      0|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 0, False: 11.5k]
  ------------------
 1607|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 0, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 11.5k]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 11.5k]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 11.5k]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 11.5k]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 11.5k]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 11.5k]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 11.5k]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 11.5k]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 11.5k]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 11.5k]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 11.5k]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 11.5k]
  ------------------
 1661|      0|	    break;
 1662|  11.5k|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|  11.5k|}
xmlFindCharEncodingHandler:
 1677|    153|xmlFindCharEncodingHandler(const char *name) {
 1678|    153|    const char *nalias;
 1679|    153|    const char *norig;
 1680|    153|    xmlCharEncoding alias;
 1681|    153|#ifdef LIBXML_ICONV_ENABLED
 1682|    153|    xmlCharEncodingHandlerPtr enc;
 1683|    153|    iconv_t icv_in, icv_out;
 1684|    153|#endif /* LIBXML_ICONV_ENABLED */
 1685|       |#ifdef LIBXML_ICU_ENABLED
 1686|       |    xmlCharEncodingHandlerPtr encu;
 1687|       |    uconv_t *ucv_in, *ucv_out;
 1688|       |#endif /* LIBXML_ICU_ENABLED */
 1689|    153|    char upper[100];
 1690|    153|    int i;
 1691|       |
 1692|    153|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (1692:9): [True: 0, False: 153]
  ------------------
 1693|    153|    if (name[0] == 0) return(NULL);
  ------------------
  |  Branch (1693:9): [True: 0, False: 153]
  ------------------
 1694|       |
 1695|       |    /*
 1696|       |     * Do the alias resolution
 1697|       |     */
 1698|    153|    norig = name;
 1699|    153|    nalias = xmlGetEncodingAlias(name);
 1700|    153|    if (nalias != NULL)
  ------------------
  |  Branch (1700:9): [True: 0, False: 153]
  ------------------
 1701|      0|	name = nalias;
 1702|       |
 1703|       |    /*
 1704|       |     * Check first for directly registered encoding names
 1705|       |     */
 1706|  1.24k|    for (i = 0;i < 99;i++) {
  ------------------
  |  Branch (1706:16): [True: 1.24k, False: 0]
  ------------------
 1707|  1.24k|        upper[i] = (char) toupper((unsigned char) name[i]);
 1708|  1.24k|	if (upper[i] == 0) break;
  ------------------
  |  Branch (1708:6): [True: 153, False: 1.09k]
  ------------------
 1709|  1.24k|    }
 1710|    153|    upper[i] = 0;
 1711|       |
 1712|    553|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    553|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (1712:17): [True: 533, False: 20]
  ------------------
 1713|    533|        if (strcmp(upper, defaultHandlers[i].name) == 0)
  ------------------
  |  Branch (1713:13): [True: 133, False: 400]
  ------------------
 1714|    133|            return((xmlCharEncodingHandlerPtr) &defaultHandlers[i]);
 1715|    533|    }
 1716|       |
 1717|     20|    if (handlers != NULL) {
  ------------------
  |  Branch (1717:9): [True: 0, False: 20]
  ------------------
 1718|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (1718:20): [True: 0, False: 0]
  ------------------
 1719|      0|            if (!strcmp(upper, handlers[i]->name)) {
  ------------------
  |  Branch (1719:17): [True: 0, False: 0]
  ------------------
 1720|      0|                return(handlers[i]);
 1721|      0|            }
 1722|      0|        }
 1723|      0|    }
 1724|       |
 1725|     20|#ifdef LIBXML_ICONV_ENABLED
 1726|       |    /* check whether iconv can handle this */
 1727|     20|    icv_in = iconv_open("UTF-8", name);
 1728|     20|    icv_out = iconv_open(name, "UTF-8");
 1729|     20|    if (icv_in == (iconv_t) -1) {
  ------------------
  |  Branch (1729:9): [True: 6, False: 14]
  ------------------
 1730|      6|        icv_in = iconv_open("UTF-8", upper);
 1731|      6|    }
 1732|     20|    if (icv_out == (iconv_t) -1) {
  ------------------
  |  Branch (1732:9): [True: 6, False: 14]
  ------------------
 1733|      6|	icv_out = iconv_open(upper, "UTF-8");
 1734|      6|    }
 1735|     20|    if ((icv_in != (iconv_t) -1) && (icv_out != (iconv_t) -1)) {
  ------------------
  |  Branch (1735:9): [True: 14, False: 6]
  |  Branch (1735:37): [True: 14, False: 0]
  ------------------
 1736|     14|	    enc = (xmlCharEncodingHandlerPtr)
 1737|     14|	          xmlMalloc(sizeof(xmlCharEncodingHandler));
 1738|     14|	    if (enc == NULL) {
  ------------------
  |  Branch (1738:10): [True: 0, False: 14]
  ------------------
 1739|      0|	        iconv_close(icv_in);
 1740|      0|	        iconv_close(icv_out);
 1741|      0|		return(NULL);
 1742|      0|	    }
 1743|     14|            memset(enc, 0, sizeof(xmlCharEncodingHandler));
 1744|     14|	    enc->name = xmlMemStrdup(name);
 1745|     14|            if (enc->name == NULL) {
  ------------------
  |  Branch (1745:17): [True: 0, False: 14]
  ------------------
 1746|      0|                xmlFree(enc);
 1747|      0|                iconv_close(icv_in);
 1748|      0|                iconv_close(icv_out);
 1749|      0|                return(NULL);
 1750|      0|            }
 1751|     14|	    enc->input = NULL;
 1752|     14|	    enc->output = NULL;
 1753|     14|	    enc->iconv_in = icv_in;
 1754|     14|	    enc->iconv_out = icv_out;
 1755|     14|	    return enc;
 1756|     14|    } else if ((icv_in != (iconv_t) -1) || icv_out != (iconv_t) -1) {
  ------------------
  |  Branch (1756:16): [True: 0, False: 6]
  |  Branch (1756:44): [True: 0, False: 6]
  ------------------
 1757|      0|	    if (icv_in != (iconv_t) -1)
  ------------------
  |  Branch (1757:10): [True: 0, False: 0]
  ------------------
 1758|      0|		iconv_close(icv_in);
 1759|      0|	    else
 1760|      0|		iconv_close(icv_out);
 1761|      0|    }
 1762|      6|#endif /* LIBXML_ICONV_ENABLED */
 1763|       |#ifdef LIBXML_ICU_ENABLED
 1764|       |    /* check whether icu can handle this */
 1765|       |    ucv_in = openIcuConverter(name, 1);
 1766|       |    ucv_out = openIcuConverter(name, 0);
 1767|       |    if (ucv_in != NULL && ucv_out != NULL) {
 1768|       |	    encu = (xmlCharEncodingHandlerPtr)
 1769|       |	           xmlMalloc(sizeof(xmlCharEncodingHandler));
 1770|       |	    if (encu == NULL) {
 1771|       |                closeIcuConverter(ucv_in);
 1772|       |                closeIcuConverter(ucv_out);
 1773|       |		return(NULL);
 1774|       |	    }
 1775|       |            memset(encu, 0, sizeof(xmlCharEncodingHandler));
 1776|       |	    encu->name = xmlMemStrdup(name);
 1777|       |            if (encu->name == NULL) {
 1778|       |                xmlFree(encu);
 1779|       |                closeIcuConverter(ucv_in);
 1780|       |                closeIcuConverter(ucv_out);
 1781|       |                return(NULL);
 1782|       |            }
 1783|       |	    encu->input = NULL;
 1784|       |	    encu->output = NULL;
 1785|       |	    encu->uconv_in = ucv_in;
 1786|       |	    encu->uconv_out = ucv_out;
 1787|       |	    return encu;
 1788|       |    } else if (ucv_in != NULL || ucv_out != NULL) {
 1789|       |            closeIcuConverter(ucv_in);
 1790|       |            closeIcuConverter(ucv_out);
 1791|       |    }
 1792|       |#endif /* LIBXML_ICU_ENABLED */
 1793|       |
 1794|       |    /*
 1795|       |     * Fallback using the canonical names
 1796|       |     */
 1797|      6|    alias = xmlParseCharEncoding(norig);
 1798|      6|    if (alias != XML_CHAR_ENCODING_ERROR) {
  ------------------
  |  Branch (1798:9): [True: 0, False: 6]
  ------------------
 1799|      0|        const char* canon;
 1800|      0|        canon = xmlGetCharEncodingName(alias);
 1801|      0|        if ((canon != NULL) && (strcmp(name, canon))) {
  ------------------
  |  Branch (1801:13): [True: 0, False: 0]
  |  Branch (1801:32): [True: 0, False: 0]
  ------------------
 1802|      0|	    return(xmlFindCharEncodingHandler(canon));
 1803|      0|        }
 1804|      0|    }
 1805|       |
 1806|       |    /* If "none of the above", give up */
 1807|      6|    return(NULL);
 1808|      6|}
xmlEncInputChunk:
 1988|  2.02k|                 int *outlen, const unsigned char *in, int *inlen) {
 1989|  2.02k|    int ret;
 1990|       |
 1991|  2.02k|    if (handler->input != NULL) {
  ------------------
  |  Branch (1991:9): [True: 1.91k, False: 114]
  ------------------
 1992|  1.91k|        int oldinlen = *inlen;
 1993|       |
 1994|  1.91k|        ret = handler->input(out, outlen, in, inlen);
 1995|  1.91k|        if (ret >= 0) {
  ------------------
  |  Branch (1995:13): [True: 1.91k, False: 0]
  ------------------
 1996|       |            /*
 1997|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 1998|       |             */
 1999|  1.91k|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (1999:17): [True: 0, False: 1.91k]
  ------------------
 2000|      0|                if (*outlen > 0)
  ------------------
  |  Branch (2000:21): [True: 0, False: 0]
  ------------------
 2001|      0|                    ret = XML_ENC_ERR_SPACE;
 2002|      0|                else
 2003|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2004|  1.91k|            } else {
 2005|  1.91k|                ret = XML_ENC_ERR_SUCCESS;
 2006|  1.91k|            }
 2007|  1.91k|        }
 2008|  1.91k|    }
 2009|    114|#ifdef LIBXML_ICONV_ENABLED
 2010|    114|    else if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2010:14): [True: 114, False: 0]
  ------------------
 2011|    114|        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);
 2012|    114|    }
 2013|      0|#endif /* LIBXML_ICONV_ENABLED */
 2014|       |#ifdef LIBXML_ICU_ENABLED
 2015|       |    else if (handler->uconv_in != NULL) {
 2016|       |        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);
 2017|       |    }
 2018|       |#endif /* LIBXML_ICU_ENABLED */
 2019|      0|    else {
 2020|      0|        *outlen = 0;
 2021|      0|        *inlen = 0;
 2022|      0|        ret = XML_ENC_ERR_INTERNAL;
 2023|      0|    }
 2024|       |
 2025|       |    /* Ignore partial errors when reading. */
 2026|  2.02k|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2026:9): [True: 0, False: 2.02k]
  ------------------
 2027|      0|        ret = XML_ENC_ERR_SUCCESS;
 2028|       |
 2029|  2.02k|    return(ret);
 2030|  2.02k|}
xmlCharEncInput:
 2118|  3.27k|{
 2119|  3.27k|    int ret;
 2120|  3.27k|    size_t avail;
 2121|  3.27k|    size_t toconv;
 2122|  3.27k|    int c_in;
 2123|  3.27k|    int c_out;
 2124|  3.27k|    xmlBufPtr in;
 2125|  3.27k|    xmlBufPtr out;
 2126|  3.27k|    const xmlChar *inData;
 2127|  3.27k|    size_t inTotal = 0;
 2128|       |
 2129|  3.27k|    if ((input == NULL) || (input->encoder == NULL) ||
  ------------------
  |  Branch (2129:9): [True: 0, False: 3.27k]
  |  Branch (2129:28): [True: 0, False: 3.27k]
  ------------------
 2130|  3.27k|        (input->buffer == NULL) || (input->raw == NULL))
  ------------------
  |  Branch (2130:9): [True: 0, False: 3.27k]
  |  Branch (2130:36): [True: 0, False: 3.27k]
  ------------------
 2131|      0|        return(XML_ENC_ERR_INTERNAL);
 2132|  3.27k|    out = input->buffer;
 2133|  3.27k|    in = input->raw;
 2134|       |
 2135|  3.27k|    toconv = xmlBufUse(in);
 2136|  3.27k|    if (toconv == 0)
  ------------------
  |  Branch (2136:9): [True: 1.24k, False: 2.02k]
  ------------------
 2137|  1.24k|        return (0);
 2138|  2.02k|    inData = xmlBufContent(in);
 2139|  2.02k|    inTotal = 0;
 2140|       |
 2141|  2.02k|    do {
 2142|  2.02k|        c_in = toconv > INT_MAX / 2 ? INT_MAX / 2 : toconv;
  ------------------
  |  Branch (2142:16): [True: 0, False: 2.02k]
  ------------------
 2143|       |
 2144|  2.02k|        avail = xmlBufAvail(out);
 2145|  2.02k|        if (avail > INT_MAX)
  ------------------
  |  Branch (2145:13): [True: 0, False: 2.02k]
  ------------------
 2146|      0|            avail = INT_MAX;
 2147|  2.02k|        if (avail < 4096) {
  ------------------
  |  Branch (2147:13): [True: 84, False: 1.94k]
  ------------------
 2148|     84|            if (xmlBufGrow(out, 4096) < 0) {
  ------------------
  |  Branch (2148:17): [True: 0, False: 84]
  ------------------
 2149|      0|                input->error = XML_ERR_NO_MEMORY;
 2150|      0|                return(XML_ENC_ERR_MEMORY);
 2151|      0|            }
 2152|     84|            avail = xmlBufAvail(out);
 2153|     84|        }
 2154|       |
 2155|  2.02k|        c_in = toconv;
 2156|  2.02k|        c_out = avail;
 2157|  2.02k|        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,
 2158|  2.02k|                               inData, &c_in);
 2159|  2.02k|        inTotal += c_in;
 2160|  2.02k|        inData += c_in;
 2161|  2.02k|        toconv -= c_in;
 2162|  2.02k|        xmlBufAddLen(out, c_out);
 2163|  2.02k|    } while (ret == XML_ENC_ERR_SPACE);
  ------------------
  |  Branch (2163:14): [True: 0, False: 2.02k]
  ------------------
 2164|       |
 2165|  2.02k|    xmlBufShrink(in, inTotal);
 2166|       |
 2167|  2.02k|    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)
  ------------------
  |  Branch (2167:9): [True: 0, False: 2.02k]
  ------------------
 2168|      0|        input->rawconsumed = ULONG_MAX;
 2169|  2.02k|    else
 2170|  2.02k|        input->rawconsumed += c_in;
 2171|       |
 2172|  2.02k|    if ((c_out == 0) && (ret != 0)) {
  ------------------
  |  Branch (2172:9): [True: 0, False: 2.02k]
  |  Branch (2172:25): [True: 0, False: 0]
  ------------------
 2173|      0|        if (input->error == 0)
  ------------------
  |  Branch (2173:13): [True: 0, False: 0]
  ------------------
 2174|      0|            input->error = xmlEncConvertError(ret);
 2175|      0|        return(ret);
 2176|      0|    }
 2177|       |
 2178|  2.02k|    return (c_out);
 2179|  2.02k|}
xmlCharEncOutput:
 2240|    229|{
 2241|    229|    int ret;
 2242|    229|    size_t written;
 2243|    229|    int writtentot = 0;
 2244|    229|    size_t toconv;
 2245|    229|    int c_in;
 2246|    229|    int c_out;
 2247|    229|    xmlBufPtr in;
 2248|    229|    xmlBufPtr out;
 2249|       |
 2250|    229|    if ((output == NULL) || (output->encoder == NULL) ||
  ------------------
  |  Branch (2250:9): [True: 0, False: 229]
  |  Branch (2250:29): [True: 0, False: 229]
  ------------------
 2251|    229|        (output->buffer == NULL) || (output->conv == NULL))
  ------------------
  |  Branch (2251:9): [True: 0, False: 229]
  |  Branch (2251:37): [True: 0, False: 229]
  ------------------
 2252|      0|        return(XML_ENC_ERR_INTERNAL);
 2253|    229|    out = output->conv;
 2254|    229|    in = output->buffer;
 2255|       |
 2256|    229|retry:
 2257|       |
 2258|    229|    written = xmlBufAvail(out);
 2259|       |
 2260|       |    /*
 2261|       |     * First specific handling of the initialization call
 2262|       |     */
 2263|    229|    if (init) {
  ------------------
  |  Branch (2263:9): [True: 30, False: 199]
  ------------------
 2264|     30|        c_in = 0;
 2265|     30|        c_out = written;
 2266|       |        /* TODO: Check return value. */
 2267|     30|        xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,
 2268|     30|                          NULL, &c_in);
 2269|     30|        xmlBufAddLen(out, c_out);
 2270|     30|        return(c_out);
 2271|     30|    }
 2272|       |
 2273|       |    /*
 2274|       |     * Conversion itself.
 2275|       |     */
 2276|    199|    toconv = xmlBufUse(in);
 2277|    199|    if (toconv > 64 * 1024)
  ------------------
  |  Branch (2277:9): [True: 0, False: 199]
  ------------------
 2278|      0|        toconv = 64 * 1024;
 2279|    199|    if (toconv * 4 >= written) {
  ------------------
  |  Branch (2279:9): [True: 24, False: 175]
  ------------------
 2280|     24|        xmlBufGrow(out, toconv * 4);
 2281|     24|        written = xmlBufAvail(out);
 2282|     24|    }
 2283|    199|    if (written > 256 * 1024)
  ------------------
  |  Branch (2283:9): [True: 3, False: 196]
  ------------------
 2284|      3|        written = 256 * 1024;
 2285|       |
 2286|    199|    c_in = toconv;
 2287|    199|    c_out = written;
 2288|    199|    ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,
 2289|    199|                            xmlBufContent(in), &c_in);
 2290|    199|    xmlBufShrink(in, c_in);
 2291|    199|    xmlBufAddLen(out, c_out);
 2292|    199|    writtentot += c_out;
 2293|       |
 2294|    199|    if (ret == XML_ENC_ERR_SPACE)
  ------------------
  |  Branch (2294:9): [True: 0, False: 199]
  ------------------
 2295|      0|        goto retry;
 2296|       |
 2297|       |    /*
 2298|       |     * Attempt to handle error cases
 2299|       |     */
 2300|    199|    if (ret == XML_ENC_ERR_INPUT) {
  ------------------
  |  Branch (2300:9): [True: 0, False: 199]
  ------------------
 2301|      0|        xmlChar charref[20];
 2302|      0|        int len = xmlBufUse(in);
 2303|      0|        xmlChar *content = xmlBufContent(in);
 2304|      0|        int cur, charrefLen;
 2305|       |
 2306|      0|        cur = xmlGetUTF8Char(content, &len);
 2307|      0|        if (cur <= 0)
  ------------------
  |  Branch (2307:13): [True: 0, False: 0]
  ------------------
 2308|      0|            goto error;
 2309|       |
 2310|       |        /*
 2311|       |         * Removes the UTF8 sequence, and replace it by a charref
 2312|       |         * and continue the transcoding phase, hoping the error
 2313|       |         * did not mangle the encoder state.
 2314|       |         */
 2315|      0|        charrefLen = snprintf((char *) &charref[0], sizeof(charref),
 2316|      0|                         "&#%d;", cur);
 2317|      0|        xmlBufShrink(in, len);
 2318|      0|        xmlBufGrow(out, charrefLen * 4);
 2319|      0|        c_out = xmlBufAvail(out);
 2320|      0|        c_in = charrefLen;
 2321|      0|        ret = xmlEncOutputChunk(output->encoder, xmlBufEnd(out), &c_out,
 2322|      0|                                charref, &c_in);
 2323|      0|        if ((ret < 0) || (c_in != charrefLen)) {
  ------------------
  |  Branch (2323:13): [True: 0, False: 0]
  |  Branch (2323:26): [True: 0, False: 0]
  ------------------
 2324|      0|            ret = XML_ENC_ERR_INTERNAL;
 2325|      0|            goto error;
 2326|      0|        }
 2327|       |
 2328|      0|        xmlBufAddLen(out, c_out);
 2329|      0|        writtentot += c_out;
 2330|      0|        goto retry;
 2331|      0|    }
 2332|       |
 2333|    199|error:
 2334|    199|    if ((writtentot <= 0) && (ret != 0)) {
  ------------------
  |  Branch (2334:9): [True: 30, False: 169]
  |  Branch (2334:30): [True: 0, False: 30]
  ------------------
 2335|      0|        if (output->error == 0)
  ------------------
  |  Branch (2335:13): [True: 0, False: 0]
  ------------------
 2336|      0|            output->error = xmlEncConvertError(ret);
 2337|      0|        return(ret);
 2338|      0|    }
 2339|       |
 2340|    199|    return(writtentot);
 2341|    199|}
xmlCharEncCloseFunc:
 2454|    147|xmlCharEncCloseFunc(xmlCharEncodingHandler *handler) {
 2455|    147|    int ret = 0;
 2456|    147|    int tofree = 0;
 2457|    147|    int i = 0;
 2458|       |
 2459|    147|    if (handler == NULL) return(-1);
  ------------------
  |  Branch (2459:9): [True: 0, False: 147]
  ------------------
 2460|       |
 2461|    499|    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {
  ------------------
  |  | 1373|    499|    (sizeof(defaultHandlers) / sizeof(defaultHandlers[0]))
  ------------------
  |  Branch (2461:17): [True: 485, False: 14]
  ------------------
 2462|    485|        if (handler == &defaultHandlers[i])
  ------------------
  |  Branch (2462:13): [True: 133, False: 352]
  ------------------
 2463|    133|            return(0);
 2464|    485|    }
 2465|       |
 2466|     14|    if (handlers != NULL) {
  ------------------
  |  Branch (2466:9): [True: 0, False: 14]
  ------------------
 2467|      0|        for (i = 0;i < nbCharEncodingHandler; i++) {
  ------------------
  |  Branch (2467:20): [True: 0, False: 0]
  ------------------
 2468|      0|            if (handler == handlers[i])
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                return(0);
 2470|      0|	}
 2471|      0|    }
 2472|     14|#ifdef LIBXML_ICONV_ENABLED
 2473|       |    /*
 2474|       |     * Iconv handlers can be used only once, free the whole block.
 2475|       |     * and the associated icon resources.
 2476|       |     */
 2477|     14|    if ((handler->iconv_out != NULL) || (handler->iconv_in != NULL)) {
  ------------------
  |  Branch (2477:9): [True: 14, False: 0]
  |  Branch (2477:41): [True: 0, False: 0]
  ------------------
 2478|     14|        tofree = 1;
 2479|     14|	if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2479:6): [True: 14, False: 0]
  ------------------
 2480|     14|	    if (iconv_close(handler->iconv_out))
  ------------------
  |  Branch (2480:10): [True: 0, False: 14]
  ------------------
 2481|      0|		ret = -1;
 2482|     14|	    handler->iconv_out = NULL;
 2483|     14|	}
 2484|     14|	if (handler->iconv_in != NULL) {
  ------------------
  |  Branch (2484:6): [True: 14, False: 0]
  ------------------
 2485|     14|	    if (iconv_close(handler->iconv_in))
  ------------------
  |  Branch (2485:10): [True: 0, False: 14]
  ------------------
 2486|      0|		ret = -1;
 2487|     14|	    handler->iconv_in = NULL;
 2488|     14|	}
 2489|     14|    }
 2490|     14|#endif /* LIBXML_ICONV_ENABLED */
 2491|       |#ifdef LIBXML_ICU_ENABLED
 2492|       |    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {
 2493|       |        tofree = 1;
 2494|       |	if (handler->uconv_out != NULL) {
 2495|       |	    closeIcuConverter(handler->uconv_out);
 2496|       |	    handler->uconv_out = NULL;
 2497|       |	}
 2498|       |	if (handler->uconv_in != NULL) {
 2499|       |	    closeIcuConverter(handler->uconv_in);
 2500|       |	    handler->uconv_in = NULL;
 2501|       |	}
 2502|       |    }
 2503|       |#endif
 2504|     14|    if (tofree) {
  ------------------
  |  Branch (2504:9): [True: 14, False: 0]
  ------------------
 2505|       |        /* free up only dynamic handlers iconv/uconv */
 2506|     14|        if (handler->name != NULL)
  ------------------
  |  Branch (2506:13): [True: 14, False: 0]
  ------------------
 2507|     14|            xmlFree(handler->name);
 2508|     14|        handler->name = NULL;
 2509|     14|        xmlFree(handler);
 2510|     14|    }
 2511|       |
 2512|     14|    return(ret);
 2513|     14|}
encoding.c:UTF8ToUTF8:
  334|    142|{
  335|    142|    int len;
  336|       |
  337|    142|    if ((out == NULL) || (outlen == NULL) || (inlenb == NULL))
  ------------------
  |  Branch (337:9): [True: 0, False: 142]
  |  Branch (337:26): [True: 0, False: 142]
  |  Branch (337:46): [True: 0, False: 142]
  ------------------
  338|      0|	return(XML_ENC_ERR_INTERNAL);
  339|    142|    if (inb == NULL) {
  ------------------
  |  Branch (339:9): [True: 15, False: 127]
  ------------------
  340|       |        /* inb == NULL means output is initialized. */
  341|     15|        *outlen = 0;
  342|     15|        *inlenb = 0;
  343|     15|        return(0);
  344|     15|    }
  345|    127|    if (*outlen > *inlenb) {
  ------------------
  |  Branch (345:9): [True: 127, False: 0]
  ------------------
  346|    127|	len = *inlenb;
  347|    127|    } else {
  348|      0|	len = *outlen;
  349|      0|    }
  350|    127|    if (len < 0)
  ------------------
  |  Branch (350:9): [True: 0, False: 127]
  ------------------
  351|      0|	return(XML_ENC_ERR_INTERNAL);
  352|       |
  353|       |    /*
  354|       |     * FIXME: Conversion functions must assure valid UTF-8, so we have
  355|       |     * to check for UTF-8 validity. Preferably, this converter shouldn't
  356|       |     * be used at all.
  357|       |     */
  358|    127|    memcpy(out, inb, len);
  359|       |
  360|    127|    *outlen = len;
  361|    127|    *inlenb = len;
  362|    127|    return(*outlen);
  363|    127|}
encoding.c:asciiToUTF8:
  149|      5|              const unsigned char* in, int *inlen) {
  150|      5|    unsigned char* outstart = out;
  151|      5|    const unsigned char* base = in;
  152|      5|    const unsigned char* processed = in;
  153|      5|    unsigned char* outend = out + *outlen;
  154|      5|    const unsigned char* inend;
  155|      5|    unsigned int c;
  156|       |
  157|      5|    inend = in + (*inlen);
  158|    797|    while ((in < inend) && (out - outstart + 5 < *outlen)) {
  ------------------
  |  Branch (158:12): [True: 792, False: 5]
  |  Branch (158:28): [True: 792, False: 0]
  ------------------
  159|    792|	c= *in++;
  160|       |
  161|    792|        if (out >= outend)
  ------------------
  |  Branch (161:13): [True: 0, False: 792]
  ------------------
  162|      0|	    break;
  163|    792|        if (c < 0x80) {
  ------------------
  |  Branch (163:13): [True: 792, False: 0]
  ------------------
  164|    792|	    *out++ = c;
  165|    792|	} else {
  166|      0|	    *outlen = out - outstart;
  167|      0|	    *inlen = processed - base;
  168|      0|	    return(XML_ENC_ERR_INPUT);
  169|      0|	}
  170|       |
  171|    792|	processed = (const unsigned char*) in;
  172|    792|    }
  173|      5|    *outlen = out - outstart;
  174|      5|    *inlen = processed - base;
  175|      5|    return(*outlen);
  176|      5|}
encoding.c:UTF8Toascii:
  197|      3|              const unsigned char* in, int *inlen) {
  198|      3|    const unsigned char* processed = in;
  199|      3|    const unsigned char* outend;
  200|      3|    const unsigned char* outstart = out;
  201|      3|    const unsigned char* instart = in;
  202|      3|    const unsigned char* inend;
  203|      3|    unsigned int c, d;
  204|      3|    int trailing;
  205|       |
  206|      3|    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))
  ------------------
  |  Branch (206:9): [True: 0, False: 3]
  |  Branch (206:26): [True: 0, False: 3]
  |  Branch (206:46): [True: 0, False: 3]
  ------------------
  207|      0|        return(XML_ENC_ERR_INTERNAL);
  208|      3|    if (in == NULL) {
  ------------------
  |  Branch (208:9): [True: 1, False: 2]
  ------------------
  209|       |        /*
  210|       |	 * initialization nothing to do
  211|       |	 */
  212|      1|	*outlen = 0;
  213|      1|	*inlen = 0;
  214|      1|	return(0);
  215|      1|    }
  216|      2|    inend = in + (*inlen);
  217|      2|    outend = out + (*outlen);
  218|    298|    while (in < inend) {
  ------------------
  |  Branch (218:12): [True: 296, False: 2]
  ------------------
  219|    296|	d = *in++;
  220|    296|	if      (d < 0x80)  { c= d; trailing= 0; }
  ------------------
  |  Branch (220:11): [True: 296, False: 0]
  ------------------
  221|      0|	else if (d < 0xC0) {
  ------------------
  |  Branch (221:11): [True: 0, False: 0]
  ------------------
  222|       |	    /* trailing byte in leading position */
  223|      0|	    *outlen = out - outstart;
  224|      0|	    *inlen = processed - instart;
  225|      0|	    return(XML_ENC_ERR_INPUT);
  226|      0|        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }
  ------------------
  |  Branch (226:20): [True: 0, False: 0]
  ------------------
  227|      0|        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }
  ------------------
  |  Branch (227:18): [True: 0, False: 0]
  ------------------
  228|      0|        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }
  ------------------
  |  Branch (228:18): [True: 0, False: 0]
  ------------------
  229|      0|	else {
  230|       |	    /* no chance for this in Ascii */
  231|      0|	    *outlen = out - outstart;
  232|      0|	    *inlen = processed - instart;
  233|      0|	    return(XML_ENC_ERR_INPUT);
  234|      0|	}
  235|       |
  236|    296|	if (inend - in < trailing) {
  ------------------
  |  Branch (236:6): [True: 0, False: 296]
  ------------------
  237|      0|	    break;
  238|      0|	}
  239|       |
  240|    296|	for ( ; trailing; trailing--) {
  ------------------
  |  Branch (240:10): [True: 0, False: 296]
  ------------------
  241|      0|	    if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))
  ------------------
  |  Branch (241:10): [True: 0, False: 0]
  |  Branch (241:27): [True: 0, False: 0]
  ------------------
  242|      0|		break;
  243|      0|	    c <<= 6;
  244|      0|	    c |= d & 0x3F;
  245|      0|	}
  246|       |
  247|       |	/* assertion: c is a single UTF-4 value */
  248|    296|	if (c < 0x80) {
  ------------------
  |  Branch (248:6): [True: 296, False: 0]
  ------------------
  249|    296|	    if (out >= outend)
  ------------------
  |  Branch (249:10): [True: 0, False: 296]
  ------------------
  250|      0|		break;
  251|    296|	    *out++ = c;
  252|    296|	} else {
  253|       |	    /* no chance for this in Ascii */
  254|      0|	    *outlen = out - outstart;
  255|      0|	    *inlen = processed - instart;
  256|      0|	    return(XML_ENC_ERR_INPUT);
  257|      0|	}
  258|    296|	processed = in;
  259|    296|    }
  260|      2|    *outlen = out - outstart;
  261|      2|    *inlen = processed - instart;
  262|      2|    return(*outlen);
  263|      2|}
encoding.c:xmlIconvWrapper:
 1833|    120|                const unsigned char *in, int *inlen) {
 1834|    120|    size_t icv_inlen, icv_outlen;
 1835|    120|    const char *icv_in = (const char *) in;
 1836|    120|    char *icv_out = (char *) out;
 1837|    120|    size_t ret;
 1838|       |
 1839|    120|    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) || (in == NULL)) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 120]
  |  Branch (1839:26): [True: 0, False: 120]
  |  Branch (1839:46): [True: 0, False: 120]
  |  Branch (1839:65): [True: 2, False: 118]
  ------------------
 1840|      2|        if (outlen != NULL) *outlen = 0;
  ------------------
  |  Branch (1840:13): [True: 2, False: 0]
  ------------------
 1841|      2|        return(XML_ENC_ERR_INTERNAL);
 1842|      2|    }
 1843|    118|    icv_inlen = *inlen;
 1844|    118|    icv_outlen = *outlen;
 1845|       |    /*
 1846|       |     * Some versions take const, other versions take non-const input.
 1847|       |     */
 1848|    118|    ret = iconv(cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);
 1849|    118|    *inlen -= icv_inlen;
 1850|    118|    *outlen -= icv_outlen;
 1851|    118|    if (ret == (size_t) -1) {
  ------------------
  |  Branch (1851:9): [True: 0, False: 118]
  ------------------
 1852|      0|        if (errno == EILSEQ)
  ------------------
  |  Branch (1852:13): [True: 0, False: 0]
  ------------------
 1853|      0|            return(XML_ENC_ERR_INPUT);
 1854|      0|        if (errno == E2BIG)
  ------------------
  |  Branch (1854:13): [True: 0, False: 0]
  ------------------
 1855|      0|            return(XML_ENC_ERR_SPACE);
 1856|      0|        if (errno == EINVAL)
  ------------------
  |  Branch (1856:13): [True: 0, False: 0]
  ------------------
 1857|      0|            return(XML_ENC_ERR_PARTIAL);
 1858|      0|        return(XML_ENC_ERR_INTERNAL);
 1859|      0|    }
 1860|    118|    return(XML_ENC_ERR_SUCCESS);
 1861|    118|}
encoding.c:xmlEncOutputChunk:
 2048|    229|                  int *outlen, const unsigned char *in, int *inlen) {
 2049|    229|    int ret;
 2050|       |
 2051|    229|    if (handler->output != NULL) {
  ------------------
  |  Branch (2051:9): [True: 223, False: 6]
  ------------------
 2052|    223|        int oldinlen = *inlen;
 2053|       |
 2054|    223|        ret = handler->output(out, outlen, in, inlen);
 2055|    223|        if (ret >= 0) {
  ------------------
  |  Branch (2055:13): [True: 223, False: 0]
  ------------------
 2056|       |            /*
 2057|       |             * The built-in converters don't signal XML_ENC_ERR_SPACE.
 2058|       |             */
 2059|    223|            if (*inlen < oldinlen) {
  ------------------
  |  Branch (2059:17): [True: 0, False: 223]
  ------------------
 2060|      0|                if (*outlen > 0)
  ------------------
  |  Branch (2060:21): [True: 0, False: 0]
  ------------------
 2061|      0|                    ret = XML_ENC_ERR_SPACE;
 2062|      0|                else
 2063|      0|                    ret = XML_ENC_ERR_PARTIAL;
 2064|    223|            } else {
 2065|    223|                ret = XML_ENC_ERR_SUCCESS;
 2066|    223|            }
 2067|    223|        }
 2068|    223|    }
 2069|      6|#ifdef LIBXML_ICONV_ENABLED
 2070|      6|    else if (handler->iconv_out != NULL) {
  ------------------
  |  Branch (2070:14): [True: 6, False: 0]
  ------------------
 2071|      6|        ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);
 2072|      6|    }
 2073|      0|#endif /* LIBXML_ICONV_ENABLED */
 2074|       |#ifdef LIBXML_ICU_ENABLED
 2075|       |    else if (handler->uconv_out != NULL) {
 2076|       |        ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen);
 2077|       |    }
 2078|       |#endif /* LIBXML_ICU_ENABLED */
 2079|      0|    else {
 2080|      0|        *outlen = 0;
 2081|      0|        *inlen = 0;
 2082|      0|        ret = XML_ENC_ERR_INTERNAL;
 2083|      0|    }
 2084|       |
 2085|       |    /* We shouldn't generate partial sequences when writing. */
 2086|    229|    if (ret == XML_ENC_ERR_PARTIAL)
  ------------------
  |  Branch (2086:9): [True: 0, False: 229]
  ------------------
 2087|      0|        ret = XML_ENC_ERR_INTERNAL;
 2088|       |
 2089|    229|    return(ret);
 2090|    229|}

xmlFreeEntity:
  118|  1.75k|{
  119|  1.75k|    xmlDictPtr dict = NULL;
  120|       |
  121|  1.75k|    if (entity == NULL)
  ------------------
  |  Branch (121:9): [True: 0, False: 1.75k]
  ------------------
  122|      0|        return;
  123|       |
  124|  1.75k|    if (entity->doc != NULL)
  ------------------
  |  Branch (124:9): [True: 1.75k, False: 0]
  ------------------
  125|  1.75k|        dict = entity->doc->dict;
  126|       |
  127|       |
  128|  1.75k|    if ((entity->children) && (entity->owner == 1) &&
  ------------------
  |  Branch (128:9): [True: 210, False: 1.54k]
  |  Branch (128:31): [True: 210, False: 0]
  ------------------
  129|  1.75k|        (entity == (xmlEntityPtr) entity->children->parent))
  ------------------
  |  Branch (129:9): [True: 210, False: 0]
  ------------------
  130|    210|        xmlFreeNodeList(entity->children);
  131|  1.75k|    if ((entity->name != NULL) &&
  ------------------
  |  Branch (131:9): [True: 1.75k, False: 0]
  ------------------
  132|  1.75k|        ((dict == NULL) || (!xmlDictOwns(dict, entity->name))))
  ------------------
  |  Branch (132:10): [True: 0, False: 1.75k]
  |  Branch (132:28): [True: 0, False: 1.75k]
  ------------------
  133|      0|        xmlFree((char *) entity->name);
  134|  1.75k|    if (entity->ExternalID != NULL)
  ------------------
  |  Branch (134:9): [True: 6, False: 1.74k]
  ------------------
  135|      6|        xmlFree((char *) entity->ExternalID);
  136|  1.75k|    if (entity->SystemID != NULL)
  ------------------
  |  Branch (136:9): [True: 63, False: 1.68k]
  ------------------
  137|     63|        xmlFree((char *) entity->SystemID);
  138|  1.75k|    if (entity->URI != NULL)
  ------------------
  |  Branch (138:9): [True: 63, False: 1.68k]
  ------------------
  139|     63|        xmlFree((char *) entity->URI);
  140|  1.75k|    if (entity->content != NULL)
  ------------------
  |  Branch (140:9): [True: 1.69k, False: 54]
  ------------------
  141|  1.69k|        xmlFree((char *) entity->content);
  142|  1.75k|    if (entity->orig != NULL)
  ------------------
  |  Branch (142:9): [True: 1.67k, False: 78]
  ------------------
  143|  1.67k|        xmlFree((char *) entity->orig);
  144|  1.75k|    xmlFree(entity);
  145|  1.75k|}
xmlGetPredefinedEntity:
  295|   334k|xmlGetPredefinedEntity(const xmlChar *name) {
  296|   334k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (296:9): [True: 0, False: 334k]
  ------------------
  297|   334k|    switch (name[0]) {
  298|   224k|        case 'l':
  ------------------
  |  Branch (298:9): [True: 224k, False: 109k]
  ------------------
  299|   224k|	    if (xmlStrEqual(name, BAD_CAST "lt"))
  ------------------
  |  |   35|   224k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (299:10): [True: 375, False: 224k]
  ------------------
  300|    375|	        return(&xmlEntityLt);
  301|   224k|	    break;
  302|   224k|        case 'g':
  ------------------
  |  Branch (302:9): [True: 876, False: 333k]
  ------------------
  303|    876|	    if (xmlStrEqual(name, BAD_CAST "gt"))
  ------------------
  |  |   35|    876|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (303:10): [True: 156, False: 720]
  ------------------
  304|    156|	        return(&xmlEntityGt);
  305|    720|	    break;
  306|    720|        case 'a':
  ------------------
  |  Branch (306:9): [True: 371, False: 334k]
  ------------------
  307|    371|	    if (xmlStrEqual(name, BAD_CAST "amp"))
  ------------------
  |  |   35|    371|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (307:10): [True: 191, False: 180]
  ------------------
  308|    191|	        return(&xmlEntityAmp);
  309|    180|	    if (xmlStrEqual(name, BAD_CAST "apos"))
  ------------------
  |  |   35|    180|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (309:10): [True: 27, False: 153]
  ------------------
  310|     27|	        return(&xmlEntityApos);
  311|    153|	    break;
  312|    153|        case 'q':
  ------------------
  |  Branch (312:9): [True: 12, False: 334k]
  ------------------
  313|     12|	    if (xmlStrEqual(name, BAD_CAST "quot"))
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (313:10): [True: 12, False: 0]
  ------------------
  314|     12|	        return(&xmlEntityQuot);
  315|      0|	    break;
  316|   108k|	default:
  ------------------
  |  Branch (316:2): [True: 108k, False: 225k]
  ------------------
  317|   108k|	    break;
  318|   334k|    }
  319|   333k|    return(NULL);
  320|   334k|}
xmlAddDtdEntity:
  338|    513|		const xmlChar *content) {
  339|    513|    xmlEntityPtr ret;
  340|    513|    xmlDtdPtr dtd;
  341|       |
  342|    513|    if (doc == NULL) {
  ------------------
  |  Branch (342:9): [True: 0, False: 513]
  ------------------
  343|      0|	xmlEntitiesErr(XML_DTD_NO_DOC,
  344|      0|	        "xmlAddDtdEntity: document is NULL");
  345|      0|	return(NULL);
  346|      0|    }
  347|    513|    if (doc->extSubset == NULL) {
  ------------------
  |  Branch (347:9): [True: 0, False: 513]
  ------------------
  348|      0|	xmlEntitiesErr(XML_DTD_NO_DTD,
  349|      0|	        "xmlAddDtdEntity: document without external subset");
  350|      0|	return(NULL);
  351|      0|    }
  352|    513|    dtd = doc->extSubset;
  353|    513|    ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);
  354|    513|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (354:9): [True: 0, False: 513]
  ------------------
  355|       |
  356|       |    /*
  357|       |     * Link it to the DTD
  358|       |     */
  359|    513|    ret->parent = dtd;
  360|    513|    ret->doc = dtd->doc;
  361|    513|    if (dtd->last == NULL) {
  ------------------
  |  Branch (361:9): [True: 21, False: 492]
  ------------------
  362|     21|	dtd->children = dtd->last = (xmlNodePtr) ret;
  363|    492|    } else {
  364|    492|        dtd->last->next = (xmlNodePtr) ret;
  365|    492|	ret->prev = dtd->last;
  366|    492|	dtd->last = (xmlNodePtr) ret;
  367|    492|    }
  368|    513|    return(ret);
  369|    513|}
xmlAddDocEntity:
  387|  1.24k|	        const xmlChar *content) {
  388|  1.24k|    xmlEntityPtr ret;
  389|  1.24k|    xmlDtdPtr dtd;
  390|       |
  391|  1.24k|    if (doc == NULL) {
  ------------------
  |  Branch (391:9): [True: 0, False: 1.24k]
  ------------------
  392|      0|	xmlEntitiesErr(XML_DTD_NO_DOC,
  393|      0|	        "xmlAddDocEntity: document is NULL");
  394|      0|	return(NULL);
  395|      0|    }
  396|  1.24k|    if (doc->intSubset == NULL) {
  ------------------
  |  Branch (396:9): [True: 0, False: 1.24k]
  ------------------
  397|      0|	xmlEntitiesErr(XML_DTD_NO_DTD,
  398|      0|	        "xmlAddDocEntity: document without internal subset");
  399|      0|	return(NULL);
  400|      0|    }
  401|  1.24k|    dtd = doc->intSubset;
  402|  1.24k|    ret = xmlAddEntity(dtd, name, type, ExternalID, SystemID, content);
  403|  1.24k|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (403:9): [True: 6, False: 1.23k]
  ------------------
  404|       |
  405|       |    /*
  406|       |     * Link it to the DTD
  407|       |     */
  408|  1.23k|    ret->parent = dtd;
  409|  1.23k|    ret->doc = dtd->doc;
  410|  1.23k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (410:9): [True: 114, False: 1.12k]
  ------------------
  411|    114|	dtd->children = dtd->last = (xmlNodePtr) ret;
  412|  1.12k|    } else {
  413|  1.12k|	dtd->last->next = (xmlNodePtr) ret;
  414|  1.12k|	ret->prev = dtd->last;
  415|  1.12k|	dtd->last = (xmlNodePtr) ret;
  416|  1.12k|    }
  417|  1.23k|    return(ret);
  418|  1.24k|}
xmlGetParameterEntity:
  485|   104k|xmlGetParameterEntity(xmlDocPtr doc, const xmlChar *name) {
  486|   104k|    xmlEntitiesTablePtr table;
  487|   104k|    xmlEntityPtr ret;
  488|       |
  489|   104k|    if (doc == NULL)
  ------------------
  |  Branch (489:9): [True: 0, False: 104k]
  ------------------
  490|      0|	return(NULL);
  491|   104k|    if ((doc->intSubset != NULL) && (doc->intSubset->pentities != NULL)) {
  ------------------
  |  Branch (491:9): [True: 104k, False: 0]
  |  Branch (491:37): [True: 102k, False: 2.28k]
  ------------------
  492|   102k|	table = (xmlEntitiesTablePtr) doc->intSubset->pentities;
  493|   102k|	ret = xmlGetEntityFromTable(table, name);
  494|   102k|	if (ret != NULL)
  ------------------
  |  Branch (494:6): [True: 101k, False: 528]
  ------------------
  495|   101k|	    return(ret);
  496|   102k|    }
  497|  2.80k|    if ((doc->extSubset != NULL) && (doc->extSubset->pentities != NULL)) {
  ------------------
  |  Branch (497:9): [True: 2.80k, False: 0]
  |  Branch (497:37): [True: 2.80k, False: 0]
  ------------------
  498|  2.80k|	table = (xmlEntitiesTablePtr) doc->extSubset->pentities;
  499|  2.80k|	return(xmlGetEntityFromTable(table, name));
  500|  2.80k|    }
  501|      0|    return(NULL);
  502|  2.80k|}
xmlGetDocEntity:
  540|   167k|xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {
  541|   167k|    xmlEntityPtr cur;
  542|   167k|    xmlEntitiesTablePtr table;
  543|       |
  544|   167k|    if (doc != NULL) {
  ------------------
  |  Branch (544:9): [True: 167k, False: 0]
  ------------------
  545|   167k|	if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {
  ------------------
  |  Branch (545:6): [True: 167k, False: 0]
  |  Branch (545:34): [True: 167k, False: 54]
  ------------------
  546|   167k|	    table = (xmlEntitiesTablePtr) doc->intSubset->entities;
  547|   167k|	    cur = xmlGetEntityFromTable(table, name);
  548|   167k|	    if (cur != NULL)
  ------------------
  |  Branch (548:10): [True: 167k, False: 39]
  ------------------
  549|   167k|		return(cur);
  550|   167k|	}
  551|     93|	if (doc->standalone != 1) {
  ------------------
  |  Branch (551:6): [True: 93, False: 0]
  ------------------
  552|     93|	    if ((doc->extSubset != NULL) &&
  ------------------
  |  Branch (552:10): [True: 75, False: 18]
  ------------------
  553|     93|		(doc->extSubset->entities != NULL)) {
  ------------------
  |  Branch (553:3): [True: 75, False: 0]
  ------------------
  554|     75|		table = (xmlEntitiesTablePtr) doc->extSubset->entities;
  555|     75|		cur = xmlGetEntityFromTable(table, name);
  556|     75|		if (cur != NULL)
  ------------------
  |  Branch (556:7): [True: 75, False: 0]
  ------------------
  557|     75|		    return(cur);
  558|     75|	    }
  559|     93|	}
  560|     93|    }
  561|     18|    return(xmlGetPredefinedEntity(name));
  562|   167k|}
xmlFreeEntitiesTable:
  940|    258|xmlFreeEntitiesTable(xmlEntitiesTablePtr table) {
  941|    258|    xmlHashFree(table, xmlFreeEntityWrapper);
  942|    258|}
xmlDumpEntityDecl:
 1046|    202|xmlDumpEntityDecl(xmlBufferPtr buf, xmlEntityPtr ent) {
 1047|    202|    if ((buf == NULL) || (ent == NULL)) return;
  ------------------
  |  Branch (1047:9): [True: 0, False: 202]
  |  Branch (1047:26): [True: 0, False: 202]
  ------------------
 1048|    202|    switch (ent->etype) {
 1049|    173|	case XML_INTERNAL_GENERAL_ENTITY:
  ------------------
  |  Branch (1049:2): [True: 173, False: 29]
  ------------------
 1050|    173|	    xmlBufferWriteChar(buf, "<!ENTITY ");
 1051|    173|	    xmlBufferWriteCHAR(buf, ent->name);
 1052|    173|	    xmlBufferWriteChar(buf, " ");
 1053|    173|	    if (ent->orig != NULL)
  ------------------
  |  Branch (1053:10): [True: 173, False: 0]
  ------------------
 1054|    173|		xmlBufferWriteQuotedString(buf, ent->orig);
 1055|      0|	    else
 1056|      0|		xmlDumpEntityContent(buf, ent->content);
 1057|    173|	    xmlBufferWriteChar(buf, ">\n");
 1058|    173|	    break;
 1059|      4|	case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
  ------------------
  |  Branch (1059:2): [True: 4, False: 198]
  ------------------
 1060|      4|	    xmlBufferWriteChar(buf, "<!ENTITY ");
 1061|      4|	    xmlBufferWriteCHAR(buf, ent->name);
 1062|      4|	    if (ent->ExternalID != NULL) {
  ------------------
  |  Branch (1062:10): [True: 2, False: 2]
  ------------------
 1063|      2|		 xmlBufferWriteChar(buf, " PUBLIC ");
 1064|      2|		 xmlBufferWriteQuotedString(buf, ent->ExternalID);
 1065|      2|		 xmlBufferWriteChar(buf, " ");
 1066|      2|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1067|      2|	    } else {
 1068|      2|		 xmlBufferWriteChar(buf, " SYSTEM ");
 1069|      2|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1070|      2|	    }
 1071|      4|	    xmlBufferWriteChar(buf, ">\n");
 1072|      4|	    break;
 1073|      1|	case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
  ------------------
  |  Branch (1073:2): [True: 1, False: 201]
  ------------------
 1074|      1|	    xmlBufferWriteChar(buf, "<!ENTITY ");
 1075|      1|	    xmlBufferWriteCHAR(buf, ent->name);
 1076|      1|	    if (ent->ExternalID != NULL) {
  ------------------
  |  Branch (1076:10): [True: 0, False: 1]
  ------------------
 1077|      0|		 xmlBufferWriteChar(buf, " PUBLIC ");
 1078|      0|		 xmlBufferWriteQuotedString(buf, ent->ExternalID);
 1079|      0|		 xmlBufferWriteChar(buf, " ");
 1080|      0|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1081|      1|	    } else {
 1082|      1|		 xmlBufferWriteChar(buf, " SYSTEM ");
 1083|      1|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1084|      1|	    }
 1085|      1|	    if (ent->content != NULL) { /* Should be true ! */
  ------------------
  |  Branch (1085:10): [True: 1, False: 0]
  ------------------
 1086|      1|		xmlBufferWriteChar(buf, " NDATA ");
 1087|      1|		if (ent->orig != NULL)
  ------------------
  |  Branch (1087:7): [True: 0, False: 1]
  ------------------
 1088|      0|		    xmlBufferWriteCHAR(buf, ent->orig);
 1089|      1|		else
 1090|      1|		    xmlBufferWriteCHAR(buf, ent->content);
 1091|      1|	    }
 1092|      1|	    xmlBufferWriteChar(buf, ">\n");
 1093|      1|	    break;
 1094|     21|	case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1094:2): [True: 21, False: 181]
  ------------------
 1095|     21|	    xmlBufferWriteChar(buf, "<!ENTITY % ");
 1096|     21|	    xmlBufferWriteCHAR(buf, ent->name);
 1097|     21|	    xmlBufferWriteChar(buf, " ");
 1098|     21|	    if (ent->orig == NULL)
  ------------------
  |  Branch (1098:10): [True: 0, False: 21]
  ------------------
 1099|      0|		xmlDumpEntityContent(buf, ent->content);
 1100|     21|	    else
 1101|     21|		xmlBufferWriteQuotedString(buf, ent->orig);
 1102|     21|	    xmlBufferWriteChar(buf, ">\n");
 1103|     21|	    break;
 1104|      3|	case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1104:2): [True: 3, False: 199]
  ------------------
 1105|      3|	    xmlBufferWriteChar(buf, "<!ENTITY % ");
 1106|      3|	    xmlBufferWriteCHAR(buf, ent->name);
 1107|      3|	    if (ent->ExternalID != NULL) {
  ------------------
  |  Branch (1107:10): [True: 0, False: 3]
  ------------------
 1108|      0|		 xmlBufferWriteChar(buf, " PUBLIC ");
 1109|      0|		 xmlBufferWriteQuotedString(buf, ent->ExternalID);
 1110|      0|		 xmlBufferWriteChar(buf, " ");
 1111|      0|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1112|      3|	    } else {
 1113|      3|		 xmlBufferWriteChar(buf, " SYSTEM ");
 1114|      3|		 xmlBufferWriteQuotedString(buf, ent->SystemID);
 1115|      3|	    }
 1116|      3|	    xmlBufferWriteChar(buf, ">\n");
 1117|      3|	    break;
 1118|      0|	default:
  ------------------
  |  Branch (1118:2): [True: 0, False: 202]
  ------------------
 1119|      0|	    xmlEntitiesErr(XML_DTD_UNKNOWN_ENTITY,
 1120|      0|		"xmlDumpEntitiesDecl: internal: unknown type entity type");
 1121|    202|    }
 1122|    202|}
entities.c:xmlAddEntity:
  202|  1.75k|	  const xmlChar *content) {
  203|  1.75k|    xmlDictPtr dict = NULL;
  204|  1.75k|    xmlEntitiesTablePtr table = NULL;
  205|  1.75k|    xmlEntityPtr ret, predef;
  206|       |
  207|  1.75k|    if (name == NULL)
  ------------------
  |  Branch (207:9): [True: 0, False: 1.75k]
  ------------------
  208|      0|	return(NULL);
  209|  1.75k|    if (dtd == NULL)
  ------------------
  |  Branch (209:9): [True: 0, False: 1.75k]
  ------------------
  210|      0|	return(NULL);
  211|  1.75k|    if (dtd->doc != NULL)
  ------------------
  |  Branch (211:9): [True: 1.75k, False: 0]
  ------------------
  212|  1.75k|        dict = dtd->doc->dict;
  213|       |
  214|  1.75k|    switch (type) {
  ------------------
  |  Branch (214:13): [True: 0, False: 1.75k]
  ------------------
  215|  1.02k|        case XML_INTERNAL_GENERAL_ENTITY:
  ------------------
  |  Branch (215:9): [True: 1.02k, False: 729]
  ------------------
  216|  1.05k|        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
  ------------------
  |  Branch (216:9): [True: 33, False: 1.72k]
  ------------------
  217|  1.06k|        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
  ------------------
  |  Branch (217:9): [True: 3, False: 1.75k]
  ------------------
  218|  1.06k|            predef = xmlGetPredefinedEntity(name);
  219|  1.06k|            if (predef != NULL) {
  ------------------
  |  Branch (219:17): [True: 75, False: 987]
  ------------------
  220|     75|                int valid = 0;
  221|       |
  222|       |                /* 4.6 Predefined Entities */
  223|     75|                if ((type == XML_INTERNAL_GENERAL_ENTITY) &&
  ------------------
  |  Branch (223:21): [True: 75, False: 0]
  ------------------
  224|     75|                    (content != NULL)) {
  ------------------
  |  Branch (224:21): [True: 75, False: 0]
  ------------------
  225|     75|                    int c = predef->content[0];
  226|       |
  227|     75|                    if (((content[0] == c) && (content[1] == 0)) &&
  ------------------
  |  Branch (227:26): [True: 48, False: 27]
  |  Branch (227:47): [True: 36, False: 12]
  ------------------
  228|     75|                        ((c == '>') || (c == '\'') || (c == '"'))) {
  ------------------
  |  Branch (228:26): [True: 15, False: 21]
  |  Branch (228:40): [True: 9, False: 12]
  |  Branch (228:55): [True: 9, False: 3]
  ------------------
  229|     33|                        valid = 1;
  230|     42|                    } else if ((content[0] == '&') && (content[1] == '#')) {
  ------------------
  |  Branch (230:32): [True: 39, False: 3]
  |  Branch (230:55): [True: 39, False: 0]
  ------------------
  231|     39|                        if (content[2] == 'x') {
  ------------------
  |  Branch (231:29): [True: 15, False: 24]
  ------------------
  232|     15|                            xmlChar *hex = BAD_CAST "0123456789ABCDEF";
  ------------------
  |  |   35|     15|#define BAD_CAST (xmlChar *)
  ------------------
  233|     15|                            xmlChar ref[] = "00;";
  234|       |
  235|     15|                            ref[0] = hex[c / 16 % 16];
  236|     15|                            ref[1] = hex[c % 16];
  237|     15|                            if (xmlStrcasecmp(&content[3], ref) == 0)
  ------------------
  |  Branch (237:33): [True: 15, False: 0]
  ------------------
  238|     15|                                valid = 1;
  239|     24|                        } else {
  240|     24|                            xmlChar ref[] = "00;";
  241|       |
  242|     24|                            ref[0] = '0' + c / 10 % 10;
  243|     24|                            ref[1] = '0' + c % 10;
  244|     24|                            if (xmlStrEqual(&content[2], ref))
  ------------------
  |  Branch (244:33): [True: 24, False: 0]
  ------------------
  245|     24|                                valid = 1;
  246|     24|                        }
  247|     39|                    }
  248|     75|                }
  249|     75|                if (!valid) {
  ------------------
  |  Branch (249:21): [True: 3, False: 72]
  ------------------
  250|      3|                    xmlEntitiesWarn(XML_ERR_ENTITY_PROCESSING,
  251|      3|                            "xmlAddEntity: invalid redeclaration of predefined"
  252|      3|                            " entity '%s'", name);
  253|      3|                    return(NULL);
  254|      3|                }
  255|     75|            }
  256|  1.05k|	    if (dtd->entities == NULL)
  ------------------
  |  Branch (256:10): [True: 162, False: 897]
  ------------------
  257|    162|		dtd->entities = xmlHashCreateDict(0, dict);
  258|  1.05k|	    table = dtd->entities;
  259|  1.05k|	    break;
  260|    666|        case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (260:9): [True: 666, False: 1.08k]
  ------------------
  261|    693|        case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (261:9): [True: 27, False: 1.72k]
  ------------------
  262|    693|	    if (dtd->pentities == NULL)
  ------------------
  |  Branch (262:10): [True: 96, False: 597]
  ------------------
  263|     96|		dtd->pentities = xmlHashCreateDict(0, dict);
  264|    693|	    table = dtd->pentities;
  265|    693|	    break;
  266|      0|        case XML_INTERNAL_PREDEFINED_ENTITY:
  ------------------
  |  Branch (266:9): [True: 0, False: 1.75k]
  ------------------
  267|      0|	    return(NULL);
  268|  1.75k|    }
  269|  1.75k|    if (table == NULL)
  ------------------
  |  Branch (269:9): [True: 0, False: 1.75k]
  ------------------
  270|      0|	return(NULL);
  271|  1.75k|    ret = xmlCreateEntity(dict, name, type, ExternalID, SystemID, content);
  272|  1.75k|    if (ret == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 1.75k]
  ------------------
  273|      0|        return(NULL);
  274|  1.75k|    ret->doc = dtd->doc;
  275|       |
  276|  1.75k|    if (xmlHashAddEntry(table, name, ret)) {
  ------------------
  |  Branch (276:9): [True: 3, False: 1.74k]
  ------------------
  277|       |	/*
  278|       |	 * entity was already defined at another level.
  279|       |	 */
  280|      3|        xmlFreeEntity(ret);
  281|      3|	return(NULL);
  282|      3|    }
  283|  1.74k|    return(ret);
  284|  1.75k|}
entities.c:xmlEntitiesWarn:
  105|      3|{
  106|      3|    __xmlRaiseError(NULL, NULL, NULL,
  107|      3|                NULL, NULL, XML_FROM_TREE, code,
  108|      3|                XML_ERR_WARNING, NULL, 0,
  109|      3|                (const char *)str1, NULL, NULL, 0, 0,
  110|      3|                msg, (const char *)str1, NULL);
  111|      3|}
entities.c:xmlCreateEntity:
  155|  1.75k|	        const xmlChar *content) {
  156|  1.75k|    xmlEntityPtr ret;
  157|       |
  158|  1.75k|    ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));
  159|  1.75k|    if (ret == NULL) {
  ------------------
  |  Branch (159:9): [True: 0, False: 1.75k]
  ------------------
  160|      0|        xmlEntitiesErrMemory("xmlCreateEntity: malloc failed");
  161|      0|	return(NULL);
  162|      0|    }
  163|  1.75k|    memset(ret, 0, sizeof(xmlEntity));
  164|  1.75k|    ret->type = XML_ENTITY_DECL;
  165|       |
  166|       |    /*
  167|       |     * fill the structure.
  168|       |     */
  169|  1.75k|    ret->etype = (xmlEntityType) type;
  170|  1.75k|    if (dict == NULL) {
  ------------------
  |  Branch (170:9): [True: 0, False: 1.75k]
  ------------------
  171|      0|	ret->name = xmlStrdup(name);
  172|      0|	if (ExternalID != NULL)
  ------------------
  |  Branch (172:6): [True: 0, False: 0]
  ------------------
  173|      0|	    ret->ExternalID = xmlStrdup(ExternalID);
  174|      0|	if (SystemID != NULL)
  ------------------
  |  Branch (174:6): [True: 0, False: 0]
  ------------------
  175|      0|	    ret->SystemID = xmlStrdup(SystemID);
  176|  1.75k|    } else {
  177|  1.75k|        ret->name = xmlDictLookup(dict, name, -1);
  178|  1.75k|	ret->ExternalID = xmlStrdup(ExternalID);
  179|  1.75k|	ret->SystemID = xmlStrdup(SystemID);
  180|  1.75k|    }
  181|  1.75k|    if (content != NULL) {
  ------------------
  |  Branch (181:9): [True: 1.69k, False: 60]
  ------------------
  182|  1.69k|        ret->length = xmlStrlen(content);
  183|  1.69k|	ret->content = xmlStrndup(content, ret->length);
  184|  1.69k|     } else {
  185|     60|        ret->length = 0;
  186|     60|        ret->content = NULL;
  187|     60|    }
  188|  1.75k|    ret->URI = NULL; /* to be computed by the layer knowing
  189|       |			the defining entity */
  190|  1.75k|    ret->orig = NULL;
  191|  1.75k|    ret->owner = 0;
  192|       |
  193|  1.75k|    return(ret);
  194|  1.75k|}
entities.c:xmlGetEntityFromTable:
  470|   272k|xmlGetEntityFromTable(xmlEntitiesTablePtr table, const xmlChar *name) {
  471|   272k|    return((xmlEntityPtr) xmlHashLookup(table, name));
  472|   272k|}
entities.c:xmlFreeEntityWrapper:
  928|  1.74k|xmlFreeEntityWrapper(void *entity, const xmlChar *name ATTRIBUTE_UNUSED) {
  929|  1.74k|    if (entity != NULL)
  ------------------
  |  Branch (929:9): [True: 1.74k, False: 0]
  ------------------
  930|  1.74k|	xmlFreeEntity((xmlEntityPtr) entity);
  931|  1.74k|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|    366|{
  476|    366|    xmlParserCtxtPtr ctxt = NULL;
  477|    366|    xmlNodePtr node = (xmlNodePtr) nod;
  478|    366|    char *str = NULL;
  479|    366|    xmlParserInputPtr input = NULL;
  480|    366|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|    366|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    366|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|    366|    xmlNodePtr baseptr = NULL;
  482|       |
  483|    366|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 366]
  ------------------
  484|      0|        return;
  485|    366|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|    366|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    366|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 366]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|    366|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 282, False: 84]
  |  Branch (487:40): [True: 0, False: 84]
  ------------------
  488|    366|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 6, False: 78]
  |  Branch (488:37): [True: 45, False: 33]
  ------------------
  489|    366|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 33]
  |  Branch (489:29): [True: 30, False: 3]
  ------------------
  490|    363|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|    363|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 363, False: 0]
  ------------------
  493|    363|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 12, False: 351]
  ------------------
  494|     12|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|     12|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 12]
  ------------------
  495|      0|                    return;
  496|     12|                ctxt->nbWarnings += 1;
  497|    351|            } else {
  498|    351|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|    351|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 351]
  ------------------
  499|      0|                    return;
  500|    351|                ctxt->nbErrors += 1;
  501|    351|            }
  502|       |
  503|    363|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 363, False: 0]
  |  Branch (503:39): [True: 363, False: 0]
  ------------------
  504|    363|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|    363|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 363, False: 0]
  ------------------
  505|    363|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 363]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|    363|        }
  510|    363|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|    366|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 366, False: 0]
  ------------------
  515|    366|	schannel = xmlStructuredError;
  ------------------
  |  |  877|    366|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    366|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|    366|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 366]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|    366|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|    366|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 366]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|    366|    } else {
  528|    366|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|    366|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|    366|    int       size, prev_size = -1;				\
  |  |   24|    366|    int       chars;						\
  |  |   25|    366|    char      *larger;						\
  |  |   26|    366|    va_list   ap;						\
  |  |   27|    366|								\
  |  |   28|    366|    str = (char *) xmlMalloc(150);				\
  |  |   29|    366|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 366, False: 0]
  |  |  ------------------
  |  |   30|    366|								\
  |  |   31|    366|    size = 150;							\
  |  |   32|    366|								\
  |  |   33|    745|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 745, False: 0]
  |  |  ------------------
  |  |   34|    745|	va_start(ap, msg);					\
  |  |   35|    745|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|    745|	va_end(ap);						\
  |  |   37|    745|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 745, False: 0]
  |  |  |  Branch (37:22): [True: 732, False: 13]
  |  |  ------------------
  |  |   38|    732|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 366, False: 366]
  |  |  ------------------
  |  |   39|    366|		break;						\
  |  |   40|    366|	    } else {						\
  |  |   41|    366|		prev_size = chars;				\
  |  |   42|    366|	    }							\
  |  |   43|    732|	}							\
  |  |   44|    745|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 379, False: 0]
  |  |  ------------------
  |  |   45|    379|	    size += chars + 1;					\
  |  |   46|    379|	else							\
  |  |   47|    379|	    size += 100;					\
  |  |   48|    379|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 379]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|    379|	str = larger;						\
  |  |   52|    379|    }}								\
  |  |   53|    366|}
  ------------------
  529|    366|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|    366|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 363, False: 3]
  ------------------
  535|    363|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 363, False: 0]
  ------------------
  536|    363|            input = ctxt->input;
  537|    363|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 363, False: 0]
  |  Branch (537:36): [True: 139, False: 224]
  ------------------
  538|    363|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 42, False: 97]
  ------------------
  539|     42|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|     42|            }
  541|    363|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 363, False: 0]
  ------------------
  542|    363|                file = input->filename;
  543|    363|                line = input->line;
  544|    363|                col = input->col;
  545|    363|            }
  546|    363|        }
  547|    363|        to = &ctxt->lastError;
  548|    363|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 0, False: 3]
  |  Branch (548:34): [True: 0, False: 0]
  ------------------
  549|      0|	int i;
  550|       |
  551|      0|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 0, False: 0]
  |  Branch (551:29): [True: 0, False: 0]
  ------------------
  552|      0|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|      0|	}
  555|      0|	for (i = 0;
  556|      0|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 0, False: 0]
  |  Branch (556:20): [True: 0, False: 0]
  |  Branch (556:38): [True: 0, False: 0]
  ------------------
  557|      0|	     i++)
  558|      0|	     node = node->parent;
  559|      0|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 0]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|      0|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|      0|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 0, False: 0]
  |  Branch (563:24): [True: 0, False: 0]
  ------------------
  564|      0|	    line = node->line;
  565|      0|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 0]
  |  Branch (565:21): [True: 0, False: 0]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|      0|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|    366|    xmlResetError(to);
  573|    366|    to->domain = domain;
  574|    366|    to->code = code;
  575|    366|    to->message = str;
  576|    366|    to->level = level;
  577|    366|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 246, False: 120]
  ------------------
  578|    246|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    120|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 0, False: 120]
  ------------------
  580|      0|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|      0|        xmlNodePtr prev = baseptr;
  587|      0|        char *href = NULL;
  588|      0|	int inclcount = 0;
  589|      0|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 0, False: 0]
  ------------------
  590|      0|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 0, False: 0]
  ------------------
  591|      0|	        prev = prev->parent;
  592|      0|	    else {
  593|      0|	        prev = prev->prev;
  594|      0|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 0]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|      0|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 0]
  ------------------
  603|      0|		    inclcount++;
  604|      0|	    }
  605|      0|	}
  606|      0|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            to->file = href;
  608|      0|	else
  609|      0|#endif
  610|      0|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|      0|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 0]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|      0|    }
  615|    366|    to->line = line;
  616|    366|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 181, False: 185]
  ------------------
  617|    181|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|    366|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 55, False: 311]
  ------------------
  619|     55|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|    366|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 9, False: 357]
  ------------------
  621|      9|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|    366|    to->int1 = int1;
  623|    366|    to->int2 = col;
  624|    366|    to->node = node;
  625|    366|    to->ctxt = ctx;
  626|       |
  627|    366|    if (to != &xmlLastError)
  ------------------
  |  |  874|    366|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    366|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 363, False: 3]
  ------------------
  628|    363|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|    363|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    363|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|    366|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 366]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|    366|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 363, False: 3]
  |  Branch (638:27): [True: 327, False: 36]
  ------------------
  639|    366|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|    327|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    327|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 327, False: 0]
  |  Branch (639:41): [True: 327, False: 0]
  ------------------
  640|    327|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 9, False: 318]
  ------------------
  641|      9|	    channel = ctxt->sax->warning;
  642|    318|        else
  643|    318|	    channel = ctxt->sax->error;
  644|    327|	data = ctxt->userData;
  645|    327|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 3, False: 36]
  ------------------
  646|      3|	channel = xmlGenericError;
  ------------------
  |  |  875|      3|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      3|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|      3|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 3]
  ------------------
  648|      0|	    data = ctxt;
  649|      3|	} else {
  650|      3|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|      3|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      3|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|      3|	}
  652|      3|    }
  653|    366|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 366]
  ------------------
  654|      0|        return;
  655|       |
  656|    366|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 318, False: 48]
  ------------------
  657|    366|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 9, False: 39]
  ------------------
  658|    366|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 33, False: 6]
  ------------------
  659|    366|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 3, False: 3]
  ------------------
  660|    363|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|      3|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 3]
  ------------------
  662|      3|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 3]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|      3|    else
  665|      3|	channel(data, "%s", str);
  666|    366|}
xmlResetError:
  901|    451|{
  902|    451|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 451]
  ------------------
  903|      0|        return;
  904|    451|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 255, False: 196]
  ------------------
  905|    255|        return;
  906|    196|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 196, False: 0]
  ------------------
  907|    196|        xmlFree(err->message);
  908|    196|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 87, False: 109]
  ------------------
  909|     87|        xmlFree(err->file);
  910|    196|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 89, False: 107]
  ------------------
  911|     89|        xmlFree(err->str1);
  912|    196|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 32, False: 164]
  ------------------
  913|     32|        xmlFree(err->str2);
  914|    196|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 7, False: 189]
  ------------------
  915|      7|        xmlFree(err->str3);
  916|    196|    memset(err, 0, sizeof(xmlError));
  917|    196|    err->code = XML_ERR_OK;
  918|    196|}
xmlResetLastError:
  928|    323|{
  929|    323|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    323|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    323|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 238, False: 85]
  ------------------
  930|    238|        return;
  931|     85|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|     85|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|     85|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|     85|}
xmlCopyError:
  984|    504|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|    504|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|    504|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 504]
  |  Branch (987:27): [True: 0, False: 504]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|    504|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|    504|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|    504|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|    504|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|    504|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|    504|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 279, False: 225]
  ------------------
  997|    279|        xmlFree(to->message);
  998|    504|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 238, False: 266]
  ------------------
  999|    238|        xmlFree(to->file);
 1000|    504|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 133, False: 371]
  ------------------
 1001|    133|        xmlFree(to->str1);
 1002|    504|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 44, False: 460]
  ------------------
 1003|     44|        xmlFree(to->str2);
 1004|    504|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 8, False: 496]
  ------------------
 1005|      8|        xmlFree(to->str3);
 1006|    504|    to->domain = from->domain;
 1007|    504|    to->code = from->code;
 1008|    504|    to->level = from->level;
 1009|    504|    to->line = from->line;
 1010|    504|    to->node = from->node;
 1011|    504|    to->int1 = from->int1;
 1012|    504|    to->int2 = from->int2;
 1013|    504|    to->node = from->node;
 1014|    504|    to->ctxt = from->ctxt;
 1015|    504|    to->message = message;
 1016|    504|    to->file = file;
 1017|    504|    to->str1 = str1;
 1018|    504|    to->str2 = str2;
 1019|    504|    to->str3 = str3;
 1020|       |
 1021|    504|    return 0;
 1022|    504|}
error.c:xmlParserPrintFileContextInternal:
  175|    405|		xmlGenericErrorFunc channel, void *data ) {
  176|    405|    const xmlChar *cur, *base, *start;
  177|    405|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|    405|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|    405|    xmlChar *ctnt;
  180|       |
  181|    405|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 405]
  |  Branch (181:28): [True: 0, False: 405]
  ------------------
  182|      0|        return;
  183|       |
  184|    405|    cur = input->cur;
  185|    405|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|    438|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 385, False: 53]
  |  Branch (187:29): [True: 32, False: 353]
  |  Branch (187:49): [True: 1, False: 352]
  ------------------
  188|     33|	cur--;
  189|     33|    }
  190|    405|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  9.69k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 9.63k, False: 62]
  |  Branch (192:41): [True: 9.46k, False: 173]
  ------------------
  193|  9.69k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 9.29k, False: 170]
  |  Branch (193:23): [True: 9.29k, False: 0]
  ------------------
  194|  9.29k|        cur--;
  195|  9.29k|        n++;
  196|  9.29k|    }
  197|    405|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 352, False: 53]
  |  Branch (197:21): [True: 173, False: 179]
  |  Branch (197:39): [True: 0, False: 179]
  ------------------
  198|    173|        cur++;
  199|    232|    } else {
  200|       |        /* skip over continuation bytes */
  201|    236|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 186, False: 50]
  |  Branch (201:38): [True: 4, False: 182]
  ------------------
  202|      4|            cur++;
  203|    232|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|    405|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|    405|    n = 0;
  208|    405|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  11.9k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 11.8k, False: 119]
  |  Branch (210:27): [True: 11.6k, False: 181]
  |  Branch (210:47): [True: 11.6k, False: 16]
  ------------------
  211|  11.6k|        int len = input->end - cur;
  212|  11.6k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  11.6k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 39, False: 11.6k]
  |  Branch (214:24): [True: 50, False: 11.5k]
  ------------------
  215|     89|            break;
  216|  11.5k|        cur += len;
  217|  11.5k|	n += len;
  218|  11.5k|    }
  219|    405|    memcpy(content, start, n);
  220|    405|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|    405|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|    405|    n = 0;
  225|    405|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  9.49k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 9.14k, False: 343]
  |  Branch (227:23): [True: 9.08k, False: 59]
  |  Branch (227:52): [True: 9.08k, False: 3]
  ------------------
  228|  9.08k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 9.08k, False: 3]
  ------------------
  229|  9.08k|	    *(ctnt) = ' ';
  230|  9.08k|	ctnt++;
  231|  9.08k|    }
  232|    405|    *ctnt++ = '^';
  233|    405|    *ctnt = 0;
  234|    405|    channel(data ,"%s\n", content);
  235|    405|}
error.c:xmlReportError:
  261|    363|{
  262|    363|    char *file = NULL;
  263|    363|    int line = 0;
  264|    363|    int code = -1;
  265|    363|    int domain;
  266|    363|    const xmlChar *name = NULL;
  267|    363|    xmlNodePtr node;
  268|    363|    xmlErrorLevel level;
  269|    363|    xmlParserInputPtr input = NULL;
  270|    363|    xmlParserInputPtr cur = NULL;
  271|       |
  272|    363|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 363]
  ------------------
  273|      0|        return;
  274|       |
  275|    363|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 363, False: 0]
  ------------------
  276|    363|	channel = xmlGenericError;
  ------------------
  |  |  875|    363|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    363|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|    363|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|    363|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    363|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|    363|    }
  279|    363|    file = err->file;
  280|    363|    line = err->line;
  281|    363|    code = err->code;
  282|    363|    domain = err->domain;
  283|    363|    level = err->level;
  284|    363|    node = err->node;
  285|       |
  286|    363|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 363]
  ------------------
  287|      0|        return;
  288|       |
  289|    363|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 30, False: 333]
  |  Branch (289:27): [True: 6, False: 24]
  ------------------
  290|      6|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|    363|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 363, False: 0]
  ------------------
  296|    363|        input = ctxt->input;
  297|    363|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 363, False: 0]
  |  Branch (297:32): [True: 139, False: 224]
  ------------------
  298|    363|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 42, False: 97]
  ------------------
  299|     42|            cur = input;
  300|     42|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|     42|        }
  302|    363|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 363, False: 0]
  ------------------
  303|    363|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 246, False: 117]
  ------------------
  304|    246|                channel(data, "%s:%d: ", input->filename, input->line);
  305|    117|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 117, False: 0]
  |  Branch (305:37): [True: 87, False: 30]
  ------------------
  306|     87|                channel(data, "Entity: line %d: ", input->line);
  307|    363|        }
  308|    363|    } else {
  309|      0|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 0, False: 0]
  ------------------
  310|      0|            channel(data, "%s:%d: ", file, line);
  311|      0|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 0]
  ------------------
  312|      0|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      0|    }
  317|    363|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 6, False: 357]
  ------------------
  318|      6|        channel(data, "element %s: ", name);
  319|      6|    }
  320|    363|    switch (domain) {
  321|    282|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 282, False: 81]
  ------------------
  322|    282|            channel(data, "parser ");
  323|    282|            break;
  324|     45|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 45, False: 318]
  ------------------
  325|     45|            channel(data, "namespace ");
  326|     45|            break;
  327|      6|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 6, False: 357]
  ------------------
  328|     36|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 30, False: 333]
  ------------------
  329|     36|            channel(data, "validity ");
  330|     36|            break;
  331|      0|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 0, False: 363]
  ------------------
  332|      0|            channel(data, "HTML parser ");
  333|      0|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 363]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 363]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 363]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 363]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 363]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 363]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 363]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 363]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 363]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 363]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 363]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 363]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 363]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 363]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 363]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 363]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 363]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 363]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 363]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 363]
  ------------------
  392|      0|            break;
  393|    363|    }
  394|    363|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 363]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 363]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|     12|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 12, False: 351]
  ------------------
  399|     12|            channel(data, "warning : ");
  400|     12|            break;
  401|     75|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 75, False: 288]
  ------------------
  402|     75|            channel(data, "error : ");
  403|     75|            break;
  404|    276|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 276, False: 87]
  ------------------
  405|    276|            channel(data, "error : ");
  406|    276|            break;
  407|    363|    }
  408|    363|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 363, False: 0]
  ------------------
  409|    363|        int len;
  410|    363|	len = xmlStrlen((const xmlChar *)str);
  411|    363|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 363, False: 0]
  |  Branch (411:19): [True: 21, False: 342]
  ------------------
  412|     21|	    channel(data, "%s\n", str);
  413|    342|	else
  414|    342|	    channel(data, "%s", str);
  415|    363|    } else {
  416|      0|        channel(data, "%s\n", "out of memory error");
  417|      0|    }
  418|       |
  419|    363|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 363, False: 0]
  ------------------
  420|    363|        xmlParserPrintFileContextInternal(input, channel, data);
  421|    363|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 42, False: 321]
  ------------------
  422|     42|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 42]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|     42|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 42, False: 0]
  |  Branch (424:37): [True: 42, False: 0]
  ------------------
  425|     42|                channel(data, "Entity: line %d: \n", cur->line);
  426|     42|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|     42|        }
  428|    363|    }
  429|    363|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 363]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|    363|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|    363|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|    363|}

xmlFuzzErrorFunc:
   56|  2.28k|                 ...) {
   57|  2.28k|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|  1.29k|xmlFuzzMemSetLimit(size_t limit) {
  109|  1.29k|    fuzzNumAllocs = 0;
  110|  1.29k|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|      0|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 0, False: 1.29k]
  ------------------
  111|  1.29k|    fuzzAllocFailed = 0;
  112|  1.29k|}
xmlFuzzDataInit:
  125|    323|xmlFuzzDataInit(const char *data, size_t size) {
  126|    323|    fuzzData.data = data;
  127|    323|    fuzzData.size = size;
  128|    323|    fuzzData.ptr = data;
  129|    323|    fuzzData.remaining = size;
  130|       |
  131|    323|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    323|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    323|    fuzzData.entities = xmlHashCreate(8);
  135|    323|    fuzzData.mainUrl = NULL;
  136|    323|    fuzzData.mainEntity = NULL;
  137|    323|}
xmlFuzzDataCleanup:
  145|    323|xmlFuzzDataCleanup(void) {
  146|    323|    xmlFree(fuzzData.outBuf);
  147|    323|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    323|}
xmlFuzzReadInt:
  181|    646|xmlFuzzReadInt(int size) {
  182|    646|    size_t ret = 0;
  183|       |
  184|  3.23k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 2.58k, False: 646]
  |  Branch (184:26): [True: 2.58k, False: 0]
  ------------------
  185|  2.58k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  2.58k|        fuzzData.remaining--;
  187|  2.58k|        ret = (ret << 8) | c;
  188|  2.58k|        size--;
  189|  2.58k|    }
  190|       |
  191|    646|    return ret;
  192|    646|}
xmlFuzzReadString:
  245|  1.04k|xmlFuzzReadString(size_t *size) {
  246|  1.04k|    const char *out = fuzzData.outPtr;
  247|       |
  248|  1.43M|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 1.43M, False: 323]
  ------------------
  249|  1.43M|        int c = *fuzzData.ptr++;
  250|  1.43M|        fuzzData.remaining--;
  251|       |
  252|  1.43M|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 729, False: 1.43M]
  |  Branch (252:28): [True: 729, False: 0]
  ------------------
  253|    729|            int c2 = *fuzzData.ptr;
  254|       |
  255|    729|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 726, False: 3]
  ------------------
  256|    726|                fuzzData.ptr++;
  257|    726|                fuzzData.remaining--;
  258|    726|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 363, False: 363]
  ------------------
  259|    363|                    *size = fuzzData.outPtr - out;
  260|    726|                *fuzzData.outPtr++ = '\0';
  261|    726|                return(out);
  262|    726|            }
  263|      3|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 3, False: 0]
  ------------------
  264|      3|                fuzzData.ptr++;
  265|      3|                fuzzData.remaining--;
  266|      3|            }
  267|      3|        }
  268|       |
  269|  1.43M|        *fuzzData.outPtr++ = c;
  270|  1.43M|    }
  271|       |
  272|    323|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 0, False: 323]
  ------------------
  273|      0|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 0, False: 0]
  ------------------
  274|      0|            *size = fuzzData.outPtr - out;
  275|      0|        *fuzzData.outPtr++ = '\0';
  276|      0|        return(out);
  277|      0|    }
  278|       |
  279|    323|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 0, False: 323]
  ------------------
  280|      0|        *size = 0;
  281|    323|    return(NULL);
  282|    323|}
xmlFuzzReadEntities:
  291|    323|xmlFuzzReadEntities(void) {
  292|    323|    size_t num = 0;
  293|       |
  294|    686|    while (1) {
  ------------------
  |  Branch (294:12): [Folded - Ignored]
  ------------------
  295|    686|        const char *url, *entity;
  296|    686|        size_t entitySize;
  297|    686|        xmlFuzzEntityInfo *entityInfo;
  298|       |
  299|    686|        url = xmlFuzzReadString(NULL);
  300|    686|        if (url == NULL) break;
  ------------------
  |  Branch (300:13): [True: 323, False: 363]
  ------------------
  301|       |
  302|    363|        entity = xmlFuzzReadString(&entitySize);
  303|    363|        if (entity == NULL) break;
  ------------------
  |  Branch (303:13): [True: 0, False: 363]
  ------------------
  304|       |
  305|    363|        if (xmlHashLookup(fuzzData.entities, (xmlChar *)url) == NULL) {
  ------------------
  |  Branch (305:13): [True: 363, False: 0]
  ------------------
  306|    363|            entityInfo = xmlMalloc(sizeof(xmlFuzzEntityInfo));
  307|    363|            if (entityInfo == NULL)
  ------------------
  |  Branch (307:17): [True: 0, False: 363]
  ------------------
  308|      0|                break;
  309|    363|            entityInfo->data = entity;
  310|    363|            entityInfo->size = entitySize;
  311|       |
  312|    363|            xmlHashAddEntry(fuzzData.entities, (xmlChar *)url, entityInfo);
  313|       |
  314|    363|            if (num == 0) {
  ------------------
  |  Branch (314:17): [True: 323, False: 40]
  ------------------
  315|    323|                fuzzData.mainUrl = url;
  316|    323|                fuzzData.mainEntity = entityInfo;
  317|    323|            }
  318|       |
  319|    363|            num++;
  320|    363|        }
  321|    363|    }
  322|    323|}
xmlFuzzMainUrl:
  330|    323|xmlFuzzMainUrl(void) {
  331|    323|    return(fuzzData.mainUrl);
  332|    323|}
xmlFuzzMainEntity:
  341|    323|xmlFuzzMainEntity(size_t *size) {
  342|    323|    if (fuzzData.mainEntity == NULL)
  ------------------
  |  Branch (342:9): [True: 0, False: 323]
  ------------------
  343|      0|        return(NULL);
  344|    323|    *size = fuzzData.mainEntity->size;
  345|    323|    return(fuzzData.mainEntity->data);
  346|    323|}
xmlFuzzEntityLoader:
  355|  10.1k|                    xmlParserCtxtPtr ctxt) {
  356|  10.1k|    xmlParserInputPtr input;
  357|  10.1k|    xmlFuzzEntityInfo *entity;
  358|       |
  359|  10.1k|    if (URL == NULL)
  ------------------
  |  Branch (359:9): [True: 0, False: 10.1k]
  ------------------
  360|      0|        return(NULL);
  361|  10.1k|    entity = xmlHashLookup(fuzzData.entities, (xmlChar *) URL);
  362|  10.1k|    if (entity == NULL)
  ------------------
  |  Branch (362:9): [True: 141, False: 9.98k]
  ------------------
  363|    141|        return(NULL);
  364|       |
  365|  9.98k|    input = xmlNewInputStream(ctxt);
  366|  9.98k|    if (input == NULL)
  ------------------
  |  Branch (366:9): [True: 0, False: 9.98k]
  ------------------
  367|      0|        return(NULL);
  368|  9.98k|    input->filename = (char *) xmlCharStrdup(URL);
  369|  9.98k|    input->buf = xmlParserInputBufferCreateMem(entity->data, entity->size,
  370|  9.98k|                                               XML_CHAR_ENCODING_NONE);
  371|  9.98k|    if (input->buf == NULL) {
  ------------------
  |  Branch (371:9): [True: 0, False: 9.98k]
  ------------------
  372|      0|        xmlFreeInputStream(input);
  373|      0|        return(NULL);
  374|      0|    }
  375|  9.98k|    input->base = input->cur = xmlBufContent(input->buf->buffer);
  376|  9.98k|    input->end = input->base + xmlBufUse(input->buf->buffer);
  377|       |
  378|  9.98k|    return input;
  379|  9.98k|}
fuzz.c:xmlFuzzMalloc:
   73|  1.85M|xmlFuzzMalloc(size_t size) {
   74|  1.85M|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 0, False: 1.85M]
  ------------------
   75|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 0, False: 0]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|      0|            fuzzAllocFailed = 1;
   80|      0|            return(NULL);
   81|      0|        }
   82|      0|        fuzzNumAllocs += 1;
   83|      0|    }
   84|  1.85M|    return malloc(size);
   85|  1.85M|}
fuzz.c:xmlFuzzRealloc:
   88|  33.0k|xmlFuzzRealloc(void *ptr, size_t size) {
   89|  33.0k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 0, False: 33.0k]
  ------------------
   90|      0|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 0, False: 0]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      0|            fuzzAllocFailed = 1;
   95|      0|            return(NULL);
   96|      0|        }
   97|      0|        fuzzNumAllocs += 1;
   98|      0|    }
   99|  33.0k|    return realloc(ptr, size);
  100|  33.0k|}

LLVMFuzzerInitialize:
   16|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   17|      2|    xmlFuzzMemSetup();
   18|      2|    xmlInitParser();
   19|      2|#ifdef LIBXML_CATALOG_ENABLED
   20|      2|    xmlInitializeCatalog();
   21|      2|#endif
   22|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   23|      2|    xmlSetExternalEntityLoader(xmlFuzzEntityLoader);
   24|       |
   25|      2|    return 0;
   26|      2|}
LLVMFuzzerTestOneInput:
   29|    323|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   30|    323|    xmlDocPtr doc;
   31|    323|    const char *docBuffer, *docUrl;
   32|    323|    size_t maxAlloc, docSize;
   33|    323|    int opts;
   34|       |
   35|    323|    xmlFuzzDataInit(data, size);
   36|    323|    opts = (int) xmlFuzzReadInt(4);
   37|       |    /*
   38|       |     * Disable options that are known to cause timeouts
   39|       |     */
   40|    323|    opts &= ~XML_PARSE_XINCLUDE &
   41|    323|            ~XML_PARSE_DTDVALID &
   42|    323|            ~XML_PARSE_SAX1;
   43|    323|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   44|       |
   45|    323|    xmlFuzzReadEntities();
   46|    323|    docBuffer = xmlFuzzMainEntity(&docSize);
   47|    323|    docUrl = xmlFuzzMainUrl();
   48|    323|    if (docBuffer == NULL)
  ------------------
  |  Branch (48:9): [True: 0, False: 323]
  ------------------
   49|      0|        goto exit;
   50|       |
   51|       |    /* Pull parser */
   52|       |
   53|    323|    xmlFuzzMemSetLimit(maxAlloc);
   54|    323|    doc = xmlReadMemory(docBuffer, docSize, docUrl, NULL, opts);
   55|       |
   56|    323|#ifdef LIBXML_OUTPUT_ENABLED
   57|    323|    {
   58|    323|        xmlChar *out;
   59|    323|        int outSize;
   60|       |
   61|       |        /* Also test the serializer. */
   62|    323|        xmlDocDumpMemory(doc, &out, &outSize);
   63|    323|        xmlFree(out);
   64|    323|    }
   65|    323|#endif
   66|       |
   67|    323|    xmlFreeDoc(doc);
   68|       |
   69|       |    /* Push parser */
   70|       |
   71|    323|#ifdef LIBXML_PUSH_ENABLED
   72|    323|    {
   73|    323|        static const size_t maxChunkSize = 128;
   74|    323|        xmlParserCtxtPtr ctxt;
   75|    323|        size_t consumed, chunkSize;
   76|       |
   77|    323|        xmlFuzzMemSetLimit(maxAlloc);
   78|    323|        ctxt = xmlCreatePushParserCtxt(NULL, NULL, NULL, 0, docUrl);
   79|    323|        if (ctxt == NULL)
  ------------------
  |  Branch (79:13): [True: 0, False: 323]
  ------------------
   80|      0|            goto exit;
   81|    323|        xmlCtxtUseOptions(ctxt, opts);
   82|       |
   83|  10.1k|        for (consumed = 0; consumed < docSize; consumed += chunkSize) {
  ------------------
  |  Branch (83:28): [True: 9.85k, False: 323]
  ------------------
   84|  9.85k|            chunkSize = docSize - consumed;
   85|  9.85k|            if (chunkSize > maxChunkSize)
  ------------------
  |  Branch (85:17): [True: 9.53k, False: 322]
  ------------------
   86|  9.53k|                chunkSize = maxChunkSize;
   87|  9.85k|            xmlParseChunk(ctxt, docBuffer + consumed, chunkSize, 0);
   88|  9.85k|        }
   89|       |
   90|    323|        xmlParseChunk(ctxt, NULL, 0, 1);
   91|    323|        xmlFreeDoc(ctxt->myDoc);
   92|    323|        xmlFreeParserCtxt(ctxt);
   93|    323|    }
   94|      0|#endif
   95|       |
   96|       |    /* Reader */
   97|       |
   98|      0|#ifdef LIBXML_READER_ENABLED
   99|      0|    {
  100|    323|        xmlTextReaderPtr reader;
  101|    323|        int j;
  102|       |
  103|    323|        xmlFuzzMemSetLimit(maxAlloc);
  104|    323|        reader = xmlReaderForMemory(docBuffer, docSize, NULL, NULL, opts);
  105|    323|        if (reader == NULL)
  ------------------
  |  Branch (105:13): [True: 0, False: 323]
  ------------------
  106|      0|            goto exit;
  107|  36.4k|        while (xmlTextReaderRead(reader) == 1) {
  ------------------
  |  Branch (107:16): [True: 36.0k, False: 323]
  ------------------
  108|  36.0k|            if (xmlTextReaderNodeType(reader) == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (108:17): [True: 14.2k, False: 21.8k]
  ------------------
  109|  14.2k|                int i, n = xmlTextReaderAttributeCount(reader);
  110|  35.6k|                for (i=0; i<n; i++) {
  ------------------
  |  Branch (110:27): [True: 21.4k, False: 14.2k]
  ------------------
  111|  21.4k|                    xmlTextReaderMoveToAttributeNo(reader, i);
  112|  42.9k|                    while (xmlTextReaderReadAttributeValue(reader) == 1);
  ------------------
  |  Branch (112:28): [True: 21.4k, False: 21.4k]
  ------------------
  113|  21.4k|                }
  114|  14.2k|            }
  115|  36.0k|        }
  116|  3.55k|        for (j = 0; j < 10; j++)
  ------------------
  |  Branch (116:21): [True: 3.23k, False: 323]
  ------------------
  117|  3.23k|            xmlTextReaderRead(reader);
  118|    323|        xmlFreeTextReader(reader);
  119|    323|    }
  120|      0|#endif
  121|       |
  122|    323|exit:
  123|    323|    xmlFuzzMemSetLimit(0);
  124|    323|    xmlFuzzDataCleanup();
  125|    323|    xmlResetLastError();
  126|    323|    return(0);
  127|    323|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  1.50k|    type *__##name(void) { \
  893|  1.50k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.50k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.50k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.50k|            return (&name); \
  895|  1.50k|        else \
  896|  1.50k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.50k|    }
__xmlGenericError:
  892|    368|    type *__##name(void) { \
  893|    368|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    368|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 368, False: 0]
  |  |  ------------------
  ------------------
  894|    368|            return (&name); \
  895|    368|        else \
  896|    368|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    368|    }
__xmlGenericErrorContext:
  892|    368|    type *__##name(void) { \
  893|    368|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    368|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 368, False: 0]
  |  |  ------------------
  ------------------
  894|    368|            return (&name); \
  895|    368|        else \
  896|    368|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    368|    }
__xmlStructuredError:
  892|    693|    type *__##name(void) { \
  893|    693|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    693|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 693, False: 0]
  |  |  ------------------
  ------------------
  894|    693|            return (&name); \
  895|    693|        else \
  896|    693|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    693|    }
__xmlDefaultSAXLocator:
  892|    966|    type *__##name(void) { \
  893|    966|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    966|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 966, False: 0]
  |  |  ------------------
  ------------------
  894|    966|            return (&name); \
  895|    966|        else \
  896|    966|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    966|    }
__xmlDoValidityCheckingDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlGetWarningsDefaultValue:
  892|    366|    type *__##name(void) { \
  893|    366|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    366|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 366, False: 0]
  |  |  ------------------
  ------------------
  894|    366|            return (&name); \
  895|    366|        else \
  896|    366|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    366|    }
__xmlKeepBlanksDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlLineNumbersDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlLoadExtDtdDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlParserDebugEntities:
  892|   564k|    type *__##name(void) { \
  893|   564k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|   564k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 564k, False: 0]
  |  |  ------------------
  ------------------
  894|   564k|            return (&name); \
  895|   564k|        else \
  896|   564k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|   564k|    }
__xmlPedanticParserDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlSubstituteEntitiesDefaultValue:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlDefaultSAXHandler:
  892|  1.32k|    type *__##name(void) { \
  893|  1.32k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.32k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.32k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.32k|            return (&name); \
  895|  1.32k|        else \
  896|  1.32k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.32k|    }
__xmlIndentTreeOutput:
  892|  4.08k|    type *__##name(void) { \
  893|  4.08k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  4.08k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 4.08k, False: 0]
  |  |  ------------------
  ------------------
  894|  4.08k|            return (&name); \
  895|  4.08k|        else \
  896|  4.08k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  4.08k|    }
__xmlTreeIndentString:
  892|  8.38k|    type *__##name(void) { \
  893|  8.38k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  8.38k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 8.38k, False: 0]
  |  |  ------------------
  ------------------
  894|  8.38k|            return (&name); \
  895|  8.38k|        else \
  896|  8.38k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  8.38k|    }
__xmlSaveNoEmptyTags:
  892|    262|    type *__##name(void) { \
  893|    262|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    262|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 262, False: 0]
  |  |  ------------------
  ------------------
  894|    262|            return (&name); \
  895|    262|        else \
  896|    262|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    262|    }
__xmlBufferAllocScheme:
  892|  13.4k|    type *__##name(void) { \
  893|  13.4k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  13.4k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 13.4k, False: 0]
  |  |  ------------------
  ------------------
  894|  13.4k|            return (&name); \
  895|  13.4k|        else \
  896|  13.4k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  13.4k|    }
__xmlDefaultBufferSize:
  892|  13.0k|    type *__##name(void) { \
  893|  13.0k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  13.0k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 13.0k, False: 0]
  |  |  ------------------
  ------------------
  894|  13.0k|            return (&name); \
  895|  13.0k|        else \
  896|  13.0k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  13.0k|    }
globals.c:xmlPosixStrdup:
  219|    366|xmlPosixStrdup(const char *cur) {
  220|    366|    return((char*) xmlCharStrdup(cur));
  221|    366|}
globals.c:xmlIsMainThreadInternal:
  660|   616k|xmlIsMainThreadInternal(void) {
  661|   616k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 616k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|   616k|#ifdef HAVE_POSIX_THREADS
  667|   616k|#ifdef XML_PTHREAD_WEAK
  668|   616k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 616k]
  ------------------
  669|      0|        return (1);
  670|   616k|#endif
  671|   616k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|   616k|}

xmlHashCreate:
  160|  1.29k|xmlHashCreate(int size) {
  161|  1.29k|    xmlHashTablePtr hash;
  162|       |
  163|  1.29k|    xmlInitParser();
  164|       |
  165|  1.29k|    hash = xmlMalloc(sizeof(*hash));
  166|  1.29k|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 1.29k]
  ------------------
  167|      0|        return(NULL);
  168|  1.29k|    hash->dict = NULL;
  169|  1.29k|    hash->size = 0;
  170|  1.29k|    hash->table = NULL;
  171|  1.29k|    hash->nbElems = 0;
  172|  1.29k|    hash->randomSeed = xmlRandom();
  173|  1.29k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|  1.29k|    hash->randomSeed = 0;
  175|  1.29k|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|  1.29k|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|  1.29k|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 174, False: 1.12k]
  ------------------
  183|    174|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|    174|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|    174|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 174]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|    174|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 174]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|    174|    }
  193|       |
  194|  1.29k|    return(hash);
  195|  1.29k|}
xmlHashCreateDict:
  209|    972|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|    972|    xmlHashTablePtr hash;
  211|       |
  212|    972|    hash = xmlHashCreate(size);
  213|    972|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 972, False: 0]
  ------------------
  214|    972|        hash->dict = dict;
  215|    972|        xmlDictReference(dict);
  216|    972|    }
  217|    972|    return(hash);
  218|    972|}
xmlHashFree:
  229|  1.29k|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|  1.29k|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 0, False: 1.29k]
  ------------------
  231|      0|        return;
  232|       |
  233|  1.29k|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 1.29k, False: 0]
  ------------------
  234|  1.29k|        const xmlHashEntry *end = &hash->table[hash->size];
  235|  1.29k|        const xmlHashEntry *entry;
  236|       |
  237|  41.6k|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 40.3k, False: 1.29k]
  ------------------
  238|  40.3k|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 24.3k, False: 15.9k]
  ------------------
  239|  24.3k|                continue;
  240|  15.9k|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 12.0k, False: 3.87k]
  |  Branch (240:38): [True: 12.0k, False: 0]
  ------------------
  241|  12.0k|                dealloc(entry->payload, entry->key);
  242|  15.9k|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 363, False: 15.6k]
  ------------------
  243|    363|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 363, False: 0]
  ------------------
  244|    363|                    xmlFree(entry->key);
  245|    363|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 0, False: 363]
  ------------------
  246|      0|                    xmlFree(entry->key2);
  247|    363|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 363]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|    363|            }
  250|  15.9k|        }
  251|       |
  252|  1.29k|        xmlFree(hash->table);
  253|  1.29k|    }
  254|       |
  255|  1.29k|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 972, False: 323]
  ------------------
  256|    972|        xmlDictFree(hash->dict);
  257|       |
  258|  1.29k|    xmlFree(hash);
  259|  1.29k|}
xmlHashDefaultDeallocator:
  603|    531|xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {
  604|    531|    xmlFree(entry);
  605|    531|}
xmlHashAddEntry:
  621|  3.77k|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|  3.77k|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|  3.77k|}
xmlHashAddEntry2:
  640|  8.18k|                 const xmlChar *key2, void *payload) {
  641|  8.18k|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));
  642|  8.18k|}
xmlHashAddEntry3:
  661|  5.83k|                 void *payload) {
  662|  5.83k|    return(xmlHashUpdateInternal(hash, key, key2, key3, payload, NULL, 0));
  663|  5.83k|}
xmlHashUpdateEntry2:
  701|    192|                   xmlHashDeallocator dealloc) {
  702|    192|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload,
  703|    192|                                 dealloc, 1));
  704|    192|}
xmlHashLookup:
  739|   284k|xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {
  740|   284k|    return(xmlHashLookup3(hash, key, NULL, NULL));
  741|   284k|}
xmlHashLookup2:
  755|  37.1k|              const xmlChar *key2) {
  756|  37.1k|    return(xmlHashLookup3(hash, key, key2, NULL));
  757|  37.1k|}
xmlHashQLookup2:
  790|  4.37k|                const xmlChar *name2) {
  791|  4.37k|    return(xmlHashQLookup3(hash, prefix, name, prefix2, name2, NULL, NULL));
  792|  4.37k|}
xmlHashLookup3:
  807|   331k|               const xmlChar *key2, const xmlChar *key3) {
  808|   331k|    const xmlHashEntry *entry;
  809|   331k|    unsigned hashValue;
  810|   331k|    int found;
  811|       |
  812|   331k|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (812:9): [True: 756, False: 330k]
  |  Branch (812:27): [True: 977, False: 329k]
  |  Branch (812:48): [True: 0, False: 329k]
  ------------------
  813|  1.73k|        return(NULL);
  814|   329k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
  815|   329k|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  816|   329k|    if (found)
  ------------------
  |  Branch (816:9): [True: 299k, False: 29.9k]
  ------------------
  817|   299k|        return(entry->payload);
  818|  29.9k|    return(NULL);
  819|   329k|}
xmlHashQLookup3:
  840|  4.37k|                const xmlChar *prefix3, const xmlChar *name3) {
  841|  4.37k|    const xmlHashEntry *entry;
  842|  4.37k|    unsigned hashValue, mask, pos, displ;
  843|       |
  844|  4.37k|    if ((hash == NULL) || (hash->size == 0) || (name == NULL))
  ------------------
  |  Branch (844:9): [True: 0, False: 4.37k]
  |  Branch (844:27): [True: 0, False: 4.37k]
  |  Branch (844:48): [True: 0, False: 4.37k]
  ------------------
  845|      0|        return(NULL);
  846|       |
  847|  4.37k|    hashValue = xmlHashQNameValue(hash->randomSeed, prefix, name, prefix2,
  848|  4.37k|                                  name2, prefix3, name3);
  849|  4.37k|    mask = hash->size - 1;
  850|  4.37k|    pos = hashValue & mask;
  851|  4.37k|    entry = &hash->table[pos];
  852|       |
  853|  4.37k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (853:9): [True: 3.75k, False: 615]
  ------------------
  854|  3.75k|        displ = 0;
  855|  3.75k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|  3.75k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  856|       |
  857|  4.87k|        do {
  858|  4.87k|            if ((hashValue == entry->hashValue) &&
  ------------------
  |  Branch (858:17): [True: 3.20k, False: 1.67k]
  ------------------
  859|  4.87k|                (xmlStrQEqual(prefix, name, entry->key)) &&
  ------------------
  |  Branch (859:17): [True: 3.20k, False: 0]
  ------------------
  860|  4.87k|                (xmlStrQEqual(prefix2, name2, entry->key2)) &&
  ------------------
  |  Branch (860:17): [True: 3.20k, False: 0]
  ------------------
  861|  4.87k|                (xmlStrQEqual(prefix3, name3, entry->key3)))
  ------------------
  |  Branch (861:17): [True: 3.20k, False: 0]
  ------------------
  862|  3.20k|                return(entry->payload);
  863|       |
  864|  1.67k|            displ++;
  865|  1.67k|            pos++;
  866|  1.67k|            entry++;
  867|  1.67k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (867:17): [True: 0, False: 1.67k]
  ------------------
  868|      0|                entry = hash->table;
  869|  1.67k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (869:18): [True: 1.52k, False: 150]
  ------------------
  870|  1.67k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (870:18): [True: 1.11k, False: 405]
  ------------------
  871|  3.75k|    }
  872|       |
  873|  1.17k|    return(NULL);
  874|  4.37k|}
xmlHashScanFull:
  914|    120|xmlHashScanFull(xmlHashTablePtr hash, xmlHashScannerFull scan, void *data) {
  915|    120|    const xmlHashEntry *entry, *end;
  916|       |
  917|    120|    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))
  ------------------
  |  Branch (917:9): [True: 0, False: 120]
  |  Branch (917:27): [True: 0, False: 120]
  |  Branch (917:48): [True: 0, False: 120]
  ------------------
  918|      0|        return;
  919|       |
  920|    120|    end = &hash->table[hash->size];
  921|       |
  922|  12.6k|    for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (922:31): [True: 12.5k, False: 120]
  ------------------
  923|  12.5k|        if ((entry->hashValue != 0) && (entry->payload != NULL))
  ------------------
  |  Branch (923:13): [True: 5.28k, False: 7.23k]
  |  Branch (923:40): [True: 5.28k, False: 0]
  ------------------
  924|  5.28k|            scan(entry->payload, data, entry->key, entry->key2, entry->key3);
  925|  12.5k|    }
  926|    120|}
xmlHashSize:
 1033|    120|xmlHashSize(xmlHashTablePtr hash) {
 1034|    120|    if (hash == NULL)
  ------------------
  |  Branch (1034:9): [True: 0, False: 120]
  ------------------
 1035|      0|        return(-1);
 1036|    120|    return(hash->nbElems);
 1037|    120|}
xmlHashRemoveEntry2:
 1070|  1.96k|                    const xmlChar *key2, xmlHashDeallocator dealloc) {
 1071|  1.96k|    return(xmlHashRemoveEntry3(hash, key, key2, NULL, dealloc));
 1072|  1.96k|}
xmlHashRemoveEntry3:
 1092|  1.96k|                    xmlHashDeallocator dealloc) {
 1093|  1.96k|    xmlHashEntry *entry, *cur, *next;
 1094|  1.96k|    unsigned hashValue, mask, pos, nextpos;
 1095|  1.96k|    int found;
 1096|       |
 1097|  1.96k|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (1097:9): [True: 0, False: 1.96k]
  |  Branch (1097:27): [True: 0, False: 1.96k]
  |  Branch (1097:48): [True: 0, False: 1.96k]
  ------------------
 1098|      0|        return(-1);
 1099|       |
 1100|  1.96k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
 1101|  1.96k|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
 1102|  1.96k|    if (!found)
  ------------------
  |  Branch (1102:9): [True: 0, False: 1.96k]
  ------------------
 1103|      0|        return(-1);
 1104|       |
 1105|  1.96k|    if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (1105:9): [True: 0, False: 1.96k]
  |  Branch (1105:30): [True: 0, False: 0]
  ------------------
 1106|      0|        dealloc(entry->payload, entry->key);
 1107|  1.96k|    if (hash->dict == NULL) {
  ------------------
  |  Branch (1107:9): [True: 0, False: 1.96k]
  ------------------
 1108|      0|        if (entry->key)
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|            xmlFree(entry->key);
 1110|      0|        if (entry->key2)
  ------------------
  |  Branch (1110:13): [True: 0, False: 0]
  ------------------
 1111|      0|            xmlFree(entry->key2);
 1112|      0|        if (entry->key3)
  ------------------
  |  Branch (1112:13): [True: 0, False: 0]
  ------------------
 1113|      0|            xmlFree(entry->key3);
 1114|      0|    }
 1115|       |
 1116|       |    /*
 1117|       |     * Find end of probe sequence. Entries at their initial probe
 1118|       |     * position start a new sequence.
 1119|       |     */
 1120|  1.96k|    mask = hash->size - 1;
 1121|  1.96k|    pos = entry - hash->table;
 1122|  1.96k|    cur = entry;
 1123|       |
 1124|  3.21k|    while (1) {
  ------------------
  |  Branch (1124:12): [Folded - Ignored]
  ------------------
 1125|  3.21k|        nextpos = pos + 1;
 1126|  3.21k|        next = cur + 1;
 1127|  3.21k|        if ((nextpos & mask) == 0)
  ------------------
  |  Branch (1127:13): [True: 12, False: 3.20k]
  ------------------
 1128|     12|            next = hash->table;
 1129|       |
 1130|  3.21k|        if ((next->hashValue == 0) ||
  ------------------
  |  Branch (1130:13): [True: 1.24k, False: 1.97k]
  ------------------
 1131|  3.21k|            (((next->hashValue - nextpos) & mask) == 0))
  ------------------
  |  Branch (1131:13): [True: 717, False: 1.25k]
  ------------------
 1132|  1.96k|            break;
 1133|       |
 1134|  1.25k|        cur = next;
 1135|  1.25k|        pos = nextpos;
 1136|  1.25k|    }
 1137|       |
 1138|       |    /*
 1139|       |     * Backward shift
 1140|       |     */
 1141|  1.96k|    next = entry + 1;
 1142|       |
 1143|  1.96k|    if (cur < entry) {
  ------------------
  |  Branch (1143:9): [True: 3, False: 1.95k]
  ------------------
 1144|      3|        xmlHashEntry *end = &hash->table[hash->size];
 1145|       |
 1146|      3|        memmove(entry, next, (char *) end - (char *) next);
 1147|      3|        entry = hash->table;
 1148|      3|        end[-1] = *entry;
 1149|      3|        next = entry + 1;
 1150|      3|    }
 1151|       |
 1152|  1.96k|    memmove(entry, next, (char *) cur - (char *) entry);
 1153|       |
 1154|       |    /*
 1155|       |     * Update entry
 1156|       |     */
 1157|  1.96k|    cur->hashValue = 0;
 1158|       |
 1159|  1.96k|    hash->nbElems--;
 1160|       |
 1161|  1.96k|    return(0);
 1162|  1.96k|}
hash.c:xmlHashGrow:
  354|  1.69k|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|  1.69k|    const xmlHashEntry *oldentry, *oldend, *end;
  356|  1.69k|    xmlHashEntry *table;
  357|  1.69k|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|  1.69k|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|  1.69k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 1.69k]
  ------------------
  361|      0|        return(-1);
  362|  1.69k|    table = xmlMalloc(size * sizeof(table[0]));
  363|  1.69k|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 0, False: 1.69k]
  ------------------
  364|      0|        return(-1);
  365|  1.69k|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|  1.69k|    oldsize = hash->size;
  368|  1.69k|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 1.29k, False: 399]
  ------------------
  369|  1.29k|        goto done;
  370|       |
  371|    399|    oldend = &hash->table[oldsize];
  372|    399|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|    399|    oldentry = hash->table;
  382|  2.73k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 2.33k, False: 399]
  ------------------
  383|  2.33k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 2.33k]
  ------------------
  384|      0|            oldentry = hash->table;
  385|  2.33k|    }
  386|       |
  387|  29.0k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 28.6k, False: 399]
  ------------------
  388|  28.6k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 25.0k, False: 3.57k]
  ------------------
  389|  25.0k|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|  33.9k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 8.95k, False: 25.0k]
  ------------------
  392|  8.95k|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 63, False: 8.88k]
  ------------------
  393|     63|                    entry = table;
  394|  8.95k|            }
  395|  25.0k|            *entry = *oldentry;
  396|  25.0k|        }
  397|       |
  398|  28.6k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 399, False: 28.2k]
  ------------------
  399|    399|            oldentry = hash->table;
  400|  28.6k|    }
  401|       |
  402|    399|    xmlFree(hash->table);
  403|       |
  404|  1.69k|done:
  405|  1.69k|    hash->table = table;
  406|  1.69k|    hash->size = size;
  407|       |
  408|  1.69k|    return(0);
  409|    399|}
hash.c:xmlHashUpdateInternal:
  427|  17.9k|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|  17.9k|    xmlChar *copy, *copy2, *copy3;
  429|  17.9k|    xmlHashEntry *entry = NULL;
  430|  17.9k|    size_t lengths[3];
  431|  17.9k|    unsigned hashValue;
  432|  17.9k|    int found = 0;
  433|       |
  434|  17.9k|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 17.9k]
  |  Branch (434:27): [True: 0, False: 17.9k]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|  17.9k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|  17.9k|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 16.8k, False: 1.12k]
  ------------------
  442|  16.8k|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|  17.9k|    if (found) {
  ------------------
  |  Branch (443:9): [True: 42, False: 17.9k]
  ------------------
  444|     42|        if (update) {
  ------------------
  |  Branch (444:13): [True: 24, False: 18]
  ------------------
  445|     24|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 24]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|     24|            entry->payload = payload;
  448|     24|            return(0);
  449|     24|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|     18|            return(-1);
  457|     18|        }
  458|     42|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|  17.9k|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|  17.9k|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|  17.9k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 1.52k, False: 16.4k]
  ------------------
  464|  1.52k|        unsigned newSize, mask, displ, pos;
  465|       |
  466|  1.52k|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 1.12k, False: 399]
  ------------------
  467|  1.12k|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|  1.12k|#define MIN_HASH_SIZE 8
  ------------------
  468|  1.12k|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|    399|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|    399|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 399]
  ------------------
  471|      0|                return(-1);
  472|    399|            newSize = hash->size * 2;
  473|    399|        }
  474|  1.52k|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 0, False: 1.52k]
  ------------------
  475|      0|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|  1.52k|        mask = hash->size - 1;
  481|  1.52k|        displ = 0;
  482|  1.52k|        pos = hashValue & mask;
  483|  1.52k|        entry = &hash->table[pos];
  484|       |
  485|  1.52k|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 177, False: 1.34k]
  ------------------
  486|    225|            do {
  487|    225|                displ++;
  488|    225|                pos++;
  489|    225|                entry++;
  490|    225|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 12, False: 213]
  ------------------
  491|     12|                    entry = hash->table;
  492|    225|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 120, False: 105]
  ------------------
  493|    225|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 48, False: 72]
  ------------------
  494|    177|        }
  495|  1.52k|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|  17.9k|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 17.5k, False: 363]
  ------------------
  501|  17.5k|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 15.9k, False: 1.67k]
  ------------------
  502|  15.9k|            copy = (xmlChar *) key;
  503|  15.9k|        } else {
  504|  1.67k|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|  1.67k|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 1.67k]
  ------------------
  506|      0|                return(-1);
  507|  1.67k|        }
  508|       |
  509|  17.5k|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 11.4k, False: 6.15k]
  |  Branch (509:31): [True: 6.07k, False: 81]
  ------------------
  510|  17.4k|            copy2 = (xmlChar *) key2;
  511|  17.4k|        } else {
  512|     81|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|     81|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 81]
  ------------------
  514|      0|                return(-1);
  515|     81|        }
  516|  17.5k|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 11.7k, False: 5.83k]
  |  Branch (516:31): [True: 5.83k, False: 0]
  ------------------
  517|  17.5k|            copy3 = (xmlChar *) key3;
  518|  17.5k|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|  17.5k|    } else {
  524|    363|        copy = xmlMalloc(lengths[0] + 1);
  525|    363|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 0, False: 363]
  ------------------
  526|      0|            return(-1);
  527|    363|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|    363|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 0, False: 363]
  ------------------
  530|      0|            copy2 = xmlMalloc(lengths[1] + 1);
  531|      0|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 0]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|      0|            memcpy(copy2, key2, lengths[1] + 1);
  536|    363|        } else {
  537|    363|            copy2 = NULL;
  538|    363|        }
  539|       |
  540|    363|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 363]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|    363|        } else {
  549|    363|            copy3 = NULL;
  550|    363|        }
  551|    363|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|  17.9k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 6.19k, False: 11.7k]
  ------------------
  557|  6.19k|        const xmlHashEntry *end = &hash->table[hash->size];
  558|  6.19k|        const xmlHashEntry *cur = entry;
  559|       |
  560|  40.3k|        do {
  561|  40.3k|            cur++;
  562|  40.3k|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 252, False: 40.1k]
  ------------------
  563|    252|                cur = hash->table;
  564|  40.3k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 34.1k, False: 6.19k]
  ------------------
  565|       |
  566|  6.19k|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 252, False: 5.94k]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|    252|            memmove(&hash->table[1], hash->table,
  572|    252|                    (char *) cur - (char *) hash->table);
  573|    252|            cur = end - 1;
  574|    252|            hash->table[0] = *cur;
  575|    252|        }
  576|       |
  577|  6.19k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|  6.19k|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|  17.9k|    entry->key = copy;
  584|  17.9k|    entry->key2 = copy2;
  585|  17.9k|    entry->key3 = copy3;
  586|  17.9k|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|  17.9k|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|  17.9k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|  17.9k|    hash->nbElems++;
  591|       |
  592|  17.9k|    return(0);
  593|  17.9k|}
hash.c:xmlHashValue:
   62|   349k|             const xmlChar *key3, size_t *lengths) {
   63|   349k|    unsigned h1, h2;
   64|   349k|    size_t i;
   65|       |
   66|   349k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|   349k|    do { \
  |  |   24|   349k|        h1 = seed ^ 0x3b00; \
  |  |   25|   349k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|   349k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|   349k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|  4.62M|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 4.27M, False: 349k]
  ------------------
   69|  4.27M|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|  4.27M|    do { \
  |  |   30|  4.27M|        h1 += ch; \
  |  |   31|  4.27M|        h1 += h1 << 3; \
  |  |   32|  4.27M|        h2 += h1; \
  |  |   33|  4.27M|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  4.27M|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  4.27M|        h2 += h2 << 2; \
  |  |   35|  4.27M|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|  4.27M|    }
   71|   349k|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 17.9k, False: 331k]
  ------------------
   72|  17.9k|        lengths[0] = i;
   73|       |
   74|   349k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|   349k|    do { \
  |  |   30|   349k|        h1 += ch; \
  |  |   31|   349k|        h1 += h1 << 3; \
  |  |   32|   349k|        h2 += h1; \
  |  |   33|   349k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   349k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   349k|        h2 += h2 << 2; \
  |  |   35|   349k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|   349k|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 16.0k, False: 333k]
  ------------------
   77|  97.8k|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 81.8k, False: 16.0k]
  ------------------
   78|  81.8k|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|  81.8k|    do { \
  |  |   30|  81.8k|        h1 += ch; \
  |  |   31|  81.8k|        h1 += h1 << 3; \
  |  |   32|  81.8k|        h2 += h1; \
  |  |   33|  81.8k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  81.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  81.8k|        h2 += h2 << 2; \
  |  |   35|  81.8k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|  81.8k|        }
   80|  16.0k|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 6.15k, False: 9.90k]
  ------------------
   81|  6.15k|            lengths[1] = i;
   82|  16.0k|    }
   83|       |
   84|   349k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|   349k|    do { \
  |  |   30|   349k|        h1 += ch; \
  |  |   31|   349k|        h1 += h1 << 3; \
  |  |   32|   349k|        h2 += h1; \
  |  |   33|   349k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   349k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   349k|        h2 += h2 << 2; \
  |  |   35|   349k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|   349k|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 15.2k, False: 334k]
  ------------------
   87|   106k|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 91.7k, False: 15.2k]
  ------------------
   88|  91.7k|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|  91.7k|    do { \
  |  |   30|  91.7k|        h1 += ch; \
  |  |   31|  91.7k|        h1 += h1 << 3; \
  |  |   32|  91.7k|        h2 += h1; \
  |  |   33|  91.7k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  91.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  91.7k|        h2 += h2 << 2; \
  |  |   35|  91.7k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|  91.7k|        }
   90|  15.2k|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 5.83k, False: 9.38k]
  ------------------
   91|  5.83k|            lengths[2] = i;
   92|  15.2k|    }
   93|       |
   94|   349k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|   349k|    do { \
  |  |   40|   349k|        h1 ^= h2; \
  |  |   41|   349k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|   349k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|   349k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|   349k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|   349k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|   349k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|   349k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|   349k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|   349k|        h2 &= 0xFFFFFFFF; \
  |  |   46|   349k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|   349k|    return(h2);
   97|   349k|}
hash.c:xmlHashFindEntry:
  294|   348k|                 unsigned hashValue, int *pfound) {
  295|   348k|    xmlHashEntry *entry;
  296|   348k|    unsigned mask, pos, displ;
  297|   348k|    int found = 0;
  298|       |
  299|   348k|    mask = hash->size - 1;
  300|   348k|    pos = hashValue & mask;
  301|   348k|    entry = &hash->table[pos];
  302|       |
  303|   348k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 333k, False: 14.6k]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|   333k|        displ = 0;
  310|   333k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|   333k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|   610k|        do {
  313|   610k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 301k, False: 308k]
  ------------------
  314|   301k|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 291k, False: 9.98k]
  ------------------
  315|   291k|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 138k, False: 153k]
  ------------------
  316|   291k|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 138k, False: 0]
  ------------------
  317|   291k|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 138k, False: 0]
  ------------------
  318|   138k|                        found = 1;
  319|   138k|                        break;
  320|   138k|                    }
  321|   291k|                }
  322|   163k|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 163k, False: 0]
  ------------------
  323|   163k|                            (const char *) key) == 0) &&
  324|   163k|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 163k, False: 0]
  ------------------
  325|   163k|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 163k, False: 0]
  ------------------
  326|   163k|                    found = 1;
  327|   163k|                    break;
  328|   163k|                }
  329|   163k|            }
  330|       |
  331|   308k|            displ++;
  332|   308k|            pos++;
  333|   308k|            entry++;
  334|   308k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 3.49k, False: 305k]
  ------------------
  335|  3.49k|                entry = hash->table;
  336|   308k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 297k, False: 11.2k]
  ------------------
  337|   308k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 276k, False: 20.9k]
  ------------------
  338|   333k|    }
  339|       |
  340|      0|    *pfound = found;
  341|   348k|    return(entry);
  342|   348k|}
hash.c:xmlHashQNameValue:
  104|  4.37k|                  const xmlChar *prefix3, const xmlChar *name3) {
  105|  4.37k|    unsigned h1, h2, ch;
  106|       |
  107|  4.37k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  4.37k|    do { \
  |  |   24|  4.37k|        h1 = seed ^ 0x3b00; \
  |  |   25|  4.37k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  4.37k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  4.37k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  108|       |
  109|  4.37k|    if (prefix != NULL) {
  ------------------
  |  Branch (109:9): [True: 210, False: 4.16k]
  ------------------
  110|    840|        while ((ch = *prefix++) != 0) {
  ------------------
  |  Branch (110:16): [True: 630, False: 210]
  ------------------
  111|    630|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    630|    do { \
  |  |   30|    630|        h1 += ch; \
  |  |   31|    630|        h1 += h1 << 3; \
  |  |   32|    630|        h2 += h1; \
  |  |   33|    630|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    630|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    630|        h2 += h2 << 2; \
  |  |   35|    630|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  112|    630|        }
  113|    210|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|    210|    do { \
  |  |   30|    210|        h1 += ch; \
  |  |   31|    210|        h1 += h1 << 3; \
  |  |   32|    210|        h2 += h1; \
  |  |   33|    210|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    210|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    210|        h2 += h2 << 2; \
  |  |   35|    210|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  114|    210|    }
  115|  4.37k|    if (name != NULL) {
  ------------------
  |  Branch (115:9): [True: 4.37k, False: 0]
  ------------------
  116|  26.1k|        while ((ch = *name++) != 0) {
  ------------------
  |  Branch (116:16): [True: 21.7k, False: 4.37k]
  ------------------
  117|  21.7k|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|  21.7k|    do { \
  |  |   30|  21.7k|        h1 += ch; \
  |  |   31|  21.7k|        h1 += h1 << 3; \
  |  |   32|  21.7k|        h2 += h1; \
  |  |   33|  21.7k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  21.7k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  21.7k|        h2 += h2 << 2; \
  |  |   35|  21.7k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  118|  21.7k|        }
  119|  4.37k|    }
  120|  4.37k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  4.37k|    do { \
  |  |   30|  4.37k|        h1 += ch; \
  |  |   31|  4.37k|        h1 += h1 << 3; \
  |  |   32|  4.37k|        h2 += h1; \
  |  |   33|  4.37k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  4.37k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  4.37k|        h2 += h2 << 2; \
  |  |   35|  4.37k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  121|  4.37k|    if (prefix2 != NULL) {
  ------------------
  |  Branch (121:9): [True: 222, False: 4.15k]
  ------------------
  122|    912|        while ((ch = *prefix2++) != 0) {
  ------------------
  |  Branch (122:16): [True: 690, False: 222]
  ------------------
  123|    690|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    690|    do { \
  |  |   30|    690|        h1 += ch; \
  |  |   31|    690|        h1 += h1 << 3; \
  |  |   32|    690|        h2 += h1; \
  |  |   33|    690|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    690|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    690|        h2 += h2 << 2; \
  |  |   35|    690|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  124|    690|        }
  125|    222|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|    222|    do { \
  |  |   30|    222|        h1 += ch; \
  |  |   31|    222|        h1 += h1 << 3; \
  |  |   32|    222|        h2 += h1; \
  |  |   33|    222|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    222|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    222|        h2 += h2 << 2; \
  |  |   35|    222|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  126|    222|    }
  127|  4.37k|    if (name2 != NULL) {
  ------------------
  |  Branch (127:9): [True: 4.37k, False: 0]
  ------------------
  128|  18.6k|        while ((ch = *name2++) != 0) {
  ------------------
  |  Branch (128:16): [True: 14.3k, False: 4.37k]
  ------------------
  129|  14.3k|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|  14.3k|    do { \
  |  |   30|  14.3k|        h1 += ch; \
  |  |   31|  14.3k|        h1 += h1 << 3; \
  |  |   32|  14.3k|        h2 += h1; \
  |  |   33|  14.3k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  14.3k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  14.3k|        h2 += h2 << 2; \
  |  |   35|  14.3k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  130|  14.3k|        }
  131|  4.37k|    }
  132|  4.37k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  4.37k|    do { \
  |  |   30|  4.37k|        h1 += ch; \
  |  |   31|  4.37k|        h1 += h1 << 3; \
  |  |   32|  4.37k|        h2 += h1; \
  |  |   33|  4.37k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  4.37k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  4.37k|        h2 += h2 << 2; \
  |  |   35|  4.37k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|  4.37k|    if (prefix3 != NULL) {
  ------------------
  |  Branch (133:9): [True: 0, False: 4.37k]
  ------------------
  134|      0|        while ((ch = *prefix3++) != 0) {
  ------------------
  |  Branch (134:16): [True: 0, False: 0]
  ------------------
  135|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  136|      0|        }
  137|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  138|      0|    }
  139|  4.37k|    if (name3 != NULL) {
  ------------------
  |  Branch (139:9): [True: 0, False: 4.37k]
  ------------------
  140|      0|        while ((ch = *name3++) != 0) {
  ------------------
  |  Branch (140:16): [True: 0, False: 0]
  ------------------
  141|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  142|      0|        }
  143|      0|    }
  144|       |
  145|  4.37k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  4.37k|    do { \
  |  |   40|  4.37k|        h1 ^= h2; \
  |  |   41|  4.37k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  4.37k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  4.37k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  4.37k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  4.37k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  4.37k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  4.37k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  4.37k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  4.37k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  4.37k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  146|       |
  147|  4.37k|    return(h2);
  148|  4.37k|}
hash.c:xmlFastStrEqual:
  269|   327k|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|   327k|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 326k, False: 516]
  ------------------
  271|   326k|        return(s2 == NULL);
  272|    516|    else
  273|    516|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 516, False: 0]
  ------------------
  274|    516|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 516, False: 0]
  ------------------
  275|   327k|}

xmlListCreate:
  189|    657|{
  190|    657|    xmlListPtr l;
  191|    657|    if (NULL == (l = (xmlListPtr )xmlMalloc( sizeof(xmlList)))) {
  ------------------
  |  Branch (191:9): [True: 0, False: 657]
  ------------------
  192|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  193|      0|		        "Cannot initialize memory for list");
  194|      0|        return (NULL);
  195|      0|    }
  196|       |    /* Initialize the list to NULL */
  197|    657|    memset(l, 0, sizeof(xmlList));
  198|       |
  199|       |    /* Add the sentinel */
  200|    657|    if (NULL ==(l->sentinel = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink)))) {
  ------------------
  |  Branch (200:9): [True: 0, False: 657]
  ------------------
  201|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  202|      0|		        "Cannot initialize memory for sentinel");
  203|      0|	xmlFree(l);
  204|      0|        return (NULL);
  205|      0|    }
  206|    657|    l->sentinel->next = l->sentinel;
  207|    657|    l->sentinel->prev = l->sentinel;
  208|    657|    l->sentinel->data = NULL;
  209|       |
  210|       |    /* If there is a link deallocator, use it */
  211|    657|    if (deallocator != NULL)
  ------------------
  |  Branch (211:9): [True: 657, False: 0]
  ------------------
  212|    657|        l->linkDeallocator = deallocator;
  213|       |    /* If there is a link comparator, use it */
  214|    657|    if (compare != NULL)
  ------------------
  |  Branch (214:9): [True: 657, False: 0]
  ------------------
  215|    657|        l->linkCompare = compare;
  216|      0|    else /* Use our own */
  217|      0|        l->linkCompare = xmlLinkCompare;
  218|    657|    return l;
  219|    657|}
xmlListAppend:
  306|  1.98k|{
  307|  1.98k|    xmlLinkPtr lkPlace, lkNew;
  308|       |
  309|  1.98k|    if (l == NULL)
  ------------------
  |  Branch (309:9): [True: 0, False: 1.98k]
  ------------------
  310|      0|        return(1);
  311|  1.98k|    lkPlace = xmlListHigherSearch(l, data);
  312|       |    /* Add the new link */
  313|  1.98k|    lkNew = (xmlLinkPtr) xmlMalloc(sizeof(xmlLink));
  314|  1.98k|    if (lkNew == NULL) {
  ------------------
  |  Branch (314:9): [True: 0, False: 1.98k]
  ------------------
  315|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  316|      0|		        "Cannot initialize memory for new link");
  317|      0|        return (1);
  318|      0|    }
  319|  1.98k|    lkNew->data = data;
  320|  1.98k|    lkNew->next = lkPlace->next;
  321|  1.98k|    (lkPlace->next)->prev = lkNew;
  322|  1.98k|    lkPlace->next = lkNew;
  323|  1.98k|    lkNew->prev = lkPlace;
  324|  1.98k|    return 0;
  325|  1.98k|}
xmlListDelete:
  334|    657|{
  335|    657|    if (l == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 657]
  ------------------
  336|      0|        return;
  337|       |
  338|    657|    xmlListClear(l);
  339|    657|    xmlFree(l->sentinel);
  340|    657|    xmlFree(l);
  341|    657|}
xmlListClear:
  423|    657|{
  424|    657|    xmlLinkPtr  lk;
  425|       |
  426|    657|    if (l == NULL)
  ------------------
  |  Branch (426:9): [True: 0, False: 657]
  ------------------
  427|      0|        return;
  428|    657|    lk = l->sentinel->next;
  429|  2.64k|    while(lk != l->sentinel) {
  ------------------
  |  Branch (429:11): [True: 1.98k, False: 657]
  ------------------
  430|  1.98k|        xmlLinkPtr next = lk->next;
  431|       |
  432|  1.98k|        xmlLinkDeallocator(l, lk);
  433|  1.98k|        lk = next;
  434|  1.98k|    }
  435|    657|}
xmlLinkGetData:
  605|  1.98k|{
  606|  1.98k|    if (lk == NULL)
  ------------------
  |  Branch (606:9): [True: 0, False: 1.98k]
  ------------------
  607|      0|        return(NULL);
  608|  1.98k|    return lk->data;
  609|  1.98k|}
list.c:xmlListHigherSearch:
  119|  1.98k|{
  120|  1.98k|    xmlLinkPtr lk;
  121|       |
  122|  1.98k|    if (l == NULL)
  ------------------
  |  Branch (122:9): [True: 0, False: 1.98k]
  ------------------
  123|      0|        return(NULL);
  124|  1.98k|    for(lk = l->sentinel->prev;lk != l->sentinel && l->linkCompare(lk->data, data) >0 ;lk = lk->prev);
  ------------------
  |  Branch (124:32): [True: 1.33k, False: 657]
  |  Branch (124:53): [True: 0, False: 1.33k]
  ------------------
  125|  1.98k|    return lk;
  126|  1.98k|}
list.c:xmlLinkDeallocator:
   60|  1.98k|{
   61|  1.98k|    (lk->prev)->next = lk->next;
   62|  1.98k|    (lk->next)->prev = lk->prev;
   63|  1.98k|    if(l->linkDeallocator)
  ------------------
  |  Branch (63:8): [True: 1.98k, False: 0]
  ------------------
   64|  1.98k|        l->linkDeallocator(lk);
   65|  1.98k|    xmlFree(lk);
   66|  1.98k|}

xmlParserNsCreate:
 1407|  1.32k|xmlParserNsCreate(void) {
 1408|  1.32k|    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));
 1409|       |
 1410|  1.32k|    if (nsdb == NULL)
  ------------------
  |  Branch (1410:9): [True: 0, False: 1.32k]
  ------------------
 1411|      0|        return(NULL);
 1412|  1.32k|    memset(nsdb, 0, sizeof(*nsdb));
 1413|  1.32k|    nsdb->defaultNsIndex = INT_MAX;
 1414|       |
 1415|  1.32k|    return(nsdb);
 1416|  1.32k|}
xmlParserNsFree:
 1425|  1.32k|xmlParserNsFree(xmlParserNsData *nsdb) {
 1426|  1.32k|    if (nsdb == NULL)
  ------------------
  |  Branch (1426:9): [True: 0, False: 1.32k]
  ------------------
 1427|      0|        return;
 1428|       |
 1429|  1.32k|    xmlFree(nsdb->extra);
 1430|  1.32k|    xmlFree(nsdb->hash);
 1431|  1.32k|    xmlFree(nsdb);
 1432|  1.32k|}
xmlParserNsLookupSax:
 1560|  2.14k|xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 1561|  2.14k|    xmlHashedString hprefix;
 1562|  2.14k|    int nsIndex;
 1563|       |
 1564|  2.14k|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1564:9): [True: 48, False: 2.09k]
  ------------------
 1565|     48|        return(NULL);
 1566|       |
 1567|  2.09k|    hprefix.name = prefix;
 1568|  2.09k|    if (prefix != NULL)
  ------------------
  |  Branch (1568:9): [True: 1.85k, False: 243]
  ------------------
 1569|  1.85k|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1570|    243|    else
 1571|    243|        hprefix.hashValue = 0;
 1572|  2.09k|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1573|  2.09k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1573:9): [True: 0, False: 2.09k]
  ------------------
 1574|      0|        return(NULL);
 1575|       |
 1576|  2.09k|    return(ctxt->nsdb->extra[nsIndex].saxData);
 1577|  2.09k|}
xmlParserNsUpdateSax:
 1593|    309|                     void *saxData) {
 1594|    309|    xmlHashedString hprefix;
 1595|    309|    int nsIndex;
 1596|       |
 1597|    309|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1597:9): [True: 0, False: 309]
  ------------------
 1598|      0|        return(-1);
 1599|       |
 1600|    309|    hprefix.name = prefix;
 1601|    309|    if (prefix != NULL)
  ------------------
  |  Branch (1601:9): [True: 222, False: 87]
  ------------------
 1602|    222|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1603|     87|    else
 1604|     87|        hprefix.hashValue = 0;
 1605|    309|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1606|    309|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1606:9): [True: 0, False: 309]
  ------------------
 1607|      0|        return(-1);
 1608|       |
 1609|    309|    ctxt->nsdb->extra[nsIndex].saxData = saxData;
 1610|    309|    return(0);
 1611|    309|}
inputPush:
 1893|   104k|{
 1894|   104k|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 104k]
  |  Branch (1894:27): [True: 0, False: 104k]
  ------------------
 1895|      0|        return(-1);
 1896|   104k|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 9, False: 104k]
  ------------------
 1897|      9|        size_t newSize = ctxt->inputMax * 2;
 1898|      9|        xmlParserInputPtr *tmp;
 1899|       |
 1900|      9|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|      9|                                               newSize * sizeof(*tmp));
 1902|      9|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 9]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|      9|        ctxt->inputTab = tmp;
 1907|      9|        ctxt->inputMax = newSize;
 1908|      9|    }
 1909|   104k|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|   104k|    ctxt->input = value;
 1911|   104k|    return (ctxt->inputNr++);
 1912|   104k|}
inputPop:
 1923|   106k|{
 1924|   106k|    xmlParserInputPtr ret;
 1925|       |
 1926|   106k|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 106k]
  ------------------
 1927|      0|        return(NULL);
 1928|   106k|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 2.64k, False: 104k]
  ------------------
 1929|  2.64k|        return (NULL);
 1930|   104k|    ctxt->inputNr--;
 1931|   104k|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 103k, False: 1.32k]
  ------------------
 1932|   103k|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|  1.32k|    else
 1934|  1.32k|        ctxt->input = NULL;
 1935|   104k|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|   104k|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|   104k|    return (ret);
 1938|   106k|}
nodePush:
 1952|  43.3k|{
 1953|  43.3k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 43.3k]
  ------------------
 1954|  43.3k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 3, False: 43.3k]
  ------------------
 1955|      3|        xmlNodePtr *tmp;
 1956|       |
 1957|      3|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|      3|                                      ctxt->nodeMax * 2 *
 1959|      3|                                      sizeof(ctxt->nodeTab[0]));
 1960|      3|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 3]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|      3|        ctxt->nodeTab = tmp;
 1965|      3|	ctxt->nodeMax *= 2;
 1966|      3|    }
 1967|  43.3k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 43.3k]
  ------------------
 1968|  43.3k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  43.3k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  43.3k|    ctxt->node = value;
 1977|  43.3k|    return (ctxt->nodeNr++);
 1978|  43.3k|}
nodePop:
 1992|  42.9k|{
 1993|  42.9k|    xmlNodePtr ret;
 1994|       |
 1995|  42.9k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 42.9k]
  ------------------
 1996|  42.9k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 12, False: 42.9k]
  ------------------
 1997|     12|        return (NULL);
 1998|  42.9k|    ctxt->nodeNr--;
 1999|  42.9k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 42.1k, False: 796]
  ------------------
 2000|  42.1k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|    796|    else
 2002|    796|        ctxt->node = NULL;
 2003|  42.9k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  42.9k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  42.9k|    return (ret);
 2006|  42.9k|}
namePop:
 2139|  14.4k|{
 2140|  14.4k|    const xmlChar *ret;
 2141|       |
 2142|  14.4k|    if ((ctxt == NULL) || (ctxt->nameNr <= 0))
  ------------------
  |  Branch (2142:9): [True: 0, False: 14.4k]
  |  Branch (2142:27): [True: 0, False: 14.4k]
  ------------------
 2143|      0|        return (NULL);
 2144|  14.4k|    ctxt->nameNr--;
 2145|  14.4k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2145:9): [True: 14.1k, False: 339]
  ------------------
 2146|  14.1k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2147|    339|    else
 2148|    339|        ctxt->name = NULL;
 2149|  14.4k|    ret = ctxt->nameTab[ctxt->nameNr];
 2150|  14.4k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2151|  14.4k|    return (ret);
 2152|  14.4k|}
xmlSkipBlankChars:
 2311|   789k|xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2312|   789k|    int res = 0;
 2313|       |
 2314|       |    /*
 2315|       |     * It's Okay to use CUR/NEXT here since all the blanks are on
 2316|       |     * the ASCII range.
 2317|       |     */
 2318|   789k|    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||
  ------------------
  |  Branch (2318:10): [True: 279k, False: 509k]
  |  Branch (2318:34): [True: 245k, False: 33.7k]
  ------------------
 2319|   789k|        (ctxt->instate == XML_PARSER_START)) {
  ------------------
  |  Branch (2319:9): [True: 24, False: 543k]
  ------------------
 2320|   245k|	const xmlChar *cur;
 2321|       |	/*
 2322|       |	 * if we are in the document content, go really fast
 2323|       |	 */
 2324|   245k|	cur = ctxt->input->cur;
 2325|   245k|	while (IS_BLANK_CH(*cur)) {
 2326|   206k|	    if (*cur == '\n') {
  ------------------
  |  Branch (2326:10): [True: 4.01k, False: 202k]
  ------------------
 2327|  4.01k|		ctxt->input->line++; ctxt->input->col = 1;
 2328|   202k|	    } else {
 2329|   202k|		ctxt->input->col++;
 2330|   202k|	    }
 2331|   206k|	    cur++;
 2332|   206k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2332:10): [True: 206k, False: 0]
  ------------------
 2333|   206k|		res++;
 2334|   206k|	    if (*cur == 0) {
  ------------------
  |  Branch (2334:10): [True: 803, False: 205k]
  ------------------
 2335|    803|		ctxt->input->cur = cur;
 2336|    803|		xmlParserGrow(ctxt);
 2337|    803|		cur = ctxt->input->cur;
 2338|    803|	    }
 2339|   206k|	}
 2340|   245k|	ctxt->input->cur = cur;
 2341|   543k|    } else {
 2342|   543k|        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));
  ------------------
  |  Branch (2342:25): [True: 32.7k, False: 510k]
  |  Branch (2342:50): [True: 493k, False: 16.9k]
  ------------------
 2343|       |
 2344|   965k|	while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (2344:9): [True: 965k, False: 9]
  ------------------
 2345|   965k|            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
  ------------------
  |  |  151|   965k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   965k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 142k, False: 822k]
  |  |  |  |  ------------------
  |  |  |  |   89|   965k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 719k, False: 102k]
  |  |  |  |  |  Branch (89:23): [True: 67.9k, False: 651k]
  |  |  |  |  ------------------
  |  |  |  |   90|   965k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 5.34k, False: 749k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2346|   216k|		NEXT;
  ------------------
  |  | 2275|   216k|#define NEXT xmlNextChar(ctxt)
  ------------------
 2347|   749k|	    } else if (CUR == '%') {
  ------------------
  |  | 2222|   749k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2347:17): [True: 103k, False: 645k]
  ------------------
 2348|       |                /*
 2349|       |                 * Need to handle support of entities branching here
 2350|       |                 */
 2351|   103k|	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  |  151|   103k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|   103k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 477, False: 102k]
  |  |  |  |  ------------------
  |  |  |  |   89|   103k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 102k, False: 6]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 102k]
  |  |  |  |  ------------------
  |  |  |  |   90|   103k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 102k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  | 2223|   102k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2351:14): [True: 267, False: 103k]
  |  Branch (2351:58): [True: 6, False: 102k]
  ------------------
 2352|    750|                    break;
 2353|   102k|	        xmlParsePEReference(ctxt);
 2354|   645k|            } else if (CUR == 0) {
  ------------------
  |  | 2222|   645k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2354:24): [True: 102k, False: 542k]
  ------------------
 2355|   102k|                unsigned long consumed;
 2356|   102k|                xmlEntityPtr ent;
 2357|       |
 2358|   102k|                if (ctxt->inputNr <= 1)
  ------------------
  |  Branch (2358:21): [True: 60, False: 102k]
  ------------------
 2359|     60|                    break;
 2360|       |
 2361|   102k|                consumed = ctxt->input->consumed;
 2362|   102k|                xmlSaturatedAddSizeT(&consumed,
 2363|   102k|                                     ctxt->input->cur - ctxt->input->base);
 2364|       |
 2365|       |                /*
 2366|       |                 * Add to sizeentities when parsing an external entity
 2367|       |                 * for the first time.
 2368|       |                 */
 2369|   102k|                ent = ctxt->input->entity;
 2370|   102k|                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (2370:21): [True: 9.87k, False: 93.0k]
  ------------------
 2371|   102k|                    ((ent->flags & XML_ENT_PARSED) == 0)) {
  ------------------
  |  |   14|  9.87k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (2371:21): [True: 15, False: 9.86k]
  ------------------
 2372|     15|                    ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|     15|#define XML_ENT_PARSED      (1<<0)
  ------------------
 2373|       |
 2374|     15|                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);
 2375|     15|                }
 2376|       |
 2377|   102k|                xmlParserEntityCheck(ctxt, consumed);
 2378|       |
 2379|   102k|                xmlPopInput(ctxt);
 2380|   542k|            } else {
 2381|   542k|                break;
 2382|   542k|            }
 2383|       |
 2384|       |            /*
 2385|       |             * Also increase the counter when entering or exiting a PERef.
 2386|       |             * The spec says: "When a parameter-entity reference is recognized
 2387|       |             * in the DTD and included, its replacement text MUST be enlarged
 2388|       |             * by the attachment of one leading and one following space (#x20)
 2389|       |             * character."
 2390|       |             */
 2391|   422k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2391:10): [True: 422k, False: 0]
  ------------------
 2392|   422k|		res++;
 2393|   422k|        }
 2394|   543k|    }
 2395|   789k|    return(res);
 2396|   789k|}
xmlPopInput:
 2414|   102k|xmlPopInput(xmlParserCtxtPtr ctxt) {
 2415|   102k|    xmlParserInputPtr input;
 2416|       |
 2417|   102k|    if ((ctxt == NULL) || (ctxt->inputNr <= 1)) return(0);
  ------------------
  |  Branch (2417:9): [True: 0, False: 102k]
  |  Branch (2417:27): [True: 6, False: 102k]
  ------------------
 2418|   102k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   102k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   102k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 102k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2419|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2420|      0|		"Popping input %d\n", ctxt->inputNr);
 2421|   102k|    if ((ctxt->inputNr > 1) && (ctxt->inSubset == 0) &&
  ------------------
  |  Branch (2421:9): [True: 102k, False: 0]
  |  Branch (2421:32): [True: 0, False: 102k]
  ------------------
 2422|   102k|        (ctxt->instate != XML_PARSER_EOF))
  ------------------
  |  Branch (2422:9): [True: 0, False: 0]
  ------------------
 2423|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 2424|      0|                    "Unfinished entity outside the DTD");
 2425|   102k|    input = inputPop(ctxt);
 2426|   102k|    if (input->entity != NULL)
  ------------------
  |  Branch (2426:9): [True: 102k, False: 0]
  ------------------
 2427|   102k|        input->entity->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|   102k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2428|   102k|    xmlFreeInputStream(input);
 2429|   102k|    if (*ctxt->input->cur == 0)
  ------------------
  |  Branch (2429:9): [True: 45.4k, False: 57.4k]
  ------------------
 2430|  45.4k|        xmlParserGrow(ctxt);
 2431|   102k|    return(CUR);
  ------------------
  |  | 2222|   102k|#define CUR (*ctxt->input->cur)
  ------------------
 2432|   102k|}
xmlPushInput:
 2444|   103k|xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
 2445|   103k|    int ret;
 2446|   103k|    if (input == NULL) return(-1);
  ------------------
  |  Branch (2446:9): [True: 0, False: 103k]
  ------------------
 2447|       |
 2448|   103k|    if (xmlParserDebugEntities) {
  ------------------
  |  |  870|   103k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   103k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 103k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2449|      0|	if ((ctxt->input != NULL) && (ctxt->input->filename))
  ------------------
  |  Branch (2449:6): [True: 0, False: 0]
  |  Branch (2449:31): [True: 0, False: 0]
  ------------------
 2450|      0|	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2451|      0|		    "%s(%d): ", ctxt->input->filename,
 2452|      0|		    ctxt->input->line);
 2453|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2454|      0|		"Pushing input %d : %.30s\n", ctxt->inputNr+1, input->cur);
 2455|      0|    }
 2456|   103k|    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (2456:10): [True: 0, False: 103k]
  |  Branch (2456:34): [True: 0, False: 0]
  ------------------
 2457|   103k|        (ctxt->inputNr > 100)) {
  ------------------
  |  Branch (2457:9): [True: 0, False: 103k]
  ------------------
 2458|      0|        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2459|      0|        while (ctxt->inputNr > 1)
  ------------------
  |  Branch (2459:16): [True: 0, False: 0]
  ------------------
 2460|      0|            xmlFreeInputStream(inputPop(ctxt));
 2461|      0|	return(-1);
 2462|      0|    }
 2463|   103k|    ret = inputPush(ctxt, input);
 2464|   103k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2464:9): [True: 0, False: 103k]
  ------------------
 2465|      0|        return(-1);
 2466|   103k|    GROW;
  ------------------
  |  | 2270|   103k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   103k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 102k, False: 141]
  |  |  ------------------
  |  | 2271|   103k|	xmlParserGrow(ctxt);
  ------------------
 2467|   103k|    return(ret);
 2468|   103k|}
xmlParseCharRef:
 2488|    306|xmlParseCharRef(xmlParserCtxtPtr ctxt) {
 2489|    306|    int val = 0;
 2490|    306|    int count = 0;
 2491|       |
 2492|       |    /*
 2493|       |     * Using RAW/CUR/NEXT is okay since we are working on ASCII range here
 2494|       |     */
 2495|    306|    if ((RAW == '&') && (NXT(1) == '#') &&
  ------------------
  |  | 2221|    306|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '&') && (NXT(1) == '#') &&
  ------------------
  |  | 2223|    306|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2495:9): [True: 306, False: 0]
  |  Branch (2495:25): [True: 306, False: 0]
  ------------------
 2496|    306|        (NXT(2) == 'x')) {
  ------------------
  |  | 2223|    306|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2496:9): [True: 69, False: 237]
  ------------------
 2497|     69|	SKIP(3);
  ------------------
  |  | 2245|     69|#define SKIP(val) do {							\
  |  | 2246|     69|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     69|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 69]
  |  |  ------------------
  |  | 2248|     69|        xmlParserGrow(ctxt);						\
  |  | 2249|     69|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2498|     69|	GROW;
  ------------------
  |  | 2270|     69|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     69|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 63, False: 6]
  |  |  ------------------
  |  | 2271|     69|	xmlParserGrow(ctxt);
  ------------------
 2499|    162|	while (RAW != ';') { /* loop blocked by count */
  ------------------
  |  | 2221|    162|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2499:9): [True: 93, False: 69]
  ------------------
 2500|     93|	    if (count++ > 20) {
  ------------------
  |  Branch (2500:10): [True: 0, False: 93]
  ------------------
 2501|      0|		count = 0;
 2502|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 2503|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2503:21): [True: 0, False: 0]
  ------------------
 2504|      0|                    return(0);
 2505|      0|	    }
 2506|     93|	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|     93|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|     93|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2506:10): [True: 93, False: 0]
  |  Branch (2506:26): [True: 42, False: 51]
  ------------------
 2507|     42|	        val = val * 16 + (CUR - '0');
  ------------------
  |  | 2222|     42|#define CUR (*ctxt->input->cur)
  ------------------
 2508|     51|	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))
  ------------------
  |  | 2221|     51|#define RAW (*ctxt->input->cur)
  ------------------
              	    else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))
  ------------------
  |  | 2221|     48|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2508:15): [True: 48, False: 3]
  |  Branch (2508:31): [True: 48, False: 0]
  |  Branch (2508:47): [True: 48, False: 0]
  ------------------
 2509|     48|	        val = val * 16 + (CUR - 'a') + 10;
  ------------------
  |  | 2222|     48|#define CUR (*ctxt->input->cur)
  ------------------
 2510|      3|	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
              	    else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2510:15): [True: 3, False: 0]
  |  Branch (2510:31): [True: 3, False: 0]
  |  Branch (2510:47): [True: 3, False: 0]
  ------------------
 2511|      3|	        val = val * 16 + (CUR - 'A') + 10;
  ------------------
  |  | 2222|      3|#define CUR (*ctxt->input->cur)
  ------------------
 2512|      0|	    else {
 2513|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2514|      0|		val = 0;
 2515|      0|		break;
 2516|      0|	    }
 2517|     93|	    if (val > 0x110000)
  ------------------
  |  Branch (2517:10): [True: 0, False: 93]
  ------------------
 2518|      0|	        val = 0x110000;
 2519|       |
 2520|     93|	    NEXT;
  ------------------
  |  | 2275|     93|#define NEXT xmlNextChar(ctxt)
  ------------------
 2521|     93|	    count++;
 2522|     93|	}
 2523|     69|	if (RAW == ';') {
  ------------------
  |  | 2221|     69|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2523:6): [True: 69, False: 0]
  ------------------
 2524|       |	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2525|     69|	    ctxt->input->col++;
 2526|     69|	    ctxt->input->cur++;
 2527|     69|	}
 2528|    237|    } else if  ((RAW == '&') && (NXT(1) == '#')) {
  ------------------
  |  | 2221|    237|#define RAW (*ctxt->input->cur)
  ------------------
                  } else if  ((RAW == '&') && (NXT(1) == '#')) {
  ------------------
  |  | 2223|    237|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2528:17): [True: 237, False: 0]
  |  Branch (2528:33): [True: 237, False: 0]
  ------------------
 2529|    237|	SKIP(2);
  ------------------
  |  | 2245|    237|#define SKIP(val) do {							\
  |  | 2246|    237|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    237|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 237]
  |  |  ------------------
  |  | 2248|    237|        xmlParserGrow(ctxt);						\
  |  | 2249|    237|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2530|    237|	GROW;
  ------------------
  |  | 2270|    237|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    237|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 158, False: 79]
  |  |  ------------------
  |  | 2271|    237|	xmlParserGrow(ctxt);
  ------------------
 2531|  1.04k|	while (RAW != ';') { /* loop blocked by count */
  ------------------
  |  | 2221|  1.04k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2531:9): [True: 804, False: 237]
  ------------------
 2532|    804|	    if (count++ > 20) {
  ------------------
  |  Branch (2532:10): [True: 12, False: 792]
  ------------------
 2533|     12|		count = 0;
 2534|     12|		GROW;
  ------------------
  |  | 2270|     12|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     12|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 12, False: 0]
  |  |  ------------------
  |  | 2271|     12|	xmlParserGrow(ctxt);
  ------------------
 2535|     12|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (2535:21): [True: 0, False: 12]
  ------------------
 2536|      0|                    return(0);
 2537|     12|	    }
 2538|    804|	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|    804|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW >= '0') && (RAW <= '9'))
  ------------------
  |  | 2221|    804|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2538:10): [True: 804, False: 0]
  |  Branch (2538:26): [True: 804, False: 0]
  ------------------
 2539|    804|	        val = val * 10 + (CUR - '0');
  ------------------
  |  | 2222|    804|#define CUR (*ctxt->input->cur)
  ------------------
 2540|      0|	    else {
 2541|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2542|      0|		val = 0;
 2543|      0|		break;
 2544|      0|	    }
 2545|    804|	    if (val > 0x110000)
  ------------------
  |  Branch (2545:10): [True: 138, False: 666]
  ------------------
 2546|    138|	        val = 0x110000;
 2547|       |
 2548|    804|	    NEXT;
  ------------------
  |  | 2275|    804|#define NEXT xmlNextChar(ctxt)
  ------------------
 2549|    804|	    count++;
 2550|    804|	}
 2551|    237|	if (RAW == ';') {
  ------------------
  |  | 2221|    237|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2551:6): [True: 237, False: 0]
  ------------------
 2552|       |	    /* on purpose to avoid reentrancy problems with NEXT and SKIP */
 2553|    237|	    ctxt->input->col++;
 2554|    237|	    ctxt->input->cur++;
 2555|    237|	}
 2556|    237|    } else {
 2557|      0|        if (RAW == '&')
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (2557:13): [True: 0, False: 0]
  ------------------
 2558|      0|            SKIP(1);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 2559|      0|        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2560|      0|    }
 2561|       |
 2562|       |    /*
 2563|       |     * [ WFC: Legal Character ]
 2564|       |     * Characters referred to using character references must match the
 2565|       |     * production for Char.
 2566|       |     */
 2567|    306|    if (val >= 0x110000) {
  ------------------
  |  Branch (2567:9): [True: 3, False: 303]
  ------------------
 2568|      3|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2569|      3|                "xmlParseCharRef: character reference out of bounds\n",
 2570|      3|	        val);
 2571|    303|    } else if (IS_CHAR(val)) {
  ------------------
  |  |  125|    303|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    303|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 303, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 303, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    303|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    303|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 303, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 39, False: 264]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    303|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 27, False: 237]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    303|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 237, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    303|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2572|    303|        return(val);
 2573|    303|    } else {
 2574|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2575|      0|                          "xmlParseCharRef: invalid xmlChar value %d\n",
 2576|      0|	                  val);
 2577|      0|    }
 2578|      3|    return(0);
 2579|    306|}
xmlSplitQName:
 3152|  5.83k|xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 3153|  5.83k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3154|  5.83k|    xmlChar *buffer = NULL;
 3155|  5.83k|    int len = 0;
 3156|  5.83k|    int max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|  5.83k|#define XML_MAX_NAMELEN 100
  ------------------
 3157|  5.83k|    xmlChar *ret = NULL;
 3158|  5.83k|    const xmlChar *cur = name;
 3159|  5.83k|    int c;
 3160|       |
 3161|  5.83k|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (3161:9): [True: 0, False: 5.83k]
  ------------------
 3162|  5.83k|    *prefix = NULL;
 3163|       |
 3164|  5.83k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3164:9): [True: 0, False: 5.83k]
  ------------------
 3165|       |
 3166|       |#ifndef XML_XML_NAMESPACE
 3167|       |    /* xml: prefix is not really a namespace */
 3168|       |    if ((cur[0] == 'x') && (cur[1] == 'm') &&
 3169|       |        (cur[2] == 'l') && (cur[3] == ':'))
 3170|       |	return(xmlStrdup(name));
 3171|       |#endif
 3172|       |
 3173|       |    /* nasty but well=formed */
 3174|  5.83k|    if (cur[0] == ':')
  ------------------
  |  Branch (3174:9): [True: 0, False: 5.83k]
  ------------------
 3175|      0|	return(xmlStrdup(name));
 3176|       |
 3177|  5.83k|    c = *cur++;
 3178|  34.1k|    while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */
  ------------------
  |  Branch (3178:12): [True: 28.5k, False: 5.60k]
  |  Branch (3178:24): [True: 28.2k, False: 234]
  |  Branch (3178:38): [True: 28.2k, False: 0]
  ------------------
 3179|  28.2k|	buf[len++] = c;
 3180|  28.2k|	c = *cur++;
 3181|  28.2k|    }
 3182|  5.83k|    if (len >= max) {
  ------------------
  |  Branch (3182:9): [True: 0, False: 5.83k]
  ------------------
 3183|       |	/*
 3184|       |	 * Okay someone managed to make a huge name, so he's ready to pay
 3185|       |	 * for the processing speed.
 3186|       |	 */
 3187|      0|	max = len * 2;
 3188|       |
 3189|      0|	buffer = (xmlChar *) xmlMallocAtomic(max);
 3190|      0|	if (buffer == NULL) {
  ------------------
  |  Branch (3190:6): [True: 0, False: 0]
  ------------------
 3191|      0|	    xmlErrMemory(ctxt, NULL);
 3192|      0|	    return(NULL);
 3193|      0|	}
 3194|      0|	memcpy(buffer, buf, len);
 3195|      0|	while ((c != 0) && (c != ':')) { /* tested bigname.xml */
  ------------------
  |  Branch (3195:9): [True: 0, False: 0]
  |  Branch (3195:21): [True: 0, False: 0]
  ------------------
 3196|      0|	    if (len + 10 > max) {
  ------------------
  |  Branch (3196:10): [True: 0, False: 0]
  ------------------
 3197|      0|	        xmlChar *tmp;
 3198|       |
 3199|      0|		max *= 2;
 3200|      0|		tmp = (xmlChar *) xmlRealloc(buffer, max);
 3201|      0|		if (tmp == NULL) {
  ------------------
  |  Branch (3201:7): [True: 0, False: 0]
  ------------------
 3202|      0|		    xmlFree(buffer);
 3203|      0|		    xmlErrMemory(ctxt, NULL);
 3204|      0|		    return(NULL);
 3205|      0|		}
 3206|      0|		buffer = tmp;
 3207|      0|	    }
 3208|      0|	    buffer[len++] = c;
 3209|      0|	    c = *cur++;
 3210|      0|	}
 3211|      0|	buffer[len] = 0;
 3212|      0|    }
 3213|       |
 3214|  5.83k|    if ((c == ':') && (*cur == 0)) {
  ------------------
  |  Branch (3214:9): [True: 234, False: 5.60k]
  |  Branch (3214:23): [True: 0, False: 234]
  ------------------
 3215|      0|        if (buffer != NULL)
  ------------------
  |  Branch (3215:13): [True: 0, False: 0]
  ------------------
 3216|      0|	    xmlFree(buffer);
 3217|      0|	*prefix = NULL;
 3218|      0|	return(xmlStrdup(name));
 3219|      0|    }
 3220|       |
 3221|  5.83k|    if (buffer == NULL)
  ------------------
  |  Branch (3221:9): [True: 5.83k, False: 0]
  ------------------
 3222|  5.83k|	ret = xmlStrndup(buf, len);
 3223|      0|    else {
 3224|      0|	ret = buffer;
 3225|      0|	buffer = NULL;
 3226|      0|	max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|      0|#define XML_MAX_NAMELEN 100
  ------------------
 3227|      0|    }
 3228|       |
 3229|       |
 3230|  5.83k|    if (c == ':') {
  ------------------
  |  Branch (3230:9): [True: 234, False: 5.60k]
  ------------------
 3231|    234|	c = *cur;
 3232|    234|        *prefix = ret;
 3233|    234|	if (c == 0) {
  ------------------
  |  Branch (3233:6): [True: 0, False: 234]
  ------------------
 3234|      0|	    return(xmlStrndup(BAD_CAST "", 0));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3235|      0|	}
 3236|    234|	len = 0;
 3237|       |
 3238|       |	/*
 3239|       |	 * Check that the first character is proper to start
 3240|       |	 * a new name
 3241|       |	 */
 3242|    234|	if (!(((c >= 0x61) && (c <= 0x7A)) ||
  ------------------
  |  Branch (3242:9): [True: 234, False: 0]
  |  Branch (3242:24): [True: 234, False: 0]
  ------------------
 3243|    234|	      ((c >= 0x41) && (c <= 0x5A)) ||
  ------------------
  |  Branch (3243:9): [True: 0, False: 0]
  |  Branch (3243:24): [True: 0, False: 0]
  ------------------
 3244|    234|	      (c == '_') || (c == ':'))) {
  ------------------
  |  Branch (3244:8): [True: 0, False: 0]
  |  Branch (3244:22): [True: 0, False: 0]
  ------------------
 3245|      0|	    int l;
 3246|      0|	    int first = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3247|       |
 3248|      0|	    if (!IS_LETTER(first) && (first != '_')) {
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3248:31): [True: 0, False: 0]
  ------------------
 3249|      0|		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3250|      0|			    "Name %s is not XML Namespace compliant\n",
 3251|      0|				  name);
 3252|      0|	    }
 3253|      0|	}
 3254|    234|	cur++;
 3255|       |
 3256|  1.13k|	while ((c != 0) && (len < max)) { /* tested bigname2.xml */
  ------------------
  |  Branch (3256:9): [True: 897, False: 234]
  |  Branch (3256:21): [True: 897, False: 0]
  ------------------
 3257|    897|	    buf[len++] = c;
 3258|    897|	    c = *cur++;
 3259|    897|	}
 3260|    234|	if (len >= max) {
  ------------------
  |  Branch (3260:6): [True: 0, False: 234]
  ------------------
 3261|       |	    /*
 3262|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3263|       |	     * for the processing speed.
 3264|       |	     */
 3265|      0|	    max = len * 2;
 3266|       |
 3267|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3268|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3268:10): [True: 0, False: 0]
  ------------------
 3269|      0|	        xmlErrMemory(ctxt, NULL);
 3270|      0|		return(NULL);
 3271|      0|	    }
 3272|      0|	    memcpy(buffer, buf, len);
 3273|      0|	    while (c != 0) { /* tested bigname2.xml */
  ------------------
  |  Branch (3273:13): [True: 0, False: 0]
  ------------------
 3274|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3274:7): [True: 0, False: 0]
  ------------------
 3275|      0|		    xmlChar *tmp;
 3276|       |
 3277|      0|		    max *= 2;
 3278|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3279|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3279:11): [True: 0, False: 0]
  ------------------
 3280|      0|			xmlErrMemory(ctxt, NULL);
 3281|      0|			xmlFree(buffer);
 3282|      0|			return(NULL);
 3283|      0|		    }
 3284|      0|		    buffer = tmp;
 3285|      0|		}
 3286|      0|		buffer[len++] = c;
 3287|      0|		c = *cur++;
 3288|      0|	    }
 3289|      0|	    buffer[len] = 0;
 3290|      0|	}
 3291|       |
 3292|    234|	if (buffer == NULL)
  ------------------
  |  Branch (3292:6): [True: 234, False: 0]
  ------------------
 3293|    234|	    ret = xmlStrndup(buf, len);
 3294|      0|	else {
 3295|      0|	    ret = buffer;
 3296|      0|	}
 3297|    234|    }
 3298|       |
 3299|  5.83k|    return(ret);
 3300|  5.83k|}
xmlParseName:
 3524|   137k|xmlParseName(xmlParserCtxtPtr ctxt) {
 3525|   137k|    const xmlChar *in;
 3526|   137k|    const xmlChar *ret;
 3527|   137k|    size_t count = 0;
 3528|   137k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3528:24): [True: 0, False: 137k]
  ------------------
 3529|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3530|   137k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   275k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3531|       |
 3532|   137k|    GROW;
  ------------------
  |  | 2270|   137k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   137k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 114k, False: 23.0k]
  |  |  ------------------
  |  | 2271|   137k|	xmlParserGrow(ctxt);
  ------------------
 3533|   137k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3533:9): [True: 0, False: 137k]
  ------------------
 3534|      0|        return(NULL);
 3535|       |
 3536|       |    /*
 3537|       |     * Accelerator for simple ASCII names
 3538|       |     */
 3539|   137k|    in = ctxt->input->cur;
 3540|   137k|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3540:10): [True: 134k, False: 2.99k]
  |  Branch (3540:27): [True: 134k, False: 9]
  ------------------
 3541|   137k|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3541:3): [True: 3.00k, False: 6]
  |  Branch (3541:20): [True: 2.99k, False: 9]
  ------------------
 3542|   137k|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (3542:2): [True: 0, False: 15]
  |  Branch (3542:18): [True: 0, False: 15]
  ------------------
 3543|   137k|	in++;
 3544|   587k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3544:10): [True: 226k, False: 361k]
  |  Branch (3544:27): [True: 224k, False: 1.98k]
  ------------------
 3545|   587k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3545:10): [True: 94.6k, False: 269k]
  |  Branch (3545:27): [True: 1.70k, False: 92.9k]
  ------------------
 3546|   587k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3546:10): [True: 342k, False: 19.7k]
  |  Branch (3546:27): [True: 129k, False: 212k]
  ------------------
 3547|   587k|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3547:9): [True: 90.9k, False: 141k]
  |  Branch (3547:25): [True: 990, False: 140k]
  ------------------
 3548|   587k|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (3548:9): [True: 479, False: 140k]
  |  Branch (3548:25): [True: 2.35k, False: 137k]
  ------------------
 3549|   450k|	    in++;
 3550|   137k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3550:6): [True: 137k, False: 52]
  |  Branch (3550:19): [True: 137k, False: 102]
  ------------------
 3551|   137k|	    count = in - ctxt->input->cur;
 3552|   137k|            if (count > maxLength) {
  ------------------
  |  Branch (3552:17): [True: 0, False: 137k]
  ------------------
 3553|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3554|      0|                return(NULL);
 3555|      0|            }
 3556|   137k|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 3557|   137k|	    ctxt->input->cur = in;
 3558|   137k|	    ctxt->input->col += count;
 3559|   137k|	    if (ret == NULL)
  ------------------
  |  Branch (3559:10): [True: 0, False: 137k]
  ------------------
 3560|      0|	        xmlErrMemory(ctxt, NULL);
 3561|   137k|	    return(ret);
 3562|   137k|	}
 3563|   137k|    }
 3564|       |    /* accelerator for special cases */
 3565|    169|    return(xmlParseNameComplex(ctxt));
 3566|   137k|}
xmlParseNmtoken:
 3816|  2.07k|xmlParseNmtoken(xmlParserCtxtPtr ctxt) {
 3817|  2.07k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3818|  2.07k|    int len = 0, l;
 3819|  2.07k|    int c;
 3820|  2.07k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3820:21): [True: 0, False: 2.07k]
  ------------------
 3821|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3822|  2.07k|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  2.07k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3823|       |
 3824|  2.07k|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  2.07k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3825|       |
 3826|  8.56k|    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3826:12): [True: 6.48k, False: 2.07k]
  ------------------
 3827|  6.48k|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  6.48k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 6.48k, False: 0]
  |  |  ------------------
  |  | 2296|  6.48k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3828|  6.48k|	NEXTL(l);
  ------------------
  |  | 2284|  6.48k|#define NEXTL(l) do {							\
  |  | 2285|  6.48k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 6.48k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  6.48k|    } else ctxt->input->col++;						\
  |  | 2288|  6.48k|    ctxt->input->cur += l;				\
  |  | 2289|  6.48k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3829|  6.48k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  6.48k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3830|  6.48k|	if (len >= XML_MAX_NAMELEN) {
  ------------------
  |  |   89|  6.48k|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (3830:6): [True: 0, False: 6.48k]
  ------------------
 3831|       |	    /*
 3832|       |	     * Okay someone managed to make a huge token, so he's ready to pay
 3833|       |	     * for the processing speed.
 3834|       |	     */
 3835|      0|	    xmlChar *buffer;
 3836|      0|	    int max = len * 2;
 3837|       |
 3838|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3839|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3839:10): [True: 0, False: 0]
  ------------------
 3840|      0|	        xmlErrMemory(ctxt, NULL);
 3841|      0|		return(NULL);
 3842|      0|	    }
 3843|      0|	    memcpy(buffer, buf, len);
 3844|      0|	    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3844:13): [True: 0, False: 0]
  ------------------
 3845|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3845:7): [True: 0, False: 0]
  ------------------
 3846|      0|		    xmlChar *tmp;
 3847|       |
 3848|      0|		    max *= 2;
 3849|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3850|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3850:11): [True: 0, False: 0]
  ------------------
 3851|      0|			xmlErrMemory(ctxt, NULL);
 3852|      0|			xmlFree(buffer);
 3853|      0|			return(NULL);
 3854|      0|		    }
 3855|      0|		    buffer = tmp;
 3856|      0|		}
 3857|      0|		COPY_BUF(buffer, len, c);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3858|      0|                if (len > maxLength) {
  ------------------
  |  Branch (3858:21): [True: 0, False: 0]
  ------------------
 3859|      0|                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3860|      0|                    xmlFree(buffer);
 3861|      0|                    return(NULL);
 3862|      0|                }
 3863|      0|		NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3864|      0|		c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3865|      0|	    }
 3866|      0|	    buffer[len] = 0;
 3867|      0|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (3867:17): [True: 0, False: 0]
  ------------------
 3868|      0|                xmlFree(buffer);
 3869|      0|                return(NULL);
 3870|      0|            }
 3871|      0|	    return(buffer);
 3872|      0|	}
 3873|  6.48k|    }
 3874|  2.07k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3874:9): [True: 0, False: 2.07k]
  ------------------
 3875|      0|        return(NULL);
 3876|  2.07k|    if (len == 0)
  ------------------
  |  Branch (3876:9): [True: 6, False: 2.06k]
  ------------------
 3877|      6|        return(NULL);
 3878|  2.06k|    if (len > maxLength) {
  ------------------
  |  Branch (3878:9): [True: 0, False: 2.06k]
  ------------------
 3879|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NmToken");
 3880|      0|        return(NULL);
 3881|      0|    }
 3882|  2.06k|    return(xmlStrndup(buf, len));
 3883|  2.06k|}
xmlParseEntityValue:
 3901|  1.69k|xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {
 3902|  1.69k|    xmlChar *buf = NULL;
 3903|  1.69k|    int len = 0;
 3904|  1.69k|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|  1.69k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 3905|  1.69k|    int c, l;
 3906|  1.69k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3906:21): [True: 0, False: 1.69k]
  ------------------
 3907|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 3908|  1.69k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  1.69k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3909|  1.69k|    xmlChar stop;
 3910|  1.69k|    xmlChar *ret = NULL;
 3911|  1.69k|    const xmlChar *cur = NULL;
 3912|  1.69k|    xmlParserInputPtr input;
 3913|       |
 3914|  1.69k|    if (RAW == '"') stop = '"';
  ------------------
  |  | 2221|  1.69k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3914:9): [True: 1.48k, False: 216]
  ------------------
 3915|    216|    else if (RAW == '\'') stop = '\'';
  ------------------
  |  | 2221|    216|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3915:14): [True: 216, False: 0]
  ------------------
 3916|      0|    else {
 3917|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);
 3918|      0|	return(NULL);
 3919|      0|    }
 3920|  1.69k|    buf = (xmlChar *) xmlMallocAtomic(size);
 3921|  1.69k|    if (buf == NULL) {
  ------------------
  |  Branch (3921:9): [True: 0, False: 1.69k]
  ------------------
 3922|      0|	xmlErrMemory(ctxt, NULL);
 3923|      0|	return(NULL);
 3924|      0|    }
 3925|       |
 3926|       |    /*
 3927|       |     * The content of the entity definition is copied in a buffer.
 3928|       |     */
 3929|       |
 3930|  1.69k|    ctxt->instate = XML_PARSER_ENTITY_VALUE;
 3931|  1.69k|    input = ctxt->input;
 3932|  1.69k|    GROW;
  ------------------
  |  | 2270|  1.69k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.69k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 313, False: 1.38k]
  |  |  ------------------
  |  | 2271|  1.69k|	xmlParserGrow(ctxt);
  ------------------
 3933|  1.69k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3933:9): [True: 0, False: 1.69k]
  ------------------
 3934|      0|        goto error;
 3935|  1.69k|    NEXT;
  ------------------
  |  | 2275|  1.69k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3936|  1.69k|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  1.69k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3937|       |    /*
 3938|       |     * NOTE: 4.4.5 Included in Literal
 3939|       |     * When a parameter entity reference appears in a literal entity
 3940|       |     * value, ... a single or double quote character in the replacement
 3941|       |     * text is always treated as a normal data character and will not
 3942|       |     * terminate the literal.
 3943|       |     * In practice it means we stop the loop only when back at parsing
 3944|       |     * the initial entity and the quote is found
 3945|       |     */
 3946|   331k|    while (((IS_CHAR(c)) && ((c != stop) || /* checked */
  ------------------
  |  |  125|   331k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|   331k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 331k, False: 9]
  |  |  |  |  ------------------
  |  |  |  |  119|   331k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|   331k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 331k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 750, False: 330k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|   331k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 330k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|   331k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 330k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|   331k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 9, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 9, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      9|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      9|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3946:13): [True: 331k, False: 0]
  |  Branch (3946:30): [True: 329k, False: 1.69k]
  ------------------
 3947|   331k|	    (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (3947:6): [True: 0, False: 1.69k]
  |  Branch (3947:34): [True: 329k, False: 0]
  ------------------
 3948|   329k|	if (len + 5 >= size) {
  ------------------
  |  Branch (3948:6): [True: 381, False: 329k]
  ------------------
 3949|    381|	    xmlChar *tmp;
 3950|       |
 3951|    381|	    size *= 2;
 3952|    381|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 3953|    381|	    if (tmp == NULL) {
  ------------------
  |  Branch (3953:10): [True: 0, False: 381]
  ------------------
 3954|      0|		xmlErrMemory(ctxt, NULL);
 3955|      0|                goto error;
 3956|      0|	    }
 3957|    381|	    buf = tmp;
 3958|    381|	}
 3959|   329k|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|   329k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 329k, False: 18]
  |  |  ------------------
  |  | 2296|   329k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3960|   329k|	NEXTL(l);
  ------------------
  |  | 2284|   329k|#define NEXTL(l) do {							\
  |  | 2285|   329k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 336, False: 329k]
  |  |  ------------------
  |  | 2286|    336|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|   329k|    } else ctxt->input->col++;						\
  |  | 2288|   329k|    ctxt->input->cur += l;				\
  |  | 2289|   329k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3961|       |
 3962|   329k|	GROW;
  ------------------
  |  | 2270|   329k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   329k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 8.40k, False: 321k]
  |  |  ------------------
  |  | 2271|   329k|	xmlParserGrow(ctxt);
  ------------------
 3963|   329k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|   329k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3964|   329k|	if (c == 0) {
  ------------------
  |  Branch (3964:6): [True: 0, False: 329k]
  ------------------
 3965|      0|	    GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 3966|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3967|      0|	}
 3968|       |
 3969|   329k|        if (len > maxLength) {
  ------------------
  |  Branch (3969:13): [True: 0, False: 329k]
  ------------------
 3970|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 3971|      0|                           "entity value too long\n");
 3972|      0|            goto error;
 3973|      0|        }
 3974|   329k|    }
 3975|  1.69k|    buf[len] = 0;
 3976|  1.69k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3976:9): [True: 0, False: 1.69k]
  ------------------
 3977|      0|        goto error;
 3978|  1.69k|    if (c != stop) {
  ------------------
  |  Branch (3978:9): [True: 0, False: 1.69k]
  ------------------
 3979|      0|        xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_FINISHED, NULL);
 3980|      0|        goto error;
 3981|      0|    }
 3982|  1.69k|    NEXT;
  ------------------
  |  | 2275|  1.69k|#define NEXT xmlNextChar(ctxt)
  ------------------
 3983|       |
 3984|       |    /*
 3985|       |     * Raise problem w.r.t. '&' and '%' being used in non-entities
 3986|       |     * reference constructs. Note Charref will be handled in
 3987|       |     * xmlStringDecodeEntities()
 3988|       |     */
 3989|  1.69k|    cur = buf;
 3990|   157k|    while (*cur != 0) { /* non input consuming */
  ------------------
  |  Branch (3990:12): [True: 156k, False: 1.69k]
  ------------------
 3991|   156k|	if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {
  ------------------
  |  Branch (3991:6): [True: 966, False: 155k]
  |  Branch (3991:24): [True: 2.62k, False: 152k]
  |  Branch (3991:41): [True: 1.85k, False: 768]
  ------------------
 3992|  2.82k|	    xmlChar *name;
 3993|  2.82k|	    xmlChar tmp = *cur;
 3994|  2.82k|            int nameOk = 0;
 3995|       |
 3996|  2.82k|	    cur++;
 3997|  2.82k|	    name = xmlParseStringName(ctxt, &cur);
 3998|  2.82k|            if (name != NULL) {
  ------------------
  |  Branch (3998:17): [True: 2.82k, False: 0]
  ------------------
 3999|  2.82k|                nameOk = 1;
 4000|  2.82k|                xmlFree(name);
 4001|  2.82k|            }
 4002|  2.82k|            if ((nameOk == 0) || (*cur != ';')) {
  ------------------
  |  Branch (4002:17): [True: 0, False: 2.82k]
  |  Branch (4002:34): [True: 0, False: 2.82k]
  ------------------
 4003|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,
 4004|      0|	    "EntityValue: '%c' forbidden except for entities references\n",
 4005|      0|	                          tmp);
 4006|      0|                goto error;
 4007|      0|	    }
 4008|  2.82k|	    if ((tmp == '%') && (ctxt->inSubset == 1) &&
  ------------------
  |  Branch (4008:10): [True: 966, False: 1.85k]
  |  Branch (4008:26): [True: 3, False: 963]
  ------------------
 4009|  2.82k|		(ctxt->inputNr == 1)) {
  ------------------
  |  Branch (4009:3): [True: 0, False: 3]
  ------------------
 4010|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);
 4011|      0|                goto error;
 4012|      0|	    }
 4013|  2.82k|	    if (*cur == 0)
  ------------------
  |  Branch (4013:10): [True: 0, False: 2.82k]
  ------------------
 4014|      0|	        break;
 4015|  2.82k|	}
 4016|   156k|	cur++;
 4017|   156k|    }
 4018|       |
 4019|       |    /*
 4020|       |     * Then PEReference entities are substituted.
 4021|       |     *
 4022|       |     * NOTE: 4.4.7 Bypassed
 4023|       |     * When a general entity reference appears in the EntityValue in
 4024|       |     * an entity declaration, it is bypassed and left as is.
 4025|       |     * so XML_SUBSTITUTE_REF is not set here.
 4026|       |     */
 4027|  1.69k|    ++ctxt->depth;
 4028|  1.69k|    ret = xmlStringDecodeEntitiesInt(ctxt, buf, len, XML_SUBSTITUTE_PEREF,
  ------------------
  |  |  527|  1.69k|#define XML_SUBSTITUTE_PEREF	2
  ------------------
 4029|  1.69k|                                     0, 0, 0, /* check */ 1);
 4030|  1.69k|    --ctxt->depth;
 4031|       |
 4032|  1.69k|    if (orig != NULL) {
  ------------------
  |  Branch (4032:9): [True: 1.69k, False: 0]
  ------------------
 4033|  1.69k|        *orig = buf;
 4034|  1.69k|        buf = NULL;
 4035|  1.69k|    }
 4036|       |
 4037|  1.69k|error:
 4038|  1.69k|    if (buf != NULL)
  ------------------
  |  Branch (4038:9): [True: 0, False: 1.69k]
  ------------------
 4039|      0|        xmlFree(buf);
 4040|  1.69k|    return(ret);
 4041|  1.69k|}
xmlParseAttValue:
 4337|  1.23k|xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 4338|  1.23k|    if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
  ------------------
  |  Branch (4338:9): [True: 0, False: 1.23k]
  |  Branch (4338:27): [True: 0, False: 1.23k]
  ------------------
 4339|  1.23k|    return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
 4340|  1.23k|}
xmlParseSystemLiteral:
 4356|    264|xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
 4357|    264|    xmlChar *buf = NULL;
 4358|    264|    int len = 0;
 4359|    264|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    264|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4360|    264|    int cur, l;
 4361|    264|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4361:21): [True: 0, False: 264]
  ------------------
 4362|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4363|    264|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    264|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 4364|    264|    xmlChar stop;
 4365|    264|    int state = ctxt->instate;
 4366|       |
 4367|    264|    if (RAW == '"') {
  ------------------
  |  | 2221|    264|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4367:9): [True: 255, False: 9]
  ------------------
 4368|    255|        NEXT;
  ------------------
  |  | 2275|    255|#define NEXT xmlNextChar(ctxt)
  ------------------
 4369|    255|	stop = '"';
 4370|    255|    } else if (RAW == '\'') {
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4370:16): [True: 9, False: 0]
  ------------------
 4371|      9|        NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
 4372|      9|	stop = '\'';
 4373|      9|    } else {
 4374|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4375|      0|	return(NULL);
 4376|      0|    }
 4377|       |
 4378|    264|    buf = (xmlChar *) xmlMallocAtomic(size);
 4379|    264|    if (buf == NULL) {
  ------------------
  |  Branch (4379:9): [True: 0, False: 264]
  ------------------
 4380|      0|        xmlErrMemory(ctxt, NULL);
 4381|      0|	return(NULL);
 4382|      0|    }
 4383|    264|    ctxt->instate = XML_PARSER_SYSTEM_LITERAL;
 4384|    264|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    264|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4385|  7.56k|    while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */
  ------------------
  |  |  125|  7.56k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  7.56k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 7.56k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  7.56k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  7.56k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 7.56k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 7.56k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  7.56k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 7.56k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  7.56k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 7.56k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  7.56k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4385:12): [True: 7.56k, False: 0]
  |  Branch (4385:30): [True: 7.29k, False: 264]
  ------------------
 4386|  7.29k|	if (len + 5 >= size) {
  ------------------
  |  Branch (4386:6): [True: 0, False: 7.29k]
  ------------------
 4387|      0|	    xmlChar *tmp;
 4388|       |
 4389|      0|	    size *= 2;
 4390|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 4391|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (4391:10): [True: 0, False: 0]
  ------------------
 4392|      0|	        xmlFree(buf);
 4393|      0|		xmlErrMemory(ctxt, NULL);
 4394|      0|		ctxt->instate = (xmlParserInputState) state;
 4395|      0|		return(NULL);
 4396|      0|	    }
 4397|      0|	    buf = tmp;
 4398|      0|	}
 4399|  7.29k|	COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|  7.29k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 7.29k, False: 0]
  |  |  ------------------
  |  | 2296|  7.29k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4400|  7.29k|        if (len > maxLength) {
  ------------------
  |  Branch (4400:13): [True: 0, False: 7.29k]
  ------------------
 4401|      0|            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "SystemLiteral");
 4402|      0|            xmlFree(buf);
 4403|      0|            ctxt->instate = (xmlParserInputState) state;
 4404|      0|            return(NULL);
 4405|      0|        }
 4406|  7.29k|	NEXTL(l);
  ------------------
  |  | 2284|  7.29k|#define NEXTL(l) do {							\
  |  | 2285|  7.29k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 7.29k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  7.29k|    } else ctxt->input->col++;						\
  |  | 2288|  7.29k|    ctxt->input->cur += l;				\
  |  | 2289|  7.29k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4407|  7.29k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  7.29k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4408|  7.29k|    }
 4409|    264|    buf[len] = 0;
 4410|    264|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4410:9): [True: 0, False: 264]
  ------------------
 4411|      0|        xmlFree(buf);
 4412|      0|        return(NULL);
 4413|      0|    }
 4414|    264|    ctxt->instate = (xmlParserInputState) state;
 4415|    264|    if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|    264|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    264|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 264, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    264|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    264|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 264, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 264]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    264|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 264]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    264|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 264, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    264|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4415:9): [True: 0, False: 264]
  ------------------
 4416|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4417|    264|    } else {
 4418|    264|	NEXT;
  ------------------
  |  | 2275|    264|#define NEXT xmlNextChar(ctxt)
  ------------------
 4419|    264|    }
 4420|    264|    return(buf);
 4421|    264|}
xmlParsePubidLiteral:
 4437|    126|xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
 4438|    126|    xmlChar *buf = NULL;
 4439|    126|    int len = 0;
 4440|    126|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    126|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4441|    126|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4441:21): [True: 0, False: 126]
  ------------------
 4442|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4443|    126|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    126|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 4444|    126|    xmlChar cur;
 4445|    126|    xmlChar stop;
 4446|    126|    xmlParserInputState oldstate = ctxt->instate;
 4447|       |
 4448|    126|    if (RAW == '"') {
  ------------------
  |  | 2221|    126|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4448:9): [True: 126, False: 0]
  ------------------
 4449|    126|        NEXT;
  ------------------
  |  | 2275|    126|#define NEXT xmlNextChar(ctxt)
  ------------------
 4450|    126|	stop = '"';
 4451|    126|    } else if (RAW == '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4451:16): [True: 0, False: 0]
  ------------------
 4452|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4453|      0|	stop = '\'';
 4454|      0|    } else {
 4455|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 4456|      0|	return(NULL);
 4457|      0|    }
 4458|    126|    buf = (xmlChar *) xmlMallocAtomic(size);
 4459|    126|    if (buf == NULL) {
  ------------------
  |  Branch (4459:9): [True: 0, False: 126]
  ------------------
 4460|      0|	xmlErrMemory(ctxt, NULL);
 4461|      0|	return(NULL);
 4462|      0|    }
 4463|    126|    ctxt->instate = XML_PARSER_PUBLIC_LITERAL;
 4464|    126|    cur = CUR;
  ------------------
  |  | 2222|    126|#define CUR (*ctxt->input->cur)
  ------------------
 4465|  3.74k|    while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */
  ------------------
  |  |  287|  3.74k|#define IS_PUBIDCHAR_CH(c) xmlIsPubidChar_ch(c)
  |  |  ------------------
  |  |  |  |  199|  3.74k|#define xmlIsPubidChar_ch(c)	(xmlIsPubidChar_tab[(c)])
  |  |  ------------------
  ------------------
  |  Branch (4465:12): [True: 3.62k, False: 126]
  |  Branch (4465:38): [True: 3.62k, False: 0]
  ------------------
 4466|  3.62k|	if (len + 1 >= size) {
  ------------------
  |  Branch (4466:6): [True: 0, False: 3.62k]
  ------------------
 4467|      0|	    xmlChar *tmp;
 4468|       |
 4469|      0|	    size *= 2;
 4470|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
 4471|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (4471:10): [True: 0, False: 0]
  ------------------
 4472|      0|		xmlErrMemory(ctxt, NULL);
 4473|      0|		xmlFree(buf);
 4474|      0|		return(NULL);
 4475|      0|	    }
 4476|      0|	    buf = tmp;
 4477|      0|	}
 4478|  3.62k|	buf[len++] = cur;
 4479|  3.62k|        if (len > maxLength) {
  ------------------
  |  Branch (4479:13): [True: 0, False: 3.62k]
  ------------------
 4480|      0|            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Public ID");
 4481|      0|            xmlFree(buf);
 4482|      0|            return(NULL);
 4483|      0|        }
 4484|  3.62k|	NEXT;
  ------------------
  |  | 2275|  3.62k|#define NEXT xmlNextChar(ctxt)
  ------------------
 4485|  3.62k|	cur = CUR;
  ------------------
  |  | 2222|  3.62k|#define CUR (*ctxt->input->cur)
  ------------------
 4486|  3.62k|    }
 4487|    126|    buf[len] = 0;
 4488|    126|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4488:9): [True: 0, False: 126]
  ------------------
 4489|      0|        xmlFree(buf);
 4490|      0|        return(NULL);
 4491|      0|    }
 4492|    126|    if (cur != stop) {
  ------------------
  |  Branch (4492:9): [True: 0, False: 126]
  ------------------
 4493|      0|	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
 4494|    126|    } else {
 4495|    126|	NEXTL(1);
  ------------------
  |  | 2284|    126|#define NEXTL(l) do {							\
  |  | 2285|    126|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 126]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    126|    } else ctxt->input->col++;						\
  |  | 2288|    126|    ctxt->input->cur += l;				\
  |  | 2289|    126|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4496|    126|    }
 4497|    126|    ctxt->instate = oldstate;
 4498|    126|    return(buf);
 4499|    126|}
xmlParseExternalID:
 4835|    636|xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4836|    636|    xmlChar *URI = NULL;
 4837|       |
 4838|    636|    *publicID = NULL;
 4839|    636|    if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {
  ------------------
  |  | 2233|    636|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  1.27k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  1.27k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 138, False: 498]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 138, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|    636|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 138, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 138, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 138, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 138, False: 0]
  |  |  ------------------
  ------------------
 4840|    138|        SKIP(6);
  ------------------
  |  | 2245|    138|#define SKIP(val) do {							\
  |  | 2246|    138|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    138|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 138]
  |  |  ------------------
  |  | 2248|    138|        xmlParserGrow(ctxt);						\
  |  | 2249|    138|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4841|    138|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    138|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4841:6): [True: 0, False: 138]
  ------------------
 4842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4843|      0|	                   "Space required after 'SYSTEM'\n");
 4844|      0|	}
 4845|    138|	URI = xmlParseSystemLiteral(ctxt);
 4846|    138|	if (URI == NULL) {
  ------------------
  |  Branch (4846:6): [True: 0, False: 138]
  ------------------
 4847|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4848|      0|        }
 4849|    498|    } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {
  ------------------
  |  | 2233|    498|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|    996|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|    996|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 126, False: 372]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 126, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|    498|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 126, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 126, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 126, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 126, False: 0]
  |  |  ------------------
  ------------------
 4850|    126|        SKIP(6);
  ------------------
  |  | 2245|    126|#define SKIP(val) do {							\
  |  | 2246|    126|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    126|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 126]
  |  |  ------------------
  |  | 2248|    126|        xmlParserGrow(ctxt);						\
  |  | 2249|    126|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4851|    126|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    126|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4851:6): [True: 0, False: 126]
  ------------------
 4852|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4853|      0|		    "Space required after 'PUBLIC'\n");
 4854|      0|	}
 4855|    126|	*publicID = xmlParsePubidLiteral(ctxt);
 4856|    126|	if (*publicID == NULL) {
  ------------------
  |  Branch (4856:6): [True: 0, False: 126]
  ------------------
 4857|      0|	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4858|      0|	}
 4859|    126|	if (strict) {
  ------------------
  |  Branch (4859:6): [True: 126, False: 0]
  ------------------
 4860|       |	    /*
 4861|       |	     * We don't handle [83] so "S SystemLiteral" is required.
 4862|       |	     */
 4863|    126|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    126|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4863:10): [True: 0, False: 126]
  ------------------
 4864|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4865|      0|			"Space required after the Public Identifier\n");
 4866|      0|	    }
 4867|    126|	} else {
 4868|       |	    /*
 4869|       |	     * We handle [83] so we return immediately, if
 4870|       |	     * "S SystemLiteral" is not detected. We skip blanks if no
 4871|       |             * system literal was found, but this is harmless since we must
 4872|       |             * be at the end of a NotationDecl.
 4873|       |	     */
 4874|      0|	    if (SKIP_BLANKS == 0) return(NULL);
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4874:10): [True: 0, False: 0]
  ------------------
 4875|      0|	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4875:10): [True: 0, False: 0]
  |  Branch (4875:27): [True: 0, False: 0]
  ------------------
 4876|      0|	}
 4877|    126|	URI = xmlParseSystemLiteral(ctxt);
 4878|    126|	if (URI == NULL) {
  ------------------
  |  Branch (4878:6): [True: 0, False: 126]
  ------------------
 4879|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4880|      0|        }
 4881|    126|    }
 4882|    636|    return(URI);
 4883|    636|}
xmlParseComment:
 5029|   482k|xmlParseComment(xmlParserCtxtPtr ctxt) {
 5030|   482k|    xmlChar *buf = NULL;
 5031|   482k|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|   482k|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5032|   482k|    size_t len = 0;
 5033|   482k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5033:24): [True: 0, False: 482k]
  ------------------
 5034|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5035|   482k|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|   965k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5036|   482k|    xmlParserInputState state;
 5037|   482k|    const xmlChar *in;
 5038|   482k|    size_t nbchar = 0;
 5039|   482k|    int ccol;
 5040|   482k|    int inputid;
 5041|       |
 5042|       |    /*
 5043|       |     * Check that there is a comment right here.
 5044|       |     */
 5045|   482k|    if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2221|   482k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|   482k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5045:9): [True: 0, False: 482k]
  |  Branch (5045:25): [True: 0, False: 482k]
  ------------------
 5046|      0|        return;
 5047|   482k|    SKIP(2);
  ------------------
  |  | 2245|   482k|#define SKIP(val) do {							\
  |  | 2246|   482k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   482k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 482k]
  |  |  ------------------
  |  | 2248|   482k|        xmlParserGrow(ctxt);						\
  |  | 2249|   482k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5048|   482k|    if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2221|   482k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2223|   482k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5048:9): [True: 0, False: 482k]
  |  Branch (5048:25): [True: 0, False: 482k]
  ------------------
 5049|      0|        return;
 5050|   482k|    state = ctxt->instate;
 5051|   482k|    ctxt->instate = XML_PARSER_COMMENT;
 5052|   482k|    inputid = ctxt->input->id;
 5053|   482k|    SKIP(2);
  ------------------
  |  | 2245|   482k|#define SKIP(val) do {							\
  |  | 2246|   482k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   482k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 482k]
  |  |  ------------------
  |  | 2248|   482k|        xmlParserGrow(ctxt);						\
  |  | 2249|   482k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5054|   482k|    GROW;
  ------------------
  |  | 2270|   482k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   482k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 431k, False: 50.6k]
  |  |  ------------------
  |  | 2271|   482k|	xmlParserGrow(ctxt);
  ------------------
 5055|       |
 5056|       |    /*
 5057|       |     * Accelerated common case where input don't need to be
 5058|       |     * modified before passing it to the handler.
 5059|       |     */
 5060|   482k|    in = ctxt->input->cur;
 5061|   482k|    do {
 5062|   482k|	if (*in == 0xA) {
  ------------------
  |  Branch (5062:6): [True: 222, False: 482k]
  ------------------
 5063|    225|	    do {
 5064|    225|		ctxt->input->line++; ctxt->input->col = 1;
 5065|    225|		in++;
 5066|    225|	    } while (*in == 0xA);
  ------------------
  |  Branch (5066:15): [True: 3, False: 222]
  ------------------
 5067|    222|	}
 5068|   491k|get_more:
 5069|   491k|        ccol = ctxt->input->col;
 5070|   929k|	while (((*in > '-') && (*in <= 0x7F)) ||
  ------------------
  |  Branch (5070:10): [True: 372k, False: 557k]
  |  Branch (5070:25): [True: 372k, False: 15]
  ------------------
 5071|   929k|	       ((*in >= 0x20) && (*in < '-')) ||
  ------------------
  |  Branch (5071:10): [True: 549k, False: 7.97k]
  |  Branch (5071:27): [True: 64.9k, False: 484k]
  ------------------
 5072|   929k|	       (*in == 0x09)) {
  ------------------
  |  Branch (5072:9): [True: 876, False: 491k]
  ------------------
 5073|   437k|		    in++;
 5074|   437k|		    ccol++;
 5075|   437k|	}
 5076|   491k|	ctxt->input->col = ccol;
 5077|   491k|	if (*in == 0xA) {
  ------------------
  |  Branch (5077:6): [True: 3.22k, False: 488k]
  ------------------
 5078|  3.31k|	    do {
 5079|  3.31k|		ctxt->input->line++; ctxt->input->col = 1;
 5080|  3.31k|		in++;
 5081|  3.31k|	    } while (*in == 0xA);
  ------------------
  |  Branch (5081:15): [True: 87, False: 3.22k]
  ------------------
 5082|  3.22k|	    goto get_more;
 5083|  3.22k|	}
 5084|   488k|	nbchar = in - ctxt->input->cur;
 5085|       |	/*
 5086|       |	 * save current set of data
 5087|       |	 */
 5088|   488k|	if (nbchar > 0) {
  ------------------
  |  Branch (5088:6): [True: 8.48k, False: 480k]
  ------------------
 5089|  8.48k|            if (buf == NULL) {
  ------------------
  |  Branch (5089:17): [True: 2.31k, False: 6.17k]
  ------------------
 5090|  2.31k|                if ((*in == '-') && (in[1] == '-'))
  ------------------
  |  Branch (5090:21): [True: 1.85k, False: 463]
  |  Branch (5090:37): [True: 1.39k, False: 456]
  ------------------
 5091|  1.39k|                    size = nbchar + 1;
 5092|    919|                else
 5093|    919|                    size = XML_PARSER_BUFFER_SIZE + nbchar;
  ------------------
  |  |  167|    919|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5094|  2.31k|                buf = (xmlChar *) xmlMallocAtomic(size);
 5095|  2.31k|                if (buf == NULL) {
  ------------------
  |  Branch (5095:21): [True: 0, False: 2.31k]
  ------------------
 5096|      0|                    xmlErrMemory(ctxt, NULL);
 5097|      0|                    ctxt->instate = state;
 5098|      0|                    return;
 5099|      0|                }
 5100|  2.31k|                len = 0;
 5101|  6.17k|            } else if (len + nbchar + 1 >= size) {
  ------------------
  |  Branch (5101:24): [True: 925, False: 5.24k]
  ------------------
 5102|    925|                xmlChar *new_buf;
 5103|    925|                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    925|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5104|    925|                new_buf = (xmlChar *) xmlRealloc(buf, size);
 5105|    925|                if (new_buf == NULL) {
  ------------------
  |  Branch (5105:21): [True: 0, False: 925]
  ------------------
 5106|      0|                    xmlFree (buf);
 5107|      0|                    xmlErrMemory(ctxt, NULL);
 5108|      0|                    ctxt->instate = state;
 5109|      0|                    return;
 5110|      0|                }
 5111|    925|                buf = new_buf;
 5112|    925|            }
 5113|  8.48k|            memcpy(&buf[len], ctxt->input->cur, nbchar);
 5114|  8.48k|            len += nbchar;
 5115|  8.48k|            buf[len] = 0;
 5116|  8.48k|	}
 5117|   488k|        if (len > maxLength) {
  ------------------
  |  Branch (5117:13): [True: 0, False: 488k]
  ------------------
 5118|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5119|      0|                         "Comment too big found", NULL);
 5120|      0|            xmlFree (buf);
 5121|      0|            return;
 5122|      0|        }
 5123|   488k|	ctxt->input->cur = in;
 5124|   488k|	if (*in == 0xA) {
  ------------------
  |  Branch (5124:6): [True: 0, False: 488k]
  ------------------
 5125|      0|	    in++;
 5126|      0|	    ctxt->input->line++; ctxt->input->col = 1;
 5127|      0|	}
 5128|   488k|	if (*in == 0xD) {
  ------------------
  |  Branch (5128:6): [True: 3.83k, False: 484k]
  ------------------
 5129|  3.83k|	    in++;
 5130|  3.83k|	    if (*in == 0xA) {
  ------------------
  |  Branch (5130:10): [True: 3.83k, False: 0]
  ------------------
 5131|  3.83k|		ctxt->input->cur = in;
 5132|  3.83k|		in++;
 5133|  3.83k|		ctxt->input->line++; ctxt->input->col = 1;
 5134|  3.83k|		goto get_more;
 5135|  3.83k|	    }
 5136|      0|	    in--;
 5137|      0|	}
 5138|   484k|	SHRINK;
  ------------------
  |  | 2265|   484k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 163k, False: 321k]
  |  |  |  Branch (2265:38): [True: 320k, False: 1.06k]
  |  |  ------------------
  |  | 2266|   484k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|   483k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 3.08k, False: 480k]
  |  |  ------------------
  |  | 2267|   484k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  3.08k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 111, False: 2.97k]
  |  |  ------------------
  |  | 2268|   484k|	xmlParserShrink(ctxt);
  ------------------
 5139|   484k|	GROW;
  ------------------
  |  | 2270|   484k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   484k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 432k, False: 52.7k]
  |  |  ------------------
  |  | 2271|   484k|	xmlParserGrow(ctxt);
  ------------------
 5140|   484k|        if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5140:13): [True: 0, False: 484k]
  ------------------
 5141|      0|            xmlFree(buf);
 5142|      0|            return;
 5143|      0|        }
 5144|   484k|	in = ctxt->input->cur;
 5145|   484k|	if (*in == '-') {
  ------------------
  |  Branch (5145:6): [True: 484k, False: 47]
  ------------------
 5146|   484k|	    if (in[1] == '-') {
  ------------------
  |  Branch (5146:10): [True: 482k, False: 2.34k]
  ------------------
 5147|   482k|	        if (in[2] == '>') {
  ------------------
  |  Branch (5147:14): [True: 482k, False: 0]
  ------------------
 5148|   482k|		    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (5148:11): [True: 0, False: 482k]
  ------------------
 5149|      0|			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5150|      0|			               "comment doesn't start and stop in the"
 5151|      0|                                       " same entity\n");
 5152|      0|		    }
 5153|   482k|		    SKIP(3);
  ------------------
  |  | 2245|   482k|#define SKIP(val) do {							\
  |  | 2246|   482k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|   482k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 45.4k, False: 437k]
  |  |  ------------------
  |  | 2248|   482k|        xmlParserGrow(ctxt);						\
  |  | 2249|   482k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5154|   482k|		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5154:11): [True: 482k, False: 0]
  |  Branch (5154:34): [True: 482k, False: 0]
  ------------------
 5155|   482k|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (5155:11): [True: 482k, False: 0]
  ------------------
 5156|   482k|			if (buf != NULL)
  ------------------
  |  Branch (5156:8): [True: 2.30k, False: 480k]
  ------------------
 5157|  2.30k|			    ctxt->sax->comment(ctxt->userData, buf);
 5158|   480k|			else
 5159|   480k|			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");
  ------------------
  |  |   35|   480k|#define BAD_CAST (xmlChar *)
  ------------------
 5160|   482k|		    }
 5161|   482k|		    if (buf != NULL)
  ------------------
  |  Branch (5161:11): [True: 2.30k, False: 480k]
  ------------------
 5162|  2.30k|		        xmlFree(buf);
 5163|   482k|		    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5163:11): [True: 482k, False: 0]
  ------------------
 5164|   482k|			ctxt->instate = state;
 5165|   482k|		    return;
 5166|   482k|		}
 5167|      0|		if (buf != NULL) {
  ------------------
  |  Branch (5167:7): [True: 0, False: 0]
  ------------------
 5168|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5169|      0|		                      "Double hyphen within comment: "
 5170|      0|                                      "<!--%.50s\n",
 5171|      0|				      buf);
 5172|      0|		} else
 5173|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5174|      0|		                      "Double hyphen within comment\n", NULL);
 5175|      0|                if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5175:21): [True: 0, False: 0]
  ------------------
 5176|      0|                    xmlFree(buf);
 5177|      0|                    return;
 5178|      0|                }
 5179|      0|		in++;
 5180|      0|		ctxt->input->col++;
 5181|      0|	    }
 5182|  2.34k|	    in++;
 5183|  2.34k|	    ctxt->input->col++;
 5184|  2.34k|	    goto get_more;
 5185|   484k|	}
 5186|   484k|    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (5186:15): [True: 44, False: 3]
  |  Branch (5186:32): [True: 29, False: 15]
  |  Branch (5186:50): [True: 0, False: 18]
  |  Branch (5186:67): [True: 0, False: 18]
  ------------------
 5187|     18|    xmlParseCommentComplex(ctxt, buf, len, size);
 5188|     18|    ctxt->instate = state;
 5189|     18|    return;
 5190|   482k|}
xmlParsePITarget:
 5207|     66|xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5208|     66|    const xmlChar *name;
 5209|       |
 5210|     66|    name = xmlParseName(ctxt);
 5211|     66|    if ((name != NULL) &&
  ------------------
  |  Branch (5211:9): [True: 66, False: 0]
  ------------------
 5212|     66|        ((name[0] == 'x') || (name[0] == 'X')) &&
  ------------------
  |  Branch (5212:10): [True: 9, False: 57]
  |  Branch (5212:30): [True: 0, False: 57]
  ------------------
 5213|     66|        ((name[1] == 'm') || (name[1] == 'M')) &&
  ------------------
  |  Branch (5213:10): [True: 6, False: 3]
  |  Branch (5213:30): [True: 0, False: 3]
  ------------------
 5214|     66|        ((name[2] == 'l') || (name[2] == 'L'))) {
  ------------------
  |  Branch (5214:10): [True: 3, False: 3]
  |  Branch (5214:30): [True: 0, False: 3]
  ------------------
 5215|      3|	int i;
 5216|      3|	if ((name[0] == 'x') && (name[1] == 'm') &&
  ------------------
  |  Branch (5216:6): [True: 3, False: 0]
  |  Branch (5216:26): [True: 3, False: 0]
  ------------------
 5217|      3|	    (name[2] == 'l') && (name[3] == 0)) {
  ------------------
  |  Branch (5217:6): [True: 3, False: 0]
  |  Branch (5217:26): [True: 0, False: 3]
  ------------------
 5218|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5219|      0|		 "XML declaration allowed only at the start of the document\n");
 5220|      0|	    return(name);
 5221|      3|	} else if (name[3] == 0) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 3]
  ------------------
 5222|      0|	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5223|      0|	    return(name);
 5224|      0|	}
 5225|      3|	for (i = 0;;i++) {
 5226|      3|	    if (xmlW3CPIs[i] == NULL) break;
  ------------------
  |  Branch (5226:10): [True: 0, False: 3]
  ------------------
 5227|      3|	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
  ------------------
  |  Branch (5227:10): [True: 3, False: 0]
  ------------------
 5228|      3|	        return(name);
 5229|      3|	}
 5230|      0|	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5231|      0|		      "xmlParsePITarget: invalid name prefix 'xml'\n",
 5232|      0|		      NULL, NULL);
 5233|      0|    }
 5234|     63|    if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {
  ------------------
  |  Branch (5234:9): [True: 63, False: 0]
  |  Branch (5234:27): [True: 0, False: 63]
  ------------------
 5235|      0|	xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5236|      0|		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
 5237|      0|    }
 5238|     63|    return(name);
 5239|     66|}
xmlParsePI:
 5317|     66|xmlParsePI(xmlParserCtxtPtr ctxt) {
 5318|     66|    xmlChar *buf = NULL;
 5319|     66|    size_t len = 0;
 5320|     66|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     66|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5321|     66|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5321:24): [True: 0, False: 66]
  ------------------
 5322|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5323|     66|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    132|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5324|     66|    int cur, l;
 5325|     66|    const xmlChar *target;
 5326|     66|    xmlParserInputState state;
 5327|       |
 5328|     66|    if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|     66|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5328:9): [True: 66, False: 0]
  |  Branch (5328:25): [True: 66, False: 0]
  ------------------
 5329|     66|	int inputid = ctxt->input->id;
 5330|     66|	state = ctxt->instate;
 5331|     66|        ctxt->instate = XML_PARSER_PI;
 5332|       |	/*
 5333|       |	 * this is a Processing Instruction.
 5334|       |	 */
 5335|     66|	SKIP(2);
  ------------------
  |  | 2245|     66|#define SKIP(val) do {							\
  |  | 2246|     66|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     66|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 66]
  |  |  ------------------
  |  | 2248|     66|        xmlParserGrow(ctxt);						\
  |  | 2249|     66|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5336|       |
 5337|       |	/*
 5338|       |	 * Parse the target name and check for special support like
 5339|       |	 * namespace.
 5340|       |	 */
 5341|     66|        target = xmlParsePITarget(ctxt);
 5342|     66|	if (target != NULL) {
  ------------------
  |  Branch (5342:6): [True: 66, False: 0]
  ------------------
 5343|     66|	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5343:10): [True: 3, False: 63]
  |  Branch (5343:26): [True: 3, False: 0]
  ------------------
 5344|      3|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5344:7): [True: 0, False: 3]
  ------------------
 5345|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5346|      0|	                           "PI declaration doesn't start and stop in"
 5347|      0|                                   " the same entity\n");
 5348|      0|		}
 5349|      3|		SKIP(2);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5350|       |
 5351|       |		/*
 5352|       |		 * SAX: PI detected.
 5353|       |		 */
 5354|      3|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5354:7): [True: 3, False: 0]
  |  Branch (5354:22): [True: 3, False: 0]
  ------------------
 5355|      3|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5355:7): [True: 3, False: 0]
  ------------------
 5356|      3|		    ctxt->sax->processingInstruction(ctxt->userData,
 5357|      3|		                                     target, NULL);
 5358|      3|		if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5358:7): [True: 3, False: 0]
  ------------------
 5359|      3|		    ctxt->instate = state;
 5360|      3|		return;
 5361|      3|	    }
 5362|     63|	    buf = (xmlChar *) xmlMallocAtomic(size);
 5363|     63|	    if (buf == NULL) {
  ------------------
  |  Branch (5363:10): [True: 0, False: 63]
  ------------------
 5364|      0|		xmlErrMemory(ctxt, NULL);
 5365|      0|		ctxt->instate = state;
 5366|      0|		return;
 5367|      0|	    }
 5368|     63|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     63|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5368:10): [True: 3, False: 60]
  ------------------
 5369|      3|		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5370|      3|			  "ParsePI: PI %s space expected\n", target);
 5371|      3|	    }
 5372|     63|	    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     63|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5373|    687|	    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|    687|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.37k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 687, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 687, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.37k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    687|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 687, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 3, False: 684]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    687|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 684]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    687|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 684, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.37k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5374|    687|		   ((cur != '?') || (NXT(1) != '>'))) {
  ------------------
  |  | 2223|     63|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5374:7): [True: 624, False: 63]
  |  Branch (5374:23): [True: 0, False: 63]
  ------------------
 5375|    624|		if (len + 5 >= size) {
  ------------------
  |  Branch (5375:7): [True: 0, False: 624]
  ------------------
 5376|      0|		    xmlChar *tmp;
 5377|      0|                    size_t new_size = size * 2;
 5378|      0|		    tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5379|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (5379:11): [True: 0, False: 0]
  ------------------
 5380|      0|			xmlErrMemory(ctxt, NULL);
 5381|      0|			xmlFree(buf);
 5382|      0|			ctxt->instate = state;
 5383|      0|			return;
 5384|      0|		    }
 5385|      0|		    buf = tmp;
 5386|      0|                    size = new_size;
 5387|      0|		}
 5388|    624|		COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|    624|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 624, False: 0]
  |  |  ------------------
  |  | 2296|    624|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 5389|    624|                if (len > maxLength) {
  ------------------
  |  Branch (5389:21): [True: 0, False: 624]
  ------------------
 5390|      0|                    xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5391|      0|                                      "PI %s too big found", target);
 5392|      0|                    xmlFree(buf);
 5393|      0|                    ctxt->instate = state;
 5394|      0|                    return;
 5395|      0|                }
 5396|    624|		NEXTL(l);
  ------------------
  |  | 2284|    624|#define NEXTL(l) do {							\
  |  | 2285|    624|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 3, False: 621]
  |  |  ------------------
  |  | 2286|      3|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    621|    } else ctxt->input->col++;						\
  |  | 2288|    624|    ctxt->input->cur += l;				\
  |  | 2289|    624|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5397|    624|		cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    624|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5398|    624|	    }
 5399|     63|	    buf[len] = 0;
 5400|     63|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5400:17): [True: 0, False: 63]
  ------------------
 5401|      0|                xmlFree(buf);
 5402|      0|                return;
 5403|      0|            }
 5404|     63|	    if (cur != '?') {
  ------------------
  |  Branch (5404:10): [True: 0, False: 63]
  ------------------
 5405|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5406|      0|		      "ParsePI: PI %s never end ...\n", target);
 5407|     63|	    } else {
 5408|     63|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5408:7): [True: 0, False: 63]
  ------------------
 5409|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5410|      0|	                           "PI declaration doesn't start and stop in"
 5411|      0|                                   " the same entity\n");
 5412|      0|		}
 5413|     63|		SKIP(2);
  ------------------
  |  | 2245|     63|#define SKIP(val) do {							\
  |  | 2246|     63|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     63|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 3, False: 60]
  |  |  ------------------
  |  | 2248|     63|        xmlParserGrow(ctxt);						\
  |  | 2249|     63|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5414|       |
 5415|     63|#ifdef LIBXML_CATALOG_ENABLED
 5416|     63|		if (((state == XML_PARSER_MISC) ||
  ------------------
  |  Branch (5416:8): [True: 6, False: 57]
  ------------------
 5417|     63|	             (state == XML_PARSER_START)) &&
  ------------------
  |  Branch (5417:15): [True: 3, False: 54]
  ------------------
 5418|     63|		    (xmlStrEqual(target, XML_CATALOG_PI))) {
  ------------------
  |  |   45|      9|    (const xmlChar *) "oasis-xml-catalog"
  ------------------
  |  Branch (5418:7): [True: 0, False: 9]
  ------------------
 5419|      0|		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5420|      0|		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
  ------------------
  |  Branch (5420:11): [True: 0, False: 0]
  ------------------
 5421|      0|			(allow == XML_CATA_ALLOW_ALL))
  ------------------
  |  Branch (5421:4): [True: 0, False: 0]
  ------------------
 5422|      0|			xmlParseCatalogPI(ctxt, buf);
 5423|      0|		}
 5424|     63|#endif
 5425|       |
 5426|       |
 5427|       |		/*
 5428|       |		 * SAX: PI detected.
 5429|       |		 */
 5430|     63|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5430:7): [True: 63, False: 0]
  |  Branch (5430:22): [True: 60, False: 3]
  ------------------
 5431|     63|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5431:7): [True: 60, False: 0]
  ------------------
 5432|     60|		    ctxt->sax->processingInstruction(ctxt->userData,
 5433|     60|		                                     target, buf);
 5434|     63|	    }
 5435|     63|	    xmlFree(buf);
 5436|     63|	} else {
 5437|      0|	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5438|      0|	}
 5439|     63|	if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5439:6): [True: 63, False: 0]
  ------------------
 5440|     63|	    ctxt->instate = state;
 5441|     63|    }
 5442|     66|}
xmlParseEntityDecl:
 5546|  1.76k|xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
 5547|  1.76k|    const xmlChar *name = NULL;
 5548|  1.76k|    xmlChar *value = NULL;
 5549|  1.76k|    xmlChar *URI = NULL, *literal = NULL;
 5550|  1.76k|    const xmlChar *ndata = NULL;
 5551|  1.76k|    int isParameter = 0;
 5552|  1.76k|    xmlChar *orig = NULL;
 5553|       |
 5554|  1.76k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  1.76k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  1.76k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5554:9): [True: 0, False: 1.76k]
  |  Branch (5554:25): [True: 0, False: 1.76k]
  ------------------
 5555|      0|        return;
 5556|  1.76k|    SKIP(2);
  ------------------
  |  | 2245|  1.76k|#define SKIP(val) do {							\
  |  | 2246|  1.76k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.76k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.76k]
  |  |  ------------------
  |  | 2248|  1.76k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.76k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5557|       |
 5558|       |    /* GROW; done in the caller */
 5559|  1.76k|    if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|  1.76k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  3.53k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  3.53k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.76k, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.76k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  1.76k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.76k, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.76k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 1.76k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 1.76k, False: 0]
  |  |  ------------------
  ------------------
 5560|  1.76k|	int inputid = ctxt->input->id;
 5561|  1.76k|	SKIP(6);
  ------------------
  |  | 2245|  1.76k|#define SKIP(val) do {							\
  |  | 2246|  1.76k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.76k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.76k]
  |  |  ------------------
  |  | 2248|  1.76k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.76k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5562|  1.76k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  1.76k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5562:6): [True: 6, False: 1.76k]
  ------------------
 5563|      6|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5564|      6|			   "Space required after '<!ENTITY'\n");
 5565|      6|	}
 5566|       |
 5567|  1.76k|	if (RAW == '%') {
  ------------------
  |  | 2221|  1.76k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5567:6): [True: 699, False: 1.06k]
  ------------------
 5568|    699|	    NEXT;
  ------------------
  |  | 2275|    699|#define NEXT xmlNextChar(ctxt)
  ------------------
 5569|    699|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    699|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5569:10): [True: 0, False: 699]
  ------------------
 5570|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5571|      0|			       "Space required after '%%'\n");
 5572|      0|	    }
 5573|    699|	    isParameter = 1;
 5574|    699|	}
 5575|       |
 5576|  1.76k|        name = xmlParseName(ctxt);
 5577|  1.76k|	if (name == NULL) {
  ------------------
  |  Branch (5577:6): [True: 3, False: 1.76k]
  ------------------
 5578|      3|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 5579|      3|	                   "xmlParseEntityDecl: no name\n");
 5580|      3|            return;
 5581|      3|	}
 5582|  1.76k|	if (xmlStrchr(name, ':') != NULL) {
  ------------------
  |  Branch (5582:6): [True: 0, False: 1.76k]
  ------------------
 5583|      0|	    xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5584|      0|		     "colons are forbidden from entities names '%s'\n",
 5585|      0|		     name, NULL, NULL);
 5586|      0|	}
 5587|  1.76k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  1.76k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5587:6): [True: 3, False: 1.76k]
  ------------------
 5588|      3|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5589|      3|			   "Space required after the entity name\n");
 5590|      3|	}
 5591|       |
 5592|  1.76k|	ctxt->instate = XML_PARSER_ENTITY_DECL;
 5593|       |	/*
 5594|       |	 * handle the various case of definitions...
 5595|       |	 */
 5596|  1.76k|	if (isParameter) {
  ------------------
  |  Branch (5596:6): [True: 699, False: 1.06k]
  ------------------
 5597|    699|	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|    699|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|    186|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5597:10): [True: 513, False: 186]
  |  Branch (5597:26): [True: 159, False: 27]
  ------------------
 5598|    672|	        value = xmlParseEntityValue(ctxt, &orig);
 5599|    672|		if (value) {
  ------------------
  |  Branch (5599:7): [True: 666, False: 6]
  ------------------
 5600|    666|		    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5600:11): [True: 666, False: 0]
  ------------------
 5601|    666|			(!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5601:4): [True: 666, False: 0]
  |  Branch (5601:27): [True: 666, False: 0]
  ------------------
 5602|    666|			ctxt->sax->entityDecl(ctxt->userData, name,
 5603|    666|		                    XML_INTERNAL_PARAMETER_ENTITY,
 5604|    666|				    NULL, NULL, value);
 5605|    666|		}
 5606|    672|	    } else {
 5607|     27|	        URI = xmlParseExternalID(ctxt, &literal, 1);
 5608|     27|		if ((URI == NULL) && (literal == NULL)) {
  ------------------
  |  Branch (5608:7): [True: 0, False: 27]
  |  Branch (5608:24): [True: 0, False: 0]
  ------------------
 5609|      0|		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5610|      0|		}
 5611|     27|		if (URI) {
  ------------------
  |  Branch (5611:7): [True: 27, False: 0]
  ------------------
 5612|     27|		    xmlURIPtr uri;
 5613|       |
 5614|     27|		    uri = xmlParseURI((const char *) URI);
 5615|     27|		    if (uri == NULL) {
  ------------------
  |  Branch (5615:11): [True: 0, False: 27]
  ------------------
 5616|      0|		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5617|      0|				     "Invalid URI: %s\n", URI);
 5618|       |			/*
 5619|       |			 * This really ought to be a well formedness error
 5620|       |			 * but the XML Core WG decided otherwise c.f. issue
 5621|       |			 * E26 of the XML erratas.
 5622|       |			 */
 5623|     27|		    } else {
 5624|     27|			if (uri->fragment != NULL) {
  ------------------
  |  Branch (5624:8): [True: 0, False: 27]
  ------------------
 5625|       |			    /*
 5626|       |			     * Okay this is foolish to block those but not
 5627|       |			     * invalid URIs.
 5628|       |			     */
 5629|      0|			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5630|     27|			} else {
 5631|     27|			    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5631:12): [True: 27, False: 0]
  ------------------
 5632|     27|				(!ctxt->disableSAX) &&
  ------------------
  |  Branch (5632:5): [True: 27, False: 0]
  ------------------
 5633|     27|				(ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5633:5): [True: 27, False: 0]
  ------------------
 5634|     27|				ctxt->sax->entityDecl(ctxt->userData, name,
 5635|     27|					    XML_EXTERNAL_PARAMETER_ENTITY,
 5636|     27|					    literal, URI, NULL);
 5637|     27|			}
 5638|     27|			xmlFreeURI(uri);
 5639|     27|		    }
 5640|     27|		}
 5641|     27|	    }
 5642|  1.06k|	} else {
 5643|  1.06k|	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|  1.06k|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '"') || (RAW == '\'')) {
  ------------------
  |  | 2221|     96|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5643:10): [True: 969, False: 96]
  |  Branch (5643:26): [True: 57, False: 39]
  ------------------
 5644|  1.02k|	        value = xmlParseEntityValue(ctxt, &orig);
 5645|  1.02k|		if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5645:7): [True: 1.02k, False: 0]
  ------------------
 5646|  1.02k|		    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5646:7): [True: 1.02k, False: 0]
  |  Branch (5646:30): [True: 1.02k, False: 0]
  ------------------
 5647|  1.02k|		    ctxt->sax->entityDecl(ctxt->userData, name,
 5648|  1.02k|				XML_INTERNAL_GENERAL_ENTITY,
 5649|  1.02k|				NULL, NULL, value);
 5650|       |		/*
 5651|       |		 * For expat compatibility in SAX mode.
 5652|       |		 */
 5653|  1.02k|		if ((ctxt->myDoc == NULL) ||
  ------------------
  |  Branch (5653:7): [True: 0, False: 1.02k]
  ------------------
 5654|  1.02k|		    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|  1.02k|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|  1.02k|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (5654:7): [True: 0, False: 1.02k]
  ------------------
 5655|      0|		    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5655:11): [True: 0, False: 0]
  ------------------
 5656|      0|			ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
  ------------------
  |  |  168|      0|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 5657|      0|			if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5657:8): [True: 0, False: 0]
  ------------------
 5658|      0|			    xmlErrMemory(ctxt, "New Doc failed");
 5659|      0|			    goto done;
 5660|      0|			}
 5661|      0|			ctxt->myDoc->properties = XML_DOC_INTERNAL;
 5662|      0|		    }
 5663|      0|		    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (5663:11): [True: 0, False: 0]
  ------------------
 5664|      0|			ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 5665|      0|					    BAD_CAST "fake", NULL, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5666|       |
 5667|      0|		    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,
 5668|      0|			              NULL, NULL, value);
 5669|      0|		}
 5670|  1.02k|	    } else {
 5671|     39|	        URI = xmlParseExternalID(ctxt, &literal, 1);
 5672|     39|		if ((URI == NULL) && (literal == NULL)) {
  ------------------
  |  Branch (5672:7): [True: 3, False: 36]
  |  Branch (5672:24): [True: 3, False: 0]
  ------------------
 5673|      3|		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 5674|      3|		}
 5675|     39|		if (URI) {
  ------------------
  |  Branch (5675:7): [True: 36, False: 3]
  ------------------
 5676|     36|		    xmlURIPtr uri;
 5677|       |
 5678|     36|		    uri = xmlParseURI((const char *)URI);
 5679|     36|		    if (uri == NULL) {
  ------------------
  |  Branch (5679:11): [True: 0, False: 36]
  ------------------
 5680|      0|		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 5681|      0|				     "Invalid URI: %s\n", URI);
 5682|       |			/*
 5683|       |			 * This really ought to be a well formedness error
 5684|       |			 * but the XML Core WG decided otherwise c.f. issue
 5685|       |			 * E26 of the XML erratas.
 5686|       |			 */
 5687|     36|		    } else {
 5688|     36|			if (uri->fragment != NULL) {
  ------------------
  |  Branch (5688:8): [True: 0, False: 36]
  ------------------
 5689|       |			    /*
 5690|       |			     * Okay this is foolish to block those but not
 5691|       |			     * invalid URIs.
 5692|       |			     */
 5693|      0|			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 5694|      0|			}
 5695|     36|			xmlFreeURI(uri);
 5696|     36|		    }
 5697|     36|		}
 5698|     39|		if ((RAW != '>') && (SKIP_BLANKS == 0)) {
  ------------------
  |  | 2221|     39|#define RAW (*ctxt->input->cur)
  ------------------
              		if ((RAW != '>') && (SKIP_BLANKS == 0)) {
  ------------------
  |  | 2273|      3|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5698:7): [True: 3, False: 36]
  |  Branch (5698:23): [True: 0, False: 3]
  ------------------
 5699|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5700|      0|				   "Space required before 'NDATA'\n");
 5701|      0|		}
 5702|     39|		if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|     39|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     78|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 3, False: 36]
  |  |  |  |  |  Branch (2228:41): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     39|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 3, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 5703|      3|		    SKIP(5);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5704|      3|		    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      3|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5704:11): [True: 0, False: 3]
  ------------------
 5705|      0|			xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5706|      0|				       "Space required after 'NDATA'\n");
 5707|      0|		    }
 5708|      3|		    ndata = xmlParseName(ctxt);
 5709|      3|		    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5709:11): [True: 3, False: 0]
  |  Branch (5709:34): [True: 3, False: 0]
  ------------------
 5710|      3|		        (ctxt->sax->unparsedEntityDecl != NULL))
  ------------------
  |  Branch (5710:11): [True: 3, False: 0]
  ------------------
 5711|      3|			ctxt->sax->unparsedEntityDecl(ctxt->userData, name,
 5712|      3|				    literal, URI, ndata);
 5713|     36|		} else {
 5714|     36|		    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5714:11): [True: 36, False: 0]
  ------------------
 5715|     36|		        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
  ------------------
  |  Branch (5715:11): [True: 33, False: 3]
  |  Branch (5715:34): [True: 33, False: 0]
  ------------------
 5716|     33|			ctxt->sax->entityDecl(ctxt->userData, name,
 5717|     33|				    XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5718|     33|				    literal, URI, NULL);
 5719|       |		    /*
 5720|       |		     * For expat compatibility in SAX mode.
 5721|       |		     * assuming the entity replacement was asked for
 5722|       |		     */
 5723|     36|		    if ((ctxt->replaceEntities != 0) &&
  ------------------
  |  Branch (5723:11): [True: 36, False: 0]
  ------------------
 5724|     36|			((ctxt->myDoc == NULL) ||
  ------------------
  |  Branch (5724:5): [True: 0, False: 36]
  ------------------
 5725|     36|			(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
  ------------------
  |  |  168|     36|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|     36|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (5725:4): [True: 0, False: 36]
  ------------------
 5726|      0|			if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5726:8): [True: 0, False: 0]
  ------------------
 5727|      0|			    ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
  ------------------
  |  |  168|      0|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 5728|      0|			    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (5728:12): [True: 0, False: 0]
  ------------------
 5729|      0|			        xmlErrMemory(ctxt, "New Doc failed");
 5730|      0|				goto done;
 5731|      0|			    }
 5732|      0|			    ctxt->myDoc->properties = XML_DOC_INTERNAL;
 5733|      0|			}
 5734|       |
 5735|      0|			if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (5735:8): [True: 0, False: 0]
  ------------------
 5736|      0|			    ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 5737|      0|						BAD_CAST "fake", NULL, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5738|      0|			xmlSAX2EntityDecl(ctxt, name,
 5739|      0|				          XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 5740|      0|				          literal, URI, NULL);
 5741|      0|		    }
 5742|     36|		}
 5743|     39|	    }
 5744|  1.06k|	}
 5745|  1.76k|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (5745:6): [True: 6, False: 1.75k]
  ------------------
 5746|      6|	    goto done;
 5747|  1.75k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  1.75k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5748|  1.75k|	if (RAW != '>') {
  ------------------
  |  | 2221|  1.75k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5748:6): [True: 0, False: 1.75k]
  ------------------
 5749|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 5750|      0|	            "xmlParseEntityDecl: entity %s not terminated\n", name);
 5751|      0|	    xmlHaltParser(ctxt);
 5752|  1.75k|	} else {
 5753|  1.75k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5753:10): [True: 0, False: 1.75k]
  ------------------
 5754|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5755|      0|	                       "Entity declaration doesn't start and stop in"
 5756|      0|                               " the same entity\n");
 5757|      0|	    }
 5758|  1.75k|	    NEXT;
  ------------------
  |  | 2275|  1.75k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5759|  1.75k|	}
 5760|  1.75k|	if (orig != NULL) {
  ------------------
  |  Branch (5760:6): [True: 1.69k, False: 66]
  ------------------
 5761|       |	    /*
 5762|       |	     * Ugly mechanism to save the raw entity value.
 5763|       |	     */
 5764|  1.69k|	    xmlEntityPtr cur = NULL;
 5765|       |
 5766|  1.69k|	    if (isParameter) {
  ------------------
  |  Branch (5766:10): [True: 666, False: 1.02k]
  ------------------
 5767|    666|	        if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5767:14): [True: 666, False: 0]
  ------------------
 5768|    666|		    (ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (5768:7): [True: 666, False: 0]
  ------------------
 5769|    666|		    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);
 5770|  1.02k|	    } else {
 5771|  1.02k|	        if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (5771:14): [True: 1.02k, False: 0]
  ------------------
 5772|  1.02k|		    (ctxt->sax->getEntity != NULL))
  ------------------
  |  Branch (5772:7): [True: 1.02k, False: 0]
  ------------------
 5773|  1.02k|		    cur = ctxt->sax->getEntity(ctxt->userData, name);
 5774|  1.02k|		if ((cur == NULL) && (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (5774:7): [True: 0, False: 1.02k]
  |  Branch (5774:24): [True: 0, False: 0]
  ------------------
 5775|      0|		    cur = xmlSAX2GetEntity(ctxt, name);
 5776|      0|		}
 5777|  1.02k|	    }
 5778|  1.69k|            if ((cur != NULL) && (cur->orig == NULL)) {
  ------------------
  |  Branch (5778:17): [True: 1.69k, False: 0]
  |  Branch (5778:34): [True: 1.67k, False: 18]
  ------------------
 5779|  1.67k|		cur->orig = orig;
 5780|  1.67k|                orig = NULL;
 5781|  1.67k|	    }
 5782|  1.69k|	}
 5783|       |
 5784|  1.76k|done:
 5785|  1.76k|	if (value != NULL) xmlFree(value);
  ------------------
  |  Branch (5785:6): [True: 1.69k, False: 72]
  ------------------
 5786|  1.76k|	if (URI != NULL) xmlFree(URI);
  ------------------
  |  Branch (5786:6): [True: 63, False: 1.70k]
  ------------------
 5787|  1.76k|	if (literal != NULL) xmlFree(literal);
  ------------------
  |  Branch (5787:6): [True: 6, False: 1.75k]
  ------------------
 5788|  1.76k|        if (orig != NULL) xmlFree(orig);
  ------------------
  |  Branch (5788:13): [True: 24, False: 1.74k]
  ------------------
 5789|  1.76k|    }
 5790|  1.76k|}
xmlParseDefaultDecl:
 5824|  5.83k|xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5825|  5.83k|    int val;
 5826|  5.83k|    xmlChar *ret;
 5827|       |
 5828|  5.83k|    *value = NULL;
 5829|  5.83k|    if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {
  ------------------
  |  | 2239|  5.83k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  11.6k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  11.6k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  11.6k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  11.6k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  11.6k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 4.81k, False: 1.02k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 378, False: 4.43k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  5.83k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 378, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 378, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 378, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 378, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 378, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 378, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  5.83k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 378, False: 0]
  |  |  ------------------
  ------------------
 5830|    378|	SKIP(9);
  ------------------
  |  | 2245|    378|#define SKIP(val) do {							\
  |  | 2246|    378|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    378|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 39, False: 339]
  |  |  ------------------
  |  | 2248|    378|        xmlParserGrow(ctxt);						\
  |  | 2249|    378|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5831|    378|	return(XML_ATTRIBUTE_REQUIRED);
 5832|    378|    }
 5833|  5.45k|    if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {
  ------------------
  |  | 2237|  5.45k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  10.9k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  10.9k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  10.9k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  10.9k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 4.43k, False: 1.02k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 4.22k, False: 210]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  5.45k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 4.22k, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 4.22k, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 4.22k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 4.22k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 4.22k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 4.22k, False: 0]
  |  |  ------------------
  ------------------
 5834|  4.22k|	SKIP(8);
  ------------------
  |  | 2245|  4.22k|#define SKIP(val) do {							\
  |  | 2246|  4.22k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  4.22k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 1.11k, False: 3.10k]
  |  |  ------------------
  |  | 2248|  4.22k|        xmlParserGrow(ctxt);						\
  |  | 2249|  4.22k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5835|  4.22k|	return(XML_ATTRIBUTE_IMPLIED);
 5836|  4.22k|    }
 5837|  1.23k|    val = XML_ATTRIBUTE_NONE;
 5838|  1.23k|    if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {
  ------------------
  |  | 2233|  1.23k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  2.46k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  2.46k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 210, False: 1.02k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 210, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  1.23k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 210, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 210, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 210, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 210, False: 0]
  |  |  ------------------
  ------------------
 5839|    210|	SKIP(6);
  ------------------
  |  | 2245|    210|#define SKIP(val) do {							\
  |  | 2246|    210|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    210|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 210]
  |  |  ------------------
  |  | 2248|    210|        xmlParserGrow(ctxt);						\
  |  | 2249|    210|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5840|    210|	val = XML_ATTRIBUTE_FIXED;
 5841|    210|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    210|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5841:6): [True: 0, False: 210]
  ------------------
 5842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5843|      0|			   "Space required after '#FIXED'\n");
 5844|      0|	}
 5845|    210|    }
 5846|  1.23k|    ret = xmlParseAttValue(ctxt);
 5847|  1.23k|    ctxt->instate = XML_PARSER_DTD;
 5848|  1.23k|    if (ret == NULL) {
  ------------------
  |  Branch (5848:9): [True: 0, False: 1.23k]
  ------------------
 5849|      0|	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,
 5850|      0|		       "Attribute default value declaration error\n");
 5851|      0|    } else
 5852|  1.23k|        *value = ret;
 5853|  1.23k|    return(val);
 5854|  5.45k|}
xmlParseEnumerationType:
 5947|  1.26k|xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
 5948|  1.26k|    xmlChar *name;
 5949|  1.26k|    xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 5950|       |
 5951|  1.26k|    if (RAW != '(') {
  ------------------
  |  | 2221|  1.26k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5951:9): [True: 0, False: 1.26k]
  ------------------
 5952|      0|	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
 5953|      0|	return(NULL);
 5954|      0|    }
 5955|  2.05k|    do {
 5956|  2.05k|        NEXT;
  ------------------
  |  | 2275|  2.05k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5957|  2.05k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.05k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5958|  2.05k|        name = xmlParseNmtoken(ctxt);
 5959|  2.05k|	if (name == NULL) {
  ------------------
  |  Branch (5959:6): [True: 0, False: 2.05k]
  ------------------
 5960|      0|	    xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
 5961|      0|	    return(ret);
 5962|      0|	}
 5963|  2.05k|	tmp = ret;
 5964|  3.86k|	while (tmp != NULL) {
  ------------------
  |  Branch (5964:9): [True: 1.81k, False: 2.05k]
  ------------------
 5965|  1.81k|	    if (xmlStrEqual(name, tmp->name)) {
  ------------------
  |  Branch (5965:10): [True: 0, False: 1.81k]
  ------------------
 5966|      0|		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 5967|      0|	  "standalone: attribute enumeration value token %s duplicated\n",
 5968|      0|				 name, NULL);
 5969|      0|		if (!xmlDictOwns(ctxt->dict, name))
  ------------------
  |  Branch (5969:7): [True: 0, False: 0]
  ------------------
 5970|      0|		    xmlFree(name);
 5971|      0|		break;
 5972|      0|	    }
 5973|  1.81k|	    tmp = tmp->next;
 5974|  1.81k|	}
 5975|  2.05k|	if (tmp == NULL) {
  ------------------
  |  Branch (5975:6): [True: 2.05k, False: 0]
  ------------------
 5976|  2.05k|	    cur = xmlCreateEnumeration(name);
 5977|  2.05k|	    if (!xmlDictOwns(ctxt->dict, name))
  ------------------
  |  Branch (5977:10): [True: 2.05k, False: 0]
  ------------------
 5978|  2.05k|		xmlFree(name);
 5979|  2.05k|	    if (cur == NULL) {
  ------------------
  |  Branch (5979:10): [True: 0, False: 2.05k]
  ------------------
 5980|      0|                xmlFreeEnumeration(ret);
 5981|      0|                return(NULL);
 5982|      0|            }
 5983|  2.05k|	    if (last == NULL) ret = last = cur;
  ------------------
  |  Branch (5983:10): [True: 1.26k, False: 786]
  ------------------
 5984|    786|	    else {
 5985|    786|		last->next = cur;
 5986|    786|		last = cur;
 5987|    786|	    }
 5988|  2.05k|	}
 5989|  2.05k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.05k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 5990|  2.05k|    } while (RAW == '|');
  ------------------
  |  | 2221|  2.05k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5990:14): [True: 786, False: 1.26k]
  ------------------
 5991|  1.26k|    if (RAW != ')') {
  ------------------
  |  | 2221|  1.26k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (5991:9): [True: 0, False: 1.26k]
  ------------------
 5992|      0|	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
 5993|      0|	return(ret);
 5994|      0|    }
 5995|  1.26k|    NEXT;
  ------------------
  |  | 2275|  1.26k|#define NEXT xmlNextChar(ctxt)
  ------------------
 5996|  1.26k|    return(ret);
 5997|  1.26k|}
xmlParseEnumeratedType:
 6017|  1.26k|xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6018|  1.26k|    if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {
  ------------------
  |  | 2237|  1.26k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  2.53k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  2.53k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  2.53k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  2.53k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 1.26k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  1.26k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6019|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6020|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6020:6): [True: 0, False: 0]
  ------------------
 6021|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6022|      0|			   "Space required after 'NOTATION'\n");
 6023|      0|	    return(0);
 6024|      0|	}
 6025|      0|	*tree = xmlParseNotationType(ctxt);
 6026|      0|	if (*tree == NULL) return(0);
  ------------------
  |  Branch (6026:6): [True: 0, False: 0]
  ------------------
 6027|      0|	return(XML_ATTRIBUTE_NOTATION);
 6028|      0|    }
 6029|  1.26k|    *tree = xmlParseEnumerationType(ctxt);
 6030|  1.26k|    if (*tree == NULL) return(0);
  ------------------
  |  Branch (6030:9): [True: 0, False: 1.26k]
  ------------------
 6031|  1.26k|    return(XML_ATTRIBUTE_ENUMERATION);
 6032|  1.26k|}
xmlParseAttributeType:
 6082|  5.83k|xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6083|  5.83k|    if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|  5.83k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  11.6k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 2.25k, False: 3.58k]
  |  |  |  |  |  Branch (2228:41): [True: 2.25k, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  5.83k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 2.25k, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 2.25k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 2.25k, False: 0]
  |  |  ------------------
  ------------------
 6084|  2.25k|	SKIP(5);
  ------------------
  |  | 2245|  2.25k|#define SKIP(val) do {							\
  |  | 2246|  2.25k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.25k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.25k]
  |  |  ------------------
  |  | 2248|  2.25k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.25k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6085|  2.25k|	return(XML_ATTRIBUTE_CDATA);
 6086|  3.58k|     } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {
  ------------------
  |  | 2233|  3.58k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  7.16k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  7.16k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.37k, False: 2.21k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.37k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  3.58k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 78, False: 1.29k]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 78, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 78, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 12, False: 66]
  |  |  ------------------
  ------------------
 6087|     12|	SKIP(6);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6088|     12|	return(XML_ATTRIBUTE_IDREFS);
 6089|  3.57k|     } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {
  ------------------
  |  | 2231|  3.57k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  7.14k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 1.35k, False: 2.21k]
  |  |  |  |  |  Branch (2228:41): [True: 1.35k, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  3.57k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 66, False: 1.29k]
  |  |  |  |  |  Branch (2229:41): [True: 66, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 66, False: 0]
  |  |  ------------------
  ------------------
 6090|     66|	SKIP(5);
  ------------------
  |  | 2245|     66|#define SKIP(val) do {							\
  |  | 2246|     66|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     66|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 66]
  |  |  ------------------
  |  | 2248|     66|        xmlParserGrow(ctxt);						\
  |  | 2249|     66|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6091|     66|	return(XML_ATTRIBUTE_IDREF);
 6092|  3.50k|     } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2221|  3.50k|#define RAW (*ctxt->input->cur)
  ------------------
                   } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2223|  1.29k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6092:17): [True: 1.29k, False: 2.21k]
  |  Branch (6092:33): [True: 1.29k, False: 0]
  ------------------
 6093|  1.29k|        SKIP(2);
  ------------------
  |  | 2245|  1.29k|#define SKIP(val) do {							\
  |  | 2246|  1.29k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.29k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.29k]
  |  |  ------------------
  |  | 2248|  1.29k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.29k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6094|  1.29k|	return(XML_ATTRIBUTE_ID);
 6095|  2.21k|     } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|  2.21k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|  4.42k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|  4.42k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 9, False: 2.20k]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 9, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|  2.21k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 9, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 9, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 9, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 6096|      9|	SKIP(6);
  ------------------
  |  | 2245|      9|#define SKIP(val) do {							\
  |  | 2246|      9|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      9|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2248|      9|        xmlParserGrow(ctxt);						\
  |  | 2249|      9|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6097|      9|	return(XML_ATTRIBUTE_ENTITY);
 6098|  2.20k|     } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {
  ------------------
  |  | 2237|  2.20k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  4.40k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  4.40k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  4.40k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  4.40k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 2.20k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  2.20k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6099|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6100|      0|	return(XML_ATTRIBUTE_ENTITIES);
 6101|  2.20k|     } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {
  ------------------
  |  | 2237|  2.20k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|  4.40k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|  4.40k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|  4.40k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|  4.40k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 936, False: 1.26k]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 936, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|  2.20k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 936, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 936, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 936, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 936, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 936, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 147, False: 789]
  |  |  ------------------
  ------------------
 6102|    147|	SKIP(8);
  ------------------
  |  | 2245|    147|#define SKIP(val) do {							\
  |  | 2246|    147|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    147|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 147]
  |  |  ------------------
  |  | 2248|    147|        xmlParserGrow(ctxt);						\
  |  | 2249|    147|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6103|    147|	return(XML_ATTRIBUTE_NMTOKENS);
 6104|  2.05k|     } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {
  ------------------
  |  | 2235|  2.05k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  4.11k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  4.11k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  4.11k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 789, False: 1.26k]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 789, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  2.05k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 789, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 789, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 789, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 789, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 789, False: 0]
  |  |  ------------------
  ------------------
 6105|    789|	SKIP(7);
  ------------------
  |  | 2245|    789|#define SKIP(val) do {							\
  |  | 2246|    789|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    789|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 789]
  |  |  ------------------
  |  | 2248|    789|        xmlParserGrow(ctxt);						\
  |  | 2249|    789|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6106|    789|	return(XML_ATTRIBUTE_NMTOKEN);
 6107|    789|     }
 6108|  1.26k|     return(xmlParseEnumeratedType(ctxt, tree));
 6109|  5.83k|}
xmlParseAttributeListDecl:
 6125|  1.50k|xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 6126|  1.50k|    const xmlChar *elemName;
 6127|  1.50k|    const xmlChar *attrName;
 6128|  1.50k|    xmlEnumerationPtr tree;
 6129|       |
 6130|  1.50k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  1.50k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  1.50k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6130:9): [True: 0, False: 1.50k]
  |  Branch (6130:25): [True: 0, False: 1.50k]
  ------------------
 6131|      0|        return;
 6132|  1.50k|    SKIP(2);
  ------------------
  |  | 2245|  1.50k|#define SKIP(val) do {							\
  |  | 2246|  1.50k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.50k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.50k]
  |  |  ------------------
  |  | 2248|  1.50k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.50k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6133|       |
 6134|  1.50k|    if (CMP7(CUR_PTR, 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
  ------------------
  |  | 2235|  1.50k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  3.01k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  3.01k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  3.01k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.50k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.50k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  1.50k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.50k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.50k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.50k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.50k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.50k, False: 0]
  |  |  ------------------
  ------------------
 6135|  1.50k|	int inputid = ctxt->input->id;
 6136|       |
 6137|  1.50k|	SKIP(7);
  ------------------
  |  | 2245|  1.50k|#define SKIP(val) do {							\
  |  | 2246|  1.50k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.50k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.50k]
  |  |  ------------------
  |  | 2248|  1.50k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.50k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6138|  1.50k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  1.50k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6138:6): [True: 0, False: 1.50k]
  ------------------
 6139|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6140|      0|		                 "Space required after '<!ATTLIST'\n");
 6141|      0|	}
 6142|  1.50k|        elemName = xmlParseName(ctxt);
 6143|  1.50k|	if (elemName == NULL) {
  ------------------
  |  Branch (6143:6): [True: 0, False: 1.50k]
  ------------------
 6144|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6145|      0|			   "ATTLIST: no name for Element\n");
 6146|      0|	    return;
 6147|      0|	}
 6148|  1.50k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  1.50k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6149|  1.50k|	GROW;
  ------------------
  |  | 2270|  1.50k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.50k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.40k, False: 106]
  |  |  ------------------
  |  | 2271|  1.50k|	xmlParserGrow(ctxt);
  ------------------
 6150|  7.34k|	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  7.34k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6150:9): [True: 5.83k, False: 1.50k]
  |  Branch (6150:25): [True: 5.83k, False: 0]
  ------------------
 6151|  5.83k|	    int type;
 6152|  5.83k|	    int def;
 6153|  5.83k|	    xmlChar *defaultValue = NULL;
 6154|       |
 6155|  5.83k|	    GROW;
  ------------------
  |  | 2270|  5.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.91k, False: 1.91k]
  |  |  ------------------
  |  | 2271|  5.83k|	xmlParserGrow(ctxt);
  ------------------
 6156|  5.83k|            tree = NULL;
 6157|  5.83k|	    attrName = xmlParseName(ctxt);
 6158|  5.83k|	    if (attrName == NULL) {
  ------------------
  |  Branch (6158:10): [True: 0, False: 5.83k]
  ------------------
 6159|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6160|      0|			       "ATTLIST: no name for Attribute\n");
 6161|      0|		break;
 6162|      0|	    }
 6163|  5.83k|	    GROW;
  ------------------
  |  | 2270|  5.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.92k, False: 1.91k]
  |  |  ------------------
  |  | 2271|  5.83k|	xmlParserGrow(ctxt);
  ------------------
 6164|  5.83k|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  5.83k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6164:10): [True: 0, False: 5.83k]
  ------------------
 6165|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6166|      0|		        "Space required after the attribute name\n");
 6167|      0|		break;
 6168|      0|	    }
 6169|       |
 6170|  5.83k|	    type = xmlParseAttributeType(ctxt, &tree);
 6171|  5.83k|	    if (type <= 0) {
  ------------------
  |  Branch (6171:10): [True: 0, False: 5.83k]
  ------------------
 6172|      0|	        break;
 6173|      0|	    }
 6174|       |
 6175|  5.83k|	    GROW;
  ------------------
  |  | 2270|  5.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.94k, False: 1.89k]
  |  |  ------------------
  |  | 2271|  5.83k|	xmlParserGrow(ctxt);
  ------------------
 6176|  5.83k|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  5.83k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6176:10): [True: 0, False: 5.83k]
  ------------------
 6177|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6178|      0|			       "Space required after the attribute type\n");
 6179|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6179:14): [True: 0, False: 0]
  ------------------
 6180|      0|		    xmlFreeEnumeration(tree);
 6181|      0|		break;
 6182|      0|	    }
 6183|       |
 6184|  5.83k|	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
 6185|  5.83k|	    if (def <= 0) {
  ------------------
  |  Branch (6185:10): [True: 0, False: 5.83k]
  ------------------
 6186|      0|                if (defaultValue != NULL)
  ------------------
  |  Branch (6186:21): [True: 0, False: 0]
  ------------------
 6187|      0|		    xmlFree(defaultValue);
 6188|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6188:14): [True: 0, False: 0]
  ------------------
 6189|      0|		    xmlFreeEnumeration(tree);
 6190|      0|	        break;
 6191|      0|	    }
 6192|  5.83k|	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
  ------------------
  |  Branch (6192:10): [True: 3.58k, False: 2.25k]
  |  Branch (6192:43): [True: 1.01k, False: 2.57k]
  ------------------
 6193|  1.01k|	        xmlAttrNormalizeSpace(defaultValue, defaultValue);
 6194|       |
 6195|  5.83k|	    GROW;
  ------------------
  |  | 2270|  5.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 3.93k, False: 1.90k]
  |  |  ------------------
  |  | 2271|  5.83k|	xmlParserGrow(ctxt);
  ------------------
 6196|  5.83k|            if (RAW != '>') {
  ------------------
  |  | 2221|  5.83k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6196:17): [True: 5.57k, False: 261]
  ------------------
 6197|  5.57k|		if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  5.57k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6197:7): [True: 0, False: 5.57k]
  ------------------
 6198|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6199|      0|			"Space required after the attribute default value\n");
 6200|      0|		    if (defaultValue != NULL)
  ------------------
  |  Branch (6200:11): [True: 0, False: 0]
  ------------------
 6201|      0|			xmlFree(defaultValue);
 6202|      0|		    if (tree != NULL)
  ------------------
  |  Branch (6202:11): [True: 0, False: 0]
  ------------------
 6203|      0|			xmlFreeEnumeration(tree);
 6204|      0|		    break;
 6205|      0|		}
 6206|  5.57k|	    }
 6207|  5.83k|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6207:10): [True: 5.83k, False: 0]
  |  Branch (6207:33): [True: 5.83k, False: 0]
  ------------------
 6208|  5.83k|		(ctxt->sax->attributeDecl != NULL))
  ------------------
  |  Branch (6208:3): [True: 5.83k, False: 0]
  ------------------
 6209|  5.83k|		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
 6210|  5.83k|	                        type, def, defaultValue, tree);
 6211|      0|	    else if (tree != NULL)
  ------------------
  |  Branch (6211:15): [True: 0, False: 0]
  ------------------
 6212|      0|		xmlFreeEnumeration(tree);
 6213|       |
 6214|  5.83k|	    if ((ctxt->sax2) && (defaultValue != NULL) &&
  ------------------
  |  Branch (6214:10): [True: 5.83k, False: 0]
  |  Branch (6214:26): [True: 1.23k, False: 4.60k]
  ------------------
 6215|  5.83k|	        (def != XML_ATTRIBUTE_IMPLIED) &&
  ------------------
  |  Branch (6215:10): [True: 1.23k, False: 0]
  ------------------
 6216|  5.83k|		(def != XML_ATTRIBUTE_REQUIRED)) {
  ------------------
  |  Branch (6216:3): [True: 1.23k, False: 0]
  ------------------
 6217|  1.23k|		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6218|  1.23k|	    }
 6219|  5.83k|	    if (ctxt->sax2) {
  ------------------
  |  Branch (6219:10): [True: 5.83k, False: 0]
  ------------------
 6220|  5.83k|		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6221|  5.83k|	    }
 6222|  5.83k|	    if (defaultValue != NULL)
  ------------------
  |  Branch (6222:10): [True: 1.23k, False: 4.60k]
  ------------------
 6223|  1.23k|	        xmlFree(defaultValue);
 6224|  5.83k|	    GROW;
  ------------------
  |  | 2270|  5.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  5.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.67k, False: 3.15k]
  |  |  ------------------
  |  | 2271|  5.83k|	xmlParserGrow(ctxt);
  ------------------
 6225|  5.83k|	}
 6226|  1.50k|	if (RAW == '>') {
  ------------------
  |  | 2221|  1.50k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6226:6): [True: 1.50k, False: 0]
  ------------------
 6227|  1.50k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6227:10): [True: 0, False: 1.50k]
  ------------------
 6228|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6229|      0|                               "Attribute list declaration doesn't start and"
 6230|      0|                               " stop in the same entity\n");
 6231|      0|	    }
 6232|  1.50k|	    NEXT;
  ------------------
  |  | 2275|  1.50k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6233|  1.50k|	}
 6234|  1.50k|    }
 6235|  1.50k|}
xmlParseElementMixedContentDecl:
 6259|  1.02k|xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6260|  1.02k|    xmlElementContentPtr ret = NULL, cur = NULL, n;
 6261|  1.02k|    const xmlChar *elem = NULL;
 6262|       |
 6263|  1.02k|    GROW;
  ------------------
  |  | 2270|  1.02k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.02k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 374, False: 652]
  |  |  ------------------
  |  | 2271|  1.02k|	xmlParserGrow(ctxt);
  ------------------
 6264|  1.02k|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|  1.02k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  2.05k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  2.05k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  2.05k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  1.02k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.02k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.02k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.02k, False: 0]
  |  |  ------------------
  ------------------
 6265|  1.02k|	SKIP(7);
  ------------------
  |  | 2245|  1.02k|#define SKIP(val) do {							\
  |  | 2246|  1.02k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  1.02k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 1.02k]
  |  |  ------------------
  |  | 2248|  1.02k|        xmlParserGrow(ctxt);						\
  |  | 2249|  1.02k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6266|  1.02k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  1.02k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6267|  1.02k|	if (RAW == ')') {
  ------------------
  |  | 2221|  1.02k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6267:6): [True: 672, False: 354]
  ------------------
 6268|    672|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6268:10): [True: 0, False: 672]
  ------------------
 6269|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6270|      0|                               "Element content declaration doesn't start and"
 6271|      0|                               " stop in the same entity\n");
 6272|      0|	    }
 6273|    672|	    NEXT;
  ------------------
  |  | 2275|    672|#define NEXT xmlNextChar(ctxt)
  ------------------
 6274|    672|	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6275|    672|	    if (ret == NULL)
  ------------------
  |  Branch (6275:10): [True: 0, False: 672]
  ------------------
 6276|      0|	        return(NULL);
 6277|    672|	    if (RAW == '*') {
  ------------------
  |  | 2221|    672|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6277:10): [True: 0, False: 672]
  ------------------
 6278|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6279|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6280|      0|	    }
 6281|    672|	    return(ret);
 6282|    672|	}
 6283|    354|	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|    354|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|    354|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6283:6): [True: 0, False: 354]
  |  Branch (6283:22): [True: 354, False: 0]
  ------------------
 6284|    354|	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6285|    354|	    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (6285:10): [True: 0, False: 354]
  ------------------
 6286|    354|	}
 6287|  3.44k|	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  3.44k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6287:9): [True: 3.09k, False: 354]
  |  Branch (6287:25): [True: 3.09k, False: 0]
  ------------------
 6288|  3.09k|	    NEXT;
  ------------------
  |  | 2275|  3.09k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6289|  3.09k|	    if (elem == NULL) {
  ------------------
  |  Branch (6289:10): [True: 354, False: 2.73k]
  ------------------
 6290|    354|	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6291|    354|		if (ret == NULL) {
  ------------------
  |  Branch (6291:7): [True: 0, False: 354]
  ------------------
 6292|      0|		    xmlFreeDocElementContent(ctxt->myDoc, cur);
 6293|      0|                    return(NULL);
 6294|      0|                }
 6295|    354|		ret->c1 = cur;
 6296|    354|		if (cur != NULL)
  ------------------
  |  Branch (6296:7): [True: 354, False: 0]
  ------------------
 6297|    354|		    cur->parent = ret;
 6298|    354|		cur = ret;
 6299|  2.73k|	    } else {
 6300|  2.73k|	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6301|  2.73k|		if (n == NULL) {
  ------------------
  |  Branch (6301:7): [True: 0, False: 2.73k]
  ------------------
 6302|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6303|      0|                    return(NULL);
 6304|      0|                }
 6305|  2.73k|		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6306|  2.73k|		if (n->c1 != NULL)
  ------------------
  |  Branch (6306:7): [True: 2.73k, False: 0]
  ------------------
 6307|  2.73k|		    n->c1->parent = n;
 6308|  2.73k|	        cur->c2 = n;
 6309|  2.73k|		if (n != NULL)
  ------------------
  |  Branch (6309:7): [True: 2.73k, False: 0]
  ------------------
 6310|  2.73k|		    n->parent = cur;
 6311|  2.73k|		cur = n;
 6312|  2.73k|	    }
 6313|  3.09k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|  3.09k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6314|  3.09k|	    elem = xmlParseName(ctxt);
 6315|  3.09k|	    if (elem == NULL) {
  ------------------
  |  Branch (6315:10): [True: 0, False: 3.09k]
  ------------------
 6316|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6317|      0|			"xmlParseElementMixedContentDecl : Name expected\n");
 6318|      0|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6319|      0|		return(NULL);
 6320|      0|	    }
 6321|  3.09k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|  3.09k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6322|  3.09k|	    GROW;
  ------------------
  |  | 2270|  3.09k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.09k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.39k, False: 702]
  |  |  ------------------
  |  | 2271|  3.09k|	xmlParserGrow(ctxt);
  ------------------
 6323|  3.09k|	}
 6324|    354|	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2221|    354|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2223|    354|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6324:6): [True: 354, False: 0]
  |  Branch (6324:22): [True: 354, False: 0]
  ------------------
 6325|    354|	    if (elem != NULL) {
  ------------------
  |  Branch (6325:10): [True: 354, False: 0]
  ------------------
 6326|    354|		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,
 6327|    354|		                               XML_ELEMENT_CONTENT_ELEMENT);
 6328|    354|		if (cur->c2 != NULL)
  ------------------
  |  Branch (6328:7): [True: 354, False: 0]
  ------------------
 6329|    354|		    cur->c2->parent = cur;
 6330|    354|            }
 6331|    354|            if (ret != NULL)
  ------------------
  |  Branch (6331:17): [True: 354, False: 0]
  ------------------
 6332|    354|                ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6333|    354|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6333:10): [True: 0, False: 354]
  ------------------
 6334|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6335|      0|                               "Element content declaration doesn't start and"
 6336|      0|                               " stop in the same entity\n");
 6337|      0|	    }
 6338|    354|	    SKIP(2);
  ------------------
  |  | 2245|    354|#define SKIP(val) do {							\
  |  | 2246|    354|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    354|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 354]
  |  |  ------------------
  |  | 2248|    354|        xmlParserGrow(ctxt);						\
  |  | 2249|    354|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6339|    354|	} else {
 6340|      0|	    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6341|      0|	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 6342|      0|	    return(NULL);
 6343|      0|	}
 6344|       |
 6345|    354|    } else {
 6346|      0|	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
 6347|      0|    }
 6348|    354|    return(ret);
 6349|  1.02k|}
xmlParseElementContentDecl:
 6711|  1.80k|                           xmlElementContentPtr *result) {
 6712|       |
 6713|  1.80k|    xmlElementContentPtr tree = NULL;
 6714|  1.80k|    int inputid = ctxt->input->id;
 6715|  1.80k|    int res;
 6716|       |
 6717|  1.80k|    *result = NULL;
 6718|       |
 6719|  1.80k|    if (RAW != '(') {
  ------------------
  |  | 2221|  1.80k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6719:9): [True: 0, False: 1.80k]
  ------------------
 6720|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6721|      0|		"xmlParseElementContentDecl : %s '(' expected\n", name);
 6722|      0|	return(-1);
 6723|      0|    }
 6724|  1.80k|    NEXT;
  ------------------
  |  | 2275|  1.80k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6725|  1.80k|    GROW;
  ------------------
  |  | 2270|  1.80k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.80k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 391, False: 1.41k]
  |  |  ------------------
  |  | 2271|  1.80k|	xmlParserGrow(ctxt);
  ------------------
 6726|  1.80k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (6726:9): [True: 0, False: 1.80k]
  ------------------
 6727|      0|        return(-1);
 6728|  1.80k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.80k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6729|  1.80k|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|  1.80k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  3.60k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  3.60k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  3.60k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 1.02k, False: 777]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  1.80k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 1.02k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 1.02k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 1.02k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 1.02k, False: 0]
  |  |  ------------------
  ------------------
 6730|  1.02k|        tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6731|  1.02k|	res = XML_ELEMENT_TYPE_MIXED;
 6732|  1.02k|    } else {
 6733|    777|        tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6734|    777|	res = XML_ELEMENT_TYPE_ELEMENT;
 6735|    777|    }
 6736|  1.80k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  1.80k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6737|  1.80k|    *result = tree;
 6738|  1.80k|    return(res);
 6739|  1.80k|}
xmlParseElementDecl:
 6757|  2.34k|xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6758|  2.34k|    const xmlChar *name;
 6759|  2.34k|    int ret = -1;
 6760|  2.34k|    xmlElementContentPtr content  = NULL;
 6761|       |
 6762|  2.34k|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|  2.34k|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|  2.34k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6762:9): [True: 0, False: 2.34k]
  |  Branch (6762:25): [True: 0, False: 2.34k]
  ------------------
 6763|      0|        return(ret);
 6764|  2.34k|    SKIP(2);
  ------------------
  |  | 2245|  2.34k|#define SKIP(val) do {							\
  |  | 2246|  2.34k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.34k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.34k]
  |  |  ------------------
  |  | 2248|  2.34k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.34k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6765|       |
 6766|       |    /* GROW; done in the caller */
 6767|  2.34k|    if (CMP7(CUR_PTR, 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {
  ------------------
  |  | 2235|  2.34k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  4.68k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  4.68k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  4.68k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 2.34k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 2.34k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|  2.34k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 2.34k, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 2.34k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 2.34k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 2.34k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 2.34k, False: 0]
  |  |  ------------------
  ------------------
 6768|  2.34k|	int inputid = ctxt->input->id;
 6769|       |
 6770|  2.34k|	SKIP(7);
  ------------------
  |  | 2245|  2.34k|#define SKIP(val) do {							\
  |  | 2246|  2.34k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.34k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.34k]
  |  |  ------------------
  |  | 2248|  2.34k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.34k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6771|  2.34k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.34k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6771:6): [True: 0, False: 2.34k]
  ------------------
 6772|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6773|      0|		           "Space required after 'ELEMENT'\n");
 6774|      0|	    return(-1);
 6775|      0|	}
 6776|  2.34k|        name = xmlParseName(ctxt);
 6777|  2.34k|	if (name == NULL) {
  ------------------
  |  Branch (6777:6): [True: 0, False: 2.34k]
  ------------------
 6778|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6779|      0|			   "xmlParseElementDecl: no name for Element\n");
 6780|      0|	    return(-1);
 6781|      0|	}
 6782|  2.34k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  2.34k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6782:6): [True: 0, False: 2.34k]
  ------------------
 6783|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6784|      0|			   "Space required after the element name\n");
 6785|      0|	}
 6786|  2.34k|	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {
  ------------------
  |  | 2231|  2.34k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  4.68k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 507, False: 1.83k]
  |  |  |  |  |  Branch (2228:41): [True: 507, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|  2.34k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 507, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 507, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 507, False: 0]
  |  |  ------------------
  ------------------
 6787|    507|	    SKIP(5);
  ------------------
  |  | 2245|    507|#define SKIP(val) do {							\
  |  | 2246|    507|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    507|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 507]
  |  |  ------------------
  |  | 2248|    507|        xmlParserGrow(ctxt);						\
  |  | 2249|    507|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6788|       |	    /*
 6789|       |	     * Element must always be empty.
 6790|       |	     */
 6791|    507|	    ret = XML_ELEMENT_TYPE_EMPTY;
 6792|  1.83k|	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2221|  1.83k|#define RAW (*ctxt->input->cur)
  ------------------
              	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2223|     27|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6792:13): [True: 27, False: 1.80k]
  |  Branch (6792:29): [True: 27, False: 0]
  ------------------
 6793|  1.83k|	           (NXT(2) == 'Y')) {
  ------------------
  |  | 2223|     27|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6793:13): [True: 27, False: 0]
  ------------------
 6794|     27|	    SKIP(3);
  ------------------
  |  | 2245|     27|#define SKIP(val) do {							\
  |  | 2246|     27|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     27|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 27]
  |  |  ------------------
  |  | 2248|     27|        xmlParserGrow(ctxt);						\
  |  | 2249|     27|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6795|       |	    /*
 6796|       |	     * Element is a generic container.
 6797|       |	     */
 6798|     27|	    ret = XML_ELEMENT_TYPE_ANY;
 6799|  1.80k|	} else if (RAW == '(') {
  ------------------
  |  | 2221|  1.80k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6799:13): [True: 1.80k, False: 3]
  ------------------
 6800|  1.80k|	    ret = xmlParseElementContentDecl(ctxt, name, &content);
 6801|  1.80k|	} else {
 6802|       |	    /*
 6803|       |	     * [ WFC: PEs in Internal Subset ] error handling.
 6804|       |	     */
 6805|      3|	    if ((RAW == '%') && (ctxt->external == 0) &&
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6805:10): [True: 0, False: 3]
  |  Branch (6805:26): [True: 0, False: 0]
  ------------------
 6806|      3|	        (ctxt->inputNr == 1)) {
  ------------------
  |  Branch (6806:10): [True: 0, False: 0]
  ------------------
 6807|      0|		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6808|      0|	  "PEReference: forbidden within markup decl in internal subset\n");
 6809|      3|	    } else {
 6810|      3|		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6811|      3|		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
 6812|      3|            }
 6813|      3|	    return(-1);
 6814|      3|	}
 6815|       |
 6816|  2.33k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.33k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6817|       |
 6818|  2.33k|	if (RAW != '>') {
  ------------------
  |  | 2221|  2.33k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6818:6): [True: 3, False: 2.33k]
  ------------------
 6819|      3|	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6820|      3|	    if (content != NULL) {
  ------------------
  |  Branch (6820:10): [True: 0, False: 3]
  ------------------
 6821|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6822|      0|	    }
 6823|  2.33k|	} else {
 6824|  2.33k|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6824:10): [True: 0, False: 2.33k]
  ------------------
 6825|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6826|      0|                               "Element declaration doesn't start and stop in"
 6827|      0|                               " the same entity\n");
 6828|      0|	    }
 6829|       |
 6830|  2.33k|	    NEXT;
  ------------------
  |  | 2275|  2.33k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6831|  2.33k|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6831:10): [True: 2.33k, False: 0]
  |  Branch (6831:33): [True: 2.33k, False: 0]
  ------------------
 6832|  2.33k|		(ctxt->sax->elementDecl != NULL)) {
  ------------------
  |  Branch (6832:3): [True: 2.33k, False: 0]
  ------------------
 6833|  2.33k|		if (content != NULL)
  ------------------
  |  Branch (6833:7): [True: 1.80k, False: 534]
  ------------------
 6834|  1.80k|		    content->parent = NULL;
 6835|  2.33k|	        ctxt->sax->elementDecl(ctxt->userData, name, ret,
 6836|  2.33k|		                       content);
 6837|  2.33k|		if ((content != NULL) && (content->parent == NULL)) {
  ------------------
  |  Branch (6837:7): [True: 1.80k, False: 534]
  |  Branch (6837:28): [True: 3, False: 1.79k]
  ------------------
 6838|       |		    /*
 6839|       |		     * this is a trick: if xmlAddElementDecl is called,
 6840|       |		     * instead of copying the full tree it is plugged directly
 6841|       |		     * if called from the parser. Avoid duplicating the
 6842|       |		     * interfaces or change the API/ABI
 6843|       |		     */
 6844|      3|		    xmlFreeDocElementContent(ctxt->myDoc, content);
 6845|      3|		}
 6846|  2.33k|	    } else if (content != NULL) {
  ------------------
  |  Branch (6846:17): [True: 0, False: 0]
  ------------------
 6847|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6848|      0|	    }
 6849|  2.33k|	}
 6850|  2.33k|    }
 6851|  2.33k|    return(ret);
 6852|  2.34k|}
xmlParseMarkupDecl:
 7015|   487k|xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 7016|   487k|    GROW;
  ------------------
  |  | 2270|   487k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   487k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 432k, False: 54.9k]
  |  |  ------------------
  |  | 2271|   487k|	xmlParserGrow(ctxt);
  ------------------
 7017|   487k|    if (CUR == '<') {
  ------------------
  |  | 2222|   487k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7017:9): [True: 487k, False: 0]
  ------------------
 7018|   487k|        if (NXT(1) == '!') {
  ------------------
  |  | 2223|   487k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7018:13): [True: 487k, False: 3]
  ------------------
 7019|   487k|	    switch (NXT(2)) {
  ------------------
  |  | 2223|   487k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
 7020|  4.10k|	        case 'E':
  ------------------
  |  Branch (7020:10): [True: 4.10k, False: 483k]
  ------------------
 7021|  4.10k|		    if (NXT(3) == 'L')
  ------------------
  |  | 2223|  4.10k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7021:11): [True: 2.34k, False: 1.76k]
  ------------------
 7022|  2.34k|			xmlParseElementDecl(ctxt);
 7023|  1.76k|		    else if (NXT(3) == 'N')
  ------------------
  |  | 2223|  1.76k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7023:16): [True: 1.76k, False: 0]
  ------------------
 7024|  1.76k|			xmlParseEntityDecl(ctxt);
 7025|      0|                    else
 7026|      0|                        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7027|  4.10k|		    break;
 7028|  1.50k|	        case 'A':
  ------------------
  |  Branch (7028:10): [True: 1.50k, False: 486k]
  ------------------
 7029|  1.50k|		    xmlParseAttributeListDecl(ctxt);
 7030|  1.50k|		    break;
 7031|      0|	        case 'N':
  ------------------
  |  Branch (7031:10): [True: 0, False: 487k]
  ------------------
 7032|      0|		    xmlParseNotationDecl(ctxt);
 7033|      0|		    break;
 7034|   482k|	        case '-':
  ------------------
  |  Branch (7034:10): [True: 482k, False: 5.61k]
  ------------------
 7035|   482k|		    xmlParseComment(ctxt);
 7036|   482k|		    break;
 7037|      6|		default:
  ------------------
  |  Branch (7037:3): [True: 6, False: 487k]
  ------------------
 7038|       |		    /* there is an error but it will be detected later */
 7039|      6|                    SKIP(2);
  ------------------
  |  | 2245|      6|#define SKIP(val) do {							\
  |  | 2246|      6|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      6|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 6]
  |  |  ------------------
  |  | 2248|      6|        xmlParserGrow(ctxt);						\
  |  | 2249|      6|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7040|      6|		    break;
 7041|   487k|	    }
 7042|   487k|	} else if (NXT(1) == '?') {
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7042:13): [True: 3, False: 0]
  ------------------
 7043|      3|	    xmlParsePI(ctxt);
 7044|      3|	}
 7045|   487k|    }
 7046|       |
 7047|       |    /*
 7048|       |     * detect requirement to exit there and act accordingly
 7049|       |     * and avoid having instate overridden later on
 7050|       |     */
 7051|   487k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7051:9): [True: 6, False: 487k]
  ------------------
 7052|      6|        return;
 7053|       |
 7054|   487k|    ctxt->instate = XML_PARSER_DTD;
 7055|   487k|}
xmlParseTextDecl:
 7069|     18|xmlParseTextDecl(xmlParserCtxtPtr ctxt) {
 7070|     18|    xmlChar *version;
 7071|     18|    int oldstate;
 7072|       |
 7073|       |    /*
 7074|       |     * We know that '<?xml' is here.
 7075|       |     */
 7076|     18|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|     18|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     36|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 18, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 18, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     18|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 18, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 18, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 18, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|     18|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     18|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 18, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|     18|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|     18|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 7077|     18|	SKIP(5);
  ------------------
  |  | 2245|     18|#define SKIP(val) do {							\
  |  | 2246|     18|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     18|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2248|     18|        xmlParserGrow(ctxt);						\
  |  | 2249|     18|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7078|     18|    } else {
 7079|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);
 7080|      0|	return;
 7081|      0|    }
 7082|       |
 7083|       |    /* Avoid expansion of parameter entities when skipping blanks. */
 7084|     18|    oldstate = ctxt->instate;
 7085|     18|    ctxt->instate = XML_PARSER_START;
 7086|       |
 7087|     18|    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     18|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (7087:9): [True: 0, False: 18]
  ------------------
 7088|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 7089|      0|		       "Space needed after '<?xml'\n");
 7090|      0|    }
 7091|       |
 7092|       |    /*
 7093|       |     * We may have the VersionInfo here.
 7094|       |     */
 7095|     18|    version = xmlParseVersionInfo(ctxt);
 7096|     18|    if (version == NULL)
  ------------------
  |  Branch (7096:9): [True: 0, False: 18]
  ------------------
 7097|      0|	version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|      0|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
 7098|     18|    else {
 7099|     18|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     18|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (7099:6): [True: 0, False: 18]
  ------------------
 7100|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 7101|      0|		           "Space needed here\n");
 7102|      0|	}
 7103|     18|    }
 7104|     18|    ctxt->input->version = version;
 7105|       |
 7106|       |    /*
 7107|       |     * We must have the encoding declaration
 7108|       |     */
 7109|     18|    xmlParseEncodingDecl(ctxt);
 7110|     18|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7110:9): [True: 0, False: 18]
  ------------------
 7111|      0|        return;
 7112|     18|    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (7112:9): [True: 0, False: 18]
  ------------------
 7113|       |	/*
 7114|       |	 * The XML REC instructs us to stop parsing right here
 7115|       |	 */
 7116|      0|        ctxt->instate = oldstate;
 7117|      0|        return;
 7118|      0|    }
 7119|       |
 7120|     18|    SKIP_BLANKS;
  ------------------
  |  | 2273|     18|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7121|     18|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     18|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     18|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7121:9): [True: 18, False: 0]
  |  Branch (7121:25): [True: 18, False: 0]
  ------------------
 7122|     18|        SKIP(2);
  ------------------
  |  | 2245|     18|#define SKIP(val) do {							\
  |  | 2246|     18|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     18|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 18]
  |  |  ------------------
  |  | 2248|     18|        xmlParserGrow(ctxt);						\
  |  | 2249|     18|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7123|     18|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7123:16): [True: 0, False: 0]
  ------------------
 7124|       |        /* Deprecated old WD ... */
 7125|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 7126|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 7127|      0|    } else {
 7128|      0|        int c;
 7129|       |
 7130|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
 7131|      0|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7131:16): [True: 0, False: 0]
  ------------------
 7132|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 7133|      0|            if (c == '>')
  ------------------
  |  Branch (7133:17): [True: 0, False: 0]
  ------------------
 7134|      0|                break;
 7135|      0|        }
 7136|      0|    }
 7137|       |
 7138|     18|    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (7138:9): [True: 18, False: 0]
  ------------------
 7139|     18|        ctxt->instate = oldstate;
 7140|     18|}
xmlParseExternalSubset:
 7156|     63|                       const xmlChar *SystemID) {
 7157|     63|    xmlDetectSAX2(ctxt);
 7158|       |
 7159|     63|    xmlDetectEncoding(ctxt);
 7160|       |
 7161|     63|    if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {
  ------------------
  |  | 2231|     63|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    126|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 63, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 9, False: 54]
  |  |  |  |  ------------------
  |  |  |  | 2229|     63|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 9, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 9, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 7162|      9|	xmlParseTextDecl(ctxt);
 7163|      9|	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (7163:6): [True: 0, False: 9]
  ------------------
 7164|       |	    /*
 7165|       |	     * The XML REC instructs us to stop parsing right here
 7166|       |	     */
 7167|      0|	    xmlHaltParser(ctxt);
 7168|      0|	    return;
 7169|      0|	}
 7170|      9|    }
 7171|     63|    if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (7171:9): [True: 0, False: 63]
  ------------------
 7172|      0|        ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7173|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (7173:6): [True: 0, False: 0]
  ------------------
 7174|      0|	    xmlErrMemory(ctxt, "New Doc failed");
 7175|      0|	    return;
 7176|      0|	}
 7177|      0|	ctxt->myDoc->properties = XML_DOC_INTERNAL;
 7178|      0|    }
 7179|     63|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))
  ------------------
  |  Branch (7179:9): [True: 63, False: 0]
  |  Branch (7179:34): [True: 0, False: 63]
  ------------------
 7180|      0|        xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);
 7181|       |
 7182|     63|    ctxt->instate = XML_PARSER_DTD;
 7183|     63|    ctxt->external = 1;
 7184|     63|    SKIP_BLANKS;
  ------------------
  |  | 2273|     63|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7185|  3.73k|    while ((ctxt->instate != XML_PARSER_EOF) && (RAW != 0)) {
  ------------------
  |  | 2221|  3.72k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7185:12): [True: 3.72k, False: 9]
  |  Branch (7185:49): [True: 3.67k, False: 51]
  ------------------
 7186|  3.67k|	GROW;
  ------------------
  |  | 2270|  3.67k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.67k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 168, False: 3.50k]
  |  |  ------------------
  |  | 2271|  3.67k|	xmlParserGrow(ctxt);
  ------------------
 7187|  3.67k|        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|  3.67k|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|  3.66k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|  3.66k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7187:13): [True: 3.66k, False: 3]
  |  Branch (7187:29): [True: 3.66k, False: 0]
  |  Branch (7187:48): [True: 9, False: 3.66k]
  ------------------
 7188|      9|            xmlParseConditionalSections(ctxt);
 7189|  3.66k|        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|  3.66k|#define RAW (*ctxt->input->cur)
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|  3.66k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7189:20): [True: 3.66k, False: 3]
  |  Branch (7189:37): [True: 3.66k, False: 0]
  |  Branch (7189:56): [True: 0, False: 0]
  ------------------
 7190|  3.66k|            xmlParseMarkupDecl(ctxt);
 7191|  3.66k|        } else {
 7192|      3|            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 7193|      3|            xmlHaltParser(ctxt);
 7194|      3|            return;
 7195|      3|        }
 7196|  3.66k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  3.66k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 7197|  3.66k|        SHRINK;
  ------------------
  |  | 2265|  3.66k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 3.66k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  3.66k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  3.66k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 2.97k, False: 696]
  |  |  ------------------
  |  | 2267|  3.66k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  2.97k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 51, False: 2.92k]
  |  |  ------------------
  |  | 2268|  3.66k|	xmlParserShrink(ctxt);
  ------------------
 7198|  3.66k|    }
 7199|       |
 7200|     60|    if (RAW != 0) {
  ------------------
  |  | 2221|     60|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7200:9): [True: 0, False: 60]
  ------------------
 7201|      0|	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 7202|      0|    }
 7203|       |
 7204|     60|}
xmlParseReference:
 7222|  9.09k|xmlParseReference(xmlParserCtxtPtr ctxt) {
 7223|  9.09k|    xmlEntityPtr ent;
 7224|  9.09k|    xmlChar *val;
 7225|  9.09k|    int was_checked;
 7226|  9.09k|    xmlNodePtr list = NULL;
 7227|  9.09k|    xmlParserErrors ret = XML_ERR_OK;
 7228|       |
 7229|       |
 7230|  9.09k|    if (RAW != '&')
  ------------------
  |  | 2221|  9.09k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7230:9): [True: 0, False: 9.09k]
  ------------------
 7231|      0|        return;
 7232|       |
 7233|       |    /*
 7234|       |     * Simple case of a CharRef
 7235|       |     */
 7236|  9.09k|    if (NXT(1) == '#') {
  ------------------
  |  | 2223|  9.09k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7236:9): [True: 48, False: 9.04k]
  ------------------
 7237|     48|	int i = 0;
 7238|     48|	xmlChar out[16];
 7239|     48|	int value = xmlParseCharRef(ctxt);
 7240|       |
 7241|     48|	if (value == 0)
  ------------------
  |  Branch (7241:6): [True: 3, False: 45]
  ------------------
 7242|      3|	    return;
 7243|       |
 7244|       |        /*
 7245|       |         * Just encode the value in UTF-8
 7246|       |         */
 7247|     45|        COPY_BUF(out, i, value);
  ------------------
  |  | 2295|     45|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 9, False: 36]
  |  |  ------------------
  |  | 2296|     45|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 7248|     45|        out[i] = 0;
 7249|     45|        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7249:13): [True: 45, False: 0]
  |  Branch (7249:36): [True: 45, False: 0]
  ------------------
 7250|     45|            (!ctxt->disableSAX))
  ------------------
  |  Branch (7250:13): [True: 45, False: 0]
  ------------------
 7251|     45|            ctxt->sax->characters(ctxt->userData, out, i);
 7252|     45|	return;
 7253|     48|    }
 7254|       |
 7255|       |    /*
 7256|       |     * We are seeing an entity reference
 7257|       |     */
 7258|  9.04k|    ent = xmlParseEntityRef(ctxt);
 7259|  9.04k|    if (ent == NULL) return;
  ------------------
  |  Branch (7259:9): [True: 3, False: 9.03k]
  ------------------
 7260|  9.03k|    if (!ctxt->wellFormed)
  ------------------
  |  Branch (7260:9): [True: 3, False: 9.03k]
  ------------------
 7261|      3|	return;
 7262|  9.03k|    was_checked = ent->flags & XML_ENT_PARSED;
  ------------------
  |  |   14|  9.03k|#define XML_ENT_PARSED      (1<<0)
  ------------------
 7263|       |
 7264|       |    /* special case of predefined entities */
 7265|  9.03k|    if ((ent->name == NULL) ||
  ------------------
  |  Branch (7265:9): [True: 0, False: 9.03k]
  ------------------
 7266|  9.03k|        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7266:9): [True: 606, False: 8.43k]
  ------------------
 7267|    606|	val = ent->content;
 7268|    606|	if (val == NULL) return;
  ------------------
  |  Branch (7268:6): [True: 0, False: 606]
  ------------------
 7269|       |	/*
 7270|       |	 * inline the entity.
 7271|       |	 */
 7272|    606|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7272:6): [True: 606, False: 0]
  |  Branch (7272:29): [True: 606, False: 0]
  ------------------
 7273|    606|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (7273:6): [True: 606, False: 0]
  ------------------
 7274|    606|	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));
 7275|    606|	return;
 7276|    606|    }
 7277|       |
 7278|       |    /*
 7279|       |     * The first reference to the entity trigger a parsing phase
 7280|       |     * where the ent->children is filled with the result from
 7281|       |     * the parsing.
 7282|       |     * Note: external parsed entities will not be loaded, it is not
 7283|       |     * required for a non-validating parser, unless the parsing option
 7284|       |     * of validating, or substituting entities were given. Doing so is
 7285|       |     * far more secure as the parser will only process data coming from
 7286|       |     * the document entity by default.
 7287|       |     *
 7288|       |     * FIXME: This doesn't work correctly since entities can be
 7289|       |     * expanded with different namespace declarations in scope.
 7290|       |     * For example:
 7291|       |     *
 7292|       |     * <!DOCTYPE doc [
 7293|       |     *   <!ENTITY ent "<ns:elem/>">
 7294|       |     * ]>
 7295|       |     * <doc>
 7296|       |     *   <decl1 xmlns:ns="urn:ns1">
 7297|       |     *     &ent;
 7298|       |     *   </decl1>
 7299|       |     *   <decl2 xmlns:ns="urn:ns2">
 7300|       |     *     &ent;
 7301|       |     *   </decl2>
 7302|       |     * </doc>
 7303|       |     *
 7304|       |     * Proposed fix:
 7305|       |     *
 7306|       |     * - Remove the ent->owner optimization which tries to avoid the
 7307|       |     *   initial copy of the entity. Always make entities own the
 7308|       |     *   subtree.
 7309|       |     * - Ignore current namespace declarations when parsing the
 7310|       |     *   entity. If a prefix can't be resolved, don't report an error
 7311|       |     *   but mark it as unresolved.
 7312|       |     * - Try to resolve these prefixes when expanding the entity.
 7313|       |     *   This will require a specialized version of xmlStaticCopyNode
 7314|       |     *   which can also make use of the namespace hash table to avoid
 7315|       |     *   quadratic behavior.
 7316|       |     *
 7317|       |     * Alternatively, we could simply reparse the entity on each
 7318|       |     * expansion like we already do with custom SAX callbacks.
 7319|       |     * External entity content should be cached in this case.
 7320|       |     */
 7321|  8.43k|    if (((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|  8.43k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (7321:9): [True: 360, False: 8.07k]
  ------------------
 7322|  8.43k|        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
  ------------------
  |  Branch (7322:10): [True: 327, False: 33]
  ------------------
 7323|    360|         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
  ------------------
  |  Branch (7323:10): [True: 33, False: 0]
  ------------------
 7324|    360|	unsigned long oldsizeentcopy = ctxt->sizeentcopy;
 7325|       |
 7326|       |	/*
 7327|       |	 * This is a bit hackish but this seems the best
 7328|       |	 * way to make sure both SAX and DOM entity support
 7329|       |	 * behaves okay.
 7330|       |	 */
 7331|    360|	void *user_data;
 7332|    360|	if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7332:6): [True: 360, False: 0]
  ------------------
 7333|    360|	    user_data = NULL;
 7334|      0|	else
 7335|      0|	    user_data = ctxt->userData;
 7336|       |
 7337|       |        /* Avoid overflow as much as possible */
 7338|    360|        ctxt->sizeentcopy = 0;
 7339|       |
 7340|    360|        if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|    360|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (7340:13): [True: 3, False: 357]
  ------------------
 7341|      3|            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7342|      3|            xmlHaltParser(ctxt);
 7343|      3|            return;
 7344|      3|        }
 7345|       |
 7346|    357|        ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|    357|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7347|       |
 7348|       |	/*
 7349|       |	 * Check that this entity is well formed
 7350|       |	 * 4.3.2: An internal general parsed entity is well-formed
 7351|       |	 * if its replacement text matches the production labeled
 7352|       |	 * content.
 7353|       |	 */
 7354|    357|	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7354:6): [True: 327, False: 30]
  ------------------
 7355|    327|	    ctxt->depth++;
 7356|    327|	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
 7357|    327|	                                              user_data, &list);
 7358|    327|	    ctxt->depth--;
 7359|       |
 7360|    327|	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
  ------------------
  |  Branch (7360:13): [True: 30, False: 0]
  ------------------
 7361|     30|	    ctxt->depth++;
 7362|     30|	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
 7363|     30|	                                   user_data, ctxt->depth, ent->URI,
 7364|     30|					   ent->ExternalID, &list);
 7365|     30|	    ctxt->depth--;
 7366|     30|	} else {
 7367|      0|	    ret = XML_ERR_ENTITY_PE_INTERNAL;
 7368|      0|	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7369|      0|			 "invalid entity type found\n", NULL);
 7370|      0|	}
 7371|       |
 7372|    357|        ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|    357|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7373|    357|        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   14|    357|#define XML_ENT_PARSED      (1<<0)
  ------------------
                      ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   15|    357|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 7374|    357|        ent->expandedSize = ctxt->sizeentcopy;
 7375|    357|	if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7375:6): [True: 141, False: 216]
  ------------------
 7376|    141|            xmlHaltParser(ctxt);
 7377|    141|	    xmlFreeNodeList(list);
 7378|    141|	    return;
 7379|    141|	}
 7380|    216|	if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {
  ------------------
  |  Branch (7380:6): [True: 0, False: 216]
  ------------------
 7381|      0|	    xmlFreeNodeList(list);
 7382|      0|	    return;
 7383|      0|	}
 7384|       |
 7385|    216|	if ((ret == XML_ERR_OK) && (list != NULL)) {
  ------------------
  |  Branch (7385:6): [True: 210, False: 6]
  |  Branch (7385:29): [True: 210, False: 0]
  ------------------
 7386|    210|            ent->children = list;
 7387|       |            /*
 7388|       |             * Prune it directly in the generated document
 7389|       |             * except for single text nodes.
 7390|       |             */
 7391|    210|            if ((ctxt->replaceEntities == 0) ||
  ------------------
  |  Branch (7391:17): [True: 0, False: 210]
  ------------------
 7392|    210|                (ctxt->parseMode == XML_PARSE_READER) ||
  ------------------
  |  Branch (7392:17): [True: 52, False: 158]
  ------------------
 7393|    210|                ((list->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (7393:18): [True: 133, False: 25]
  ------------------
 7394|    181|                 (list->next == NULL))) {
  ------------------
  |  Branch (7394:18): [True: 129, False: 4]
  ------------------
 7395|    181|                ent->owner = 1;
 7396|    382|                while (list != NULL) {
  ------------------
  |  Branch (7396:24): [True: 201, False: 181]
  ------------------
 7397|    201|                    list->parent = (xmlNodePtr) ent;
 7398|    201|                    if (list->doc != ent->doc)
  ------------------
  |  Branch (7398:25): [True: 0, False: 201]
  ------------------
 7399|      0|                        xmlSetTreeDoc(list, ent->doc);
 7400|    201|                    if (list->next == NULL)
  ------------------
  |  Branch (7400:25): [True: 181, False: 20]
  ------------------
 7401|    181|                        ent->last = list;
 7402|    201|                    list = list->next;
 7403|    201|                }
 7404|    181|                list = NULL;
 7405|    181|            } else {
 7406|     29|                ent->owner = 0;
 7407|     98|                while (list != NULL) {
  ------------------
  |  Branch (7407:24): [True: 69, False: 29]
  ------------------
 7408|     69|                    list->parent = (xmlNodePtr) ctxt->node;
 7409|     69|                    list->doc = ctxt->myDoc;
 7410|     69|                    if (list->next == NULL)
  ------------------
  |  Branch (7410:25): [True: 29, False: 40]
  ------------------
 7411|     29|                        ent->last = list;
 7412|     69|                    list = list->next;
 7413|     69|                }
 7414|     29|                list = ent->children;
 7415|       |#ifdef LIBXML_LEGACY_ENABLED
 7416|       |                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7417|       |                    xmlAddEntityReference(ent, list, NULL);
 7418|       |#endif /* LIBXML_LEGACY_ENABLED */
 7419|     29|            }
 7420|    210|	} else if ((ret != XML_ERR_OK) &&
  ------------------
  |  Branch (7420:13): [True: 6, False: 0]
  ------------------
 7421|      6|		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
  ------------------
  |  Branch (7421:6): [True: 3, False: 3]
  ------------------
 7422|      3|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7423|      3|		     "Entity '%s' failed to parse\n", ent->name);
 7424|      3|            if (ent->content != NULL)
  ------------------
  |  Branch (7424:17): [True: 0, False: 3]
  ------------------
 7425|      0|                ent->content[0] = 0;
 7426|      3|	} else if (list != NULL) {
  ------------------
  |  Branch (7426:13): [True: 0, False: 3]
  ------------------
 7427|      0|	    xmlFreeNodeList(list);
 7428|      0|	    list = NULL;
 7429|      0|	}
 7430|       |
 7431|       |        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7432|    216|        was_checked = 0;
 7433|    216|    }
 7434|       |
 7435|       |    /*
 7436|       |     * Now that the entity content has been gathered
 7437|       |     * provide it to the application, this can take different forms based
 7438|       |     * on the parsing modes.
 7439|       |     */
 7440|  8.28k|    if (ent->children == NULL) {
  ------------------
  |  Branch (7440:9): [True: 6, False: 8.28k]
  ------------------
 7441|       |	/*
 7442|       |	 * Probably running in SAX mode and the callbacks don't
 7443|       |	 * build the entity content. So unless we already went
 7444|       |	 * though parsing for first checking go though the entity
 7445|       |	 * content to generate callbacks associated to the entity
 7446|       |	 */
 7447|      6|	if (was_checked != 0) {
  ------------------
  |  Branch (7447:6): [True: 0, False: 6]
  ------------------
 7448|      0|	    void *user_data;
 7449|       |	    /*
 7450|       |	     * This is a bit hackish but this seems the best
 7451|       |	     * way to make sure both SAX and DOM entity support
 7452|       |	     * behaves okay.
 7453|       |	     */
 7454|      0|	    if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7454:10): [True: 0, False: 0]
  ------------------
 7455|      0|		user_data = NULL;
 7456|      0|	    else
 7457|      0|		user_data = ctxt->userData;
 7458|       |
 7459|      0|	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7459:10): [True: 0, False: 0]
  ------------------
 7460|      0|		ctxt->depth++;
 7461|      0|		ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7462|      0|				   ent->content, user_data, NULL);
 7463|      0|		ctxt->depth--;
 7464|      0|	    } else if (ent->etype ==
  ------------------
  |  Branch (7464:17): [True: 0, False: 0]
  ------------------
 7465|      0|		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7466|      0|	        unsigned long oldsizeentities = ctxt->sizeentities;
 7467|       |
 7468|      0|		ctxt->depth++;
 7469|      0|		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,
 7470|      0|			   ctxt->sax, user_data, ctxt->depth,
 7471|      0|			   ent->URI, ent->ExternalID, NULL);
 7472|      0|		ctxt->depth--;
 7473|       |
 7474|       |                /* Undo the change to sizeentities */
 7475|      0|                ctxt->sizeentities = oldsizeentities;
 7476|      0|	    } else {
 7477|      0|		ret = XML_ERR_ENTITY_PE_INTERNAL;
 7478|      0|		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7479|      0|			     "invalid entity type found\n", NULL);
 7480|      0|	    }
 7481|      0|	    if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7481:10): [True: 0, False: 0]
  ------------------
 7482|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7483|      0|		return;
 7484|      0|	    }
 7485|      0|            if (xmlParserEntityCheck(ctxt, 0))
  ------------------
  |  Branch (7485:17): [True: 0, False: 0]
  ------------------
 7486|      0|                return;
 7487|      0|	}
 7488|      6|	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7488:6): [True: 6, False: 0]
  |  Branch (7488:29): [True: 6, False: 0]
  ------------------
 7489|      6|	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7489:6): [True: 0, False: 6]
  |  Branch (7489:38): [True: 0, False: 0]
  ------------------
 7490|       |	    /*
 7491|       |	     * Entity reference callback comes second, it's somewhat
 7492|       |	     * superfluous but a compatibility to historical behaviour
 7493|       |	     */
 7494|      0|	    ctxt->sax->reference(ctxt->userData, ent->name);
 7495|      0|	}
 7496|      6|	return;
 7497|      6|    }
 7498|       |
 7499|       |    /*
 7500|       |     * We also check for amplification if entities aren't substituted.
 7501|       |     * They might be expanded later.
 7502|       |     */
 7503|  8.28k|    if ((was_checked != 0) &&
  ------------------
  |  Branch (7503:9): [True: 8.07k, False: 210]
  ------------------
 7504|  8.28k|        (xmlParserEntityCheck(ctxt, ent->expandedSize)))
  ------------------
  |  Branch (7504:9): [True: 6, False: 8.06k]
  ------------------
 7505|      6|        return;
 7506|       |
 7507|       |    /*
 7508|       |     * If we didn't get any children for the entity being built
 7509|       |     */
 7510|  8.27k|    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7510:9): [True: 8.27k, False: 0]
  |  Branch (7510:32): [True: 8.27k, False: 0]
  ------------------
 7511|  8.27k|	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7511:2): [True: 0, False: 8.27k]
  |  Branch (7511:34): [True: 0, False: 0]
  ------------------
 7512|       |	/*
 7513|       |	 * Create a node.
 7514|       |	 */
 7515|      0|	ctxt->sax->reference(ctxt->userData, ent->name);
 7516|      0|	return;
 7517|      0|    }
 7518|       |
 7519|  8.27k|    if (ctxt->replaceEntities)  {
  ------------------
  |  Branch (7519:9): [True: 8.27k, False: 0]
  ------------------
 7520|       |	/*
 7521|       |	 * There is a problem on the handling of _private for entities
 7522|       |	 * (bug 155816): Should we copy the content of the field from
 7523|       |	 * the entity (possibly overwriting some value set by the user
 7524|       |	 * when a copy is created), should we leave it alone, or should
 7525|       |	 * we try to take care of different situations?  The problem
 7526|       |	 * is exacerbated by the usage of this field by the xmlReader.
 7527|       |	 * To fix this bug, we look at _private on the created node
 7528|       |	 * and, if it's NULL, we copy in whatever was in the entity.
 7529|       |	 * If it's not NULL we leave it alone.  This is somewhat of a
 7530|       |	 * hack - maybe we should have further tests to determine
 7531|       |	 * what to do.
 7532|       |	 */
 7533|  8.27k|	if (ctxt->node != NULL) {
  ------------------
  |  Branch (7533:6): [True: 8.27k, False: 0]
  ------------------
 7534|       |	    /*
 7535|       |	     * Seems we are generating the DOM content, do
 7536|       |	     * a simple tree copy for all references except the first
 7537|       |	     * In the first occurrence list contains the replacement.
 7538|       |	     */
 7539|  8.27k|	    if (((list == NULL) && (ent->owner == 0)) ||
  ------------------
  |  Branch (7539:11): [True: 8.24k, False: 29]
  |  Branch (7539:29): [True: 0, False: 8.24k]
  ------------------
 7540|  8.27k|		(ctxt->parseMode == XML_PARSE_READER)) {
  ------------------
  |  Branch (7540:3): [True: 2.59k, False: 5.67k]
  ------------------
 7541|  2.59k|		xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7542|       |
 7543|       |		/*
 7544|       |		 * when operating on a reader, the entities definitions
 7545|       |		 * are always owning the entities subtree.
 7546|       |		if (ctxt->parseMode == XML_PARSE_READER)
 7547|       |		    ent->owner = 1;
 7548|       |		 */
 7549|       |
 7550|  2.59k|		cur = ent->children;
 7551|  2.65k|		while (cur != NULL) {
  ------------------
  |  Branch (7551:10): [True: 2.65k, False: 0]
  ------------------
 7552|  2.65k|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7553|  2.65k|		    if (nw != NULL) {
  ------------------
  |  Branch (7553:11): [True: 2.65k, False: 0]
  ------------------
 7554|  2.65k|			if (nw->_private == NULL)
  ------------------
  |  Branch (7554:8): [True: 2.65k, False: 0]
  ------------------
 7555|  2.65k|			    nw->_private = cur->_private;
 7556|  2.65k|			if (firstChild == NULL){
  ------------------
  |  Branch (7556:8): [True: 2.59k, False: 59]
  ------------------
 7557|  2.59k|			    firstChild = nw;
 7558|  2.59k|			}
 7559|  2.65k|			nw = xmlAddChild(ctxt->node, nw);
 7560|  2.65k|		    }
 7561|  2.65k|		    if (cur == ent->last) {
  ------------------
  |  Branch (7561:11): [True: 2.59k, False: 59]
  ------------------
 7562|       |			/*
 7563|       |			 * needed to detect some strange empty
 7564|       |			 * node cases in the reader tests
 7565|       |			 */
 7566|  2.59k|			if ((ctxt->parseMode == XML_PARSE_READER) &&
  ------------------
  |  Branch (7566:8): [True: 2.59k, False: 0]
  ------------------
 7567|  2.59k|			    (nw != NULL) &&
  ------------------
  |  Branch (7567:8): [True: 2.59k, False: 0]
  ------------------
 7568|  2.59k|			    (nw->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7568:8): [True: 17, False: 2.58k]
  ------------------
 7569|  2.59k|			    (nw->children == NULL))
  ------------------
  |  Branch (7569:8): [True: 11, False: 6]
  ------------------
 7570|     11|			    nw->extra = 1;
 7571|       |
 7572|  2.59k|			break;
 7573|  2.59k|		    }
 7574|     59|		    cur = cur->next;
 7575|     59|		}
 7576|       |#ifdef LIBXML_LEGACY_ENABLED
 7577|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7578|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7579|       |#endif /* LIBXML_LEGACY_ENABLED */
 7580|  5.67k|	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {
  ------------------
  |  Branch (7580:17): [True: 5.64k, False: 29]
  |  Branch (7580:35): [True: 29, False: 0]
  ------------------
 7581|  5.67k|		xmlNodePtr nw = NULL, cur, next, last,
 7582|  5.67k|			   firstChild = NULL;
 7583|       |
 7584|       |		/*
 7585|       |		 * Copy the entity child list and make it the new
 7586|       |		 * entity child list. The goal is to make sure any
 7587|       |		 * ID or REF referenced will be the one from the
 7588|       |		 * document content and not the entity copy.
 7589|       |		 */
 7590|  5.67k|		cur = ent->children;
 7591|  5.67k|		ent->children = NULL;
 7592|  5.67k|		last = ent->last;
 7593|  5.67k|		ent->last = NULL;
 7594|  5.79k|		while (cur != NULL) {
  ------------------
  |  Branch (7594:10): [True: 5.79k, False: 0]
  ------------------
 7595|  5.79k|		    next = cur->next;
 7596|  5.79k|		    cur->next = NULL;
 7597|  5.79k|		    cur->parent = NULL;
 7598|  5.79k|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7599|  5.79k|		    if (nw != NULL) {
  ------------------
  |  Branch (7599:11): [True: 5.79k, False: 0]
  ------------------
 7600|  5.79k|			if (nw->_private == NULL)
  ------------------
  |  Branch (7600:8): [True: 5.79k, False: 0]
  ------------------
 7601|  5.79k|			    nw->_private = cur->_private;
 7602|  5.79k|			if (firstChild == NULL){
  ------------------
  |  Branch (7602:8): [True: 5.67k, False: 118]
  ------------------
 7603|  5.67k|			    firstChild = cur;
 7604|  5.67k|			}
 7605|  5.79k|			xmlAddChild((xmlNodePtr) ent, nw);
 7606|  5.79k|		    }
 7607|  5.79k|		    xmlAddChild(ctxt->node, cur);
 7608|  5.79k|		    if (cur == last)
  ------------------
  |  Branch (7608:11): [True: 5.67k, False: 118]
  ------------------
 7609|  5.67k|			break;
 7610|    118|		    cur = next;
 7611|    118|		}
 7612|  5.67k|		if (ent->owner == 0)
  ------------------
  |  Branch (7612:7): [True: 29, False: 5.64k]
  ------------------
 7613|     29|		    ent->owner = 1;
 7614|       |#ifdef LIBXML_LEGACY_ENABLED
 7615|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7616|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7617|       |#endif /* LIBXML_LEGACY_ENABLED */
 7618|  5.67k|	    } else {
 7619|      0|		const xmlChar *nbktext;
 7620|       |
 7621|       |		/*
 7622|       |		 * the name change is to avoid coalescing of the
 7623|       |		 * node with a possible previous text one which
 7624|       |		 * would make ent->children a dangling pointer
 7625|       |		 */
 7626|      0|		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7627|      0|					-1);
 7628|      0|		if (ent->children->type == XML_TEXT_NODE)
  ------------------
  |  Branch (7628:7): [True: 0, False: 0]
  ------------------
 7629|      0|		    ent->children->name = nbktext;
 7630|      0|		if ((ent->last != ent->children) &&
  ------------------
  |  Branch (7630:7): [True: 0, False: 0]
  ------------------
 7631|      0|		    (ent->last->type == XML_TEXT_NODE))
  ------------------
  |  Branch (7631:7): [True: 0, False: 0]
  ------------------
 7632|      0|		    ent->last->name = nbktext;
 7633|      0|		xmlAddChildList(ctxt->node, ent->children);
 7634|      0|	    }
 7635|       |
 7636|       |	    /*
 7637|       |	     * This is to avoid a nasty side effect, see
 7638|       |	     * characters() in SAX.c
 7639|       |	     */
 7640|  8.27k|	    ctxt->nodemem = 0;
 7641|  8.27k|	    ctxt->nodelen = 0;
 7642|  8.27k|	    return;
 7643|  8.27k|	}
 7644|  8.27k|    }
 7645|  8.27k|}
xmlParseEntityRef:
 7678|  15.8k|xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7679|  15.8k|    const xmlChar *name;
 7680|  15.8k|    xmlEntityPtr ent = NULL;
 7681|       |
 7682|  15.8k|    GROW;
  ------------------
  |  | 2270|  15.8k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  15.8k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.26k, False: 10.6k]
  |  |  ------------------
  |  | 2271|  15.8k|	xmlParserGrow(ctxt);
  ------------------
 7683|  15.8k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7683:9): [True: 0, False: 15.8k]
  ------------------
 7684|      0|        return(NULL);
 7685|       |
 7686|  15.8k|    if (RAW != '&')
  ------------------
  |  | 2221|  15.8k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7686:9): [True: 0, False: 15.8k]
  ------------------
 7687|      0|        return(NULL);
 7688|  15.8k|    NEXT;
  ------------------
  |  | 2275|  15.8k|#define NEXT xmlNextChar(ctxt)
  ------------------
 7689|  15.8k|    name = xmlParseName(ctxt);
 7690|  15.8k|    if (name == NULL) {
  ------------------
  |  Branch (7690:9): [True: 0, False: 15.8k]
  ------------------
 7691|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7692|      0|		       "xmlParseEntityRef: no name\n");
 7693|      0|        return(NULL);
 7694|      0|    }
 7695|  15.8k|    if (RAW != ';') {
  ------------------
  |  | 2221|  15.8k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7695:9): [True: 0, False: 15.8k]
  ------------------
 7696|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7697|      0|	return(NULL);
 7698|      0|    }
 7699|  15.8k|    NEXT;
  ------------------
  |  | 2275|  15.8k|#define NEXT xmlNextChar(ctxt)
  ------------------
 7700|       |
 7701|       |    /*
 7702|       |     * Predefined entities override any extra definition
 7703|       |     */
 7704|  15.8k|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7704:9): [True: 15.8k, False: 0]
  ------------------
 7705|  15.8k|        ent = xmlGetPredefinedEntity(name);
 7706|  15.8k|        if (ent != NULL)
  ------------------
  |  Branch (7706:13): [True: 680, False: 15.1k]
  ------------------
 7707|    680|            return(ent);
 7708|  15.8k|    }
 7709|       |
 7710|       |    /*
 7711|       |     * Ask first SAX for entity resolution, otherwise try the
 7712|       |     * entities which may have stored in the parser context.
 7713|       |     */
 7714|  15.1k|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7714:9): [True: 15.1k, False: 0]
  ------------------
 7715|  15.1k|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7715:6): [True: 15.1k, False: 0]
  ------------------
 7716|  15.1k|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7717|  15.1k|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7717:6): [True: 15.1k, False: 1]
  |  Branch (7717:34): [True: 3, False: 15.1k]
  ------------------
 7718|  15.1k|	    (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7718:6): [True: 0, False: 3]
  ------------------
 7719|      0|	    ent = xmlGetPredefinedEntity(name);
 7720|  15.1k|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7720:6): [True: 15.1k, False: 1]
  |  Branch (7720:34): [True: 3, False: 15.1k]
  ------------------
 7721|  15.1k|	    (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7721:6): [True: 3, False: 0]
  ------------------
 7722|      3|	    ent = xmlSAX2GetEntity(ctxt, name);
 7723|      3|	}
 7724|  15.1k|    }
 7725|  15.1k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7725:9): [True: 0, False: 15.1k]
  ------------------
 7726|      0|	return(NULL);
 7727|       |    /*
 7728|       |     * [ WFC: Entity Declared ]
 7729|       |     * In a document without any DTD, a document with only an
 7730|       |     * internal DTD subset which contains no parameter entity
 7731|       |     * references, or a document with "standalone='yes'", the
 7732|       |     * Name given in the entity reference must match that in an
 7733|       |     * entity declaration, except that well-formed documents
 7734|       |     * need not declare any of the following entities: amp, lt,
 7735|       |     * gt, apos, quot.
 7736|       |     * The declaration of a parameter entity must precede any
 7737|       |     * reference to it.
 7738|       |     * Similarly, the declaration of a general entity must
 7739|       |     * precede any reference to it which appears in a default
 7740|       |     * value in an attribute-list declaration. Note that if
 7741|       |     * entities are declared in the external subset or in
 7742|       |     * external parameter entities, a non-validating processor
 7743|       |     * is not obligated to read and process their declarations;
 7744|       |     * for such documents, the rule that an entity must be
 7745|       |     * declared is a well-formedness constraint only if
 7746|       |     * standalone='yes'.
 7747|       |     */
 7748|  15.1k|    if (ent == NULL) {
  ------------------
  |  Branch (7748:9): [True: 3, False: 15.1k]
  ------------------
 7749|      3|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7749:6): [True: 0, False: 3]
  ------------------
 7750|      3|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7750:7): [True: 0, False: 3]
  ------------------
 7751|      3|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7751:7): [True: 0, False: 0]
  ------------------
 7752|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7753|      0|		     "Entity '%s' not defined\n", name);
 7754|      3|	} else {
 7755|      3|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7756|      3|		     "Entity '%s' not defined\n", name);
 7757|      3|	    if ((ctxt->inSubset == 0) &&
  ------------------
  |  Branch (7757:10): [True: 3, False: 0]
  ------------------
 7758|      3|		(ctxt->sax != NULL) &&
  ------------------
  |  Branch (7758:3): [True: 3, False: 0]
  ------------------
 7759|      3|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (7759:17): [True: 3, False: 0]
  ------------------
 7760|      3|		(ctxt->sax->reference != NULL)) {
  ------------------
  |  Branch (7760:3): [True: 3, False: 0]
  ------------------
 7761|      3|		ctxt->sax->reference(ctxt->userData, name);
 7762|      3|	    }
 7763|      3|	}
 7764|      3|	ctxt->valid = 0;
 7765|      3|    }
 7766|       |
 7767|       |    /*
 7768|       |     * [ WFC: Parsed Entity ]
 7769|       |     * An entity reference must not contain the name of an
 7770|       |     * unparsed entity
 7771|       |     */
 7772|  15.1k|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7772:14): [True: 0, False: 15.1k]
  ------------------
 7773|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7774|      0|		 "Entity reference to unparsed entity %s\n", name);
 7775|      0|    }
 7776|       |
 7777|       |    /*
 7778|       |     * [ WFC: No External Entity References ]
 7779|       |     * Attribute values cannot contain direct or indirect
 7780|       |     * entity references to external entities.
 7781|       |     */
 7782|  15.1k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7782:14): [True: 6.76k, False: 8.43k]
  ------------------
 7783|  15.1k|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7783:7): [True: 0, False: 6.76k]
  ------------------
 7784|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7785|      0|	     "Attribute references external entity '%s'\n", name);
 7786|      0|    }
 7787|       |    /*
 7788|       |     * [ WFC: No < in Attribute Values ]
 7789|       |     * The replacement text of any entity referred to directly or
 7790|       |     * indirectly in an attribute value (other than "&lt;") must
 7791|       |     * not contain a <.
 7792|       |     */
 7793|  15.1k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7793:14): [True: 6.76k, False: 8.43k]
  ------------------
 7794|  15.1k|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7794:7): [True: 6.76k, False: 0]
  ------------------
 7795|  6.76k|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|  6.76k|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7795:6): [True: 48, False: 6.71k]
  ------------------
 7796|     48|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7796:17): [True: 48, False: 0]
  |  Branch (7796:43): [True: 0, False: 48]
  ------------------
 7797|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7798|     48|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|     48|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7799|     48|        }
 7800|  6.76k|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|  6.76k|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7800:13): [True: 0, False: 6.76k]
  ------------------
 7801|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7802|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7803|      0|                    "values\n", name);
 7804|  6.76k|    }
 7805|       |
 7806|       |    /*
 7807|       |     * Internal check, no parameter entities here ...
 7808|       |     */
 7809|  8.43k|    else {
 7810|  8.43k|	switch (ent->etype) {
 7811|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7811:6): [True: 0, False: 8.43k]
  ------------------
 7812|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7812:6): [True: 0, False: 8.43k]
  ------------------
 7813|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7814|      0|	     "Attempt to reference the parameter entity '%s'\n",
 7815|      0|			      name);
 7816|      0|	    break;
 7817|  8.43k|	    default:
  ------------------
  |  Branch (7817:6): [True: 8.43k, False: 0]
  ------------------
 7818|  8.43k|	    break;
 7819|  8.43k|	}
 7820|  8.43k|    }
 7821|       |
 7822|       |    /*
 7823|       |     * [ WFC: No Recursion ]
 7824|       |     * A parsed entity must not contain a recursive reference
 7825|       |     * to itself, either directly or indirectly.
 7826|       |     * Done somewhere else
 7827|       |     */
 7828|  15.1k|    return(ent);
 7829|  15.1k|}
xmlParsePEReference:
 8059|   103k|{
 8060|   103k|    const xmlChar *name;
 8061|   103k|    xmlEntityPtr entity = NULL;
 8062|   103k|    xmlParserInputPtr input;
 8063|       |
 8064|   103k|    if (RAW != '%')
  ------------------
  |  | 2221|   103k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8064:9): [True: 0, False: 103k]
  ------------------
 8065|      0|        return;
 8066|   103k|    NEXT;
  ------------------
  |  | 2275|   103k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8067|   103k|    name = xmlParseName(ctxt);
 8068|   103k|    if (name == NULL) {
  ------------------
  |  Branch (8068:9): [True: 3, False: 103k]
  ------------------
 8069|      3|	xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, "PEReference: no name\n");
 8070|      3|	return;
 8071|      3|    }
 8072|   103k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   103k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   103k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 103k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8073|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 8074|      0|		"PEReference: %s\n", name);
 8075|   103k|    if (RAW != ';') {
  ------------------
  |  | 2221|   103k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8075:9): [True: 3, False: 103k]
  ------------------
 8076|      3|	xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);
 8077|      3|        return;
 8078|      3|    }
 8079|       |
 8080|   103k|    NEXT;
  ------------------
  |  | 2275|   103k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8081|       |
 8082|       |    /*
 8083|       |     * Request the entity from SAX
 8084|       |     */
 8085|   103k|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (8085:9): [True: 103k, False: 0]
  ------------------
 8086|   103k|	(ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (8086:2): [True: 103k, False: 0]
  ------------------
 8087|   103k|	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
 8088|   103k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8088:9): [True: 0, False: 103k]
  ------------------
 8089|      0|	return;
 8090|   103k|    if (entity == NULL) {
  ------------------
  |  Branch (8090:9): [True: 0, False: 103k]
  ------------------
 8091|       |	/*
 8092|       |	 * [ WFC: Entity Declared ]
 8093|       |	 * In a document without any DTD, a document with only an
 8094|       |	 * internal DTD subset which contains no parameter entity
 8095|       |	 * references, or a document with "standalone='yes'", ...
 8096|       |	 * ... The declaration of a parameter entity must precede
 8097|       |	 * any reference to it...
 8098|       |	 */
 8099|      0|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (8099:6): [True: 0, False: 0]
  ------------------
 8100|      0|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (8100:7): [True: 0, False: 0]
  ------------------
 8101|      0|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (8101:7): [True: 0, False: 0]
  ------------------
 8102|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8103|      0|			      "PEReference: %%%s; not found\n",
 8104|      0|			      name);
 8105|      0|	} else {
 8106|       |	    /*
 8107|       |	     * [ VC: Entity Declared ]
 8108|       |	     * In a document with an external subset or external
 8109|       |	     * parameter entities with "standalone='no'", ...
 8110|       |	     * ... The declaration of a parameter entity must
 8111|       |	     * precede any reference to it...
 8112|       |	     */
 8113|      0|            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {
  ------------------
  |  Branch (8113:17): [True: 0, False: 0]
  |  Branch (8113:37): [True: 0, False: 0]
  ------------------
 8114|      0|                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8115|      0|                                 "PEReference: %%%s; not found\n",
 8116|      0|                                 name, NULL);
 8117|      0|            } else
 8118|      0|                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8119|      0|                              "PEReference: %%%s; not found\n",
 8120|      0|                              name, NULL);
 8121|      0|            ctxt->valid = 0;
 8122|      0|	}
 8123|   103k|    } else {
 8124|       |	/*
 8125|       |	 * Internal checking in case the entity quest barfed
 8126|       |	 */
 8127|   103k|	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8127:6): [True: 9.88k, False: 93.1k]
  ------------------
 8128|   103k|	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
  ------------------
  |  Branch (8128:6): [True: 0, False: 9.88k]
  ------------------
 8129|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8130|      0|		  "Internal: %%%s; is not a parameter entity\n",
 8131|      0|			  name, NULL);
 8132|   103k|	} else {
 8133|   103k|            unsigned long parentConsumed;
 8134|   103k|            xmlEntityPtr oldEnt;
 8135|       |
 8136|   103k|	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8136:10): [True: 9.88k, False: 93.1k]
  ------------------
 8137|   103k|	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
  ------------------
  |  Branch (8137:10): [True: 0, False: 9.88k]
  ------------------
 8138|   103k|		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
  ------------------
  |  Branch (8138:3): [True: 0, False: 0]
  ------------------
 8139|   103k|		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
  ------------------
  |  Branch (8139:3): [True: 0, False: 0]
  ------------------
 8140|   103k|		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
  ------------------
  |  Branch (8140:3): [True: 0, False: 0]
  ------------------
 8141|   103k|		(ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (8141:3): [True: 0, False: 0]
  ------------------
 8142|   103k|		(ctxt->validate == 0))
  ------------------
  |  Branch (8142:3): [True: 0, False: 0]
  ------------------
 8143|      0|		return;
 8144|       |
 8145|   103k|            if (entity->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|   103k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (8145:17): [True: 3, False: 103k]
  ------------------
 8146|      3|                xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 8147|      3|                xmlHaltParser(ctxt);
 8148|      3|                return;
 8149|      3|            }
 8150|       |
 8151|       |            /* Must be computed from old input before pushing new input. */
 8152|   103k|            parentConsumed = ctxt->input->parentConsumed;
 8153|   103k|            oldEnt = ctxt->input->entity;
 8154|   103k|            if ((oldEnt == NULL) ||
  ------------------
  |  Branch (8154:17): [True: 1.63k, False: 101k]
  ------------------
 8155|   103k|                ((oldEnt->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8155:18): [True: 10.3k, False: 90.9k]
  ------------------
 8156|   101k|                 ((oldEnt->flags & XML_ENT_PARSED) == 0))) {
  ------------------
  |  |   14|  10.3k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (8156:18): [True: 876, False: 9.51k]
  ------------------
 8157|  2.51k|                xmlSaturatedAdd(&parentConsumed, ctxt->input->consumed);
 8158|  2.51k|                xmlSaturatedAddSizeT(&parentConsumed,
 8159|  2.51k|                                     ctxt->input->cur - ctxt->input->base);
 8160|  2.51k|            }
 8161|       |
 8162|   103k|	    input = xmlNewEntityInputStream(ctxt, entity);
 8163|   103k|	    if (xmlPushInput(ctxt, input) < 0) {
  ------------------
  |  Branch (8163:10): [True: 0, False: 103k]
  ------------------
 8164|      0|                xmlFreeInputStream(input);
 8165|      0|		return;
 8166|      0|            }
 8167|       |
 8168|   103k|            entity->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|   103k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 8169|       |
 8170|   103k|            input->parentConsumed = parentConsumed;
 8171|       |
 8172|   103k|	    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {
  ------------------
  |  Branch (8172:10): [True: 9.88k, False: 93.1k]
  ------------------
 8173|  9.88k|                xmlDetectEncoding(ctxt);
 8174|       |
 8175|  9.88k|                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
  ------------------
  |  | 2231|  9.88k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|  19.7k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 9.73k, False: 147]
  |  |  |  |  |  Branch (2228:41): [True: 3, False: 9.73k]
  |  |  |  |  ------------------
  |  |  |  | 2229|  9.88k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 3, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 8176|  9.88k|                    (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      3|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      3|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      3|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      3|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8177|      3|                    xmlParseTextDecl(ctxt);
 8178|      3|                }
 8179|  9.88k|            }
 8180|   103k|	}
 8181|   103k|    }
 8182|   103k|    ctxt->hasPErefs = 1;
 8183|   103k|}
xmlParseDocTypeDecl:
 8461|    570|xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8462|    570|    const xmlChar *name = NULL;
 8463|    570|    xmlChar *ExternalID = NULL;
 8464|    570|    xmlChar *URI = NULL;
 8465|       |
 8466|       |    /*
 8467|       |     * We know that '<!DOCTYPE' has been detected.
 8468|       |     */
 8469|    570|    SKIP(9);
  ------------------
  |  | 2245|    570|#define SKIP(val) do {							\
  |  | 2246|    570|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    570|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 570]
  |  |  ------------------
  |  | 2248|    570|        xmlParserGrow(ctxt);						\
  |  | 2249|    570|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8470|       |
 8471|    570|    SKIP_BLANKS;
  ------------------
  |  | 2273|    570|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8472|       |
 8473|       |    /*
 8474|       |     * Parse the DOCTYPE name.
 8475|       |     */
 8476|    570|    name = xmlParseName(ctxt);
 8477|    570|    if (name == NULL) {
  ------------------
  |  Branch (8477:9): [True: 0, False: 570]
  ------------------
 8478|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8479|      0|		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
 8480|      0|    }
 8481|    570|    ctxt->intSubName = name;
 8482|       |
 8483|    570|    SKIP_BLANKS;
  ------------------
  |  | 2273|    570|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8484|       |
 8485|       |    /*
 8486|       |     * Check for SystemID and ExternalID
 8487|       |     */
 8488|    570|    URI = xmlParseExternalID(ctxt, &ExternalID, 1);
 8489|       |
 8490|    570|    if ((URI != NULL) || (ExternalID != NULL)) {
  ------------------
  |  Branch (8490:9): [True: 201, False: 369]
  |  Branch (8490:26): [True: 0, False: 369]
  ------------------
 8491|    201|        ctxt->hasExternalSubset = 1;
 8492|    201|    }
 8493|    570|    ctxt->extSubURI = URI;
 8494|    570|    ctxt->extSubSystem = ExternalID;
 8495|       |
 8496|    570|    SKIP_BLANKS;
  ------------------
  |  | 2273|    570|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8497|       |
 8498|       |    /*
 8499|       |     * Create and update the internal subset.
 8500|       |     */
 8501|    570|    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&
  ------------------
  |  Branch (8501:9): [True: 570, False: 0]
  |  Branch (8501:32): [True: 570, False: 0]
  ------------------
 8502|    570|	(!ctxt->disableSAX))
  ------------------
  |  Branch (8502:2): [True: 570, False: 0]
  ------------------
 8503|    570|	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);
 8504|    570|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8504:9): [True: 0, False: 570]
  ------------------
 8505|      0|	return;
 8506|       |
 8507|       |    /*
 8508|       |     * Is there any internal subset declarations ?
 8509|       |     * they are handled separately in xmlParseInternalSubset()
 8510|       |     */
 8511|    570|    if (RAW == '[')
  ------------------
  |  | 2221|    570|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8511:9): [True: 408, False: 162]
  ------------------
 8512|    408|	return;
 8513|       |
 8514|       |    /*
 8515|       |     * We should be at the end of the DOCTYPE declaration.
 8516|       |     */
 8517|    162|    if (RAW != '>') {
  ------------------
  |  | 2221|    162|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8517:9): [True: 0, False: 162]
  ------------------
 8518|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8519|      0|    }
 8520|    162|    NEXT;
  ------------------
  |  | 2275|    162|#define NEXT xmlNextChar(ctxt)
  ------------------
 8521|    162|}
xmlParseCDSect:
10109|     37|xmlParseCDSect(xmlParserCtxtPtr ctxt) {
10110|     37|    xmlChar *buf = NULL;
10111|     37|    int len = 0;
10112|     37|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     37|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
10113|     37|    int r, rl;
10114|     37|    int	s, sl;
10115|     37|    int cur, l;
10116|     37|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10116:21): [True: 0, False: 37]
  ------------------
10117|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
10118|     37|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     37|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10119|       |
10120|     37|    if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2222|     37|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10120:9): [True: 0, False: 37]
  |  Branch (10120:25): [True: 0, False: 37]
  |  Branch (10120:44): [True: 0, False: 37]
  ------------------
10121|      0|        return;
10122|     37|    SKIP(3);
  ------------------
  |  | 2245|     37|#define SKIP(val) do {							\
  |  | 2246|     37|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     37|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2248|     37|        xmlParserGrow(ctxt);						\
  |  | 2249|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10123|       |
10124|     37|    if (!CMP6(CUR_PTR, 'C', 'D', 'A', 'T', 'A', '['))
  ------------------
  |  | 2233|     37|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     74|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     74|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 37, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 37, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     37|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 37, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 37, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 37, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 37, False: 0]
  |  |  ------------------
  ------------------
10125|      0|        return;
10126|     37|    SKIP(6);
  ------------------
  |  | 2245|     37|#define SKIP(val) do {							\
  |  | 2246|     37|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     37|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2248|     37|        xmlParserGrow(ctxt);						\
  |  | 2249|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10127|       |
10128|     37|    ctxt->instate = XML_PARSER_CDATA_SECTION;
10129|     37|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     37|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10130|     37|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     37|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     37|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 34, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  119|     37|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     34|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 34, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 4, False: 30]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     34|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 30]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     34|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 30, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     37|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 3, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 2, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  121|      3|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 1, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  122|      3|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 1, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10130:9): [True: 0, False: 37]
  ------------------
10131|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10132|      0|        goto out;
10133|      0|    }
10134|     37|    NEXTL(rl);
  ------------------
  |  | 2284|     37|#define NEXTL(l) do {							\
  |  | 2285|     37|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 2, False: 35]
  |  |  ------------------
  |  | 2286|      2|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     35|    } else ctxt->input->col++;						\
  |  | 2288|     37|    ctxt->input->cur += l;				\
  |  | 2289|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10135|     37|    s = CUR_CHAR(sl);
  ------------------
  |  | 2291|     37|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10136|     37|    if (!IS_CHAR(s)) {
  ------------------
  |  |  125|     37|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     37|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 30, False: 7]
  |  |  |  |  ------------------
  |  |  |  |  119|     37|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     30|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 30, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 30]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     30|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 30]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     30|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 30, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     37|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 7, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 4, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  121|      7|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 3, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 1, False: 2]
  |  |  |  |  ------------------
  |  |  |  |  122|      7|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10136:9): [True: 0, False: 37]
  ------------------
10137|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10138|      0|        goto out;
10139|      0|    }
10140|     37|    NEXTL(sl);
  ------------------
  |  | 2284|     37|#define NEXTL(l) do {							\
  |  | 2285|     37|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     37|    } else ctxt->input->col++;						\
  |  | 2288|     37|    ctxt->input->cur += l;				\
  |  | 2289|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10141|     37|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     37|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10142|     37|    buf = (xmlChar *) xmlMallocAtomic(size);
10143|     37|    if (buf == NULL) {
  ------------------
  |  Branch (10143:9): [True: 0, False: 37]
  ------------------
10144|      0|	xmlErrMemory(ctxt, NULL);
10145|      0|        goto out;
10146|      0|    }
10147|  6.09k|    while (IS_CHAR(cur) &&
  ------------------
  |  |  125|  6.09k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  12.1k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 6.09k, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 2.49k, False: 3.59k]
  |  |  |  |  ------------------
  |  |  |  |  119|  12.1k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  2.49k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 2.49k, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 59, False: 2.44k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  2.49k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 2.44k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  2.49k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 2.44k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  12.1k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 3.59k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 2.39k, False: 1.19k]
  |  |  |  |  ------------------
  |  |  |  |  121|  3.59k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 1.19k, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 1, False: 1.19k]
  |  |  |  |  ------------------
  |  |  |  |  122|  3.59k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 1.19k, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 1.19k, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10148|  6.09k|           ((r != ']') || (s != ']') || (cur != '>'))) {
  ------------------
  |  Branch (10148:13): [True: 6.05k, False: 40]
  |  Branch (10148:27): [True: 2, False: 38]
  |  Branch (10148:41): [True: 1, False: 37]
  ------------------
10149|  6.05k|	if (len + 5 >= size) {
  ------------------
  |  Branch (10149:6): [True: 49, False: 6.00k]
  ------------------
10150|     49|	    xmlChar *tmp;
10151|       |
10152|     49|	    tmp = (xmlChar *) xmlRealloc(buf, size * 2);
10153|     49|	    if (tmp == NULL) {
  ------------------
  |  Branch (10153:10): [True: 0, False: 49]
  ------------------
10154|      0|		xmlErrMemory(ctxt, NULL);
10155|      0|                goto out;
10156|      0|	    }
10157|     49|	    buf = tmp;
10158|     49|	    size *= 2;
10159|     49|	}
10160|  6.05k|	COPY_BUF(buf, len, r);
  ------------------
  |  | 2295|  6.05k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 2.45k, False: 3.60k]
  |  |  ------------------
  |  | 2296|  6.05k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
10161|  6.05k|        if (len > maxLength) {
  ------------------
  |  Branch (10161:13): [True: 0, False: 6.05k]
  ------------------
10162|      0|            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10163|      0|                           "CData section too big found\n");
10164|      0|            goto out;
10165|      0|        }
10166|  6.05k|	r = s;
10167|  6.05k|	rl = sl;
10168|  6.05k|	s = cur;
10169|  6.05k|	sl = l;
10170|  6.05k|	NEXTL(l);
  ------------------
  |  | 2284|  6.05k|#define NEXTL(l) do {							\
  |  | 2285|  6.05k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 57, False: 5.99k]
  |  |  ------------------
  |  | 2286|     57|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  5.99k|    } else ctxt->input->col++;						\
  |  | 2288|  6.05k|    ctxt->input->cur += l;				\
  |  | 2289|  6.05k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10171|  6.05k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  6.05k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10172|  6.05k|    }
10173|     37|    buf[len] = 0;
10174|     37|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (10174:9): [True: 0, False: 37]
  ------------------
10175|      0|        xmlFree(buf);
10176|      0|        return;
10177|      0|    }
10178|     37|    if (cur != '>') {
  ------------------
  |  Branch (10178:9): [True: 0, False: 37]
  ------------------
10179|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10180|      0|	                     "CData section not finished\n%.50s\n", buf);
10181|      0|        goto out;
10182|      0|    }
10183|     37|    NEXTL(l);
  ------------------
  |  | 2284|     37|#define NEXTL(l) do {							\
  |  | 2285|     37|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     37|    } else ctxt->input->col++;						\
  |  | 2288|     37|    ctxt->input->cur += l;				\
  |  | 2289|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10184|       |
10185|       |    /*
10186|       |     * OK the buffer is to be consumed as cdata.
10187|       |     */
10188|     37|    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (10188:9): [True: 37, False: 0]
  |  Branch (10188:32): [True: 35, False: 2]
  ------------------
10189|     35|	if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (10189:6): [True: 35, False: 0]
  ------------------
10190|     35|	    ctxt->sax->cdataBlock(ctxt->userData, buf, len);
10191|      0|	else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (10191:11): [True: 0, False: 0]
  ------------------
10192|      0|	    ctxt->sax->characters(ctxt->userData, buf, len);
10193|     35|    }
10194|       |
10195|     37|out:
10196|     37|    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (10196:9): [True: 37, False: 0]
  ------------------
10197|     37|        ctxt->instate = XML_PARSER_CONTENT;
10198|     37|    xmlFree(buf);
10199|     37|}
xmlParseContent:
10286|    351|xmlParseContent(xmlParserCtxtPtr ctxt) {
10287|    351|    int nameNr = ctxt->nameNr;
10288|       |
10289|    351|    xmlParseContentInternal(ctxt);
10290|       |
10291|    351|    if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (10291:9): [True: 213, False: 138]
  ------------------
10292|    351|        (ctxt->errNo == XML_ERR_OK) &&
  ------------------
  |  Branch (10292:9): [True: 204, False: 9]
  ------------------
10293|    351|        (ctxt->nameNr > nameNr)) {
  ------------------
  |  Branch (10293:9): [True: 0, False: 204]
  ------------------
10294|      0|        const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10295|      0|        int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10296|      0|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10297|      0|                "Premature end of data in tag %s line %d\n",
10298|      0|		name, line, NULL);
10299|      0|    }
10300|    351|}
xmlParseElement:
10319|    297|xmlParseElement(xmlParserCtxtPtr ctxt) {
10320|    297|    if (xmlParseElementStart(ctxt) != 0)
  ------------------
  |  Branch (10320:9): [True: 67, False: 230]
  ------------------
10321|     67|        return;
10322|       |
10323|    230|    xmlParseContentInternal(ctxt);
10324|    230|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10324:9): [True: 5, False: 225]
  ------------------
10325|      5|	return;
10326|       |
10327|    225|    if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (10327:9): [True: 5, False: 220]
  ------------------
10328|      5|        if (ctxt->errNo == XML_ERR_OK) {
  ------------------
  |  Branch (10328:13): [True: 2, False: 3]
  ------------------
10329|      2|            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10330|      2|            int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10331|      2|            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10332|      2|                    "Premature end of data in tag %s line %d\n",
10333|      2|                    name, line, NULL);
10334|      2|        }
10335|      5|        return;
10336|      5|    }
10337|       |
10338|    220|    xmlParseElementEnd(ctxt);
10339|    220|}
xmlParseVersionNum:
10526|    507|xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10527|    507|    xmlChar *buf = NULL;
10528|    507|    int len = 0;
10529|    507|    int size = 10;
10530|    507|    xmlChar cur;
10531|       |
10532|    507|    buf = (xmlChar *) xmlMallocAtomic(size);
10533|    507|    if (buf == NULL) {
  ------------------
  |  Branch (10533:9): [True: 0, False: 507]
  ------------------
10534|      0|	xmlErrMemory(ctxt, NULL);
10535|      0|	return(NULL);
10536|      0|    }
10537|    507|    cur = CUR;
  ------------------
  |  | 2222|    507|#define CUR (*ctxt->input->cur)
  ------------------
10538|    507|    if (!((cur >= '0') && (cur <= '9'))) {
  ------------------
  |  Branch (10538:11): [True: 507, False: 0]
  |  Branch (10538:27): [True: 507, False: 0]
  ------------------
10539|      0|	xmlFree(buf);
10540|      0|	return(NULL);
10541|      0|    }
10542|    507|    buf[len++] = cur;
10543|    507|    NEXT;
  ------------------
  |  | 2275|    507|#define NEXT xmlNextChar(ctxt)
  ------------------
10544|    507|    cur=CUR;
  ------------------
  |  | 2222|    507|#define CUR (*ctxt->input->cur)
  ------------------
10545|    507|    if (cur != '.') {
  ------------------
  |  Branch (10545:9): [True: 0, False: 507]
  ------------------
10546|      0|	xmlFree(buf);
10547|      0|	return(NULL);
10548|      0|    }
10549|    507|    buf[len++] = cur;
10550|    507|    NEXT;
  ------------------
  |  | 2275|    507|#define NEXT xmlNextChar(ctxt)
  ------------------
10551|    507|    cur=CUR;
  ------------------
  |  | 2222|    507|#define CUR (*ctxt->input->cur)
  ------------------
10552|  1.01k|    while ((cur >= '0') && (cur <= '9')) {
  ------------------
  |  Branch (10552:12): [True: 507, False: 507]
  |  Branch (10552:28): [True: 507, False: 0]
  ------------------
10553|    507|	if (len + 1 >= size) {
  ------------------
  |  Branch (10553:6): [True: 0, False: 507]
  ------------------
10554|      0|	    xmlChar *tmp;
10555|       |
10556|      0|	    size *= 2;
10557|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
10558|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10558:10): [True: 0, False: 0]
  ------------------
10559|      0|	        xmlFree(buf);
10560|      0|		xmlErrMemory(ctxt, NULL);
10561|      0|		return(NULL);
10562|      0|	    }
10563|      0|	    buf = tmp;
10564|      0|	}
10565|    507|	buf[len++] = cur;
10566|    507|	NEXT;
  ------------------
  |  | 2275|    507|#define NEXT xmlNextChar(ctxt)
  ------------------
10567|    507|	cur=CUR;
  ------------------
  |  | 2222|    507|#define CUR (*ctxt->input->cur)
  ------------------
10568|    507|    }
10569|    507|    buf[len] = 0;
10570|    507|    return(buf);
10571|    507|}
xmlParseVersionInfo:
10589|    507|xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10590|    507|    xmlChar *version = NULL;
10591|       |
10592|    507|    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {
  ------------------
  |  | 2235|    507|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|  1.01k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|  1.01k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|  1.01k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 507, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 507, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    507|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 507, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 507, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 507, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 507, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 507, False: 0]
  |  |  ------------------
  ------------------
10593|    507|	SKIP(7);
  ------------------
  |  | 2245|    507|#define SKIP(val) do {							\
  |  | 2246|    507|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    507|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 507]
  |  |  ------------------
  |  | 2248|    507|        xmlParserGrow(ctxt);						\
  |  | 2249|    507|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10594|    507|	SKIP_BLANKS;
  ------------------
  |  | 2273|    507|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10595|    507|	if (RAW != '=') {
  ------------------
  |  | 2221|    507|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10595:6): [True: 0, False: 507]
  ------------------
10596|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10597|      0|	    return(NULL);
10598|      0|        }
10599|    507|	NEXT;
  ------------------
  |  | 2275|    507|#define NEXT xmlNextChar(ctxt)
  ------------------
10600|    507|	SKIP_BLANKS;
  ------------------
  |  | 2273|    507|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10601|    507|	if (RAW == '"') {
  ------------------
  |  | 2221|    507|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10601:6): [True: 468, False: 39]
  ------------------
10602|    468|	    NEXT;
  ------------------
  |  | 2275|    468|#define NEXT xmlNextChar(ctxt)
  ------------------
10603|    468|	    version = xmlParseVersionNum(ctxt);
10604|    468|	    if (RAW != '"') {
  ------------------
  |  | 2221|    468|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10604:10): [True: 0, False: 468]
  ------------------
10605|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10606|      0|	    } else
10607|    468|	        NEXT;
  ------------------
  |  | 2275|    468|#define NEXT xmlNextChar(ctxt)
  ------------------
10608|    468|	} else if (RAW == '\''){
  ------------------
  |  | 2221|     39|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10608:13): [True: 39, False: 0]
  ------------------
10609|     39|	    NEXT;
  ------------------
  |  | 2275|     39|#define NEXT xmlNextChar(ctxt)
  ------------------
10610|     39|	    version = xmlParseVersionNum(ctxt);
10611|     39|	    if (RAW != '\'') {
  ------------------
  |  | 2221|     39|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10611:10): [True: 0, False: 39]
  ------------------
10612|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10613|      0|	    } else
10614|     39|	        NEXT;
  ------------------
  |  | 2275|     39|#define NEXT xmlNextChar(ctxt)
  ------------------
10615|     39|	} else {
10616|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10617|      0|	}
10618|    507|    }
10619|    507|    return(version);
10620|    507|}
xmlParseEncName:
10635|    117|xmlParseEncName(xmlParserCtxtPtr ctxt) {
10636|    117|    xmlChar *buf = NULL;
10637|    117|    int len = 0;
10638|    117|    int size = 10;
10639|    117|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10639:21): [True: 0, False: 117]
  ------------------
10640|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10641|    117|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    117|#define XML_MAX_NAME_LENGTH 50000
  ------------------
10642|    117|    xmlChar cur;
10643|       |
10644|    117|    cur = CUR;
  ------------------
  |  | 2222|    117|#define CUR (*ctxt->input->cur)
  ------------------
10645|    117|    if (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10645:10): [True: 27, False: 90]
  |  Branch (10645:26): [True: 27, False: 0]
  ------------------
10646|    117|        ((cur >= 'A') && (cur <= 'Z'))) {
  ------------------
  |  Branch (10646:10): [True: 90, False: 0]
  |  Branch (10646:26): [True: 90, False: 0]
  ------------------
10647|    117|	buf = (xmlChar *) xmlMallocAtomic(size);
10648|    117|	if (buf == NULL) {
  ------------------
  |  Branch (10648:6): [True: 0, False: 117]
  ------------------
10649|      0|	    xmlErrMemory(ctxt, NULL);
10650|      0|	    return(NULL);
10651|      0|	}
10652|       |
10653|    117|	buf[len++] = cur;
10654|    117|	NEXT;
  ------------------
  |  | 2275|    117|#define NEXT xmlNextChar(ctxt)
  ------------------
10655|    117|	cur = CUR;
  ------------------
  |  | 2222|    117|#define CUR (*ctxt->input->cur)
  ------------------
10656|    831|	while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (10656:10): [True: 54, False: 777]
  |  Branch (10656:26): [True: 54, False: 0]
  ------------------
10657|    831|	       ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (10657:10): [True: 198, False: 579]
  |  Branch (10657:26): [True: 198, False: 0]
  ------------------
10658|    831|	       ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (10658:10): [True: 300, False: 279]
  |  Branch (10658:26): [True: 300, False: 0]
  ------------------
10659|    831|	       (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (10659:9): [True: 0, False: 279]
  |  Branch (10659:25): [True: 0, False: 279]
  ------------------
10660|    831|	       (cur == '-')) {
  ------------------
  |  Branch (10660:9): [True: 162, False: 117]
  ------------------
10661|    714|	    if (len + 1 >= size) {
  ------------------
  |  Branch (10661:10): [True: 45, False: 669]
  ------------------
10662|     45|	        xmlChar *tmp;
10663|       |
10664|     45|		size *= 2;
10665|     45|		tmp = (xmlChar *) xmlRealloc(buf, size);
10666|     45|		if (tmp == NULL) {
  ------------------
  |  Branch (10666:7): [True: 0, False: 45]
  ------------------
10667|      0|		    xmlErrMemory(ctxt, NULL);
10668|      0|		    xmlFree(buf);
10669|      0|		    return(NULL);
10670|      0|		}
10671|     45|		buf = tmp;
10672|     45|	    }
10673|    714|	    buf[len++] = cur;
10674|    714|            if (len > maxLength) {
  ------------------
  |  Branch (10674:17): [True: 0, False: 714]
  ------------------
10675|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "EncName");
10676|      0|                xmlFree(buf);
10677|      0|                return(NULL);
10678|      0|            }
10679|    714|	    NEXT;
  ------------------
  |  | 2275|    714|#define NEXT xmlNextChar(ctxt)
  ------------------
10680|    714|	    cur = CUR;
  ------------------
  |  | 2222|    714|#define CUR (*ctxt->input->cur)
  ------------------
10681|    714|        }
10682|    117|	buf[len] = 0;
10683|    117|    } else {
10684|      0|	xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);
10685|      0|    }
10686|    117|    return(buf);
10687|    117|}
xmlParseEncodingDecl:
10705|    270|xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10706|    270|    xmlChar *encoding = NULL;
10707|       |
10708|    270|    SKIP_BLANKS;
  ------------------
  |  | 2273|    270|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10709|    270|    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)
  ------------------
  |  | 2237|    270|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|    540|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|    540|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|    540|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|    540|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 117, False: 153]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 117, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|    270|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 117, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 117, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 117, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 117, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 117, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 117, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10709:9): [True: 153, False: 117]
  ------------------
10710|    153|        return(NULL);
10711|       |
10712|    117|    SKIP(8);
  ------------------
  |  | 2245|    117|#define SKIP(val) do {							\
  |  | 2246|    117|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    117|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 117]
  |  |  ------------------
  |  | 2248|    117|        xmlParserGrow(ctxt);						\
  |  | 2249|    117|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10713|    117|    SKIP_BLANKS;
  ------------------
  |  | 2273|    117|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10714|    117|    if (RAW != '=') {
  ------------------
  |  | 2221|    117|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10714:9): [True: 0, False: 117]
  ------------------
10715|      0|        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10716|      0|        return(NULL);
10717|      0|    }
10718|    117|    NEXT;
  ------------------
  |  | 2275|    117|#define NEXT xmlNextChar(ctxt)
  ------------------
10719|    117|    SKIP_BLANKS;
  ------------------
  |  | 2273|    117|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10720|    117|    if (RAW == '"') {
  ------------------
  |  | 2221|    117|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10720:9): [True: 108, False: 9]
  ------------------
10721|    108|        NEXT;
  ------------------
  |  | 2275|    108|#define NEXT xmlNextChar(ctxt)
  ------------------
10722|    108|        encoding = xmlParseEncName(ctxt);
10723|    108|        if (RAW != '"') {
  ------------------
  |  | 2221|    108|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10723:13): [True: 0, False: 108]
  ------------------
10724|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10725|      0|            xmlFree((xmlChar *) encoding);
10726|      0|            return(NULL);
10727|      0|        } else
10728|    108|            NEXT;
  ------------------
  |  | 2275|    108|#define NEXT xmlNextChar(ctxt)
  ------------------
10729|    108|    } else if (RAW == '\''){
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10729:16): [True: 9, False: 0]
  ------------------
10730|      9|        NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
10731|      9|        encoding = xmlParseEncName(ctxt);
10732|      9|        if (RAW != '\'') {
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10732:13): [True: 0, False: 9]
  ------------------
10733|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10734|      0|            xmlFree((xmlChar *) encoding);
10735|      0|            return(NULL);
10736|      0|        } else
10737|      9|            NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
10738|      9|    } else {
10739|      0|        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10740|      0|    }
10741|       |
10742|    117|    if (encoding == NULL)
  ------------------
  |  Branch (10742:9): [True: 0, False: 117]
  ------------------
10743|      0|        return(NULL);
10744|       |
10745|    117|    xmlSetDeclaredEncoding(ctxt, encoding);
10746|       |
10747|    117|    return(ctxt->encoding);
10748|    117|}
xmlParseSDDecl:
10784|    171|xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10785|    171|    int standalone = -2;
10786|       |
10787|    171|    SKIP_BLANKS;
  ------------------
  |  | 2273|    171|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10788|    171|    if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {
  ------------------
  |  | 2242|    171|  ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \
  |  |  ------------------
  |  |  |  | 2239|    342|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  |  |  ------------------
  |  |  |  |  |  | 2237|    342|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2235|    342|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2233|    342|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2231|    342|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2228|    342|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 150, False: 21]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2229|    171|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2235:42): [True: 150, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2237:46): [True: 150, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 2240|    342|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2240:5): [True: 150, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2243|    171|    ((unsigned char *) s)[ 9 ] == c10 )
  |  |  ------------------
  |  |  |  Branch (2243:5): [True: 150, False: 0]
  |  |  ------------------
  ------------------
10789|    150|	SKIP(10);
  ------------------
  |  | 2245|    150|#define SKIP(val) do {							\
  |  | 2246|    150|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    150|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 150]
  |  |  ------------------
  |  | 2248|    150|        xmlParserGrow(ctxt);						\
  |  | 2249|    150|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10790|    150|        SKIP_BLANKS;
  ------------------
  |  | 2273|    150|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10791|    150|	if (RAW != '=') {
  ------------------
  |  | 2221|    150|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10791:6): [True: 0, False: 150]
  ------------------
10792|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10793|      0|	    return(standalone);
10794|      0|        }
10795|    150|	NEXT;
  ------------------
  |  | 2275|    150|#define NEXT xmlNextChar(ctxt)
  ------------------
10796|    150|	SKIP_BLANKS;
  ------------------
  |  | 2273|    150|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10797|    150|        if (RAW == '\''){
  ------------------
  |  | 2221|    150|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10797:13): [True: 9, False: 141]
  ------------------
10798|      9|	    NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
10799|      9|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      6|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10799:10): [True: 6, False: 3]
  |  Branch (10799:26): [True: 6, False: 0]
  ------------------
10800|      6|	        standalone = 0;
10801|      6|                SKIP(2);
  ------------------
  |  | 2245|      6|#define SKIP(val) do {							\
  |  | 2246|      6|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      6|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 6]
  |  |  ------------------
  |  | 2248|      6|        xmlParserGrow(ctxt);						\
  |  | 2249|      6|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10802|      6|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10802:17): [True: 3, False: 0]
  |  Branch (10802:33): [True: 3, False: 0]
  ------------------
10803|      3|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      3|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10803:17): [True: 3, False: 0]
  ------------------
10804|      3|	        standalone = 1;
10805|      3|		SKIP(3);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10806|      3|            } else {
10807|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10808|      0|	    }
10809|      9|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10809:10): [True: 0, False: 9]
  ------------------
10810|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10811|      0|	    } else
10812|      9|	        NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
10813|    141|	} else if (RAW == '"'){
  ------------------
  |  | 2221|    141|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10813:13): [True: 141, False: 0]
  ------------------
10814|    141|	    NEXT;
  ------------------
  |  | 2275|    141|#define NEXT xmlNextChar(ctxt)
  ------------------
10815|    141|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|    141|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|     90|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10815:10): [True: 90, False: 51]
  |  Branch (10815:26): [True: 90, False: 0]
  ------------------
10816|     90|	        standalone = 0;
10817|     90|		SKIP(2);
  ------------------
  |  | 2245|     90|#define SKIP(val) do {							\
  |  | 2246|     90|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     90|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 90]
  |  |  ------------------
  |  | 2248|     90|        xmlParserGrow(ctxt);						\
  |  | 2249|     90|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10818|     90|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|     51|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|     51|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10818:17): [True: 51, False: 0]
  |  Branch (10818:33): [True: 51, False: 0]
  ------------------
10819|     51|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|     51|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10819:17): [True: 51, False: 0]
  ------------------
10820|     51|	        standalone = 1;
10821|     51|                SKIP(3);
  ------------------
  |  | 2245|     51|#define SKIP(val) do {							\
  |  | 2246|     51|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     51|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 51]
  |  |  ------------------
  |  | 2248|     51|        xmlParserGrow(ctxt);						\
  |  | 2249|     51|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10822|     51|            } else {
10823|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10824|      0|	    }
10825|    141|	    if (RAW != '"') {
  ------------------
  |  | 2221|    141|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10825:10): [True: 0, False: 141]
  ------------------
10826|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10827|      0|	    } else
10828|    141|	        NEXT;
  ------------------
  |  | 2275|    141|#define NEXT xmlNextChar(ctxt)
  ------------------
10829|    141|	} else {
10830|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10831|      0|        }
10832|    150|    }
10833|    171|    return(standalone);
10834|    171|}
xmlParseXMLDecl:
10848|    489|xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10849|    489|    xmlChar *version;
10850|       |
10851|       |    /*
10852|       |     * This value for standalone indicates that the document has an
10853|       |     * XML declaration but it does not have a standalone attribute.
10854|       |     * It will be overwritten later if a standalone attribute is found.
10855|       |     */
10856|       |
10857|    489|    ctxt->standalone = -2;
10858|       |
10859|       |    /*
10860|       |     * We know that '<?xml' is here.
10861|       |     */
10862|    489|    SKIP(5);
  ------------------
  |  | 2245|    489|#define SKIP(val) do {							\
  |  | 2246|    489|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    489|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 489]
  |  |  ------------------
  |  | 2248|    489|        xmlParserGrow(ctxt);						\
  |  | 2249|    489|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10863|       |
10864|    489|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    489|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    489|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 489, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    489|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    489|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10865|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10866|      0|	               "Blank needed after '<?xml'\n");
10867|      0|    }
10868|    489|    SKIP_BLANKS;
  ------------------
  |  | 2273|    489|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10869|       |
10870|       |    /*
10871|       |     * We must have the VersionInfo here.
10872|       |     */
10873|    489|    version = xmlParseVersionInfo(ctxt);
10874|    489|    if (version == NULL) {
  ------------------
  |  Branch (10874:9): [True: 0, False: 489]
  ------------------
10875|      0|	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10876|    489|    } else {
10877|    489|	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
  ------------------
  |  |   37|    489|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
  |  Branch (10877:6): [True: 0, False: 489]
  ------------------
10878|       |	    /*
10879|       |	     * Changed here for XML-1.0 5th edition
10880|       |	     */
10881|      0|	    if (ctxt->options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (10881:10): [True: 0, False: 0]
  ------------------
10882|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10883|      0|			          "Unsupported version '%s'\n",
10884|      0|			          version);
10885|      0|	    } else {
10886|      0|	        if ((version[0] == '1') && ((version[1] == '.'))) {
  ------------------
  |  Branch (10886:14): [True: 0, False: 0]
  |  Branch (10886:37): [True: 0, False: 0]
  ------------------
10887|      0|		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10888|      0|		                  "Unsupported version '%s'\n",
10889|      0|				  version, NULL);
10890|      0|		} else {
10891|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10892|      0|				      "Unsupported version '%s'\n",
10893|      0|				      version);
10894|      0|		}
10895|      0|	    }
10896|      0|	}
10897|    489|	if (ctxt->version != NULL)
  ------------------
  |  Branch (10897:6): [True: 0, False: 489]
  ------------------
10898|      0|	    xmlFree((void *) ctxt->version);
10899|    489|	ctxt->version = version;
10900|    489|    }
10901|       |
10902|       |    /*
10903|       |     * We may have the encoding declaration
10904|       |     */
10905|    489|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    489|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    489|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 252, False: 237]
  |  |  |  |  ------------------
  |  |  |  |   89|    489|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 237, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 237]
  |  |  |  |  ------------------
  |  |  |  |   90|    489|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 237]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10906|    237|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    237|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    237|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10906:13): [True: 237, False: 0]
  |  Branch (10906:29): [True: 237, False: 0]
  ------------------
10907|    237|	    SKIP(2);
  ------------------
  |  | 2245|    237|#define SKIP(val) do {							\
  |  | 2246|    237|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    237|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 237]
  |  |  ------------------
  |  | 2248|    237|        xmlParserGrow(ctxt);						\
  |  | 2249|    237|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10908|    237|	    return;
10909|    237|	}
10910|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10911|      0|    }
10912|    252|    xmlParseEncodingDecl(ctxt);
10913|    252|    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (10913:9): [True: 0, False: 252]
  ------------------
10914|    252|         (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (10914:10): [True: 0, False: 252]
  ------------------
10915|       |	/*
10916|       |	 * The XML REC instructs us to stop parsing right here
10917|       |	 */
10918|      0|        return;
10919|      0|    }
10920|       |
10921|       |    /*
10922|       |     * We may have the standalone status.
10923|       |     */
10924|    252|    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {
  ------------------
  |  |  151|     99|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     99|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 18, False: 81]
  |  |  |  |  ------------------
  |  |  |  |   89|     99|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 81, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 81]
  |  |  |  |  ------------------
  |  |  |  |   90|     99|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 81]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10924:9): [True: 99, False: 153]
  ------------------
10925|     81|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     81|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|     81|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10925:13): [True: 81, False: 0]
  |  Branch (10925:29): [True: 81, False: 0]
  ------------------
10926|     81|	    SKIP(2);
  ------------------
  |  | 2245|     81|#define SKIP(val) do {							\
  |  | 2246|     81|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     81|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 81]
  |  |  ------------------
  |  | 2248|     81|        xmlParserGrow(ctxt);						\
  |  | 2249|     81|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10927|     81|	    return;
10928|     81|	}
10929|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10930|      0|    }
10931|       |
10932|       |    /*
10933|       |     * We can grow the input buffer freely at that point
10934|       |     */
10935|    171|    GROW;
  ------------------
  |  | 2270|    171|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    171|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 81, False: 90]
  |  |  ------------------
  |  | 2271|    171|	xmlParserGrow(ctxt);
  ------------------
10936|       |
10937|    171|    SKIP_BLANKS;
  ------------------
  |  | 2273|    171|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10938|    171|    ctxt->standalone = xmlParseSDDecl(ctxt);
10939|       |
10940|    171|    SKIP_BLANKS;
  ------------------
  |  | 2273|    171|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10941|    171|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    171|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    171|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10941:9): [True: 171, False: 0]
  |  Branch (10941:25): [True: 171, False: 0]
  ------------------
10942|    171|        SKIP(2);
  ------------------
  |  | 2245|    171|#define SKIP(val) do {							\
  |  | 2246|    171|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    171|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 171]
  |  |  ------------------
  |  | 2248|    171|        xmlParserGrow(ctxt);						\
  |  | 2249|    171|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10943|    171|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10943:16): [True: 0, False: 0]
  ------------------
10944|       |        /* Deprecated old WD ... */
10945|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10946|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10947|      0|    } else {
10948|      0|        int c;
10949|       |
10950|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10951|      0|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (10951:16): [True: 0, False: 0]
  ------------------
10952|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10953|      0|            if (c == '>')
  ------------------
  |  Branch (10953:17): [True: 0, False: 0]
  ------------------
10954|      0|                break;
10955|      0|        }
10956|      0|    }
10957|    171|}
xmlParseMisc:
10971|    794|xmlParseMisc(xmlParserCtxtPtr ctxt) {
10972|    835|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (10972:12): [True: 835, False: 0]
  ------------------
10973|    835|        SKIP_BLANKS;
  ------------------
  |  | 2273|    835|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10974|    835|        GROW;
  ------------------
  |  | 2270|    835|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    835|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 653, False: 182]
  |  |  ------------------
  |  | 2271|    835|	xmlParserGrow(ctxt);
  ------------------
10975|    835|        if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|    835|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|    529|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10975:13): [True: 529, False: 306]
  |  Branch (10975:29): [True: 13, False: 516]
  ------------------
10976|     13|	    xmlParsePI(ctxt);
10977|    822|        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {
  ------------------
  |  | 2228|    822|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 516, False: 306]
  |  |  |  Branch (2228:41): [True: 220, False: 296]
  |  |  ------------------
  |  | 2229|    822|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 28, False: 192]
  |  |  |  Branch (2229:41): [True: 28, False: 0]
  |  |  ------------------
  ------------------
10978|     28|	    xmlParseComment(ctxt);
10979|    794|        } else {
10980|    794|            break;
10981|    794|        }
10982|    835|    }
10983|    794|}
xmlParseDocument:
11001|    322|xmlParseDocument(xmlParserCtxtPtr ctxt) {
11002|    322|    xmlInitParser();
11003|       |
11004|    322|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (11004:9): [True: 0, False: 322]
  |  Branch (11004:27): [True: 0, False: 322]
  ------------------
11005|      0|        return(-1);
11006|       |
11007|    322|    GROW;
  ------------------
  |  | 2270|    322|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    322|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 322, False: 0]
  |  |  ------------------
  |  | 2271|    322|	xmlParserGrow(ctxt);
  ------------------
11008|       |
11009|       |    /*
11010|       |     * SAX: detecting the level.
11011|       |     */
11012|    322|    xmlDetectSAX2(ctxt);
11013|       |
11014|       |    /*
11015|       |     * SAX: beginning of the document processing.
11016|       |     */
11017|    322|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11017:9): [True: 322, False: 0]
  |  Branch (11017:24): [True: 322, False: 0]
  ------------------
11018|    322|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    322|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    322|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11019|    322|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11019:9): [True: 0, False: 322]
  ------------------
11020|      0|	return(-1);
11021|       |
11022|    322|    xmlDetectEncoding(ctxt);
11023|       |
11024|    322|    if (CUR == 0) {
  ------------------
  |  | 2222|    322|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (11024:9): [True: 0, False: 322]
  ------------------
11025|      0|	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11026|      0|	return(-1);
11027|      0|    }
11028|       |
11029|    322|    GROW;
  ------------------
  |  | 2270|    322|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    322|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 189, False: 133]
  |  |  ------------------
  |  | 2271|    322|	xmlParserGrow(ctxt);
  ------------------
11030|    322|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|    322|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    644|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 313, False: 9]
  |  |  |  |  |  Branch (2228:41): [True: 166, False: 147]
  |  |  |  |  ------------------
  |  |  |  | 2229|    322|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 164, False: 2]
  |  |  |  |  |  Branch (2229:41): [True: 164, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 163, False: 1]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|    163|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    163|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 163, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    163|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    163|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11031|       |
11032|       |	/*
11033|       |	 * Note that we will switch encoding on the fly.
11034|       |	 */
11035|    163|	xmlParseXMLDecl(ctxt);
11036|    163|	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (11036:6): [True: 0, False: 163]
  ------------------
11037|    163|	    (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (11037:6): [True: 0, False: 163]
  ------------------
11038|       |	    /*
11039|       |	     * The XML REC instructs us to stop parsing right here
11040|       |	     */
11041|      0|	    return(-1);
11042|      0|	}
11043|    163|	SKIP_BLANKS;
  ------------------
  |  | 2273|    163|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11044|    163|    } else {
11045|    159|	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    159|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11046|    159|    }
11047|    322|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (11047:9): [True: 322, False: 0]
  |  Branch (11047:24): [True: 322, False: 0]
  |  Branch (11047:54): [True: 322, False: 0]
  ------------------
11048|    322|        ctxt->sax->startDocument(ctxt->userData);
11049|    322|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11049:9): [True: 0, False: 322]
  ------------------
11050|      0|	return(-1);
11051|    322|    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (11051:9): [True: 322, False: 0]
  |  Branch (11051:34): [True: 322, False: 0]
  ------------------
11052|    322|        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
  ------------------
  |  Branch (11052:9): [True: 322, False: 0]
  |  Branch (11052:39): [True: 0, False: 322]
  ------------------
11053|      0|	ctxt->myDoc->compression = ctxt->input->buf->compressed;
11054|      0|    }
11055|       |
11056|       |    /*
11057|       |     * The Misc part of the Prolog
11058|       |     */
11059|    322|    xmlParseMisc(ctxt);
11060|       |
11061|       |    /*
11062|       |     * Then possibly doc type declaration(s) and more Misc
11063|       |     * (doctypedecl Misc*)?
11064|       |     */
11065|    322|    GROW;
  ------------------
  |  | 2270|    322|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    322|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 193, False: 129]
  |  |  ------------------
  |  | 2271|    322|	xmlParserGrow(ctxt);
  ------------------
11066|    322|    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
  ------------------
  |  | 2239|    322|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|    644|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|    644|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|    644|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|    644|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|    644|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 313, False: 9]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 192, False: 121]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|    322|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 190, False: 2]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 190, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 190, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 190, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 190, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 190, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|    322|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 190, False: 0]
  |  |  ------------------
  ------------------
11067|       |
11068|    190|	ctxt->inSubset = 1;
11069|    190|	xmlParseDocTypeDecl(ctxt);
11070|    190|	if (RAW == '[') {
  ------------------
  |  | 2221|    190|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11070:6): [True: 136, False: 54]
  ------------------
11071|    136|	    ctxt->instate = XML_PARSER_DTD;
11072|    136|	    xmlParseInternalSubset(ctxt);
11073|    136|	    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11073:10): [True: 11, False: 125]
  ------------------
11074|     11|		return(-1);
11075|    136|	}
11076|       |
11077|       |	/*
11078|       |	 * Create and update the external subset.
11079|       |	 */
11080|    179|	ctxt->inSubset = 2;
11081|    179|	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  ------------------
  |  Branch (11081:6): [True: 179, False: 0]
  |  Branch (11081:29): [True: 179, False: 0]
  ------------------
11082|    179|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (11082:6): [True: 179, False: 0]
  ------------------
11083|    179|	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
11084|    179|	                              ctxt->extSubSystem, ctxt->extSubURI);
11085|    179|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11085:6): [True: 4, False: 175]
  ------------------
11086|      4|	    return(-1);
11087|    175|	ctxt->inSubset = 0;
11088|       |
11089|    175|        xmlCleanSpecialAttr(ctxt);
11090|       |
11091|    175|	ctxt->instate = XML_PARSER_PROLOG;
11092|    175|	xmlParseMisc(ctxt);
11093|    175|    }
11094|       |
11095|       |    /*
11096|       |     * Time to start parsing the tree itself
11097|       |     */
11098|    307|    GROW;
  ------------------
  |  | 2270|    307|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    307|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 221, False: 86]
  |  |  ------------------
  |  | 2271|    307|	xmlParserGrow(ctxt);
  ------------------
11099|    307|    if (RAW != '<') {
  ------------------
  |  | 2221|    307|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11099:9): [True: 10, False: 297]
  ------------------
11100|     10|	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11101|     10|		       "Start tag expected, '<' not found\n");
11102|    297|    } else {
11103|    297|	ctxt->instate = XML_PARSER_CONTENT;
11104|    297|	xmlParseElement(ctxt);
11105|    297|	ctxt->instate = XML_PARSER_EPILOG;
11106|       |
11107|       |
11108|       |	/*
11109|       |	 * The Misc part at the end
11110|       |	 */
11111|    297|	xmlParseMisc(ctxt);
11112|       |
11113|    297|        if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (11113:13): [True: 5, False: 292]
  ------------------
11114|      5|            if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (11114:17): [True: 1, False: 4]
  ------------------
11115|      1|	        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11116|    292|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (11116:20): [True: 283, False: 9]
  ------------------
11117|    292|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (11117:20): [True: 15, False: 268]
  ------------------
11118|    292|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (11118:20): [True: 0, False: 15]
  ------------------
11119|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
11120|      0|                           "Truncated multi-byte sequence at EOF\n");
11121|      0|        }
11122|    297|	ctxt->instate = XML_PARSER_EOF;
11123|    297|    }
11124|       |
11125|       |    /*
11126|       |     * SAX: end of the document processing.
11127|       |     */
11128|    307|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11128:9): [True: 307, False: 0]
  |  Branch (11128:24): [True: 307, False: 0]
  ------------------
11129|    307|        ctxt->sax->endDocument(ctxt->userData);
11130|       |
11131|       |    /*
11132|       |     * Remove locally kept entity definitions if the tree was not built
11133|       |     */
11134|    307|    if ((ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (11134:9): [True: 307, False: 0]
  ------------------
11135|    307|	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|    307|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|    307|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (11135:2): [True: 0, False: 307]
  ------------------
11136|      0|	xmlFreeDoc(ctxt->myDoc);
11137|      0|	ctxt->myDoc = NULL;
11138|      0|    }
11139|       |
11140|    307|    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (11140:9): [True: 262, False: 45]
  |  Branch (11140:31): [True: 262, False: 0]
  ------------------
11141|    262|        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
11142|    262|	if (ctxt->valid)
  ------------------
  |  Branch (11142:6): [True: 255, False: 7]
  ------------------
11143|    255|	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
11144|    262|	if (ctxt->nsWellFormed)
  ------------------
  |  Branch (11144:6): [True: 251, False: 11]
  ------------------
11145|    251|	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
11146|    262|	if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (11146:6): [True: 0, False: 262]
  ------------------
11147|      0|	    ctxt->myDoc->properties |= XML_DOC_OLD10;
11148|    262|    }
11149|    307|    if (! ctxt->wellFormed) {
  ------------------
  |  Branch (11149:9): [True: 45, False: 262]
  ------------------
11150|     45|	ctxt->valid = 0;
11151|     45|	return(-1);
11152|     45|    }
11153|    262|    return(0);
11154|    307|}
xmlParseChunk:
12110|  13.0k|              int terminate) {
12111|  13.0k|    int end_in_lf = 0;
12112|       |
12113|  13.0k|    if (ctxt == NULL)
  ------------------
  |  Branch (12113:9): [True: 0, False: 13.0k]
  ------------------
12114|      0|        return(XML_ERR_INTERNAL_ERROR);
12115|  13.0k|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12115:9): [True: 566, False: 12.4k]
  |  Branch (12115:40): [True: 535, False: 31]
  ------------------
12116|    535|        return(ctxt->errNo);
12117|  12.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12117:9): [True: 0, False: 12.4k]
  ------------------
12118|      0|        return(-1);
12119|  12.4k|    if (ctxt->input == NULL)
  ------------------
  |  Branch (12119:9): [True: 0, False: 12.4k]
  ------------------
12120|      0|        return(-1);
12121|       |
12122|  12.4k|    ctxt->progressive = 1;
12123|  12.4k|    if (ctxt->instate == XML_PARSER_START)
  ------------------
  |  Branch (12123:9): [True: 672, False: 11.8k]
  ------------------
12124|    672|        xmlDetectSAX2(ctxt);
12125|  12.4k|    if ((size > 0) && (chunk != NULL) && (!terminate) &&
  ------------------
  |  Branch (12125:9): [True: 11.8k, False: 578]
  |  Branch (12125:23): [True: 11.8k, False: 0]
  |  Branch (12125:42): [True: 11.8k, False: 0]
  ------------------
12126|  12.4k|        (chunk[size - 1] == '\r')) {
  ------------------
  |  Branch (12126:9): [True: 89, False: 11.8k]
  ------------------
12127|     89|	end_in_lf = 1;
12128|     89|	size--;
12129|     89|    }
12130|       |
12131|  12.4k|    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12131:9): [True: 11.8k, False: 578]
  |  Branch (12131:23): [True: 11.8k, False: 0]
  |  Branch (12131:42): [True: 11.8k, False: 0]
  ------------------
12132|  12.4k|        (ctxt->input->buf != NULL) && (ctxt->instate != XML_PARSER_EOF))  {
  ------------------
  |  Branch (12132:9): [True: 11.8k, False: 0]
  |  Branch (12132:39): [True: 11.8k, False: 0]
  ------------------
12133|  11.8k|	size_t pos = ctxt->input->cur - ctxt->input->base;
12134|  11.8k|	int res;
12135|       |
12136|  11.8k|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12137|  11.8k|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12138|  11.8k|	if (res < 0) {
  ------------------
  |  Branch (12138:6): [True: 0, False: 11.8k]
  ------------------
12139|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12140|      0|	    xmlHaltParser(ctxt);
12141|      0|	    return(ctxt->errNo);
12142|      0|	}
12143|  11.8k|    }
12144|       |
12145|  12.4k|    xmlParseTryOrFinish(ctxt, terminate);
12146|  12.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12146:9): [True: 84, False: 12.3k]
  ------------------
12147|     84|        return(ctxt->errNo);
12148|       |
12149|  12.3k|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (12149:9): [True: 12.3k, False: 0]
  ------------------
12150|  12.3k|         (((ctxt->input->end - ctxt->input->cur) > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  12.3k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12150:11): [True: 0, False: 12.3k]
  ------------------
12151|  12.3k|         ((ctxt->input->cur - ctxt->input->base) > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  12.3k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (12151:10): [True: 0, False: 12.3k]
  ------------------
12152|  12.3k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (12152:9): [True: 0, False: 0]
  ------------------
12153|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, "Huge input lookup");
12154|      0|        xmlHaltParser(ctxt);
12155|      0|    }
12156|  12.3k|    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (12156:9): [True: 91, False: 12.2k]
  |  Branch (12156:40): [True: 32, False: 59]
  ------------------
12157|     32|        return(ctxt->errNo);
12158|       |
12159|  12.3k|    if ((end_in_lf == 1) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (12159:9): [True: 89, False: 12.2k]
  |  Branch (12159:29): [True: 89, False: 0]
  ------------------
12160|  12.3k|        (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12160:9): [True: 89, False: 0]
  ------------------
12161|     89|	size_t pos = ctxt->input->cur - ctxt->input->base;
12162|     89|        int res;
12163|       |
12164|     89|	res = xmlParserInputBufferPush(ctxt->input->buf, 1, "\r");
12165|     89|	xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12166|     89|        if (res < 0) {
  ------------------
  |  Branch (12166:13): [True: 0, False: 89]
  ------------------
12167|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12168|      0|            xmlHaltParser(ctxt);
12169|      0|            return(ctxt->errNo);
12170|      0|        }
12171|     89|    }
12172|  12.3k|    if (terminate) {
  ------------------
  |  Branch (12172:9): [True: 530, False: 11.8k]
  ------------------
12173|       |	/*
12174|       |	 * Check for termination
12175|       |	 */
12176|    530|        if ((ctxt->instate != XML_PARSER_EOF) &&
  ------------------
  |  Branch (12176:13): [True: 530, False: 0]
  ------------------
12177|    530|            (ctxt->instate != XML_PARSER_EPILOG)) {
  ------------------
  |  Branch (12177:13): [True: 6, False: 524]
  ------------------
12178|      6|            if (ctxt->nameNr > 0) {
  ------------------
  |  Branch (12178:17): [True: 4, False: 2]
  ------------------
12179|      4|                const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
12180|      4|                int line = ctxt->pushTab[ctxt->nameNr - 1].line;
12181|      4|                xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
12182|      4|                        "Premature end of data in tag %s line %d\n",
12183|      4|                        name, line, NULL);
12184|      4|            } else if (ctxt->instate == XML_PARSER_START) {
  ------------------
  |  Branch (12184:24): [True: 2, False: 0]
  ------------------
12185|      2|                xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
12186|      2|            } else {
12187|      0|                xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
12188|      0|                               "Start tag expected, '<' not found\n");
12189|      0|            }
12190|    524|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (12190:20): [True: 524, False: 0]
  ------------------
12191|    524|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (12191:20): [True: 30, False: 494]
  ------------------
12192|    524|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (12192:20): [True: 0, False: 30]
  ------------------
12193|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
12194|      0|                           "Truncated multi-byte sequence at EOF\n");
12195|      0|        }
12196|    530|	if (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (12196:6): [True: 530, False: 0]
  ------------------
12197|    530|	    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12197:10): [True: 530, False: 0]
  |  Branch (12197:25): [True: 530, False: 0]
  ------------------
12198|    530|		ctxt->sax->endDocument(ctxt->userData);
12199|    530|	}
12200|    530|	ctxt->instate = XML_PARSER_EOF;
12201|    530|    }
12202|  12.3k|    if (ctxt->wellFormed == 0)
  ------------------
  |  Branch (12202:9): [True: 6, False: 12.3k]
  ------------------
12203|      6|	return((xmlParserErrors) ctxt->errNo);
12204|  12.3k|    else
12205|  12.3k|        return(0);
12206|  12.3k|}
xmlCreatePushParserCtxt:
12235|    646|                        const char *chunk, int size, const char *filename) {
12236|    646|    xmlParserCtxtPtr ctxt;
12237|    646|    xmlParserInputPtr inputStream;
12238|    646|    xmlParserInputBufferPtr buf;
12239|       |
12240|    646|    buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
12241|    646|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (12241:9): [True: 0, False: 646]
  ------------------
12242|       |
12243|    646|    ctxt = xmlNewSAXParserCtxt(sax, user_data);
12244|    646|    if (ctxt == NULL) {
  ------------------
  |  Branch (12244:9): [True: 0, False: 646]
  ------------------
12245|      0|        xmlErrMemory(NULL, "creating parser: out of memory\n");
12246|      0|	xmlFreeParserInputBuffer(buf);
12247|      0|	return(NULL);
12248|      0|    }
12249|    646|    ctxt->dictNames = 1;
12250|    646|    if (filename == NULL) {
  ------------------
  |  Branch (12250:9): [True: 323, False: 323]
  ------------------
12251|    323|	ctxt->directory = NULL;
12252|    323|    } else {
12253|    323|        ctxt->directory = xmlParserGetDirectory(filename);
12254|    323|    }
12255|       |
12256|    646|    inputStream = xmlNewInputStream(ctxt);
12257|    646|    if (inputStream == NULL) {
  ------------------
  |  Branch (12257:9): [True: 0, False: 646]
  ------------------
12258|      0|	xmlFreeParserCtxt(ctxt);
12259|      0|	xmlFreeParserInputBuffer(buf);
12260|      0|	return(NULL);
12261|      0|    }
12262|       |
12263|    646|    if (filename == NULL)
  ------------------
  |  Branch (12263:9): [True: 323, False: 323]
  ------------------
12264|    323|	inputStream->filename = NULL;
12265|    323|    else {
12266|    323|	inputStream->filename = (char *)
12267|    323|	    xmlCanonicPath((const xmlChar *) filename);
12268|    323|	if (inputStream->filename == NULL) {
  ------------------
  |  Branch (12268:6): [True: 0, False: 323]
  ------------------
12269|      0|            xmlFreeInputStream(inputStream);
12270|      0|	    xmlFreeParserCtxt(ctxt);
12271|      0|	    xmlFreeParserInputBuffer(buf);
12272|      0|	    return(NULL);
12273|      0|	}
12274|    323|    }
12275|    646|    inputStream->buf = buf;
12276|    646|    xmlBufResetInput(inputStream->buf->buffer, inputStream);
12277|    646|    inputPush(ctxt, inputStream);
12278|       |
12279|    646|    if ((size != 0) && (chunk != NULL) &&
  ------------------
  |  Branch (12279:9): [True: 310, False: 336]
  |  Branch (12279:24): [True: 310, False: 0]
  ------------------
12280|    646|        (ctxt->input != NULL) && (ctxt->input->buf != NULL)) {
  ------------------
  |  Branch (12280:9): [True: 310, False: 0]
  |  Branch (12280:34): [True: 310, False: 0]
  ------------------
12281|    310|	size_t pos = ctxt->input->cur - ctxt->input->base;
12282|    310|        int res;
12283|       |
12284|    310|	res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);
12285|    310|        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);
12286|    310|        if (res < 0) {
  ------------------
  |  Branch (12286:13): [True: 0, False: 310]
  ------------------
12287|      0|            xmlFatalErr(ctxt, ctxt->input->buf->error, NULL);
12288|      0|            xmlHaltParser(ctxt);
12289|      0|        }
12290|    310|    }
12291|       |
12292|    646|    return(ctxt);
12293|    646|}
xmlStopParser:
12303|    323|xmlStopParser(xmlParserCtxtPtr ctxt) {
12304|    323|    if (ctxt == NULL)
  ------------------
  |  Branch (12304:9): [True: 0, False: 323]
  ------------------
12305|      0|        return;
12306|    323|    xmlHaltParser(ctxt);
12307|    323|    ctxt->errNo = XML_ERR_USER_STOP;
12308|    323|}
xmlCreateMemoryParserCtxt:
13985|    323|xmlCreateMemoryParserCtxt(const char *buffer, int size) {
13986|    323|    xmlParserCtxtPtr ctxt;
13987|    323|    xmlParserInputPtr input;
13988|    323|    xmlParserInputBufferPtr buf;
13989|       |
13990|    323|    if (buffer == NULL)
  ------------------
  |  Branch (13990:9): [True: 0, False: 323]
  ------------------
13991|      0|	return(NULL);
13992|    323|    if (size <= 0)
  ------------------
  |  Branch (13992:9): [True: 1, False: 322]
  ------------------
13993|      1|	return(NULL);
13994|       |
13995|    322|    ctxt = xmlNewParserCtxt();
13996|    322|    if (ctxt == NULL)
  ------------------
  |  Branch (13996:9): [True: 0, False: 322]
  ------------------
13997|      0|	return(NULL);
13998|       |
13999|    322|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14000|    322|    if (buf == NULL) {
  ------------------
  |  Branch (14000:9): [True: 0, False: 322]
  ------------------
14001|      0|	xmlFreeParserCtxt(ctxt);
14002|      0|	return(NULL);
14003|      0|    }
14004|       |
14005|    322|    input = xmlNewInputStream(ctxt);
14006|    322|    if (input == NULL) {
  ------------------
  |  Branch (14006:9): [True: 0, False: 322]
  ------------------
14007|      0|	xmlFreeParserInputBuffer(buf);
14008|      0|	xmlFreeParserCtxt(ctxt);
14009|      0|	return(NULL);
14010|      0|    }
14011|       |
14012|    322|    input->filename = NULL;
14013|    322|    input->buf = buf;
14014|    322|    xmlBufResetInput(input->buf->buffer, input);
14015|       |
14016|    322|    inputPush(ctxt, input);
14017|    322|    return(ctxt);
14018|    322|}
xmlCreateDocParserCtxt:
14196|    324|xmlCreateDocParserCtxt(const xmlChar *str) {
14197|    324|    xmlParserCtxtPtr ctxt;
14198|    324|    xmlParserInputPtr input;
14199|    324|    xmlParserInputBufferPtr buf;
14200|       |
14201|    324|    if (str == NULL)
  ------------------
  |  Branch (14201:9): [True: 0, False: 324]
  ------------------
14202|      0|	return(NULL);
14203|       |
14204|    324|    ctxt = xmlNewParserCtxt();
14205|    324|    if (ctxt == NULL)
  ------------------
  |  Branch (14205:9): [True: 0, False: 324]
  ------------------
14206|      0|	return(NULL);
14207|       |
14208|    324|    buf = xmlParserInputBufferCreateString(str);
14209|    324|    if (buf == NULL) {
  ------------------
  |  Branch (14209:9): [True: 0, False: 324]
  ------------------
14210|      0|	xmlFreeParserCtxt(ctxt);
14211|      0|	return(NULL);
14212|      0|    }
14213|       |
14214|    324|    input = xmlNewInputStream(ctxt);
14215|    324|    if (input == NULL) {
  ------------------
  |  Branch (14215:9): [True: 0, False: 324]
  ------------------
14216|      0|	xmlFreeParserInputBuffer(buf);
14217|      0|	xmlFreeParserCtxt(ctxt);
14218|      0|	return(NULL);
14219|      0|    }
14220|       |
14221|    324|    input->filename = NULL;
14222|    324|    input->buf = buf;
14223|    324|    xmlBufResetInput(input->buf->buffer, input);
14224|       |
14225|    324|    inputPush(ctxt, input);
14226|    324|    return(ctxt);
14227|    324|}
xmlCtxtUseOptions:
14693|    646|{
14694|    646|   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
14695|    646|}
xmlReadMemory:
14830|    323|{
14831|    323|    xmlParserCtxtPtr ctxt;
14832|       |
14833|    323|    xmlInitParser();
14834|    323|    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14835|    323|    if (ctxt == NULL)
  ------------------
  |  Branch (14835:9): [True: 1, False: 322]
  ------------------
14836|      1|        return (NULL);
14837|    322|    return (xmlDoRead(ctxt, URL, encoding, options, 0));
14838|    323|}
parser.c:xmlParserNsLookup:
 1485|  52.4k|                  xmlParserNsBucket **bucketPtr) {
 1486|  52.4k|    xmlParserNsBucket *bucket;
 1487|  52.4k|    unsigned index, hashValue;
 1488|       |
 1489|  52.4k|    if (prefix->name == NULL)
  ------------------
  |  Branch (1489:9): [True: 42.3k, False: 10.0k]
  ------------------
 1490|  42.3k|        return(ctxt->nsdb->defaultNsIndex);
 1491|       |
 1492|  10.0k|    if (ctxt->nsdb->hashSize == 0)
  ------------------
  |  Branch (1492:9): [True: 174, False: 9.90k]
  ------------------
 1493|    174|        return(INT_MAX);
 1494|       |
 1495|  9.90k|    hashValue = prefix->hashValue;
 1496|  9.90k|    index = hashValue & (ctxt->nsdb->hashSize - 1);
 1497|  9.90k|    bucket = &ctxt->nsdb->hash[index];
 1498|       |
 1499|  11.4k|    while (bucket->hashValue) {
  ------------------
  |  Branch (1499:12): [True: 11.4k, False: 63]
  ------------------
 1500|  11.4k|        if ((bucket->hashValue == hashValue) &&
  ------------------
  |  Branch (1500:13): [True: 9.85k, False: 1.57k]
  ------------------
 1501|  11.4k|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (1501:13): [True: 9.84k, False: 9]
  ------------------
 1502|  9.84k|            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {
  ------------------
  |  Branch (1502:17): [True: 9.84k, False: 0]
  ------------------
 1503|  9.84k|                if (bucketPtr != NULL)
  ------------------
  |  Branch (1503:21): [True: 229, False: 9.61k]
  ------------------
 1504|    229|                    *bucketPtr = bucket;
 1505|  9.84k|                return(bucket->index);
 1506|  9.84k|            }
 1507|  9.84k|        }
 1508|       |
 1509|  1.58k|        index++;
 1510|  1.58k|        bucket++;
 1511|  1.58k|        if (index == ctxt->nsdb->hashSize) {
  ------------------
  |  Branch (1511:13): [True: 0, False: 1.58k]
  ------------------
 1512|      0|            index = 0;
 1513|      0|            bucket = ctxt->nsdb->hash;
 1514|      0|        }
 1515|  1.58k|    }
 1516|       |
 1517|     63|    if (bucketPtr != NULL)
  ------------------
  |  Branch (1517:9): [True: 63, False: 0]
  ------------------
 1518|     63|        *bucketPtr = bucket;
 1519|     63|    return(INT_MAX);
 1520|  9.90k|}
parser.c:xmlFatalErrMsgInt:
  385|      9|{
  386|      9|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (386:9): [True: 9, False: 0]
  |  Branch (386:27): [True: 3, False: 6]
  ------------------
  387|      9|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (387:9): [True: 0, False: 3]
  ------------------
  388|      0|	return;
  389|      9|    if (ctxt != NULL)
  ------------------
  |  Branch (389:9): [True: 9, False: 0]
  ------------------
  390|      9|	ctxt->errNo = error;
  391|      9|    __xmlRaiseError(NULL, NULL, NULL,
  392|      9|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  393|      9|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  394|      9|    if (ctxt != NULL) {
  ------------------
  |  Branch (394:9): [True: 9, False: 0]
  ------------------
  395|      9|	ctxt->wellFormed = 0;
  396|      9|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (396:6): [True: 9, False: 0]
  ------------------
  397|      9|	    ctxt->disableSAX = 1;
  398|      9|    }
  399|      9|}
parser.c:xmlSaturatedAddSizeT:
  549|   395k|xmlSaturatedAddSizeT(unsigned long *dst, unsigned long val) {
  550|   395k|    if (val > ULONG_MAX - *dst)
  ------------------
  |  Branch (550:9): [True: 0, False: 395k]
  ------------------
  551|      0|        *dst = ULONG_MAX;
  552|   395k|    else
  553|   395k|        *dst += val;
  554|   395k|}
parser.c:xmlSaturatedAdd:
  541|  1.46M|xmlSaturatedAdd(unsigned long *dst, unsigned long val) {
  542|  1.46M|    if (val > ULONG_MAX - *dst)
  ------------------
  |  Branch (542:9): [True: 0, False: 1.46M]
  ------------------
  543|      0|        *dst = ULONG_MAX;
  544|  1.46M|    else
  545|  1.46M|        *dst += val;
  546|  1.46M|}
parser.c:xmlParserEntityCheck:
  582|   392k|{
  583|   392k|    unsigned long consumed;
  584|   392k|    xmlParserInputPtr input = ctxt->input;
  585|   392k|    xmlEntityPtr entity = input->entity;
  586|       |
  587|       |    /*
  588|       |     * Compute total consumed bytes so far, including input streams of
  589|       |     * external entities.
  590|       |     */
  591|   392k|    consumed = input->parentConsumed;
  592|   392k|    if ((entity == NULL) ||
  ------------------
  |  Branch (592:9): [True: 289k, False: 102k]
  ------------------
  593|   392k|        ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (593:10): [True: 9.87k, False: 93.0k]
  ------------------
  594|   289k|         ((entity->flags & XML_ENT_PARSED) == 0))) {
  ------------------
  |  |   14|  9.87k|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (594:10): [True: 3, False: 9.87k]
  ------------------
  595|   289k|        xmlSaturatedAdd(&consumed, input->consumed);
  596|   289k|        xmlSaturatedAddSizeT(&consumed, input->cur - input->base);
  597|   289k|    }
  598|   392k|    xmlSaturatedAdd(&consumed, ctxt->sizeentities);
  599|       |
  600|       |    /*
  601|       |     * Add extra cost and some fixed cost.
  602|       |     */
  603|   392k|    xmlSaturatedAdd(&ctxt->sizeentcopy, extra);
  604|   392k|    xmlSaturatedAdd(&ctxt->sizeentcopy, XML_ENT_FIXED_COST);
  ------------------
  |  |  152|   392k|#define XML_ENT_FIXED_COST 20
  ------------------
  605|       |
  606|       |    /*
  607|       |     * It's important to always use saturation arithmetic when tracking
  608|       |     * entity sizes to make the size checks reliable. If "sizeentcopy"
  609|       |     * overflows, we have to abort.
  610|       |     */
  611|   392k|    if ((ctxt->sizeentcopy > XML_PARSER_ALLOWED_EXPANSION) &&
  ------------------
  |  |  145|   392k|#define XML_PARSER_ALLOWED_EXPANSION 1000000
  ------------------
  |  Branch (611:9): [True: 627, False: 391k]
  ------------------
  612|   392k|        ((ctxt->sizeentcopy >= ULONG_MAX) ||
  ------------------
  |  Branch (612:10): [True: 0, False: 627]
  ------------------
  613|    627|         (ctxt->sizeentcopy / ctxt->maxAmpl > consumed))) {
  ------------------
  |  Branch (613:10): [True: 627, False: 0]
  ------------------
  614|    627|        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,
  615|    627|                       "Maximum entity amplification factor exceeded, see "
  616|    627|                       "xmlCtxtSetMaxAmplification.\n");
  617|    627|        xmlHaltParser(ctxt);
  618|    627|        return(1);
  619|    627|    }
  620|       |
  621|   391k|    return(0);
  622|   392k|}
parser.c:xmlStringDecodeEntitiesInt:
 2798|   160k|                           int check) {
 2799|   160k|    xmlChar *buffer = NULL;
 2800|   160k|    size_t buffer_size = 0;
 2801|   160k|    size_t nbchars = 0;
 2802|       |
 2803|   160k|    xmlChar *current = NULL;
 2804|   160k|    xmlChar *rep = NULL;
 2805|   160k|    const xmlChar *last;
 2806|   160k|    xmlEntityPtr ent;
 2807|   160k|    int c,l;
 2808|       |
 2809|   160k|    if (str == NULL)
  ------------------
  |  Branch (2809:9): [True: 0, False: 160k]
  ------------------
 2810|      0|        return(NULL);
 2811|   160k|    last = str + len;
 2812|       |
 2813|   160k|    if (((ctxt->depth > 40) &&
  ------------------
  |  Branch (2813:10): [True: 0, False: 160k]
  ------------------
 2814|   160k|         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (2814:10): [True: 0, False: 0]
  ------------------
 2815|   160k|	(ctxt->depth > 100)) {
  ------------------
  |  Branch (2815:2): [True: 0, False: 160k]
  ------------------
 2816|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_LOOP,
 2817|      0|                       "Maximum entity nesting depth exceeded");
 2818|      0|	return(NULL);
 2819|      0|    }
 2820|       |
 2821|       |    /*
 2822|       |     * allocate a translation buffer.
 2823|       |     */
 2824|   160k|    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|   160k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
 2825|   160k|    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);
 2826|   160k|    if (buffer == NULL) goto mem_error;
  ------------------
  |  Branch (2826:9): [True: 0, False: 160k]
  ------------------
 2827|       |
 2828|       |    /*
 2829|       |     * OK loop until we reach one of the ending char or a size limit.
 2830|       |     * we are operating on already parsed values.
 2831|       |     */
 2832|   160k|    if (str < last)
  ------------------
  |  Branch (2832:9): [True: 160k, False: 156]
  ------------------
 2833|   160k|	c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|   160k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2834|    156|    else
 2835|    156|        c = 0;
 2836|  9.30M|    while ((c != 0) && (c != end) && /* non input consuming loop */
  ------------------
  |  Branch (2836:12): [True: 9.14M, False: 160k]
  |  Branch (2836:24): [True: 9.14M, False: 0]
  ------------------
 2837|  9.30M|           (c != end2) && (c != end3) &&
  ------------------
  |  Branch (2837:12): [True: 9.14M, False: 0]
  |  Branch (2837:27): [True: 9.14M, False: 0]
  ------------------
 2838|  9.30M|           (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (2838:12): [True: 9.14M, False: 0]
  ------------------
 2839|       |
 2840|  9.14M|	if (c == 0) break;
  ------------------
  |  Branch (2840:6): [True: 0, False: 9.14M]
  ------------------
 2841|  9.14M|        if ((c == '&') && (str[1] == '#')) {
  ------------------
  |  Branch (2841:13): [True: 153k, False: 8.98M]
  |  Branch (2841:27): [True: 768, False: 153k]
  ------------------
 2842|    768|	    int val = xmlParseStringCharRef(ctxt, &str);
 2843|    768|	    if (val == 0)
  ------------------
  |  Branch (2843:10): [True: 0, False: 768]
  ------------------
 2844|      0|                goto int_error;
 2845|    768|	    COPY_BUF(buffer, nbchars, val);
  ------------------
  |  | 2295|    768|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 462, False: 306]
  |  |  ------------------
  |  | 2296|    768|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2846|    768|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|    768|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2846:10): [True: 0, False: 768]
  ------------------
 2847|      0|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2848|      0|	    }
 2849|  9.14M|	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {
  ------------------
  |  |  521|   153k|#define XML_SUBSTITUTE_REF	1
  ------------------
  |  Branch (2849:13): [True: 153k, False: 8.98M]
  |  Branch (2849:27): [True: 151k, False: 1.85k]
  ------------------
 2850|   151k|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   151k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   151k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 151k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2851|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2852|      0|			"String decoding Entity Reference: %.30s\n",
 2853|      0|			str);
 2854|   151k|	    ent = xmlParseStringEntityRef(ctxt, &str);
 2855|   151k|	    if ((ent != NULL) &&
  ------------------
  |  Branch (2855:10): [True: 151k, False: 3]
  ------------------
 2856|   151k|		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (2856:3): [True: 3, False: 151k]
  ------------------
 2857|      3|		if (ent->content != NULL) {
  ------------------
  |  Branch (2857:7): [True: 3, False: 0]
  ------------------
 2858|      3|		    COPY_BUF(buffer, nbchars, ent->content[0]);
  ------------------
  |  | 2295|      3|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 3, False: 0]
  |  |  ------------------
  |  | 2296|      3|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2859|      3|		    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      3|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2859:11): [True: 0, False: 3]
  ------------------
 2860|      0|			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2861|      0|		    }
 2862|      3|		} else {
 2863|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 2864|      0|			    "predefined entity has no content\n");
 2865|      0|                    goto int_error;
 2866|      0|		}
 2867|   151k|	    } else if ((ent != NULL) && (ent->content != NULL)) {
  ------------------
  |  Branch (2867:17): [True: 151k, False: 3]
  |  Branch (2867:34): [True: 151k, False: 0]
  ------------------
 2868|   151k|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2868:14): [True: 151k, False: 0]
  |  Branch (2868:25): [True: 9, False: 151k]
  ------------------
 2869|      9|                    goto int_error;
 2870|       |
 2871|   151k|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|   151k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2871:21): [True: 3, False: 151k]
  ------------------
 2872|      3|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2873|      3|                    xmlHaltParser(ctxt);
 2874|      3|                    ent->content[0] = 0;
 2875|      3|                    goto int_error;
 2876|      3|                }
 2877|       |
 2878|   151k|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|   151k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2879|   151k|		ctxt->depth++;
 2880|   151k|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2881|   151k|                        ent->length, what, 0, 0, 0, check);
 2882|   151k|		ctxt->depth--;
 2883|   151k|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|   151k|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2884|       |
 2885|   151k|		if (rep == NULL) {
  ------------------
  |  Branch (2885:7): [True: 156, False: 150k]
  ------------------
 2886|    156|                    ent->content[0] = 0;
 2887|    156|                    goto int_error;
 2888|    156|                }
 2889|       |
 2890|   150k|                current = rep;
 2891|  17.6M|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2891:24): [True: 17.5M, False: 150k]
  ------------------
 2892|  17.5M|                    buffer[nbchars++] = *current++;
 2893|  17.5M|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  17.5M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2893:25): [True: 8.24k, False: 17.5M]
  ------------------
 2894|  16.4k|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|  8.24k|#define growBuffer(buffer, n) {						\
  |  | 2775|  8.24k|    xmlChar *tmp;							\
  |  | 2776|  8.24k|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|  8.24k|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 8.24k]
  |  |  ------------------
  |  | 2778|  8.24k|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|  8.24k|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 8.24k]
  |  |  ------------------
  |  | 2780|  8.24k|    buffer = tmp;							\
  |  | 2781|  8.24k|    buffer##_size = new_size;                                           \
  |  | 2782|  8.24k|}
  ------------------
 2895|  16.4k|                    }
 2896|  17.5M|                }
 2897|   150k|                xmlFree(rep);
 2898|   150k|                rep = NULL;
 2899|   150k|	    } else if (ent != NULL) {
  ------------------
  |  Branch (2899:17): [True: 0, False: 3]
  ------------------
 2900|      0|		int i = xmlStrlen(ent->name);
 2901|      0|		const xmlChar *cur = ent->name;
 2902|       |
 2903|      0|		buffer[nbchars++] = '&';
 2904|      0|		if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2904:7): [True: 0, False: 0]
  ------------------
 2905|      0|		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 2906|      0|		}
 2907|      0|		for (;i > 0;i--)
  ------------------
  |  Branch (2907:9): [True: 0, False: 0]
  ------------------
 2908|      0|		    buffer[nbchars++] = *cur++;
 2909|      0|		buffer[nbchars++] = ';';
 2910|      0|	    }
 2911|  8.99M|	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {
  ------------------
  |  |  527|    810|#define XML_SUBSTITUTE_PEREF	2
  ------------------
  |  Branch (2911:13): [True: 810, False: 8.99M]
  |  Branch (2911:25): [True: 810, False: 0]
  ------------------
 2912|    810|	    if (xmlParserDebugEntities)
  ------------------
  |  |  870|    810|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|    810|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 810]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2913|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2914|      0|			"String decoding PE Reference: %.30s\n", str);
 2915|    810|	    ent = xmlParseStringPEReference(ctxt, &str);
 2916|    810|	    if (ent != NULL) {
  ------------------
  |  Branch (2916:10): [True: 810, False: 0]
  ------------------
 2917|    810|                if (ent->content == NULL) {
  ------------------
  |  Branch (2917:21): [True: 6, False: 804]
  ------------------
 2918|       |		    /*
 2919|       |		     * Note: external parsed entities will not be loaded,
 2920|       |		     * it is not required for a non-validating parser to
 2921|       |		     * complete external PEReferences coming from the
 2922|       |		     * internal subset
 2923|       |		     */
 2924|      6|		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
  ------------------
  |  Branch (2924:11): [True: 6, False: 0]
  ------------------
 2925|      6|			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
  ------------------
  |  Branch (2925:4): [True: 0, False: 0]
  ------------------
 2926|      6|			(ctxt->validate != 0)) {
  ------------------
  |  Branch (2926:4): [True: 0, False: 0]
  ------------------
 2927|      6|			xmlLoadEntityContent(ctxt, ent);
 2928|      6|		    } else {
 2929|      0|			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
 2930|      0|		  "not validating will not read content for PE entity %s\n",
 2931|      0|		                      ent->name, NULL);
 2932|      0|		    }
 2933|      6|		}
 2934|       |
 2935|    810|	        if ((check) && (xmlParserEntityCheck(ctxt, ent->length)))
  ------------------
  |  Branch (2935:14): [True: 810, False: 0]
  |  Branch (2935:25): [True: 6, False: 804]
  ------------------
 2936|      6|                    goto int_error;
 2937|       |
 2938|    804|                if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|    804|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (2938:21): [True: 0, False: 804]
  ------------------
 2939|      0|	            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 2940|      0|                    xmlHaltParser(ctxt);
 2941|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2941:25): [True: 0, False: 0]
  ------------------
 2942|      0|                        ent->content[0] = 0;
 2943|      0|                    goto int_error;
 2944|      0|                }
 2945|       |
 2946|    804|                ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|    804|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2947|    804|		ctxt->depth++;
 2948|    804|		rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 2949|    804|                        ent->length, what, 0, 0, 0, check);
 2950|    804|		ctxt->depth--;
 2951|    804|                ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|    804|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 2952|       |
 2953|    804|		if (rep == NULL) {
  ------------------
  |  Branch (2953:7): [True: 0, False: 804]
  ------------------
 2954|      0|                    if (ent->content != NULL)
  ------------------
  |  Branch (2954:25): [True: 0, False: 0]
  ------------------
 2955|      0|                        ent->content[0] = 0;
 2956|      0|                    goto int_error;
 2957|      0|                }
 2958|    804|                current = rep;
 2959|  4.25M|                while (*current != 0) { /* non input consuming loop */
  ------------------
  |  Branch (2959:24): [True: 4.25M, False: 804]
  ------------------
 2960|  4.25M|                    buffer[nbchars++] = *current++;
 2961|  4.25M|                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  4.25M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2961:25): [True: 225, False: 4.25M]
  ------------------
 2962|    450|                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|    225|#define growBuffer(buffer, n) {						\
  |  | 2775|    225|    xmlChar *tmp;							\
  |  | 2776|    225|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|    225|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 225]
  |  |  ------------------
  |  | 2778|    225|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|    225|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 225]
  |  |  ------------------
  |  | 2780|    225|    buffer = tmp;							\
  |  | 2781|    225|    buffer##_size = new_size;                                           \
  |  | 2782|    225|}
  ------------------
 2963|    450|                    }
 2964|  4.25M|                }
 2965|    804|                xmlFree(rep);
 2966|    804|                rep = NULL;
 2967|    804|	    }
 2968|  8.99M|	} else {
 2969|  8.99M|	    COPY_BUF(buffer, nbchars, c);
  ------------------
  |  | 2295|  8.99M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 8.99M, False: 27]
  |  |  ------------------
  |  | 2296|  8.99M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 2970|  8.99M|	    str += l;
 2971|  8.99M|	    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {
  ------------------
  |  |  167|  8.99M|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
  |  Branch (2971:10): [True: 1.95k, False: 8.98M]
  ------------------
 2972|  3.91k|	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
  ------------------
  |  | 2774|  1.95k|#define growBuffer(buffer, n) {						\
  |  | 2775|  1.95k|    xmlChar *tmp;							\
  |  | 2776|  1.95k|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|  1.95k|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 1.95k]
  |  |  ------------------
  |  | 2778|  1.95k|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|  1.95k|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 1.95k]
  |  |  ------------------
  |  | 2780|  1.95k|    buffer = tmp;							\
  |  | 2781|  1.95k|    buffer##_size = new_size;                                           \
  |  | 2782|  1.95k|}
  ------------------
 2973|  3.91k|	    }
 2974|  8.99M|	}
 2975|  9.14M|	if (str < last)
  ------------------
  |  Branch (2975:6): [True: 8.98M, False: 160k]
  ------------------
 2976|  8.98M|	    c = CUR_SCHAR(str, l);
  ------------------
  |  | 2292|  8.98M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 2977|   160k|	else
 2978|   160k|	    c = 0;
 2979|  9.14M|    }
 2980|   160k|    buffer[nbchars] = 0;
 2981|   160k|    return(buffer);
 2982|       |
 2983|      0|mem_error:
 2984|      0|    xmlErrMemory(ctxt, NULL);
 2985|    174|int_error:
 2986|    174|    if (rep != NULL)
  ------------------
  |  Branch (2986:9): [True: 0, False: 174]
  ------------------
 2987|      0|        xmlFree(rep);
 2988|    174|    if (buffer != NULL)
  ------------------
  |  Branch (2988:9): [True: 174, False: 0]
  ------------------
 2989|    174|        xmlFree(buffer);
 2990|    174|    return(NULL);
 2991|      0|}
parser.c:xmlParseStringCharRef:
 2600|    768|xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 2601|    768|    const xmlChar *ptr;
 2602|    768|    xmlChar cur;
 2603|    768|    int val = 0;
 2604|       |
 2605|    768|    if ((str == NULL) || (*str == NULL)) return(0);
  ------------------
  |  Branch (2605:9): [True: 0, False: 768]
  |  Branch (2605:26): [True: 0, False: 768]
  ------------------
 2606|    768|    ptr = *str;
 2607|    768|    cur = *ptr;
 2608|    768|    if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {
  ------------------
  |  Branch (2608:9): [True: 768, False: 0]
  |  Branch (2608:25): [True: 768, False: 0]
  |  Branch (2608:44): [True: 33, False: 735]
  ------------------
 2609|     33|	ptr += 3;
 2610|     33|	cur = *ptr;
 2611|     87|	while (cur != ';') { /* Non input consuming loop */
  ------------------
  |  Branch (2611:9): [True: 54, False: 33]
  ------------------
 2612|     54|	    if ((cur >= '0') && (cur <= '9'))
  ------------------
  |  Branch (2612:10): [True: 54, False: 0]
  |  Branch (2612:26): [True: 42, False: 12]
  ------------------
 2613|     42|	        val = val * 16 + (cur - '0');
 2614|     12|	    else if ((cur >= 'a') && (cur <= 'f'))
  ------------------
  |  Branch (2614:15): [True: 0, False: 12]
  |  Branch (2614:31): [True: 0, False: 0]
  ------------------
 2615|      0|	        val = val * 16 + (cur - 'a') + 10;
 2616|     12|	    else if ((cur >= 'A') && (cur <= 'F'))
  ------------------
  |  Branch (2616:15): [True: 12, False: 0]
  |  Branch (2616:31): [True: 12, False: 0]
  ------------------
 2617|     12|	        val = val * 16 + (cur - 'A') + 10;
 2618|      0|	    else {
 2619|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);
 2620|      0|		val = 0;
 2621|      0|		break;
 2622|      0|	    }
 2623|     54|	    if (val > 0x110000)
  ------------------
  |  Branch (2623:10): [True: 0, False: 54]
  ------------------
 2624|      0|	        val = 0x110000;
 2625|       |
 2626|     54|	    ptr++;
 2627|     54|	    cur = *ptr;
 2628|     54|	}
 2629|     33|	if (cur == ';')
  ------------------
  |  Branch (2629:6): [True: 33, False: 0]
  ------------------
 2630|     33|	    ptr++;
 2631|    735|    } else if  ((cur == '&') && (ptr[1] == '#')){
  ------------------
  |  Branch (2631:17): [True: 735, False: 0]
  |  Branch (2631:33): [True: 735, False: 0]
  ------------------
 2632|    735|	ptr += 2;
 2633|    735|	cur = *ptr;
 2634|  2.51k|	while (cur != ';') { /* Non input consuming loops */
  ------------------
  |  Branch (2634:9): [True: 1.77k, False: 735]
  ------------------
 2635|  1.77k|	    if ((cur >= '0') && (cur <= '9'))
  ------------------
  |  Branch (2635:10): [True: 1.77k, False: 0]
  |  Branch (2635:26): [True: 1.77k, False: 0]
  ------------------
 2636|  1.77k|	        val = val * 10 + (cur - '0');
 2637|      0|	    else {
 2638|      0|		xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);
 2639|      0|		val = 0;
 2640|      0|		break;
 2641|      0|	    }
 2642|  1.77k|	    if (val > 0x110000)
  ------------------
  |  Branch (2642:10): [True: 0, False: 1.77k]
  ------------------
 2643|      0|	        val = 0x110000;
 2644|       |
 2645|  1.77k|	    ptr++;
 2646|  1.77k|	    cur = *ptr;
 2647|  1.77k|	}
 2648|    735|	if (cur == ';')
  ------------------
  |  Branch (2648:6): [True: 735, False: 0]
  ------------------
 2649|    735|	    ptr++;
 2650|    735|    } else {
 2651|      0|	xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);
 2652|      0|	return(0);
 2653|      0|    }
 2654|    768|    *str = ptr;
 2655|       |
 2656|       |    /*
 2657|       |     * [ WFC: Legal Character ]
 2658|       |     * Characters referred to using character references must match the
 2659|       |     * production for Char.
 2660|       |     */
 2661|    768|    if (val >= 0x110000) {
  ------------------
  |  Branch (2661:9): [True: 0, False: 768]
  ------------------
 2662|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2663|      0|                "xmlParseStringCharRef: character reference out of bounds\n",
 2664|      0|                val);
 2665|    768|    } else if (IS_CHAR(val)) {
  ------------------
  |  |  125|    768|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    768|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 768, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 762, False: 6]
  |  |  |  |  ------------------
  |  |  |  |  119|    768|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    762|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 762, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 6, False: 756]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    762|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 9, False: 747]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    762|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 747, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    768|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 6, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 6, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      6|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      6|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2666|    768|        return(val);
 2667|    768|    } else {
 2668|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 2669|      0|			  "xmlParseStringCharRef: invalid xmlChar value %d\n",
 2670|      0|			  val);
 2671|      0|    }
 2672|      0|    return(0);
 2673|    768|}
parser.c:xmlParseStringEntityRef:
 7863|   151k|xmlParseStringEntityRef(xmlParserCtxtPtr ctxt, const xmlChar ** str) {
 7864|   151k|    xmlChar *name;
 7865|   151k|    const xmlChar *ptr;
 7866|   151k|    xmlChar cur;
 7867|   151k|    xmlEntityPtr ent = NULL;
 7868|       |
 7869|   151k|    if ((str == NULL) || (*str == NULL))
  ------------------
  |  Branch (7869:9): [True: 0, False: 151k]
  |  Branch (7869:26): [True: 0, False: 151k]
  ------------------
 7870|      0|        return(NULL);
 7871|   151k|    ptr = *str;
 7872|   151k|    cur = *ptr;
 7873|   151k|    if (cur != '&')
  ------------------
  |  Branch (7873:9): [True: 0, False: 151k]
  ------------------
 7874|      0|	return(NULL);
 7875|       |
 7876|   151k|    ptr++;
 7877|   151k|    name = xmlParseStringName(ctxt, &ptr);
 7878|   151k|    if (name == NULL) {
  ------------------
  |  Branch (7878:9): [True: 0, False: 151k]
  ------------------
 7879|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7880|      0|		       "xmlParseStringEntityRef: no name\n");
 7881|      0|	*str = ptr;
 7882|      0|	return(NULL);
 7883|      0|    }
 7884|   151k|    if (*ptr != ';') {
  ------------------
  |  Branch (7884:9): [True: 0, False: 151k]
  ------------------
 7885|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7886|      0|        xmlFree(name);
 7887|      0|	*str = ptr;
 7888|      0|	return(NULL);
 7889|      0|    }
 7890|   151k|    ptr++;
 7891|       |
 7892|       |
 7893|       |    /*
 7894|       |     * Predefined entities override any extra definition
 7895|       |     */
 7896|   151k|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7896:9): [True: 151k, False: 0]
  ------------------
 7897|   151k|        ent = xmlGetPredefinedEntity(name);
 7898|   151k|        if (ent != NULL) {
  ------------------
  |  Branch (7898:13): [True: 3, False: 151k]
  ------------------
 7899|      3|            xmlFree(name);
 7900|      3|            *str = ptr;
 7901|      3|            return(ent);
 7902|      3|        }
 7903|   151k|    }
 7904|       |
 7905|       |    /*
 7906|       |     * Ask first SAX for entity resolution, otherwise try the
 7907|       |     * entities which may have stored in the parser context.
 7908|       |     */
 7909|   151k|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7909:9): [True: 151k, False: 0]
  ------------------
 7910|   151k|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7910:6): [True: 151k, False: 0]
  ------------------
 7911|   151k|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7912|   151k|	if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7912:6): [True: 3, False: 151k]
  |  Branch (7912:23): [True: 0, False: 3]
  ------------------
 7913|      0|	    ent = xmlGetPredefinedEntity(name);
 7914|   151k|	if ((ent == NULL) && (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7914:6): [True: 3, False: 151k]
  |  Branch (7914:23): [True: 3, False: 0]
  ------------------
 7915|      3|	    ent = xmlSAX2GetEntity(ctxt, name);
 7916|      3|	}
 7917|   151k|    }
 7918|   151k|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (7918:9): [True: 0, False: 151k]
  ------------------
 7919|      0|	xmlFree(name);
 7920|      0|	return(NULL);
 7921|      0|    }
 7922|       |
 7923|       |    /*
 7924|       |     * [ WFC: Entity Declared ]
 7925|       |     * In a document without any DTD, a document with only an
 7926|       |     * internal DTD subset which contains no parameter entity
 7927|       |     * references, or a document with "standalone='yes'", the
 7928|       |     * Name given in the entity reference must match that in an
 7929|       |     * entity declaration, except that well-formed documents
 7930|       |     * need not declare any of the following entities: amp, lt,
 7931|       |     * gt, apos, quot.
 7932|       |     * The declaration of a parameter entity must precede any
 7933|       |     * reference to it.
 7934|       |     * Similarly, the declaration of a general entity must
 7935|       |     * precede any reference to it which appears in a default
 7936|       |     * value in an attribute-list declaration. Note that if
 7937|       |     * entities are declared in the external subset or in
 7938|       |     * external parameter entities, a non-validating processor
 7939|       |     * is not obligated to read and process their declarations;
 7940|       |     * for such documents, the rule that an entity must be
 7941|       |     * declared is a well-formedness constraint only if
 7942|       |     * standalone='yes'.
 7943|       |     */
 7944|   151k|    if (ent == NULL) {
  ------------------
  |  Branch (7944:9): [True: 3, False: 151k]
  ------------------
 7945|      3|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7945:6): [True: 0, False: 3]
  ------------------
 7946|      3|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7946:7): [True: 0, False: 3]
  ------------------
 7947|      3|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7947:7): [True: 0, False: 0]
  ------------------
 7948|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7949|      0|		     "Entity '%s' not defined\n", name);
 7950|      3|	} else {
 7951|      3|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7952|      3|			  "Entity '%s' not defined\n",
 7953|      3|			  name);
 7954|      3|	}
 7955|       |	/* TODO ? check regressions ctxt->valid = 0; */
 7956|      3|    }
 7957|       |
 7958|       |    /*
 7959|       |     * [ WFC: Parsed Entity ]
 7960|       |     * An entity reference must not contain the name of an
 7961|       |     * unparsed entity
 7962|       |     */
 7963|   151k|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7963:14): [True: 0, False: 151k]
  ------------------
 7964|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7965|      0|		 "Entity reference to unparsed entity %s\n", name);
 7966|      0|    }
 7967|       |
 7968|       |    /*
 7969|       |     * [ WFC: No External Entity References ]
 7970|       |     * Attribute values cannot contain direct or indirect
 7971|       |     * entity references to external entities.
 7972|       |     */
 7973|   151k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7973:14): [True: 151k, False: 0]
  ------------------
 7974|   151k|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7974:7): [True: 0, False: 151k]
  ------------------
 7975|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7976|      0|	 "Attribute references external entity '%s'\n", name);
 7977|      0|    }
 7978|       |    /*
 7979|       |     * [ WFC: No < in Attribute Values ]
 7980|       |     * The replacement text of any entity referred to directly or
 7981|       |     * indirectly in an attribute value (other than "&lt;") must
 7982|       |     * not contain a <.
 7983|       |     */
 7984|   151k|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7984:14): [True: 151k, False: 0]
  ------------------
 7985|   151k|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7985:7): [True: 151k, False: 0]
  ------------------
 7986|   151k|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|   151k|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7986:6): [True: 180, False: 150k]
  ------------------
 7987|    180|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7987:17): [True: 180, False: 0]
  |  Branch (7987:43): [True: 0, False: 180]
  ------------------
 7988|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7989|    180|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|    180|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7990|    180|        }
 7991|   151k|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|   151k|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7991:13): [True: 0, False: 151k]
  ------------------
 7992|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7993|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7994|      0|                    "values\n", name);
 7995|   151k|    }
 7996|       |
 7997|       |    /*
 7998|       |     * Internal check, no parameter entities here ...
 7999|       |     */
 8000|      0|    else {
 8001|      0|	switch (ent->etype) {
 8002|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (8002:6): [True: 0, False: 0]
  ------------------
 8003|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (8003:6): [True: 0, False: 0]
  ------------------
 8004|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 8005|      0|	     "Attempt to reference the parameter entity '%s'\n",
 8006|      0|				  name);
 8007|      0|	    break;
 8008|      0|	    default:
  ------------------
  |  Branch (8008:6): [True: 0, False: 0]
  ------------------
 8009|      0|	    break;
 8010|      0|	}
 8011|      0|    }
 8012|       |
 8013|       |    /*
 8014|       |     * [ WFC: No Recursion ]
 8015|       |     * A parsed entity must not contain a recursive reference
 8016|       |     * to itself, either directly or indirectly.
 8017|       |     * Done somewhere else
 8018|       |     */
 8019|       |
 8020|   151k|    xmlFree(name);
 8021|   151k|    *str = ptr;
 8022|   151k|    return(ent);
 8023|   151k|}
parser.c:xmlParseStringPEReference:
 8362|    810|xmlParseStringPEReference(xmlParserCtxtPtr ctxt, const xmlChar **str) {
 8363|    810|    const xmlChar *ptr;
 8364|    810|    xmlChar cur;
 8365|    810|    xmlChar *name;
 8366|    810|    xmlEntityPtr entity = NULL;
 8367|       |
 8368|    810|    if ((str == NULL) || (*str == NULL)) return(NULL);
  ------------------
  |  Branch (8368:9): [True: 0, False: 810]
  |  Branch (8368:26): [True: 0, False: 810]
  ------------------
 8369|    810|    ptr = *str;
 8370|    810|    cur = *ptr;
 8371|    810|    if (cur != '%')
  ------------------
  |  Branch (8371:9): [True: 0, False: 810]
  ------------------
 8372|      0|        return(NULL);
 8373|    810|    ptr++;
 8374|    810|    name = xmlParseStringName(ctxt, &ptr);
 8375|    810|    if (name == NULL) {
  ------------------
  |  Branch (8375:9): [True: 0, False: 810]
  ------------------
 8376|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8377|      0|		       "xmlParseStringPEReference: no name\n");
 8378|      0|	*str = ptr;
 8379|      0|	return(NULL);
 8380|      0|    }
 8381|    810|    cur = *ptr;
 8382|    810|    if (cur != ';') {
  ------------------
  |  Branch (8382:9): [True: 0, False: 810]
  ------------------
 8383|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 8384|      0|	xmlFree(name);
 8385|      0|	*str = ptr;
 8386|      0|	return(NULL);
 8387|      0|    }
 8388|    810|    ptr++;
 8389|       |
 8390|       |    /*
 8391|       |     * Request the entity from SAX
 8392|       |     */
 8393|    810|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (8393:9): [True: 810, False: 0]
  ------------------
 8394|    810|	(ctxt->sax->getParameterEntity != NULL))
  ------------------
  |  Branch (8394:2): [True: 810, False: 0]
  ------------------
 8395|    810|	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
 8396|    810|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (8396:9): [True: 0, False: 810]
  ------------------
 8397|      0|	xmlFree(name);
 8398|      0|	*str = ptr;
 8399|      0|	return(NULL);
 8400|      0|    }
 8401|    810|    if (entity == NULL) {
  ------------------
  |  Branch (8401:9): [True: 0, False: 810]
  ------------------
 8402|       |	/*
 8403|       |	 * [ WFC: Entity Declared ]
 8404|       |	 * In a document without any DTD, a document with only an
 8405|       |	 * internal DTD subset which contains no parameter entity
 8406|       |	 * references, or a document with "standalone='yes'", ...
 8407|       |	 * ... The declaration of a parameter entity must precede
 8408|       |	 * any reference to it...
 8409|       |	 */
 8410|      0|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (8410:6): [True: 0, False: 0]
  ------------------
 8411|      0|	    ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (8411:7): [True: 0, False: 0]
  |  Branch (8411:41): [True: 0, False: 0]
  ------------------
 8412|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 8413|      0|		 "PEReference: %%%s; not found\n", name);
 8414|      0|	} else {
 8415|       |	    /*
 8416|       |	     * [ VC: Entity Declared ]
 8417|       |	     * In a document with an external subset or external
 8418|       |	     * parameter entities with "standalone='no'", ...
 8419|       |	     * ... The declaration of a parameter entity must
 8420|       |	     * precede any reference to it...
 8421|       |	     */
 8422|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8423|      0|			  "PEReference: %%%s; not found\n",
 8424|      0|			  name, NULL);
 8425|      0|	    ctxt->valid = 0;
 8426|      0|	}
 8427|    810|    } else {
 8428|       |	/*
 8429|       |	 * Internal checking in case the entity quest barfed
 8430|       |	 */
 8431|    810|	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8431:6): [True: 6, False: 804]
  ------------------
 8432|    810|	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
  ------------------
  |  Branch (8432:6): [True: 0, False: 6]
  ------------------
 8433|      0|	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
 8434|      0|			  "%%%s; is not a parameter entity\n",
 8435|      0|			  name, NULL);
 8436|      0|	}
 8437|    810|    }
 8438|    810|    ctxt->hasPErefs = 1;
 8439|    810|    xmlFree(name);
 8440|    810|    *str = ptr;
 8441|    810|    return(entity);
 8442|    810|}
parser.c:xmlLoadEntityContent:
 8197|      6|xmlLoadEntityContent(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 8198|      6|    xmlParserInputPtr oldinput, input = NULL;
 8199|      6|    xmlParserInputPtr *oldinputTab;
 8200|      6|    const xmlChar *oldencoding;
 8201|      6|    xmlChar *content = NULL;
 8202|      6|    size_t length, i;
 8203|      6|    int oldinputNr, oldinputMax, oldprogressive;
 8204|      6|    int ret = -1;
 8205|      6|    int res;
 8206|       |
 8207|      6|    if ((ctxt == NULL) || (entity == NULL) ||
  ------------------
  |  Branch (8207:9): [True: 0, False: 6]
  |  Branch (8207:27): [True: 0, False: 6]
  ------------------
 8208|      6|        ((entity->etype != XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (8208:10): [True: 0, False: 6]
  ------------------
 8209|      6|	 (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||
  ------------------
  |  Branch (8209:3): [True: 0, False: 0]
  ------------------
 8210|      6|	(entity->content != NULL)) {
  ------------------
  |  Branch (8210:2): [True: 0, False: 6]
  ------------------
 8211|      0|	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8212|      0|	            "xmlLoadEntityContent parameter error");
 8213|      0|        return(-1);
 8214|      0|    }
 8215|       |
 8216|      6|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|      6|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|      6|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 6]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8217|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 8218|      0|		"Reading %s entity content input\n", entity->name);
 8219|       |
 8220|      6|    input = xmlLoadExternalEntity((char *) entity->URI,
 8221|      6|           (char *) entity->ExternalID, ctxt);
 8222|      6|    if (input == NULL) {
  ------------------
  |  Branch (8222:9): [True: 0, False: 6]
  ------------------
 8223|      0|	xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8224|      0|	            "xmlLoadEntityContent input error");
 8225|      0|        return(-1);
 8226|      0|    }
 8227|       |
 8228|      6|    oldinput = ctxt->input;
 8229|      6|    oldinputNr = ctxt->inputNr;
 8230|      6|    oldinputMax = ctxt->inputMax;
 8231|      6|    oldinputTab = ctxt->inputTab;
 8232|      6|    oldencoding = ctxt->encoding;
 8233|      6|    oldprogressive = ctxt->progressive;
 8234|       |
 8235|      6|    ctxt->input = NULL;
 8236|      6|    ctxt->inputNr = 0;
 8237|      6|    ctxt->inputMax = 1;
 8238|      6|    ctxt->encoding = NULL;
 8239|      6|    ctxt->progressive = 0;
 8240|      6|    ctxt->inputTab = xmlMalloc(sizeof(xmlParserInputPtr));
 8241|      6|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (8241:9): [True: 0, False: 6]
  ------------------
 8242|      0|        xmlErrMemory(ctxt, NULL);
 8243|      0|        xmlFreeInputStream(input);
 8244|      0|        goto error;
 8245|      0|    }
 8246|       |
 8247|      6|    xmlBufResetInput(input->buf->buffer, input);
 8248|       |
 8249|      6|    inputPush(ctxt, input);
 8250|       |
 8251|      6|    xmlDetectEncoding(ctxt);
 8252|       |
 8253|       |    /*
 8254|       |     * Parse a possible text declaration first
 8255|       |     */
 8256|      6|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|      6|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     12|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 6, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 3, False: 3]
  |  |  |  |  ------------------
  |  |  |  | 2229|      6|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 3, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 3, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      3|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      3|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      3|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      3|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8257|      3|	xmlParseTextDecl(ctxt);
 8258|       |        /*
 8259|       |         * An XML-1.0 document can't reference an entity not XML-1.0
 8260|       |         */
 8261|      3|        if ((xmlStrEqual(ctxt->version, BAD_CAST "1.0")) &&
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8261:13): [True: 3, False: 0]
  ------------------
 8262|      3|            (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (8262:13): [True: 0, False: 3]
  ------------------
 8263|      0|            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
 8264|      0|                           "Version mismatch between document and entity\n");
 8265|      0|        }
 8266|      3|    }
 8267|       |
 8268|      6|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8268:9): [True: 0, False: 6]
  ------------------
 8269|      0|        goto error;
 8270|       |
 8271|      6|    length = input->cur - input->base;
 8272|      6|    xmlBufShrink(input->buf->buffer, length);
 8273|      6|    xmlSaturatedAdd(&ctxt->sizeentities, length);
 8274|       |
 8275|      6|    while ((res = xmlParserInputBufferGrow(input->buf, 4096)) > 0)
  ------------------
  |  Branch (8275:12): [True: 0, False: 6]
  ------------------
 8276|      0|        ;
 8277|       |
 8278|      6|    xmlBufResetInput(input->buf->buffer, input);
 8279|       |
 8280|      6|    if (res < 0) {
  ------------------
  |  Branch (8280:9): [True: 0, False: 6]
  ------------------
 8281|      0|        xmlFatalErr(ctxt, input->buf->error, NULL);
 8282|      0|        goto error;
 8283|      0|    }
 8284|       |
 8285|      6|    length = xmlBufUse(input->buf->buffer);
 8286|      6|    content = xmlBufDetach(input->buf->buffer);
 8287|       |
 8288|      6|    if (length > INT_MAX) {
  ------------------
  |  Branch (8288:9): [True: 0, False: 6]
  ------------------
 8289|      0|        xmlErrMemory(ctxt, NULL);
 8290|      0|        goto error;
 8291|      0|    }
 8292|       |
 8293|    147|    for (i = 0; i < length; ) {
  ------------------
  |  Branch (8293:17): [True: 141, False: 6]
  ------------------
 8294|    141|        int clen = length - i;
 8295|    141|        int c = xmlGetUTF8Char(content + i, &clen);
 8296|       |
 8297|    141|        if ((c < 0) || (!IS_CHAR(c))) {
  ------------------
  |  |  125|    141|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    141|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 141, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    141|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    141|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 141, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 9, False: 132]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    141|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 132]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    141|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 132, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    141|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (8297:13): [True: 0, False: 141]
  |  Branch (8297:24): [True: 0, False: 141]
  ------------------
 8298|      0|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 8299|      0|                              "xmlLoadEntityContent: invalid char value %d\n",
 8300|      0|                              content[i]);
 8301|      0|            goto error;
 8302|      0|        }
 8303|    141|        i += clen;
 8304|    141|    }
 8305|       |
 8306|      6|    xmlSaturatedAdd(&ctxt->sizeentities, length);
 8307|      6|    entity->content = content;
 8308|      6|    entity->length = length;
 8309|      6|    content = NULL;
 8310|      6|    ret = 0;
 8311|       |
 8312|      6|error:
 8313|     12|    while (ctxt->inputNr > 0)
  ------------------
  |  Branch (8313:12): [True: 6, False: 6]
  ------------------
 8314|      6|        xmlFreeInputStream(inputPop(ctxt));
 8315|      6|    xmlFree(ctxt->inputTab);
 8316|      6|    xmlFree((xmlChar *) ctxt->encoding);
 8317|       |
 8318|      6|    ctxt->input = oldinput;
 8319|      6|    ctxt->inputNr = oldinputNr;
 8320|      6|    ctxt->inputMax = oldinputMax;
 8321|      6|    ctxt->inputTab = oldinputTab;
 8322|      6|    ctxt->encoding = oldencoding;
 8323|      6|    ctxt->progressive = oldprogressive;
 8324|       |
 8325|      6|    xmlFree(content);
 8326|       |
 8327|      6|    return(ret);
 8328|      6|}
parser.c:xmlFatalErrMsgStr:
  445|     21|{
  446|     21|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (446:9): [True: 21, False: 0]
  |  Branch (446:27): [True: 11, False: 10]
  ------------------
  447|     21|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (447:9): [True: 0, False: 11]
  ------------------
  448|      0|	return;
  449|     21|    if (ctxt != NULL)
  ------------------
  |  Branch (449:9): [True: 21, False: 0]
  ------------------
  450|     21|	ctxt->errNo = error;
  451|     21|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  452|     21|                    XML_FROM_PARSER, error, XML_ERR_FATAL,
  453|     21|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  454|     21|                    val);
  455|     21|    if (ctxt != NULL) {
  ------------------
  |  Branch (455:9): [True: 21, False: 0]
  ------------------
  456|     21|	ctxt->wellFormed = 0;
  457|     21|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (457:6): [True: 21, False: 0]
  ------------------
  458|     21|	    ctxt->disableSAX = 1;
  459|     21|    }
  460|     21|}
parser.c:xmlParseNameComplex:
 3399|    169|xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3400|    169|    int len = 0, l;
 3401|    169|    int c;
 3402|    169|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3402:21): [True: 0, False: 169]
  ------------------
 3403|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3404|    169|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    169|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3405|       |
 3406|       |    /*
 3407|       |     * Handler for more complex cases
 3408|       |     */
 3409|    169|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    169|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3410|    169|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3410:9): [True: 169, False: 0]
  ------------------
 3411|       |        /*
 3412|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3413|       |	 * Update 5 of XML-1.0
 3414|       |	 */
 3415|    169|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3415:6): [True: 0, False: 169]
  |  Branch (3415:20): [True: 0, False: 169]
  |  Branch (3415:34): [True: 0, False: 169]
  ------------------
 3416|    169|	    (!(((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3416:10): [True: 61, False: 108]
  |  Branch (3416:24): [True: 52, False: 9]
  ------------------
 3417|    169|	       ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3417:10): [True: 111, False: 6]
  |  Branch (3417:24): [True: 102, False: 9]
  ------------------
 3418|    169|	       (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3418:9): [True: 0, False: 15]
  |  Branch (3418:23): [True: 0, False: 15]
  ------------------
 3419|    169|	       ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3419:10): [True: 9, False: 6]
  |  Branch (3419:25): [True: 0, False: 9]
  ------------------
 3420|    169|	       ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3420:10): [True: 9, False: 6]
  |  Branch (3420:25): [True: 3, False: 6]
  ------------------
 3421|    169|	       ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3421:10): [True: 6, False: 6]
  |  Branch (3421:25): [True: 6, False: 0]
  ------------------
 3422|    169|	       ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3422:10): [True: 0, False: 6]
  |  Branch (3422:26): [True: 0, False: 0]
  ------------------
 3423|    169|	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3423:10): [True: 0, False: 6]
  |  Branch (3423:26): [True: 0, False: 0]
  ------------------
 3424|    169|	       ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3424:10): [True: 0, False: 6]
  |  Branch (3424:27): [True: 0, False: 0]
  ------------------
 3425|    169|	       ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3425:10): [True: 0, False: 6]
  |  Branch (3425:27): [True: 0, False: 0]
  ------------------
 3426|    169|	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3426:10): [True: 0, False: 6]
  |  Branch (3426:27): [True: 0, False: 0]
  ------------------
 3427|    169|	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3427:10): [True: 0, False: 6]
  |  Branch (3427:27): [True: 0, False: 0]
  ------------------
 3428|    169|	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3428:10): [True: 0, False: 6]
  |  Branch (3428:27): [True: 0, False: 0]
  ------------------
 3429|    169|	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3429:10): [True: 0, False: 6]
  |  Branch (3429:27): [True: 0, False: 0]
  ------------------
 3430|    169|	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
  ------------------
  |  Branch (3430:10): [True: 0, False: 6]
  |  Branch (3430:28): [True: 0, False: 0]
  ------------------
 3431|      6|	    return(NULL);
 3432|      6|	}
 3433|    163|	len += l;
 3434|    163|	NEXTL(l);
  ------------------
  |  | 2284|    163|#define NEXTL(l) do {							\
  |  | 2285|    163|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 163]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    163|    } else ctxt->input->col++;						\
  |  | 2288|    163|    ctxt->input->cur += l;				\
  |  | 2289|    163|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3435|    163|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|    163|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3436|  7.10k|	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3436:9): [True: 7.06k, False: 48]
  |  Branch (3436:23): [True: 7.06k, False: 0]
  |  Branch (3436:37): [True: 7.06k, False: 0]
  ------------------
 3437|  7.10k|	       (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3437:11): [True: 6.86k, False: 191]
  |  Branch (3437:25): [True: 6.72k, False: 144]
  ------------------
 3438|  7.06k|	        ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3438:11): [True: 189, False: 146]
  |  Branch (3438:25): [True: 45, False: 144]
  ------------------
 3439|  7.06k|	        ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3439:11): [True: 178, False: 112]
  |  Branch (3439:25): [True: 30, False: 148]
  ------------------
 3440|  7.06k|	        (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3440:10): [True: 0, False: 260]
  |  Branch (3440:24): [True: 1, False: 259]
  ------------------
 3441|  7.06k|	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3441:10): [True: 0, False: 259]
  |  Branch (3441:24): [True: 0, False: 259]
  |  Branch (3441:38): [True: 0, False: 259]
  ------------------
 3442|  7.06k|	        ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3442:11): [True: 144, False: 115]
  |  Branch (3442:26): [True: 0, False: 144]
  ------------------
 3443|  7.06k|	        ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3443:11): [True: 144, False: 115]
  |  Branch (3443:26): [True: 69, False: 75]
  ------------------
 3444|  7.06k|	        ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3444:11): [True: 75, False: 115]
  |  Branch (3444:26): [True: 75, False: 0]
  ------------------
 3445|  7.06k|	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3445:11): [True: 0, False: 115]
  |  Branch (3445:27): [True: 0, False: 0]
  ------------------
 3446|  7.06k|	        ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3446:11): [True: 0, False: 115]
  |  Branch (3446:27): [True: 0, False: 0]
  ------------------
 3447|  7.06k|	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3447:11): [True: 0, False: 115]
  |  Branch (3447:27): [True: 0, False: 0]
  ------------------
 3448|  7.06k|	        ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3448:11): [True: 0, False: 115]
  |  Branch (3448:28): [True: 0, False: 0]
  ------------------
 3449|  7.06k|	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3449:11): [True: 0, False: 115]
  |  Branch (3449:28): [True: 0, False: 0]
  ------------------
 3450|  7.06k|	        ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3450:11): [True: 0, False: 115]
  |  Branch (3450:28): [True: 0, False: 0]
  ------------------
 3451|  7.06k|	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3451:11): [True: 0, False: 115]
  |  Branch (3451:28): [True: 0, False: 0]
  ------------------
 3452|  7.06k|	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3452:11): [True: 0, False: 115]
  |  Branch (3452:28): [True: 0, False: 0]
  ------------------
 3453|  7.06k|	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3453:11): [True: 0, False: 115]
  |  Branch (3453:28): [True: 0, False: 0]
  ------------------
 3454|  7.06k|	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3454:11): [True: 0, False: 115]
  |  Branch (3454:28): [True: 0, False: 0]
  ------------------
 3455|  7.06k|	        ((c >= 0x10000) && (c <= 0xEFFFF))
  ------------------
  |  Branch (3455:11): [True: 0, False: 115]
  |  Branch (3455:29): [True: 0, False: 0]
  ------------------
 3456|  7.06k|		)) {
 3457|  6.94k|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3457:17): [True: 6.94k, False: 0]
  ------------------
 3458|  6.94k|	        len += l;
 3459|  6.94k|	    NEXTL(l);
  ------------------
  |  | 2284|  6.94k|#define NEXTL(l) do {							\
  |  | 2285|  6.94k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 6.94k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  6.94k|    } else ctxt->input->col++;						\
  |  | 2288|  6.94k|    ctxt->input->cur += l;				\
  |  | 2289|  6.94k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3460|  6.94k|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|  6.94k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3461|  6.94k|	}
 3462|    163|    } else {
 3463|      0|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3463:6): [True: 0, False: 0]
  |  Branch (3463:20): [True: 0, False: 0]
  |  Branch (3463:34): [True: 0, False: 0]
  ------------------
 3464|      0|	    (!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3464:24): [True: 0, False: 0]
  ------------------
 3465|      0|	     (c != ':'))) {
  ------------------
  |  Branch (3465:7): [True: 0, False: 0]
  ------------------
 3466|      0|	    return(NULL);
 3467|      0|	}
 3468|      0|	len += l;
 3469|      0|	NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3470|      0|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3471|       |
 3472|      0|	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3472:9): [True: 0, False: 0]
  |  Branch (3472:23): [True: 0, False: 0]
  |  Branch (3472:37): [True: 0, False: 0]
  ------------------
 3473|      0|	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3473:28): [True: 0, False: 0]
  ------------------
 3474|      0|		(c == '.') || (c == '-') ||
  ------------------
  |  Branch (3474:3): [True: 0, False: 0]
  |  Branch (3474:17): [True: 0, False: 0]
  ------------------
 3475|      0|		(c == '_') || (c == ':') ||
  ------------------
  |  Branch (3475:3): [True: 0, False: 0]
  |  Branch (3475:17): [True: 0, False: 0]
  ------------------
 3476|      0|		(IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3476:3): [True: 0, False: 0]
  ------------------
 3477|      0|		(IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3477:3): [True: 0, False: 0]
  ------------------
 3478|      0|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3478:17): [True: 0, False: 0]
  ------------------
 3479|      0|	        len += l;
 3480|      0|	    NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3481|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3482|      0|	}
 3483|      0|    }
 3484|    163|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3484:9): [True: 0, False: 163]
  ------------------
 3485|      0|        return(NULL);
 3486|    163|    if (len > maxLength) {
  ------------------
  |  Branch (3486:9): [True: 0, False: 163]
  ------------------
 3487|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3488|      0|        return(NULL);
 3489|      0|    }
 3490|    163|    if (ctxt->input->cur - ctxt->input->base < len) {
  ------------------
  |  Branch (3490:9): [True: 0, False: 163]
  ------------------
 3491|       |        /*
 3492|       |         * There were a couple of bugs where PERefs lead to to a change
 3493|       |         * of the buffer. Check the buffer size to avoid passing an invalid
 3494|       |         * pointer to xmlDictLookup.
 3495|       |         */
 3496|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3497|      0|                    "unexpected change of input buffer");
 3498|      0|        return (NULL);
 3499|      0|    }
 3500|    163|    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
  ------------------
  |  Branch (3500:9): [True: 0, False: 163]
  |  Branch (3500:40): [True: 0, False: 0]
  ------------------
 3501|      0|        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
 3502|    163|    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 3503|    163|}
parser.c:xmlIsNameChar:
 3357|  3.61M|xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3358|  3.61M|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3358:9): [True: 3.61M, False: 0]
  ------------------
 3359|       |        /*
 3360|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3361|       |	 * Update 5 of XML-1.0
 3362|       |	 */
 3363|  3.61M|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3363:6): [True: 3.61M, False: 345]
  |  Branch (3363:20): [True: 3.61M, False: 0]
  |  Branch (3363:34): [True: 3.61M, False: 6]
  ------------------
 3364|  3.61M|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3364:8): [True: 3.25M, False: 357k]
  |  Branch (3364:22): [True: 3.25M, False: 1.37k]
  ------------------
 3365|  3.61M|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3365:8): [True: 1.54k, False: 357k]
  |  Branch (3365:22): [True: 105, False: 1.43k]
  ------------------
 3366|  3.61M|	     ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3366:8): [True: 356k, False: 2.63k]
  |  Branch (3366:22): [True: 200k, False: 156k]
  ------------------
 3367|  3.61M|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3367:7): [True: 68, False: 158k]
  |  Branch (3367:21): [True: 17, False: 158k]
  ------------------
 3368|  3.61M|	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3368:7): [True: 13, False: 158k]
  |  Branch (3368:21): [True: 1.00k, False: 157k]
  |  Branch (3368:35): [True: 0, False: 157k]
  ------------------
 3369|  3.61M|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3369:8): [True: 1.25k, False: 156k]
  |  Branch (3369:23): [True: 0, False: 1.25k]
  ------------------
 3370|  3.61M|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3370:8): [True: 1.25k, False: 156k]
  |  Branch (3370:23): [True: 51, False: 1.20k]
  ------------------
 3371|  3.61M|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3371:8): [True: 1.20k, False: 156k]
  |  Branch (3371:23): [True: 51, False: 1.15k]
  ------------------
 3372|  3.61M|	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3372:8): [True: 1.15k, False: 156k]
  |  Branch (3372:24): [True: 0, False: 1.15k]
  ------------------
 3373|  3.61M|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3373:8): [True: 1.15k, False: 156k]
  |  Branch (3373:24): [True: 0, False: 1.15k]
  ------------------
 3374|  3.61M|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3374:8): [True: 1.15k, False: 156k]
  |  Branch (3374:24): [True: 0, False: 1.15k]
  ------------------
 3375|  3.61M|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3375:8): [True: 1.15k, False: 156k]
  |  Branch (3375:25): [True: 0, False: 1.15k]
  ------------------
 3376|  3.61M|	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3376:8): [True: 1.15k, False: 156k]
  |  Branch (3376:25): [True: 0, False: 1.15k]
  ------------------
 3377|  3.61M|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3377:8): [True: 1.15k, False: 156k]
  |  Branch (3377:25): [True: 1.13k, False: 21]
  ------------------
 3378|  3.61M|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3378:8): [True: 21, False: 156k]
  |  Branch (3378:25): [True: 0, False: 21]
  ------------------
 3379|  3.61M|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3379:8): [True: 21, False: 156k]
  |  Branch (3379:25): [True: 21, False: 0]
  ------------------
 3380|  3.61M|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3380:8): [True: 0, False: 156k]
  |  Branch (3380:25): [True: 0, False: 0]
  ------------------
 3381|  3.61M|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3381:8): [True: 0, False: 156k]
  |  Branch (3381:25): [True: 0, False: 0]
  ------------------
 3382|  3.61M|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3382:8): [True: 0, False: 156k]
  |  Branch (3382:26): [True: 0, False: 0]
  ------------------
 3383|  3.46M|	     return(1);
 3384|  3.61M|    } else {
 3385|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3385:31): [True: 0, False: 0]
  ------------------
 3386|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3386:13): [True: 0, False: 0]
  |  Branch (3386:27): [True: 0, False: 0]
  ------------------
 3387|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3387:6): [True: 0, False: 0]
  |  Branch (3387:20): [True: 0, False: 0]
  ------------------
 3388|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3388:6): [True: 0, False: 0]
  ------------------
 3389|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3389:6): [True: 0, False: 0]
  ------------------
 3390|      0|	    return(1);
 3391|      0|    }
 3392|   156k|    return(0);
 3393|  3.61M|}
parser.c:xmlFatalErrMsg:
  279|    726|{
  280|    726|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (280:9): [True: 726, False: 0]
  |  Branch (280:27): [True: 621, False: 105]
  ------------------
  281|    726|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (281:9): [True: 597, False: 24]
  ------------------
  282|    597|	return;
  283|    129|    if (ctxt != NULL)
  ------------------
  |  Branch (283:9): [True: 129, False: 0]
  ------------------
  284|    129|	ctxt->errNo = error;
  285|    129|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  286|    129|                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
  287|    129|    if (ctxt != NULL) {
  ------------------
  |  Branch (287:9): [True: 129, False: 0]
  ------------------
  288|    129|	ctxt->wellFormed = 0;
  289|    129|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (289:6): [True: 129, False: 0]
  ------------------
  290|    129|	    ctxt->disableSAX = 1;
  291|    129|    }
  292|    129|}
parser.c:xmlParseStringName:
 3730|   154k|xmlParseStringName(xmlParserCtxtPtr ctxt, const xmlChar** str) {
 3731|   154k|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3732|   154k|    const xmlChar *cur = *str;
 3733|   154k|    int len = 0, l;
 3734|   154k|    int c;
 3735|   154k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3735:21): [True: 0, False: 154k]
  ------------------
 3736|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3737|   154k|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   154k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3738|       |
 3739|   154k|    c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|   154k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3740|   154k|    if (!xmlIsNameStartChar(ctxt, c)) {
  ------------------
  |  Branch (3740:9): [True: 0, False: 154k]
  ------------------
 3741|      0|	return(NULL);
 3742|      0|    }
 3743|       |
 3744|   154k|    COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|   154k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 154k, False: 0]
  |  |  ------------------
  |  | 2296|   154k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3745|   154k|    cur += l;
 3746|   154k|    c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|   154k|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3747|  1.54M|    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3747:12): [True: 1.39M, False: 146k]
  ------------------
 3748|  1.39M|	COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  1.39M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 1.39M, False: 0]
  |  |  ------------------
  |  | 2296|  1.39M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3749|  1.39M|	cur += l;
 3750|  1.39M|	c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|  1.39M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3751|  1.39M|	if (len >= XML_MAX_NAMELEN) { /* test bigentname.xml */
  ------------------
  |  |   89|  1.39M|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (3751:6): [True: 8.67k, False: 1.38M]
  ------------------
 3752|       |	    /*
 3753|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3754|       |	     * for the processing speed.
 3755|       |	     */
 3756|  8.67k|	    xmlChar *buffer;
 3757|  8.67k|	    int max = len * 2;
 3758|       |
 3759|  8.67k|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3760|  8.67k|	    if (buffer == NULL) {
  ------------------
  |  Branch (3760:10): [True: 0, False: 8.67k]
  ------------------
 3761|      0|	        xmlErrMemory(ctxt, NULL);
 3762|      0|		return(NULL);
 3763|      0|	    }
 3764|  8.67k|	    memcpy(buffer, buf, len);
 3765|  1.98M|	    while (xmlIsNameChar(ctxt, c)) {
  ------------------
  |  Branch (3765:13): [True: 1.97M, False: 8.67k]
  ------------------
 3766|  1.97M|		if (len + 10 > max) {
  ------------------
  |  Branch (3766:7): [True: 8.69k, False: 1.96M]
  ------------------
 3767|  8.69k|		    xmlChar *tmp;
 3768|       |
 3769|  8.69k|		    max *= 2;
 3770|  8.69k|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3771|  8.69k|		    if (tmp == NULL) {
  ------------------
  |  Branch (3771:11): [True: 0, False: 8.69k]
  ------------------
 3772|      0|			xmlErrMemory(ctxt, NULL);
 3773|      0|			xmlFree(buffer);
 3774|      0|			return(NULL);
 3775|      0|		    }
 3776|  8.69k|		    buffer = tmp;
 3777|  8.69k|		}
 3778|  1.97M|		COPY_BUF(buffer, len, c);
  ------------------
  |  | 2295|  1.97M|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 1.97M, False: 0]
  |  |  ------------------
  |  | 2296|  1.97M|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 3779|  1.97M|		cur += l;
 3780|  1.97M|		c = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|  1.97M|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3781|  1.97M|                if (len > maxLength) {
  ------------------
  |  Branch (3781:21): [True: 0, False: 1.97M]
  ------------------
 3782|      0|                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3783|      0|                    xmlFree(buffer);
 3784|      0|                    return(NULL);
 3785|      0|                }
 3786|  1.97M|	    }
 3787|  8.67k|	    buffer[len] = 0;
 3788|  8.67k|	    *str = cur;
 3789|  8.67k|	    return(buffer);
 3790|  8.67k|	}
 3791|  1.39M|    }
 3792|   146k|    if (len > maxLength) {
  ------------------
  |  Branch (3792:9): [True: 0, False: 146k]
  ------------------
 3793|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3794|      0|        return(NULL);
 3795|      0|    }
 3796|   146k|    *str = cur;
 3797|   146k|    return(xmlStrndup(buf, len));
 3798|   146k|}
parser.c:xmlIsNameStartChar:
 3326|   154k|xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3327|   154k|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3327:9): [True: 154k, False: 0]
  ------------------
 3328|       |        /*
 3329|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3330|       |	 * Update 5 of XML-1.0
 3331|       |	 */
 3332|   154k|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3332:6): [True: 154k, False: 0]
  |  Branch (3332:20): [True: 154k, False: 0]
  |  Branch (3332:34): [True: 154k, False: 0]
  ------------------
 3333|   154k|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3333:8): [True: 154k, False: 104]
  |  Branch (3333:22): [True: 154k, False: 11]
  ------------------
 3334|   154k|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3334:8): [True: 80, False: 35]
  |  Branch (3334:22): [True: 69, False: 11]
  ------------------
 3335|   154k|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3335:7): [True: 0, False: 46]
  |  Branch (3335:21): [True: 6, False: 40]
  ------------------
 3336|   154k|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3336:8): [True: 11, False: 29]
  |  Branch (3336:23): [True: 0, False: 11]
  ------------------
 3337|   154k|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3337:8): [True: 11, False: 29]
  |  Branch (3337:23): [True: 0, False: 11]
  ------------------
 3338|   154k|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3338:8): [True: 11, False: 29]
  |  Branch (3338:23): [True: 6, False: 5]
  ------------------
 3339|   154k|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3339:8): [True: 5, False: 29]
  |  Branch (3339:24): [True: 0, False: 5]
  ------------------
 3340|   154k|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3340:8): [True: 5, False: 29]
  |  Branch (3340:24): [True: 0, False: 5]
  ------------------
 3341|   154k|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3341:8): [True: 5, False: 29]
  |  Branch (3341:25): [True: 0, False: 5]
  ------------------
 3342|   154k|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3342:8): [True: 5, False: 29]
  |  Branch (3342:25): [True: 2, False: 3]
  ------------------
 3343|   154k|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3343:8): [True: 3, False: 29]
  |  Branch (3343:25): [True: 0, False: 3]
  ------------------
 3344|   154k|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3344:8): [True: 3, False: 29]
  |  Branch (3344:25): [True: 3, False: 0]
  ------------------
 3345|   154k|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3345:8): [True: 0, False: 29]
  |  Branch (3345:25): [True: 0, False: 0]
  ------------------
 3346|   154k|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3346:8): [True: 0, False: 29]
  |  Branch (3346:25): [True: 0, False: 0]
  ------------------
 3347|   154k|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3347:8): [True: 0, False: 29]
  |  Branch (3347:26): [True: 0, False: 0]
  ------------------
 3348|   154k|	    return(1);
 3349|   154k|    } else {
 3350|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3350:29): [True: 0, False: 0]
  |  Branch (3350:43): [True: 0, False: 0]
  ------------------
 3351|      0|	    return(1);
 3352|      0|    }
 3353|     29|    return(0);
 3354|   154k|}
parser.c:xmlParseCharDataInternal:
 4557|  54.3k|xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {
 4558|  54.3k|    const xmlChar *in;
 4559|  54.3k|    int nbchar = 0;
 4560|  54.3k|    int line = ctxt->input->line;
 4561|  54.3k|    int col = ctxt->input->col;
 4562|  54.3k|    int ccol;
 4563|       |
 4564|  54.3k|    GROW;
  ------------------
  |  | 2270|  54.3k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  54.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 27.5k, False: 26.7k]
  |  |  ------------------
  |  | 2271|  54.3k|	xmlParserGrow(ctxt);
  ------------------
 4565|       |    /*
 4566|       |     * Accelerated common case where input don't need to be
 4567|       |     * modified before passing it to the handler.
 4568|       |     */
 4569|  54.3k|    in = ctxt->input->cur;
 4570|  83.5k|    do {
 4571|  96.9k|get_more_space:
 4572|   124k|        while (*in == 0x20) { in++; ctxt->input->col++; }
  ------------------
  |  Branch (4572:16): [True: 27.7k, False: 96.9k]
  ------------------
 4573|  96.9k|        if (*in == 0xA) {
  ------------------
  |  Branch (4573:13): [True: 13.3k, False: 83.5k]
  ------------------
 4574|  13.7k|            do {
 4575|  13.7k|                ctxt->input->line++; ctxt->input->col = 1;
 4576|  13.7k|                in++;
 4577|  13.7k|            } while (*in == 0xA);
  ------------------
  |  Branch (4577:22): [True: 382, False: 13.3k]
  ------------------
 4578|  13.3k|            goto get_more_space;
 4579|  13.3k|        }
 4580|  83.5k|        if (*in == '<') {
  ------------------
  |  Branch (4580:13): [True: 12.6k, False: 70.9k]
  ------------------
 4581|  12.6k|            nbchar = in - ctxt->input->cur;
 4582|  12.6k|            if (nbchar > 0) {
  ------------------
  |  Branch (4582:17): [True: 12.6k, False: 0]
  ------------------
 4583|  12.6k|                const xmlChar *tmp = ctxt->input->cur;
 4584|  12.6k|                ctxt->input->cur = in;
 4585|       |
 4586|  12.6k|                if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4586:21): [True: 12.6k, False: 0]
  ------------------
 4587|  12.6k|                    (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4587:21): [True: 12.5k, False: 83]
  ------------------
 4588|  12.6k|                    (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4588:21): [True: 0, False: 12.5k]
  ------------------
 4589|  12.5k|                     ctxt->sax->characters)) {
 4590|      0|                    if (areBlanks(ctxt, tmp, nbchar, 1)) {
  ------------------
  |  Branch (4590:25): [True: 0, False: 0]
  ------------------
 4591|      0|                        if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4591:29): [True: 0, False: 0]
  ------------------
 4592|      0|                            ctxt->sax->ignorableWhitespace(ctxt->userData,
 4593|      0|                                                   tmp, nbchar);
 4594|      0|                    } else {
 4595|      0|                        if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4595:29): [True: 0, False: 0]
  ------------------
 4596|      0|                            ctxt->sax->characters(ctxt->userData,
 4597|      0|                                                  tmp, nbchar);
 4598|      0|                        if (*ctxt->space == -1)
  ------------------
  |  Branch (4598:29): [True: 0, False: 0]
  ------------------
 4599|      0|                            *ctxt->space = -2;
 4600|      0|                    }
 4601|  12.6k|                } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4601:28): [True: 12.6k, False: 0]
  ------------------
 4602|  12.6k|                           (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4602:28): [True: 12.5k, False: 83]
  ------------------
 4603|  12.6k|                           (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4603:28): [True: 12.5k, False: 0]
  ------------------
 4604|  12.5k|                    ctxt->sax->characters(ctxt->userData,
 4605|  12.5k|                                          tmp, nbchar);
 4606|  12.5k|                }
 4607|  12.6k|            }
 4608|  12.6k|            return;
 4609|  12.6k|        }
 4610|       |
 4611|  84.8k|get_more:
 4612|  84.8k|        ccol = ctxt->input->col;
 4613|   873k|        while (test_char_data[*in]) {
  ------------------
  |  Branch (4613:16): [True: 788k, False: 84.8k]
  ------------------
 4614|   788k|            in++;
 4615|   788k|            ccol++;
 4616|   788k|        }
 4617|  84.8k|        ctxt->input->col = ccol;
 4618|  84.8k|        if (*in == 0xA) {
  ------------------
  |  Branch (4618:13): [True: 12.9k, False: 71.8k]
  ------------------
 4619|  12.9k|            do {
 4620|  12.9k|                ctxt->input->line++; ctxt->input->col = 1;
 4621|  12.9k|                in++;
 4622|  12.9k|            } while (*in == 0xA);
  ------------------
  |  Branch (4622:22): [True: 47, False: 12.9k]
  ------------------
 4623|  12.9k|            goto get_more;
 4624|  12.9k|        }
 4625|  71.8k|        if (*in == ']') {
  ------------------
  |  Branch (4625:13): [True: 956, False: 70.9k]
  ------------------
 4626|    956|            if ((in[1] == ']') && (in[2] == '>')) {
  ------------------
  |  Branch (4626:17): [True: 39, False: 917]
  |  Branch (4626:35): [True: 0, False: 39]
  ------------------
 4627|      0|                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4628|      0|                if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (4628:21): [True: 0, False: 0]
  ------------------
 4629|      0|                    ctxt->input->cur = in + 1;
 4630|      0|                return;
 4631|      0|            }
 4632|    956|            in++;
 4633|    956|            ctxt->input->col++;
 4634|    956|            goto get_more;
 4635|    956|        }
 4636|  70.9k|        nbchar = in - ctxt->input->cur;
 4637|  70.9k|        if (nbchar > 0) {
  ------------------
  |  Branch (4637:13): [True: 41.7k, False: 29.1k]
  ------------------
 4638|  41.7k|            if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4638:17): [True: 41.7k, False: 0]
  ------------------
 4639|  41.7k|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4639:17): [True: 41.7k, False: 38]
  ------------------
 4640|  41.7k|                (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4640:17): [True: 0, False: 41.7k]
  ------------------
 4641|  41.7k|                 ctxt->sax->characters) &&
 4642|  41.7k|                (IS_BLANK_CH(*ctxt->input->cur))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4643|      0|                const xmlChar *tmp = ctxt->input->cur;
 4644|      0|                ctxt->input->cur = in;
 4645|       |
 4646|      0|                if (areBlanks(ctxt, tmp, nbchar, 0)) {
  ------------------
  |  Branch (4646:21): [True: 0, False: 0]
  ------------------
 4647|      0|                    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4647:25): [True: 0, False: 0]
  ------------------
 4648|      0|                        ctxt->sax->ignorableWhitespace(ctxt->userData,
 4649|      0|                                                       tmp, nbchar);
 4650|      0|                } else {
 4651|      0|                    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4651:25): [True: 0, False: 0]
  ------------------
 4652|      0|                        ctxt->sax->characters(ctxt->userData,
 4653|      0|                                              tmp, nbchar);
 4654|      0|                    if (*ctxt->space == -1)
  ------------------
  |  Branch (4654:25): [True: 0, False: 0]
  ------------------
 4655|      0|                        *ctxt->space = -2;
 4656|      0|                }
 4657|      0|                line = ctxt->input->line;
 4658|      0|                col = ctxt->input->col;
 4659|  41.7k|            } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4659:24): [True: 41.7k, False: 0]
  ------------------
 4660|  41.7k|                       (ctxt->disableSAX == 0)) {
  ------------------
  |  Branch (4660:24): [True: 41.7k, False: 38]
  ------------------
 4661|  41.7k|                if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4661:21): [True: 41.7k, False: 0]
  ------------------
 4662|  41.7k|                    ctxt->sax->characters(ctxt->userData,
 4663|  41.7k|                                          ctxt->input->cur, nbchar);
 4664|  41.7k|                line = ctxt->input->line;
 4665|  41.7k|                col = ctxt->input->col;
 4666|  41.7k|            }
 4667|  41.7k|            if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4667:17): [True: 0, False: 41.7k]
  ------------------
 4668|      0|                return;
 4669|  41.7k|        }
 4670|  70.9k|        ctxt->input->cur = in;
 4671|  70.9k|        if (*in == 0xD) {
  ------------------
  |  Branch (4671:13): [True: 29.3k, False: 41.6k]
  ------------------
 4672|  29.3k|            in++;
 4673|  29.3k|            if (*in == 0xA) {
  ------------------
  |  Branch (4673:17): [True: 29.3k, False: 3]
  ------------------
 4674|  29.3k|                ctxt->input->cur = in;
 4675|  29.3k|                in++;
 4676|  29.3k|                ctxt->input->line++; ctxt->input->col = 1;
 4677|  29.3k|                continue; /* while */
 4678|  29.3k|            }
 4679|      3|            in--;
 4680|      3|        }
 4681|  41.6k|        if (*in == '<') {
  ------------------
  |  Branch (4681:13): [True: 39.0k, False: 2.59k]
  ------------------
 4682|  39.0k|            return;
 4683|  39.0k|        }
 4684|  2.59k|        if (*in == '&') {
  ------------------
  |  Branch (4684:13): [True: 1.92k, False: 672]
  ------------------
 4685|  1.92k|            return;
 4686|  1.92k|        }
 4687|    672|        SHRINK;
  ------------------
  |  | 2265|    672|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 183, False: 489]
  |  |  |  Branch (2265:38): [True: 0, False: 489]
  |  |  ------------------
  |  | 2266|    672|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|    183|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 33, False: 150]
  |  |  ------------------
  |  | 2267|    672|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     33|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 20, False: 13]
  |  |  ------------------
  |  | 2268|    672|	xmlParserShrink(ctxt);
  ------------------
 4688|    672|        GROW;
  ------------------
  |  | 2270|    672|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    672|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 607, False: 65]
  |  |  ------------------
  |  | 2271|    672|	xmlParserGrow(ctxt);
  ------------------
 4689|    672|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4689:13): [True: 0, False: 672]
  ------------------
 4690|      0|            return;
 4691|    672|        in = ctxt->input->cur;
 4692|  29.9k|    } while (((*in >= 0x20) && (*in <= 0x7F)) ||
  ------------------
  |  Branch (4692:15): [True: 1.60k, False: 28.3k]
  |  Branch (4692:32): [True: 1.47k, False: 127]
  ------------------
 4693|  29.9k|             (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (4693:14): [True: 27.7k, False: 730]
  |  Branch (4693:31): [True: 0, False: 730]
  ------------------
 4694|    730|    ctxt->input->line = line;
 4695|    730|    ctxt->input->col = col;
 4696|    730|    xmlParseCharDataComplex(ctxt, partial);
 4697|    730|}
parser.c:areBlanks:
 3071|    274|                     int blank_chars) {
 3072|    274|    int i, ret;
 3073|    274|    xmlNodePtr lastChild;
 3074|       |
 3075|       |    /*
 3076|       |     * Don't spend time trying to differentiate them, the same callback is
 3077|       |     * used !
 3078|       |     */
 3079|    274|    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
  ------------------
  |  Branch (3079:9): [True: 274, False: 0]
  ------------------
 3080|    274|	return(0);
 3081|       |
 3082|       |    /*
 3083|       |     * Check for xml:space value.
 3084|       |     */
 3085|      0|    if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||
  ------------------
  |  Branch (3085:9): [True: 0, False: 0]
  |  Branch (3085:34): [True: 0, False: 0]
  ------------------
 3086|      0|        (*(ctxt->space) == -2))
  ------------------
  |  Branch (3086:9): [True: 0, False: 0]
  ------------------
 3087|      0|	return(0);
 3088|       |
 3089|       |    /*
 3090|       |     * Check that the string is made of blanks
 3091|       |     */
 3092|      0|    if (blank_chars == 0) {
  ------------------
  |  Branch (3092:9): [True: 0, False: 0]
  ------------------
 3093|      0|	for (i = 0;i < len;i++)
  ------------------
  |  Branch (3093:13): [True: 0, False: 0]
  ------------------
 3094|      0|	    if (!(IS_BLANK_CH(str[i]))) return(0);
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3095|      0|    }
 3096|       |
 3097|       |    /*
 3098|       |     * Look if the element is mixed content in the DTD if available
 3099|       |     */
 3100|      0|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (3100:9): [True: 0, False: 0]
  ------------------
 3101|      0|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (3101:9): [True: 0, False: 0]
  ------------------
 3102|      0|	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);
 3103|      0|        if (ret == 0) return(1);
  ------------------
  |  Branch (3103:13): [True: 0, False: 0]
  ------------------
 3104|      0|        if (ret == 1) return(0);
  ------------------
  |  Branch (3104:13): [True: 0, False: 0]
  ------------------
 3105|      0|    }
 3106|       |
 3107|       |    /*
 3108|       |     * Otherwise, heuristic :-\
 3109|       |     */
 3110|      0|    if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3110:9): [True: 0, False: 0]
  |  Branch (3110:25): [True: 0, False: 0]
  ------------------
 3111|      0|    if ((ctxt->node->children == NULL) &&
  ------------------
  |  Branch (3111:9): [True: 0, False: 0]
  ------------------
 3112|      0|	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3112:2): [True: 0, False: 0]
  |  Branch (3112:18): [True: 0, False: 0]
  ------------------
 3113|       |
 3114|      0|    lastChild = xmlGetLastChild(ctxt->node);
 3115|      0|    if (lastChild == NULL) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 0]
  ------------------
 3116|      0|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3116:13): [True: 0, False: 0]
  ------------------
 3117|      0|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (3117:13): [True: 0, False: 0]
  ------------------
 3118|      0|    } else if (xmlNodeIsText(lastChild))
  ------------------
  |  Branch (3118:16): [True: 0, False: 0]
  ------------------
 3119|      0|        return(0);
 3120|      0|    else if ((ctxt->node->children != NULL) &&
  ------------------
  |  Branch (3120:14): [True: 0, False: 0]
  ------------------
 3121|      0|             (xmlNodeIsText(ctxt->node->children)))
  ------------------
  |  Branch (3121:14): [True: 0, False: 0]
  ------------------
 3122|      0|        return(0);
 3123|      0|    return(1);
 3124|      0|}
parser.c:xmlParseCharDataComplex:
 4711|    730|xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 4712|    730|    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4713|    730|    int nbchar = 0;
 4714|    730|    int cur, l;
 4715|       |
 4716|    730|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    730|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4717|  23.9k|    while ((cur != '<') && /* checked */
  ------------------
  |  Branch (4717:12): [True: 23.7k, False: 155]
  ------------------
 4718|  23.9k|           (cur != '&') &&
  ------------------
  |  Branch (4718:12): [True: 23.7k, False: 0]
  ------------------
 4719|  23.9k|	   (IS_CHAR(cur))) {
  ------------------
  |  |  125|  23.7k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  23.7k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 19.2k, False: 4.51k]
  |  |  |  |  ------------------
  |  |  |  |  119|  23.7k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  19.2k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 18.6k, False: 575]
  |  |  |  |  |  |  |  Branch (108:44): [True: 464, False: 18.2k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  19.2k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 18.8k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  19.2k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 18.2k, False: 575]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  23.7k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 4.51k, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 4.50k, False: 3]
  |  |  |  |  ------------------
  |  |  |  |  121|  4.51k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 3, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|  4.51k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4719:5): [True: 23.2k, False: 575]
  ------------------
 4720|  23.2k|	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4720:6): [True: 0, False: 23.2k]
  |  Branch (4720:22): [True: 0, False: 0]
  |  Branch (4720:41): [True: 0, False: 0]
  ------------------
 4721|      0|	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4722|      0|	}
 4723|  23.2k|	COPY_BUF(buf, nbchar, cur);
  ------------------
  |  | 2295|  23.2k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 18.2k, False: 4.91k]
  |  |  ------------------
  |  | 2296|  23.2k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4724|       |	/* move current position before possible calling of ctxt->sax->characters */
 4725|  23.2k|	NEXTL(l);
  ------------------
  |  | 2284|  23.2k|#define NEXTL(l) do {							\
  |  | 2285|  23.2k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 383, False: 22.8k]
  |  |  ------------------
  |  | 2286|    383|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  22.8k|    } else ctxt->input->col++;						\
  |  | 2288|  23.2k|    ctxt->input->cur += l;				\
  |  | 2289|  23.2k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4726|  23.2k|	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|  23.2k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (4726:6): [True: 69, False: 23.1k]
  ------------------
 4727|     69|	    buf[nbchar] = 0;
 4728|       |
 4729|       |	    /*
 4730|       |	     * OK the segment is to be consumed as chars.
 4731|       |	     */
 4732|     69|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4732:10): [True: 69, False: 0]
  |  Branch (4732:33): [True: 69, False: 0]
  ------------------
 4733|     69|		if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4733:7): [True: 0, False: 69]
  ------------------
 4734|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4734:11): [True: 0, False: 0]
  ------------------
 4735|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 4736|      0|			                               buf, nbchar);
 4737|     69|		} else {
 4738|     69|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4738:11): [True: 69, False: 0]
  ------------------
 4739|     69|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4740|     69|		    if ((ctxt->sax->characters !=
  ------------------
  |  Branch (4740:11): [True: 0, False: 69]
  ------------------
 4741|     69|		         ctxt->sax->ignorableWhitespace) &&
 4742|     69|			(*ctxt->space == -1))
  ------------------
  |  Branch (4742:4): [True: 0, False: 0]
  ------------------
 4743|      0|			*ctxt->space = -2;
 4744|     69|		}
 4745|     69|	    }
 4746|     69|	    nbchar = 0;
 4747|       |            /* something really bad happened in the SAX callback */
 4748|     69|            if (ctxt->instate != XML_PARSER_CONTENT)
  ------------------
  |  Branch (4748:17): [True: 0, False: 69]
  ------------------
 4749|      0|                return;
 4750|     69|            SHRINK;
  ------------------
  |  | 2265|     69|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 29, False: 40]
  |  |  |  Branch (2265:38): [True: 0, False: 40]
  |  |  ------------------
  |  | 2266|     69|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     29|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 26, False: 3]
  |  |  ------------------
  |  | 2267|     69|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|     26|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 2, False: 24]
  |  |  ------------------
  |  | 2268|     69|	xmlParserShrink(ctxt);
  ------------------
 4751|     69|	}
 4752|  23.2k|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|  23.2k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4753|  23.2k|    }
 4754|    730|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4754:9): [True: 0, False: 730]
  ------------------
 4755|      0|        return;
 4756|    730|    if (nbchar != 0) {
  ------------------
  |  Branch (4756:9): [True: 208, False: 522]
  ------------------
 4757|    208|        buf[nbchar] = 0;
 4758|       |	/*
 4759|       |	 * OK the segment is to be consumed as chars.
 4760|       |	 */
 4761|    208|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4761:6): [True: 208, False: 0]
  |  Branch (4761:29): [True: 205, False: 3]
  ------------------
 4762|    205|	    if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4762:10): [True: 0, False: 205]
  ------------------
 4763|      0|		if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4763:7): [True: 0, False: 0]
  ------------------
 4764|      0|		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 4765|    205|	    } else {
 4766|    205|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4766:7): [True: 205, False: 0]
  ------------------
 4767|    205|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4768|    205|		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
  ------------------
  |  Branch (4768:7): [True: 0, False: 205]
  ------------------
 4769|    205|		    (*ctxt->space == -1))
  ------------------
  |  Branch (4769:7): [True: 0, False: 0]
  ------------------
 4770|      0|		    *ctxt->space = -2;
 4771|    205|	    }
 4772|    205|	}
 4773|    208|    }
 4774|       |    /*
 4775|       |     * cur == 0 can mean
 4776|       |     *
 4777|       |     * - XML_PARSER_EOF or memory error. This is checked above.
 4778|       |     * - An actual 0 character.
 4779|       |     * - End of buffer.
 4780|       |     * - An incomplete UTF-8 sequence. This is allowed if partial is set.
 4781|       |     */
 4782|    730|    if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (4782:9): [True: 158, False: 572]
  ------------------
 4783|    158|        if ((cur == 0) && (CUR != 0)) {
  ------------------
  |  | 2222|      3|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4783:13): [True: 3, False: 155]
  |  Branch (4783:27): [True: 3, False: 0]
  ------------------
 4784|      3|            if (partial == 0) {
  ------------------
  |  Branch (4784:17): [True: 3, False: 0]
  ------------------
 4785|      3|                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4786|      3|                        "Incomplete UTF-8 sequence starting with %02X\n", CUR);
  ------------------
  |  | 2222|      3|#define CUR (*ctxt->input->cur)
  ------------------
 4787|      3|                NEXTL(1);
  ------------------
  |  | 2284|      3|#define NEXTL(l) do {							\
  |  | 2285|      3|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      3|    } else ctxt->input->col++;						\
  |  | 2288|      3|    ctxt->input->cur += l;				\
  |  | 2289|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4788|      3|            }
 4789|    155|        } else if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (4789:20): [True: 0, False: 155]
  |  Branch (4789:36): [True: 0, False: 0]
  ------------------
 4790|       |            /* Generate the error and skip the offending character */
 4791|      0|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4792|      0|                              "PCDATA invalid Char value %d\n", cur);
 4793|      0|            NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4794|      0|        }
 4795|    158|    }
 4796|    730|}
parser.c:xmlParseCommentComplex:
 4901|     18|                       size_t len, size_t size) {
 4902|     18|    int q, ql;
 4903|     18|    int r, rl;
 4904|     18|    int cur, l;
 4905|     18|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4905:24): [True: 0, False: 18]
  ------------------
 4906|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4907|     18|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     36|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4908|     18|    int inputid;
 4909|       |
 4910|     18|    inputid = ctxt->input->id;
 4911|       |
 4912|     18|    if (buf == NULL) {
  ------------------
  |  Branch (4912:9): [True: 3, False: 15]
  ------------------
 4913|      3|        len = 0;
 4914|      3|	size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      3|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4915|      3|	buf = (xmlChar *) xmlMallocAtomic(size);
 4916|      3|	if (buf == NULL) {
  ------------------
  |  Branch (4916:6): [True: 0, False: 3]
  ------------------
 4917|      0|	    xmlErrMemory(ctxt, NULL);
 4918|      0|	    return;
 4919|      0|	}
 4920|      3|    }
 4921|     18|    q = CUR_CHAR(ql);
  ------------------
  |  | 2291|     18|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4922|     18|    if (q == 0)
  ------------------
  |  Branch (4922:9): [True: 0, False: 18]
  ------------------
 4923|      0|        goto not_terminated;
 4924|     18|    if (!IS_CHAR(q)) {
  ------------------
  |  |  125|     18|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     18|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 18, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     18|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     18|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 18, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     18|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     18|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 15, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     18|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4924:9): [True: 3, False: 15]
  ------------------
 4925|      3|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4926|      3|                          "xmlParseComment: invalid xmlChar value %d\n",
 4927|      3|	                  q);
 4928|      3|	xmlFree (buf);
 4929|      3|	return;
 4930|      3|    }
 4931|     15|    NEXTL(ql);
  ------------------
  |  | 2284|     15|#define NEXTL(l) do {							\
  |  | 2285|     15|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 15]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     15|    } else ctxt->input->col++;						\
  |  | 2288|     15|    ctxt->input->cur += l;				\
  |  | 2289|     15|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4932|     15|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     15|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4933|     15|    if (r == 0)
  ------------------
  |  Branch (4933:9): [True: 0, False: 15]
  ------------------
 4934|      0|        goto not_terminated;
 4935|     15|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     15|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     15|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 15, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     15|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     15|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 15, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 15]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     15|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 15]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     15|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 15, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     15|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4935:9): [True: 0, False: 15]
  ------------------
 4936|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4937|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4938|      0|	                  r);
 4939|      0|	xmlFree (buf);
 4940|      0|	return;
 4941|      0|    }
 4942|     15|    NEXTL(rl);
  ------------------
  |  | 2284|     15|#define NEXTL(l) do {							\
  |  | 2285|     15|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 15]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     15|    } else ctxt->input->col++;						\
  |  | 2288|     15|    ctxt->input->cur += l;				\
  |  | 2289|     15|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4943|     15|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     15|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4944|     15|    if (cur == 0)
  ------------------
  |  Branch (4944:9): [True: 0, False: 15]
  ------------------
 4945|      0|        goto not_terminated;
 4946|    114|    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|    114|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    228|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 114, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 114, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    228|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    114|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 114, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 114]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    114|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 114]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    114|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 114, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    228|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4947|    114|           ((cur != '>') ||
  ------------------
  |  Branch (4947:13): [True: 93, False: 21]
  ------------------
 4948|    114|	    (r != '-') || (q != '-'))) {
  ------------------
  |  Branch (4948:6): [True: 6, False: 15]
  |  Branch (4948:20): [True: 0, False: 15]
  ------------------
 4949|     99|	if ((r == '-') && (q == '-')) {
  ------------------
  |  Branch (4949:6): [True: 15, False: 84]
  |  Branch (4949:20): [True: 0, False: 15]
  ------------------
 4950|      0|	    xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);
 4951|      0|	}
 4952|     99|	if (len + 5 >= size) {
  ------------------
  |  Branch (4952:6): [True: 0, False: 99]
  ------------------
 4953|      0|	    xmlChar *new_buf;
 4954|      0|            size_t new_size;
 4955|       |
 4956|      0|	    new_size = size * 2;
 4957|      0|	    new_buf = (xmlChar *) xmlRealloc(buf, new_size);
 4958|      0|	    if (new_buf == NULL) {
  ------------------
  |  Branch (4958:10): [True: 0, False: 0]
  ------------------
 4959|      0|		xmlFree (buf);
 4960|      0|		xmlErrMemory(ctxt, NULL);
 4961|      0|		return;
 4962|      0|	    }
 4963|      0|	    buf = new_buf;
 4964|      0|            size = new_size;
 4965|      0|	}
 4966|     99|	COPY_BUF(buf, len, q);
  ------------------
  |  | 2295|     99|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 81, False: 18]
  |  |  ------------------
  |  | 2296|     99|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4967|     99|        if (len > maxLength) {
  ------------------
  |  Branch (4967:13): [True: 0, False: 99]
  ------------------
 4968|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4969|      0|                         "Comment too big found", NULL);
 4970|      0|            xmlFree (buf);
 4971|      0|            return;
 4972|      0|        }
 4973|       |
 4974|     99|	q = r;
 4975|     99|	ql = rl;
 4976|     99|	r = cur;
 4977|     99|	rl = l;
 4978|       |
 4979|     99|	NEXTL(l);
  ------------------
  |  | 2284|     99|#define NEXTL(l) do {							\
  |  | 2285|     99|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 99]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     99|    } else ctxt->input->col++;						\
  |  | 2288|     99|    ctxt->input->cur += l;				\
  |  | 2289|     99|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4980|     99|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     99|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4981|       |
 4982|     99|    }
 4983|     15|    buf[len] = 0;
 4984|     15|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 15]
  ------------------
 4985|      0|        xmlFree(buf);
 4986|      0|        return;
 4987|      0|    }
 4988|     15|    if (cur == 0) {
  ------------------
  |  Branch (4988:9): [True: 0, False: 15]
  ------------------
 4989|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 4990|      0|	                     "Comment not terminated \n<!--%.50s\n", buf);
 4991|     15|    } else if (!IS_CHAR(cur)) {
  ------------------
  |  |  125|     15|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     15|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 15, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     15|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     15|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 15, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 15]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     15|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 15]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     15|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 15, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     15|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4991:16): [True: 0, False: 15]
  ------------------
 4992|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4993|      0|                          "xmlParseComment: invalid xmlChar value %d\n",
 4994|      0|	                  cur);
 4995|     15|    } else {
 4996|     15|	if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (4996:6): [True: 0, False: 15]
  ------------------
 4997|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 4998|      0|		           "Comment doesn't start and stop in the same"
 4999|      0|                           " entity\n");
 5000|      0|	}
 5001|     15|        NEXT;
  ------------------
  |  | 2275|     15|#define NEXT xmlNextChar(ctxt)
  ------------------
 5002|     15|	if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5002:6): [True: 15, False: 0]
  |  Branch (5002:29): [True: 15, False: 0]
  ------------------
 5003|     15|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (5003:6): [True: 15, False: 0]
  ------------------
 5004|     15|	    ctxt->sax->comment(ctxt->userData, buf);
 5005|     15|    }
 5006|     15|    xmlFree(buf);
 5007|     15|    return;
 5008|      0|not_terminated:
 5009|      0|    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5010|      0|			 "Comment not terminated\n", NULL);
 5011|      0|    xmlFree(buf);
 5012|      0|    return;
 5013|     15|}
parser.c:xmlNsErr:
  501|     36|{
  502|     36|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (502:9): [True: 36, False: 0]
  |  Branch (502:27): [True: 0, False: 36]
  ------------------
  503|     36|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (503:9): [True: 0, False: 0]
  ------------------
  504|      0|	return;
  505|     36|    if (ctxt != NULL)
  ------------------
  |  Branch (505:9): [True: 36, False: 0]
  ------------------
  506|     36|	ctxt->errNo = error;
  507|     36|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  508|     36|                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
  509|     36|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  510|     36|                    info1, info2, info3);
  511|     36|    if (ctxt != NULL)
  ------------------
  |  Branch (511:9): [True: 36, False: 0]
  ------------------
  512|     36|	ctxt->nsWellFormed = 0;
  513|     36|}
parser.c:xmlErrMsgStr:
  474|      6|{
  475|      6|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (475:9): [True: 6, False: 0]
  |  Branch (475:27): [True: 0, False: 6]
  ------------------
  476|      6|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (476:9): [True: 0, False: 0]
  ------------------
  477|      0|	return;
  478|      6|    if (ctxt != NULL)
  ------------------
  |  Branch (478:9): [True: 6, False: 0]
  ------------------
  479|      6|	ctxt->errNo = error;
  480|      6|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  481|      6|                    XML_FROM_PARSER, error, XML_ERR_ERROR,
  482|      6|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  483|      6|                    val);
  484|      6|}
parser.c:xmlAttrNormalizeSpace:
  922|  1.02k|{
  923|  1.02k|    if ((src == NULL) || (dst == NULL))
  ------------------
  |  Branch (923:9): [True: 0, False: 1.02k]
  |  Branch (923:26): [True: 0, False: 1.02k]
  ------------------
  924|      0|        return(NULL);
  925|       |
  926|  1.02k|    while (*src == 0x20) src++;
  ------------------
  |  Branch (926:12): [True: 3, False: 1.02k]
  ------------------
  927|  2.63k|    while (*src != 0) {
  ------------------
  |  Branch (927:12): [True: 1.60k, False: 1.02k]
  ------------------
  928|  1.60k|	if (*src == 0x20) {
  ------------------
  |  Branch (928:6): [True: 45, False: 1.56k]
  ------------------
  929|    144|	    while (*src == 0x20) src++;
  ------------------
  |  Branch (929:13): [True: 99, False: 45]
  ------------------
  930|     45|	    if (*src != 0)
  ------------------
  |  Branch (930:10): [True: 36, False: 9]
  ------------------
  931|     36|		*dst++ = 0x20;
  932|  1.56k|	} else {
  933|  1.56k|	    *dst++ = *src++;
  934|  1.56k|	}
  935|  1.60k|    }
  936|  1.02k|    *dst = 0;
  937|  1.02k|    if (dst == src)
  ------------------
  |  Branch (937:9): [True: 1.00k, False: 18]
  ------------------
  938|  1.00k|       return(NULL);
  939|     18|    return(dst);
  940|  1.02k|}
parser.c:xmlAddDefAttrs:
 1014|  1.23k|               const xmlChar *value) {
 1015|  1.23k|    xmlDefAttrsPtr defaults;
 1016|  1.23k|    xmlDefAttr *attr;
 1017|  1.23k|    int len, expandedSize;
 1018|  1.23k|    xmlHashedString name;
 1019|  1.23k|    xmlHashedString prefix;
 1020|  1.23k|    xmlHashedString hvalue;
 1021|  1.23k|    const xmlChar *localname;
 1022|       |
 1023|       |    /*
 1024|       |     * Allows to detect attribute redefinitions
 1025|       |     */
 1026|  1.23k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1026:9): [True: 1.18k, False: 45]
  ------------------
 1027|  1.18k|        if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1027:13): [True: 3, False: 1.18k]
  ------------------
 1028|      3|	    return;
 1029|  1.18k|    }
 1030|       |
 1031|  1.23k|    if (ctxt->attsDefault == NULL) {
  ------------------
  |  Branch (1031:9): [True: 54, False: 1.17k]
  ------------------
 1032|     54|        ctxt->attsDefault = xmlHashCreateDict(10, ctxt->dict);
 1033|     54|	if (ctxt->attsDefault == NULL)
  ------------------
  |  Branch (1033:6): [True: 0, False: 54]
  ------------------
 1034|      0|	    goto mem_error;
 1035|     54|    }
 1036|       |
 1037|       |    /*
 1038|       |     * split the element name into prefix:localname , the string found
 1039|       |     * are within the DTD and then not associated to namespace names.
 1040|       |     */
 1041|  1.23k|    localname = xmlSplitQName3(fullname, &len);
 1042|  1.23k|    if (localname == NULL) {
  ------------------
  |  Branch (1042:9): [True: 1.21k, False: 18]
  ------------------
 1043|  1.21k|        name = xmlDictLookupHashed(ctxt->dict, fullname, -1);
 1044|  1.21k|	prefix.name = NULL;
 1045|  1.21k|    } else {
 1046|     18|        name = xmlDictLookupHashed(ctxt->dict, localname, -1);
 1047|     18|	prefix = xmlDictLookupHashed(ctxt->dict, fullname, len);
 1048|     18|        if (prefix.name == NULL)
  ------------------
  |  Branch (1048:13): [True: 0, False: 18]
  ------------------
 1049|      0|            goto mem_error;
 1050|     18|    }
 1051|  1.23k|    if (name.name == NULL)
  ------------------
  |  Branch (1051:9): [True: 0, False: 1.23k]
  ------------------
 1052|      0|        goto mem_error;
 1053|       |
 1054|       |    /*
 1055|       |     * make sure there is some storage
 1056|       |     */
 1057|  1.23k|    defaults = xmlHashLookup2(ctxt->attsDefault, name.name, prefix.name);
 1058|  1.23k|    if ((defaults == NULL) ||
  ------------------
  |  Branch (1058:9): [True: 168, False: 1.06k]
  ------------------
 1059|  1.23k|        (defaults->nbAttrs >= defaults->maxAttrs)) {
  ------------------
  |  Branch (1059:9): [True: 24, False: 1.03k]
  ------------------
 1060|    192|        xmlDefAttrsPtr temp;
 1061|    192|        int newSize;
 1062|       |
 1063|    192|        newSize = (defaults != NULL) ? 2 * defaults->maxAttrs : 4;
  ------------------
  |  Branch (1063:19): [True: 24, False: 168]
  ------------------
 1064|    192|        temp = xmlRealloc(defaults,
 1065|    192|                          sizeof(*defaults) + newSize * sizeof(xmlDefAttr));
 1066|    192|	if (temp == NULL)
  ------------------
  |  Branch (1066:6): [True: 0, False: 192]
  ------------------
 1067|      0|	    goto mem_error;
 1068|    192|        if (defaults == NULL)
  ------------------
  |  Branch (1068:13): [True: 168, False: 24]
  ------------------
 1069|    168|            temp->nbAttrs = 0;
 1070|    192|	temp->maxAttrs = newSize;
 1071|    192|        defaults = temp;
 1072|    192|	if (xmlHashUpdateEntry2(ctxt->attsDefault, name.name, prefix.name,
  ------------------
  |  Branch (1072:6): [True: 0, False: 192]
  ------------------
 1073|    192|	                        defaults, NULL) < 0) {
 1074|      0|	    xmlFree(defaults);
 1075|      0|	    goto mem_error;
 1076|      0|	}
 1077|    192|    }
 1078|       |
 1079|       |    /*
 1080|       |     * Split the attribute name into prefix:localname , the string found
 1081|       |     * are within the DTD and hen not associated to namespace names.
 1082|       |     */
 1083|  1.23k|    localname = xmlSplitQName3(fullattr, &len);
 1084|  1.23k|    if (localname == NULL) {
  ------------------
  |  Branch (1084:9): [True: 1.15k, False: 72]
  ------------------
 1085|  1.15k|        name = xmlDictLookupHashed(ctxt->dict, fullattr, -1);
 1086|  1.15k|	prefix.name = NULL;
 1087|  1.15k|    } else {
 1088|     72|        name = xmlDictLookupHashed(ctxt->dict, localname, -1);
 1089|     72|	prefix = xmlDictLookupHashed(ctxt->dict, fullattr, len);
 1090|     72|        if (prefix.name == NULL)
  ------------------
  |  Branch (1090:13): [True: 0, False: 72]
  ------------------
 1091|      0|            goto mem_error;
 1092|     72|    }
 1093|  1.23k|    if (name.name == NULL)
  ------------------
  |  Branch (1093:9): [True: 0, False: 1.23k]
  ------------------
 1094|      0|        goto mem_error;
 1095|       |
 1096|       |    /* intern the string and precompute the end */
 1097|  1.23k|    len = strlen((const char *) value);
 1098|  1.23k|    hvalue = xmlDictLookupHashed(ctxt->dict, value, len);
 1099|  1.23k|    if (hvalue.name == NULL)
  ------------------
  |  Branch (1099:9): [True: 0, False: 1.23k]
  ------------------
 1100|      0|        goto mem_error;
 1101|       |
 1102|  1.23k|    expandedSize = strlen((const char *) name.name);
 1103|  1.23k|    if (prefix.name != NULL)
  ------------------
  |  Branch (1103:9): [True: 72, False: 1.15k]
  ------------------
 1104|     72|        expandedSize += strlen((const char *) prefix.name);
 1105|  1.23k|    expandedSize += len;
 1106|       |
 1107|  1.23k|    attr = &defaults->attrs[defaults->nbAttrs++];
 1108|  1.23k|    attr->name = name;
 1109|  1.23k|    attr->prefix = prefix;
 1110|  1.23k|    attr->value = hvalue;
 1111|  1.23k|    attr->valueEnd = hvalue.name + len;
 1112|  1.23k|    attr->external = ctxt->external;
 1113|  1.23k|    attr->expandedSize = expandedSize;
 1114|       |
 1115|  1.23k|    return;
 1116|       |
 1117|      0|mem_error:
 1118|      0|    xmlErrMemory(ctxt, NULL);
 1119|      0|    return;
 1120|  1.23k|}
parser.c:xmlAddSpecialAttr:
 1136|  5.83k|{
 1137|  5.83k|    if (ctxt->attsSpecial == NULL) {
  ------------------
  |  Branch (1137:9): [True: 120, False: 5.71k]
  ------------------
 1138|    120|        ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);
 1139|    120|	if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1139:6): [True: 0, False: 120]
  ------------------
 1140|      0|	    goto mem_error;
 1141|    120|    }
 1142|       |
 1143|  5.83k|    if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1143:9): [True: 3, False: 5.83k]
  ------------------
 1144|      3|        return;
 1145|       |
 1146|  5.83k|    xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,
 1147|  5.83k|                     (void *) (ptrdiff_t) type);
 1148|  5.83k|    return;
 1149|       |
 1150|      0|mem_error:
 1151|      0|    xmlErrMemory(ctxt, NULL);
 1152|      0|    return;
 1153|  5.83k|}
parser.c:xmlParseElementChildrenContentDeclPriv:
 6385|    960|                                       int depth) {
 6386|    960|    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6387|    960|    const xmlChar *elem;
 6388|    960|    xmlChar type = 0;
 6389|       |
 6390|    960|    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (6390:10): [True: 0, False: 960]
  |  Branch (6390:27): [True: 0, False: 0]
  ------------------
 6391|    960|        (depth >  2048)) {
  ------------------
  |  Branch (6391:9): [True: 0, False: 960]
  ------------------
 6392|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6393|      0|"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
 6394|      0|                          depth);
 6395|      0|	return(NULL);
 6396|      0|    }
 6397|    960|    SKIP_BLANKS;
  ------------------
  |  | 2273|    960|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6398|    960|    GROW;
  ------------------
  |  | 2270|    960|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    960|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 287, False: 673]
  |  |  ------------------
  |  | 2271|    960|	xmlParserGrow(ctxt);
  ------------------
 6399|    960|    if (RAW == '(') {
  ------------------
  |  | 2221|    960|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6399:9): [True: 48, False: 912]
  ------------------
 6400|     48|	int inputid = ctxt->input->id;
 6401|       |
 6402|       |        /* Recurse on first child */
 6403|     48|	NEXT;
  ------------------
  |  | 2275|     48|#define NEXT xmlNextChar(ctxt)
  ------------------
 6404|     48|	SKIP_BLANKS;
  ------------------
  |  | 2273|     48|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6405|     48|        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6406|     48|                                                           depth + 1);
 6407|     48|        if (cur == NULL)
  ------------------
  |  Branch (6407:13): [True: 0, False: 48]
  ------------------
 6408|      0|            return(NULL);
 6409|     48|	SKIP_BLANKS;
  ------------------
  |  | 2273|     48|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6410|     48|	GROW;
  ------------------
  |  | 2270|     48|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     48|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 27, False: 21]
  |  |  ------------------
  |  | 2271|     48|	xmlParserGrow(ctxt);
  ------------------
 6411|    912|    } else {
 6412|    912|	elem = xmlParseName(ctxt);
 6413|    912|	if (elem == NULL) {
  ------------------
  |  Branch (6413:6): [True: 0, False: 912]
  ------------------
 6414|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6415|      0|	    return(NULL);
 6416|      0|	}
 6417|    912|        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6418|    912|	if (cur == NULL) {
  ------------------
  |  Branch (6418:6): [True: 0, False: 912]
  ------------------
 6419|      0|	    xmlErrMemory(ctxt, NULL);
 6420|      0|	    return(NULL);
 6421|      0|	}
 6422|    912|	GROW;
  ------------------
  |  | 2270|    912|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    912|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 268, False: 644]
  |  |  ------------------
  |  | 2271|    912|	xmlParserGrow(ctxt);
  ------------------
 6423|    912|	if (RAW == '?') {
  ------------------
  |  | 2221|    912|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6423:6): [True: 93, False: 819]
  ------------------
 6424|     93|	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
 6425|     93|	    NEXT;
  ------------------
  |  | 2275|     93|#define NEXT xmlNextChar(ctxt)
  ------------------
 6426|    819|	} else if (RAW == '*') {
  ------------------
  |  | 2221|    819|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6426:13): [True: 99, False: 720]
  ------------------
 6427|     99|	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
 6428|     99|	    NEXT;
  ------------------
  |  | 2275|     99|#define NEXT xmlNextChar(ctxt)
  ------------------
 6429|    720|	} else if (RAW == '+') {
  ------------------
  |  | 2221|    720|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6429:13): [True: 141, False: 579]
  ------------------
 6430|    141|	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
 6431|    141|	    NEXT;
  ------------------
  |  | 2275|    141|#define NEXT xmlNextChar(ctxt)
  ------------------
 6432|    579|	} else {
 6433|    579|	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;
 6434|    579|	}
 6435|    912|	GROW;
  ------------------
  |  | 2270|    912|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    912|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 265, False: 647]
  |  |  ------------------
  |  | 2271|    912|	xmlParserGrow(ctxt);
  ------------------
 6436|    912|    }
 6437|    960|    SKIP_BLANKS;
  ------------------
  |  | 2273|    960|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6438|  3.79k|    while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|  3.79k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6438:12): [True: 2.84k, False: 957]
  |  Branch (6438:28): [True: 2.84k, False: 0]
  ------------------
 6439|       |        /*
 6440|       |	 * Each loop we parse one separator and one element.
 6441|       |	 */
 6442|  2.84k|        if (RAW == ',') {
  ------------------
  |  | 2221|  2.84k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6442:13): [True: 924, False: 1.91k]
  ------------------
 6443|    924|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|    366|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6443:10): [True: 366, False: 558]
  ------------------
 6444|       |
 6445|       |	    /*
 6446|       |	     * Detect "Name | Name , Name" error
 6447|       |	     */
 6448|    558|	    else if (type != CUR) {
  ------------------
  |  | 2222|    558|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6448:15): [True: 0, False: 558]
  ------------------
 6449|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6450|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6451|      0|		                  type);
 6452|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6452:7): [True: 0, False: 0]
  |  Branch (6452:25): [True: 0, False: 0]
  ------------------
 6453|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6454|      0|		if (ret != NULL)
  ------------------
  |  Branch (6454:7): [True: 0, False: 0]
  ------------------
 6455|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6456|      0|		return(NULL);
 6457|      0|	    }
 6458|    924|	    NEXT;
  ------------------
  |  | 2275|    924|#define NEXT xmlNextChar(ctxt)
  ------------------
 6459|       |
 6460|    924|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6461|    924|	    if (op == NULL) {
  ------------------
  |  Branch (6461:10): [True: 0, False: 924]
  ------------------
 6462|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6462:7): [True: 0, False: 0]
  |  Branch (6462:25): [True: 0, False: 0]
  ------------------
 6463|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6464|      0|	        xmlFreeDocElementContent(ctxt->myDoc, ret);
 6465|      0|		return(NULL);
 6466|      0|	    }
 6467|    924|	    if (last == NULL) {
  ------------------
  |  Branch (6467:10): [True: 366, False: 558]
  ------------------
 6468|    366|		op->c1 = ret;
 6469|    366|		if (ret != NULL)
  ------------------
  |  Branch (6469:7): [True: 366, False: 0]
  ------------------
 6470|    366|		    ret->parent = op;
 6471|    366|		ret = cur = op;
 6472|    558|	    } else {
 6473|    558|	        cur->c2 = op;
 6474|    558|		if (op != NULL)
  ------------------
  |  Branch (6474:7): [True: 558, False: 0]
  ------------------
 6475|    558|		    op->parent = cur;
 6476|    558|		op->c1 = last;
 6477|    558|		if (last != NULL)
  ------------------
  |  Branch (6477:7): [True: 558, False: 0]
  ------------------
 6478|    558|		    last->parent = op;
 6479|    558|		cur =op;
 6480|    558|		last = NULL;
 6481|    558|	    }
 6482|  1.91k|	} else if (RAW == '|') {
  ------------------
  |  | 2221|  1.91k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6482:13): [True: 1.91k, False: 3]
  ------------------
 6483|  1.91k|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|    291|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6483:10): [True: 291, False: 1.62k]
  ------------------
 6484|       |
 6485|       |	    /*
 6486|       |	     * Detect "Name , Name | Name" error
 6487|       |	     */
 6488|  1.62k|	    else if (type != CUR) {
  ------------------
  |  | 2222|  1.62k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6488:15): [True: 0, False: 1.62k]
  ------------------
 6489|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6490|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6491|      0|				  type);
 6492|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6492:7): [True: 0, False: 0]
  |  Branch (6492:25): [True: 0, False: 0]
  ------------------
 6493|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6494|      0|		if (ret != NULL)
  ------------------
  |  Branch (6494:7): [True: 0, False: 0]
  ------------------
 6495|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6496|      0|		return(NULL);
 6497|      0|	    }
 6498|  1.91k|	    NEXT;
  ------------------
  |  | 2275|  1.91k|#define NEXT xmlNextChar(ctxt)
  ------------------
 6499|       |
 6500|  1.91k|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6501|  1.91k|	    if (op == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 1.91k]
  ------------------
 6502|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  |  Branch (6502:25): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6504|      0|		if (ret != NULL)
  ------------------
  |  Branch (6504:7): [True: 0, False: 0]
  ------------------
 6505|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6506|      0|		return(NULL);
 6507|      0|	    }
 6508|  1.91k|	    if (last == NULL) {
  ------------------
  |  Branch (6508:10): [True: 291, False: 1.62k]
  ------------------
 6509|    291|		op->c1 = ret;
 6510|    291|		if (ret != NULL)
  ------------------
  |  Branch (6510:7): [True: 291, False: 0]
  ------------------
 6511|    291|		    ret->parent = op;
 6512|    291|		ret = cur = op;
 6513|  1.62k|	    } else {
 6514|  1.62k|	        cur->c2 = op;
 6515|  1.62k|		if (op != NULL)
  ------------------
  |  Branch (6515:7): [True: 1.62k, False: 0]
  ------------------
 6516|  1.62k|		    op->parent = cur;
 6517|  1.62k|		op->c1 = last;
 6518|  1.62k|		if (last != NULL)
  ------------------
  |  Branch (6518:7): [True: 1.62k, False: 0]
  ------------------
 6519|  1.62k|		    last->parent = op;
 6520|  1.62k|		cur =op;
 6521|  1.62k|		last = NULL;
 6522|  1.62k|	    }
 6523|  1.91k|	} else {
 6524|      3|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6525|      3|	    if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6525:10): [True: 3, False: 0]
  |  Branch (6525:28): [True: 3, False: 0]
  ------------------
 6526|      3|	        xmlFreeDocElementContent(ctxt->myDoc, last);
 6527|      3|	    if (ret != NULL)
  ------------------
  |  Branch (6527:10): [True: 3, False: 0]
  ------------------
 6528|      3|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6529|      3|	    return(NULL);
 6530|      3|	}
 6531|  2.83k|	GROW;
  ------------------
  |  | 2270|  2.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.54k, False: 1.29k]
  |  |  ------------------
  |  | 2271|  2.83k|	xmlParserGrow(ctxt);
  ------------------
 6532|  2.83k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.83k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6533|  2.83k|	GROW;
  ------------------
  |  | 2270|  2.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.55k, False: 1.28k]
  |  |  ------------------
  |  | 2271|  2.83k|	xmlParserGrow(ctxt);
  ------------------
 6534|  2.83k|	if (RAW == '(') {
  ------------------
  |  | 2221|  2.83k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6534:6): [True: 135, False: 2.70k]
  ------------------
 6535|    135|	    int inputid = ctxt->input->id;
 6536|       |	    /* Recurse on second child */
 6537|    135|	    NEXT;
  ------------------
  |  | 2275|    135|#define NEXT xmlNextChar(ctxt)
  ------------------
 6538|    135|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    135|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6539|    135|	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6540|    135|                                                          depth + 1);
 6541|    135|            if (last == NULL) {
  ------------------
  |  Branch (6541:17): [True: 0, False: 135]
  ------------------
 6542|      0|		if (ret != NULL)
  ------------------
  |  Branch (6542:7): [True: 0, False: 0]
  ------------------
 6543|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6544|      0|		return(NULL);
 6545|      0|            }
 6546|    135|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    135|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6547|  2.70k|	} else {
 6548|  2.70k|	    elem = xmlParseName(ctxt);
 6549|  2.70k|	    if (elem == NULL) {
  ------------------
  |  Branch (6549:10): [True: 0, False: 2.70k]
  ------------------
 6550|      0|		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6551|      0|		if (ret != NULL)
  ------------------
  |  Branch (6551:7): [True: 0, False: 0]
  ------------------
 6552|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6553|      0|		return(NULL);
 6554|      0|	    }
 6555|  2.70k|	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6556|  2.70k|	    if (last == NULL) {
  ------------------
  |  Branch (6556:10): [True: 0, False: 2.70k]
  ------------------
 6557|      0|		if (ret != NULL)
  ------------------
  |  Branch (6557:7): [True: 0, False: 0]
  ------------------
 6558|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6559|      0|		return(NULL);
 6560|      0|	    }
 6561|  2.70k|	    if (RAW == '?') {
  ------------------
  |  | 2221|  2.70k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6561:10): [True: 327, False: 2.37k]
  ------------------
 6562|    327|		last->ocur = XML_ELEMENT_CONTENT_OPT;
 6563|    327|		NEXT;
  ------------------
  |  | 2275|    327|#define NEXT xmlNextChar(ctxt)
  ------------------
 6564|  2.37k|	    } else if (RAW == '*') {
  ------------------
  |  | 2221|  2.37k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6564:17): [True: 219, False: 2.15k]
  ------------------
 6565|    219|		last->ocur = XML_ELEMENT_CONTENT_MULT;
 6566|    219|		NEXT;
  ------------------
  |  | 2275|    219|#define NEXT xmlNextChar(ctxt)
  ------------------
 6567|  2.15k|	    } else if (RAW == '+') {
  ------------------
  |  | 2221|  2.15k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6567:17): [True: 81, False: 2.07k]
  ------------------
 6568|     81|		last->ocur = XML_ELEMENT_CONTENT_PLUS;
 6569|     81|		NEXT;
  ------------------
  |  | 2275|     81|#define NEXT xmlNextChar(ctxt)
  ------------------
 6570|  2.07k|	    } else {
 6571|  2.07k|		last->ocur = XML_ELEMENT_CONTENT_ONCE;
 6572|  2.07k|	    }
 6573|  2.70k|	}
 6574|  2.83k|	SKIP_BLANKS;
  ------------------
  |  | 2273|  2.83k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6575|  2.83k|	GROW;
  ------------------
  |  | 2270|  2.83k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.83k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.47k, False: 1.36k]
  |  |  ------------------
  |  | 2271|  2.83k|	xmlParserGrow(ctxt);
  ------------------
 6576|  2.83k|    }
 6577|    957|    if ((cur != NULL) && (last != NULL)) {
  ------------------
  |  Branch (6577:9): [True: 957, False: 0]
  |  Branch (6577:26): [True: 654, False: 303]
  ------------------
 6578|    654|        cur->c2 = last;
 6579|    654|	if (last != NULL)
  ------------------
  |  Branch (6579:6): [True: 654, False: 0]
  ------------------
 6580|    654|	    last->parent = cur;
 6581|    654|    }
 6582|    957|    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6582:9): [True: 0, False: 957]
  ------------------
 6583|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6584|      0|                       "Element content declaration doesn't start and stop in"
 6585|      0|                       " the same entity\n");
 6586|      0|    }
 6587|    957|    NEXT;
  ------------------
  |  | 2275|    957|#define NEXT xmlNextChar(ctxt)
  ------------------
 6588|    957|    if (RAW == '?') {
  ------------------
  |  | 2221|    957|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6588:9): [True: 42, False: 915]
  ------------------
 6589|     42|	if (ret != NULL) {
  ------------------
  |  Branch (6589:6): [True: 42, False: 0]
  ------------------
 6590|     42|	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||
  ------------------
  |  Branch (6590:10): [True: 0, False: 42]
  ------------------
 6591|     42|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6591:10): [True: 0, False: 42]
  ------------------
 6592|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6593|     42|	    else
 6594|     42|	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
 6595|     42|	}
 6596|     42|	NEXT;
  ------------------
  |  | 2275|     42|#define NEXT xmlNextChar(ctxt)
  ------------------
 6597|    915|    } else if (RAW == '*') {
  ------------------
  |  | 2221|    915|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6597:16): [True: 192, False: 723]
  ------------------
 6598|    192|	if (ret != NULL) {
  ------------------
  |  Branch (6598:6): [True: 192, False: 0]
  ------------------
 6599|    192|	    ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6600|    192|	    cur = ret;
 6601|       |	    /*
 6602|       |	     * Some normalization:
 6603|       |	     * (a | b* | c?)* == (a | b | c)*
 6604|       |	     */
 6605|  1.23k|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6605:13): [True: 1.23k, False: 0]
  |  Branch (6605:30): [True: 1.04k, False: 192]
  ------------------
 6606|  1.04k|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6606:7): [True: 1.04k, False: 0]
  ------------------
 6607|  1.04k|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6607:15): [True: 36, False: 1.00k]
  ------------------
 6608|  1.04k|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6608:8): [True: 0, False: 1.00k]
  ------------------
 6609|     36|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6610|  1.04k|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6610:7): [True: 1.04k, False: 0]
  ------------------
 6611|  1.04k|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6611:15): [True: 6, False: 1.03k]
  ------------------
 6612|  1.04k|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6612:8): [True: 0, False: 1.03k]
  ------------------
 6613|      6|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6614|  1.04k|		cur = cur->c2;
 6615|  1.04k|	    }
 6616|    192|	}
 6617|    192|	NEXT;
  ------------------
  |  | 2275|    192|#define NEXT xmlNextChar(ctxt)
  ------------------
 6618|    723|    } else if (RAW == '+') {
  ------------------
  |  | 2221|    723|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6618:16): [True: 138, False: 585]
  ------------------
 6619|    138|	if (ret != NULL) {
  ------------------
  |  Branch (6619:6): [True: 138, False: 0]
  ------------------
 6620|    138|	    int found = 0;
 6621|       |
 6622|    138|	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6622:10): [True: 0, False: 138]
  ------------------
 6623|    138|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6623:10): [True: 0, False: 138]
  ------------------
 6624|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6625|    138|	    else
 6626|    138|	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;
 6627|       |	    /*
 6628|       |	     * Some normalization:
 6629|       |	     * (a | b*)+ == (a | b)*
 6630|       |	     * (a | b?)+ == (a | b)*
 6631|       |	     */
 6632|    225|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6632:13): [True: 225, False: 0]
  |  Branch (6632:30): [True: 87, False: 138]
  ------------------
 6633|     87|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6633:7): [True: 87, False: 0]
  ------------------
 6634|     87|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6634:15): [True: 0, False: 87]
  ------------------
 6635|     87|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6635:8): [True: 0, False: 87]
  ------------------
 6636|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6637|      0|		    found = 1;
 6638|      0|		}
 6639|     87|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6639:7): [True: 87, False: 0]
  ------------------
 6640|     87|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6640:15): [True: 0, False: 87]
  ------------------
 6641|     87|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6641:8): [True: 0, False: 87]
  ------------------
 6642|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6643|      0|		    found = 1;
 6644|      0|		}
 6645|     87|		cur = cur->c2;
 6646|     87|	    }
 6647|    138|	    if (found)
  ------------------
  |  Branch (6647:10): [True: 0, False: 138]
  ------------------
 6648|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6649|    138|	}
 6650|    138|	NEXT;
  ------------------
  |  | 2275|    138|#define NEXT xmlNextChar(ctxt)
  ------------------
 6651|    138|    }
 6652|    957|    return(ret);
 6653|    960|}
parser.c:xmlDetectSAX2:
  857|  1.40k|xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
  858|  1.40k|    xmlSAXHandlerPtr sax;
  859|       |
  860|       |    /* Avoid unused variable warning if features are disabled. */
  861|  1.40k|    (void) sax;
  862|       |
  863|  1.40k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (863:9): [True: 0, False: 1.40k]
  ------------------
  864|  1.40k|    sax = ctxt->sax;
  865|  1.40k|#ifdef LIBXML_SAX1_ENABLED
  866|  1.40k|    if ((sax) && (sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|  1.40k|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (866:9): [True: 1.40k, False: 0]
  |  Branch (866:18): [True: 1.40k, False: 0]
  ------------------
  867|  1.40k|        ctxt->sax2 = 1;
  868|       |#else
  869|       |    ctxt->sax2 = 1;
  870|       |#endif /* LIBXML_SAX1_ENABLED */
  871|       |
  872|  1.40k|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|  1.40k|#define BAD_CAST (xmlChar *)
  ------------------
  873|  1.40k|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|  1.40k|#define BAD_CAST (xmlChar *)
  ------------------
  874|  1.40k|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|  1.40k|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  875|  1.40k|    if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||
  ------------------
  |  Branch (875:9): [True: 0, False: 1.40k]
  |  Branch (875:34): [True: 0, False: 1.40k]
  ------------------
  876|  1.40k|		(ctxt->str_xml_ns == NULL)) {
  ------------------
  |  Branch (876:3): [True: 0, False: 1.40k]
  ------------------
  877|      0|        xmlErrMemory(ctxt, NULL);
  878|      0|    }
  879|  1.40k|}
parser.c:xmlParseConditionalSections:
 6868|      9|xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
 6869|      9|    int *inputIds = NULL;
 6870|      9|    size_t inputIdsSize = 0;
 6871|      9|    size_t depth = 0;
 6872|       |
 6873|     81|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (6873:12): [True: 81, False: 0]
  ------------------
 6874|     81|        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|     81|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     45|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     45|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6874:13): [True: 45, False: 36]
  |  Branch (6874:29): [True: 45, False: 0]
  |  Branch (6874:48): [True: 39, False: 6]
  ------------------
 6875|     39|            int id = ctxt->input->id;
 6876|       |
 6877|     39|            SKIP(3);
  ------------------
  |  | 2245|     39|#define SKIP(val) do {							\
  |  | 2246|     39|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     39|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 39]
  |  |  ------------------
  |  | 2248|     39|        xmlParserGrow(ctxt);						\
  |  | 2249|     39|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6878|     39|            SKIP_BLANKS;
  ------------------
  |  | 2273|     39|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6879|       |
 6880|     39|            if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {
  ------------------
  |  | 2235|     39|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|     78|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|     78|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|     78|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 39, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 36, False: 3]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     39|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 36, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 36, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 36, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 36, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 36, False: 0]
  |  |  ------------------
  ------------------
 6881|     36|                SKIP(7);
  ------------------
  |  | 2245|     36|#define SKIP(val) do {							\
  |  | 2246|     36|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     36|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 12, False: 24]
  |  |  ------------------
  |  | 2248|     36|        xmlParserGrow(ctxt);						\
  |  | 2249|     36|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6882|     36|                SKIP_BLANKS;
  ------------------
  |  | 2273|     36|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6883|     36|                if (RAW != '[') {
  ------------------
  |  | 2221|     36|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6883:21): [True: 0, False: 36]
  ------------------
 6884|      0|                    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6885|      0|                    xmlHaltParser(ctxt);
 6886|      0|                    goto error;
 6887|      0|                }
 6888|     36|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6888:21): [True: 0, False: 36]
  ------------------
 6889|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6890|      0|                                   "All markup of the conditional section is"
 6891|      0|                                   " not in the same entity\n");
 6892|      0|                }
 6893|     36|                NEXT;
  ------------------
  |  | 2275|     36|#define NEXT xmlNextChar(ctxt)
  ------------------
 6894|       |
 6895|     36|                if (inputIdsSize <= depth) {
  ------------------
  |  Branch (6895:21): [True: 9, False: 27]
  ------------------
 6896|      9|                    int *tmp;
 6897|       |
 6898|      9|                    inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);
  ------------------
  |  Branch (6898:37): [True: 6, False: 3]
  ------------------
 6899|      9|                    tmp = (int *) xmlRealloc(inputIds,
 6900|      9|                            inputIdsSize * sizeof(int));
 6901|      9|                    if (tmp == NULL) {
  ------------------
  |  Branch (6901:25): [True: 0, False: 9]
  ------------------
 6902|      0|                        xmlErrMemory(ctxt, NULL);
 6903|      0|                        goto error;
 6904|      0|                    }
 6905|      9|                    inputIds = tmp;
 6906|      9|                }
 6907|     36|                inputIds[depth] = id;
 6908|     36|                depth++;
 6909|     36|            } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {
  ------------------
  |  | 2233|      3|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      6|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      6|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 3, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      3|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 3, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 3, False: 0]
  |  |  ------------------
  ------------------
 6910|      3|                size_t ignoreDepth = 0;
 6911|       |
 6912|      3|                SKIP(6);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 3, False: 0]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6913|      3|                SKIP_BLANKS;
  ------------------
  |  | 2273|      3|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6914|      3|                if (RAW != '[') {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6914:21): [True: 0, False: 3]
  ------------------
 6915|      0|                    xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
 6916|      0|                    xmlHaltParser(ctxt);
 6917|      0|                    goto error;
 6918|      0|                }
 6919|      3|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6919:21): [True: 0, False: 3]
  ------------------
 6920|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6921|      0|                                   "All markup of the conditional section is"
 6922|      0|                                   " not in the same entity\n");
 6923|      0|                }
 6924|      3|                NEXT;
  ------------------
  |  | 2275|      3|#define NEXT xmlNextChar(ctxt)
  ------------------
 6925|       |
 6926|    495|                while (RAW != 0) {
  ------------------
  |  | 2221|    495|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6926:24): [True: 495, False: 0]
  ------------------
 6927|    495|                    if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|    495|#define RAW (*ctxt->input->cur)
  ------------------
                                  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     15|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                                  if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|     15|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6927:25): [True: 15, False: 480]
  |  Branch (6927:41): [True: 15, False: 0]
  |  Branch (6927:60): [True: 9, False: 6]
  ------------------
 6928|      9|                        SKIP(3);
  ------------------
  |  | 2245|      9|#define SKIP(val) do {							\
  |  | 2246|      9|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      9|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2248|      9|        xmlParserGrow(ctxt);						\
  |  | 2249|      9|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6929|      9|                        ignoreDepth++;
 6930|       |                        /* Check for integer overflow */
 6931|      9|                        if (ignoreDepth == 0) {
  ------------------
  |  Branch (6931:29): [True: 0, False: 9]
  ------------------
 6932|      0|                            xmlErrMemory(ctxt, NULL);
 6933|      0|                            goto error;
 6934|      0|                        }
 6935|    486|                    } else if ((RAW == ']') && (NXT(1) == ']') &&
  ------------------
  |  | 2221|    486|#define RAW (*ctxt->input->cur)
  ------------------
                                  } else if ((RAW == ']') && (NXT(1) == ']') &&
  ------------------
  |  | 2223|     12|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6935:32): [True: 12, False: 474]
  |  Branch (6935:48): [True: 12, False: 0]
  ------------------
 6936|    486|                               (NXT(2) == '>')) {
  ------------------
  |  | 2223|     12|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6936:32): [True: 12, False: 0]
  ------------------
 6937|     12|                        if (ignoreDepth == 0)
  ------------------
  |  Branch (6937:29): [True: 3, False: 9]
  ------------------
 6938|      3|                            break;
 6939|      9|                        SKIP(3);
  ------------------
  |  | 2245|      9|#define SKIP(val) do {							\
  |  | 2246|      9|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      9|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2248|      9|        xmlParserGrow(ctxt);						\
  |  | 2249|      9|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6940|      9|                        ignoreDepth--;
 6941|    474|                    } else {
 6942|    474|                        NEXT;
  ------------------
  |  | 2275|    474|#define NEXT xmlNextChar(ctxt)
  ------------------
 6943|    474|                    }
 6944|    495|                }
 6945|       |
 6946|      3|		if (RAW == 0) {
  ------------------
  |  | 2221|      3|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6946:7): [True: 0, False: 3]
  ------------------
 6947|      0|		    xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
 6948|      0|                    goto error;
 6949|      0|		}
 6950|      3|                if (ctxt->input->id != id) {
  ------------------
  |  Branch (6950:21): [True: 0, False: 3]
  ------------------
 6951|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6952|      0|                                   "All markup of the conditional section is"
 6953|      0|                                   " not in the same entity\n");
 6954|      0|                }
 6955|      3|                SKIP(3);
  ------------------
  |  | 2245|      3|#define SKIP(val) do {							\
  |  | 2246|      3|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      3|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2248|      3|        xmlParserGrow(ctxt);						\
  |  | 2249|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6956|      3|            } else {
 6957|      0|                xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
 6958|      0|                xmlHaltParser(ctxt);
 6959|      0|                goto error;
 6960|      0|            }
 6961|     42|        } else if ((depth > 0) &&
  ------------------
  |  Branch (6961:20): [True: 42, False: 0]
  ------------------
 6962|     42|                   (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2221|     42|#define RAW (*ctxt->input->cur)
  ------------------
                                 (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|     33|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                                 (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|     33|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6962:20): [True: 33, False: 9]
  |  Branch (6962:36): [True: 33, False: 0]
  |  Branch (6962:55): [True: 33, False: 0]
  ------------------
 6963|     33|            depth--;
 6964|     33|            if (ctxt->input->id != inputIds[depth]) {
  ------------------
  |  Branch (6964:17): [True: 3, False: 30]
  ------------------
 6965|      3|                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6966|      3|                               "All markup of the conditional section is not"
 6967|      3|                               " in the same entity\n");
 6968|      3|            }
 6969|     33|            SKIP(3);
  ------------------
  |  | 2245|     33|#define SKIP(val) do {							\
  |  | 2246|     33|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     33|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 3, False: 30]
  |  |  ------------------
  |  | 2248|     33|        xmlParserGrow(ctxt);						\
  |  | 2249|     33|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6970|     33|        } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|      9|#define RAW (*ctxt->input->cur)
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      6|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                      } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6970:20): [True: 6, False: 3]
  |  Branch (6970:37): [True: 6, False: 0]
  |  Branch (6970:56): [True: 0, False: 0]
  ------------------
 6971|      6|            xmlParseMarkupDecl(ctxt);
 6972|      6|        } else {
 6973|      3|            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
 6974|      3|            xmlHaltParser(ctxt);
 6975|      3|            goto error;
 6976|      3|        }
 6977|       |
 6978|     78|        if (depth == 0)
  ------------------
  |  Branch (6978:13): [True: 6, False: 72]
  ------------------
 6979|      6|            break;
 6980|       |
 6981|     72|        SKIP_BLANKS;
  ------------------
  |  | 2273|     72|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6982|     72|        SHRINK;
  ------------------
  |  | 2265|     72|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 72, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|     72|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     72|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 72]
  |  |  ------------------
  |  | 2267|     72|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     72|	xmlParserShrink(ctxt);
  ------------------
 6983|     72|        GROW;
  ------------------
  |  | 2270|     72|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     72|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 48, False: 24]
  |  |  ------------------
  |  | 2271|     72|	xmlParserGrow(ctxt);
  ------------------
 6984|     72|    }
 6985|       |
 6986|      9|error:
 6987|      9|    xmlFree(inputIds);
 6988|      9|}
parser.c:xmlErrAttributeDup:
  243|     31|{
  244|     31|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (244:9): [True: 31, False: 0]
  |  Branch (244:27): [True: 19, False: 12]
  ------------------
  245|     31|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (245:9): [True: 0, False: 19]
  ------------------
  246|      0|	return;
  247|     31|    if (ctxt != NULL)
  ------------------
  |  Branch (247:9): [True: 31, False: 0]
  ------------------
  248|     31|	ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;
  249|       |
  250|     31|    if (prefix == NULL)
  ------------------
  |  Branch (250:9): [True: 14, False: 17]
  ------------------
  251|     14|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  252|     14|                        XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  253|     14|                        (const char *) localname, NULL, NULL, 0, 0,
  254|     14|                        "Attribute %s redefined\n", localname);
  255|     17|    else
  256|     17|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER,
  257|     17|                        XML_ERR_ATTRIBUTE_REDEFINED, XML_ERR_FATAL, NULL, 0,
  258|     17|                        (const char *) prefix, (const char *) localname,
  259|     17|                        NULL, 0, 0, "Attribute %s:%s redefined\n", prefix,
  260|     17|                        localname);
  261|     31|    if (ctxt != NULL) {
  ------------------
  |  Branch (261:9): [True: 31, False: 0]
  ------------------
  262|     31|	ctxt->wellFormed = 0;
  263|     31|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (263:6): [True: 31, False: 0]
  ------------------
  264|     31|	    ctxt->disableSAX = 1;
  265|     31|    }
  266|     31|}
parser.c:xmlParseNameAndCompare:
 3682|  11.3k|xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3683|  11.3k|    register const xmlChar *cmp = other;
 3684|  11.3k|    register const xmlChar *in;
 3685|  11.3k|    const xmlChar *ret;
 3686|       |
 3687|  11.3k|    GROW;
  ------------------
  |  | 2270|  11.3k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  11.3k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 6.21k, False: 5.15k]
  |  |  ------------------
  |  | 2271|  11.3k|	xmlParserGrow(ctxt);
  ------------------
 3688|  11.3k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3688:9): [True: 0, False: 11.3k]
  ------------------
 3689|      0|        return(NULL);
 3690|       |
 3691|  11.3k|    in = ctxt->input->cur;
 3692|  53.9k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (3692:12): [True: 53.9k, False: 0]
  |  Branch (3692:24): [True: 42.6k, False: 11.3k]
  ------------------
 3693|  42.6k|	++in;
 3694|  42.6k|	++cmp;
 3695|  42.6k|    }
 3696|  11.3k|    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3696:9): [True: 11.3k, False: 2]
  |  Branch (3696:23): [True: 11.3k, False: 0]
  ------------------
 3697|       |	/* success */
 3698|  11.3k|	ctxt->input->col += in - ctxt->input->cur;
 3699|  11.3k|	ctxt->input->cur = in;
 3700|  11.3k|	return (const xmlChar*) 1;
 3701|  11.3k|    }
 3702|       |    /* failure (or end of input buffer), check with full function */
 3703|      2|    ret = xmlParseName (ctxt);
 3704|       |    /* strings coming from the dictionary direct compare possible */
 3705|      2|    if (ret == other) {
  ------------------
  |  Branch (3705:9): [True: 0, False: 2]
  ------------------
 3706|      0|	return (const xmlChar*) 1;
 3707|      0|    }
 3708|      2|    return ret;
 3709|      2|}
parser.c:spacePop:
 2173|  43.0k|static int spacePop(xmlParserCtxtPtr ctxt) {
 2174|  43.0k|    int ret;
 2175|  43.0k|    if (ctxt->spaceNr <= 0) return(0);
  ------------------
  |  Branch (2175:9): [True: 0, False: 43.0k]
  ------------------
 2176|  43.0k|    ctxt->spaceNr--;
 2177|  43.0k|    if (ctxt->spaceNr > 0)
  ------------------
  |  Branch (2177:9): [True: 43.0k, False: 0]
  ------------------
 2178|  43.0k|	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];
 2179|      0|    else
 2180|      0|        ctxt->space = &ctxt->spaceTab[0];
 2181|  43.0k|    ret = ctxt->spaceTab[ctxt->spaceNr];
 2182|  43.0k|    ctxt->spaceTab[ctxt->spaceNr] = -1;
 2183|  43.0k|    return(ret);
 2184|  43.0k|}
parser.c:xmlParseAttValueInternal:
 9115|  73.0k|{
 9116|  73.0k|    xmlChar limit = 0;
 9117|  73.0k|    const xmlChar *in = NULL, *start, *end, *last;
 9118|  73.0k|    xmlChar *ret = NULL;
 9119|  73.0k|    int line, col;
 9120|  73.0k|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (9120:21): [True: 0, False: 73.0k]
  ------------------
 9121|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 9122|  73.0k|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|  73.0k|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 9123|       |
 9124|  73.0k|    GROW;
  ------------------
  |  | 2270|  73.0k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  73.0k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 31.3k, False: 41.7k]
  |  |  ------------------
  |  | 2271|  73.0k|	xmlParserGrow(ctxt);
  ------------------
 9125|  73.0k|    in = (xmlChar *) CUR_PTR;
  ------------------
  |  | 2224|  73.0k|#define CUR_PTR ctxt->input->cur
  ------------------
 9126|  73.0k|    line = ctxt->input->line;
 9127|  73.0k|    col = ctxt->input->col;
 9128|  73.0k|    if (*in != '"' && *in != '\'') {
  ------------------
  |  Branch (9128:9): [True: 3.46k, False: 69.6k]
  |  Branch (9128:23): [True: 0, False: 3.46k]
  ------------------
 9129|      0|        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 9130|      0|        return (NULL);
 9131|      0|    }
 9132|  73.0k|    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 9133|       |
 9134|       |    /*
 9135|       |     * try to handle in this routine the most common case where no
 9136|       |     * allocation of a new string is required and where content is
 9137|       |     * pure ASCII.
 9138|       |     */
 9139|  73.0k|    limit = *in++;
 9140|  73.0k|    col++;
 9141|  73.0k|    end = ctxt->input->end;
 9142|  73.0k|    start = in;
 9143|  73.0k|    if (in >= end) {
  ------------------
  |  Branch (9143:9): [True: 0, False: 73.0k]
  ------------------
 9144|      0|        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9145|      0|    }
 9146|  73.0k|    if (normalize) {
  ------------------
  |  Branch (9146:9): [True: 3.20k, False: 69.8k]
  ------------------
 9147|       |        /*
 9148|       |	 * Skip any leading spaces
 9149|       |	 */
 9150|  3.30k|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9150:9): [True: 3.30k, False: 0]
  |  Branch (9150:23): [True: 3.29k, False: 3]
  ------------------
 9151|  3.30k|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9151:10): [True: 63, False: 3.23k]
  |  Branch (9151:27): [True: 0, False: 3.23k]
  ------------------
 9152|  3.29k|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9152:10): [True: 33, False: 3.20k]
  |  Branch (9152:26): [True: 0, False: 3.20k]
  ------------------
 9153|     96|	    if (*in == 0xA) {
  ------------------
  |  Branch (9153:10): [True: 33, False: 63]
  ------------------
 9154|     33|	        line++; col = 1;
 9155|     63|	    } else {
 9156|     63|	        col++;
 9157|     63|	    }
 9158|     96|	    in++;
 9159|     96|	    start = in;
 9160|     96|	    if (in >= end) {
  ------------------
  |  Branch (9160:10): [True: 0, False: 96]
  ------------------
 9161|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9162|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9162:21): [True: 0, False: 0]
  ------------------
 9163|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9164|      0|                                   "AttValue length too long\n");
 9165|      0|                    return(NULL);
 9166|      0|                }
 9167|      0|	    }
 9168|     96|	}
 9169|  32.1k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9169:9): [True: 32.1k, False: 0]
  |  Branch (9169:23): [True: 29.0k, False: 3.12k]
  |  Branch (9169:41): [True: 28.9k, False: 21]
  ------------------
 9170|  32.1k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9170:9): [True: 28.9k, False: 0]
  |  Branch (9170:26): [True: 28.9k, False: 48]
  |  Branch (9170:42): [True: 28.9k, False: 0]
  ------------------
 9171|  28.9k|	    col++;
 9172|  28.9k|	    if ((*in++ == 0x20) && (*in == 0x20)) break;
  ------------------
  |  Branch (9172:10): [True: 24, False: 28.9k]
  |  Branch (9172:29): [True: 6, False: 18]
  ------------------
 9173|  28.9k|	    if (in >= end) {
  ------------------
  |  Branch (9173:10): [True: 0, False: 28.9k]
  ------------------
 9174|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9175|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9175:21): [True: 0, False: 0]
  ------------------
 9176|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9177|      0|                                   "AttValue length too long\n");
 9178|      0|                    return(NULL);
 9179|      0|                }
 9180|      0|	    }
 9181|  28.9k|	}
 9182|  3.20k|	last = in;
 9183|       |	/*
 9184|       |	 * skip the trailing blanks
 9185|       |	 */
 9186|  3.21k|	while ((last[-1] == 0x20) && (last > start)) last--;
  ------------------
  |  Branch (9186:9): [True: 27, False: 3.18k]
  |  Branch (9186:31): [True: 12, False: 15]
  ------------------
 9187|  3.25k|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9187:9): [True: 3.25k, False: 0]
  |  Branch (9187:23): [True: 108, False: 3.14k]
  ------------------
 9188|  3.25k|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9188:10): [True: 12, False: 96]
  |  Branch (9188:27): [True: 6, False: 90]
  ------------------
 9189|    108|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9189:10): [True: 30, False: 60]
  |  Branch (9189:26): [True: 0, False: 60]
  ------------------
 9190|     48|	    if (*in == 0xA) {
  ------------------
  |  Branch (9190:10): [True: 30, False: 18]
  ------------------
 9191|     30|	        line++, col = 1;
 9192|     30|	    } else {
 9193|     18|	        col++;
 9194|     18|	    }
 9195|     48|	    in++;
 9196|     48|	    if (in >= end) {
  ------------------
  |  Branch (9196:10): [True: 0, False: 48]
  ------------------
 9197|      0|		const xmlChar *oldbase = ctxt->input->base;
 9198|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 9199|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9199:21): [True: 0, False: 0]
  ------------------
 9200|      0|                    return(NULL);
 9201|      0|		if (oldbase != ctxt->input->base) {
  ------------------
  |  Branch (9201:7): [True: 0, False: 0]
  ------------------
 9202|      0|		    ptrdiff_t delta = ctxt->input->base - oldbase;
 9203|      0|		    start = start + delta;
 9204|      0|		    in = in + delta;
 9205|      0|		    last = last + delta;
 9206|      0|		}
 9207|      0|		end = ctxt->input->end;
 9208|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9208:21): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9210|      0|                                   "AttValue length too long\n");
 9211|      0|                    return(NULL);
 9212|      0|                }
 9213|      0|	    }
 9214|     48|	}
 9215|  3.20k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9215:13): [True: 0, False: 3.20k]
  ------------------
 9216|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9217|      0|                           "AttValue length too long\n");
 9218|      0|            return(NULL);
 9219|      0|        }
 9220|  3.20k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9220:6): [True: 60, False: 3.14k]
  ------------------
 9221|  69.8k|    } else {
 9222|   894k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9222:9): [True: 894k, False: 13]
  |  Branch (9222:23): [True: 824k, False: 69.5k]
  |  Branch (9222:41): [True: 824k, False: 61]
  ------------------
 9223|   894k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9223:9): [True: 824k, False: 9]
  |  Branch (9223:26): [True: 824k, False: 216]
  |  Branch (9223:42): [True: 824k, False: 0]
  ------------------
 9224|   824k|	    in++;
 9225|   824k|	    col++;
 9226|   824k|	    if (in >= end) {
  ------------------
  |  Branch (9226:10): [True: 13, False: 824k]
  ------------------
 9227|     13|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|     13|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|     13|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|     13|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|     13|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 13]
  |  |  |  |  ------------------
  |  |  |  | 2271|     13|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|     13|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 13]
  |  |  ------------------
  |  | 9104|     13|        return(NULL);\
  |  | 9105|     13|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 13]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|     13|    end = ctxt->input->end;
  ------------------
 9228|     13|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9228:21): [True: 0, False: 13]
  ------------------
 9229|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9230|      0|                                   "AttValue length too long\n");
 9231|      0|                    return(NULL);
 9232|      0|                }
 9233|     13|	    }
 9234|   824k|	}
 9235|  69.8k|	last = in;
 9236|  69.8k|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9236:13): [True: 0, False: 69.8k]
  ------------------
 9237|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9238|      0|                           "AttValue length too long\n");
 9239|      0|            return(NULL);
 9240|      0|        }
 9241|  69.8k|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9241:6): [True: 299, False: 69.5k]
  ------------------
 9242|  69.8k|    }
 9243|  72.7k|    in++;
 9244|  72.7k|    col++;
 9245|  72.7k|    if (len != NULL) {
  ------------------
  |  Branch (9245:9): [True: 71.4k, False: 1.23k]
  ------------------
 9246|  71.4k|        if (alloc) *alloc = 0;
  ------------------
  |  Branch (9246:13): [True: 71.4k, False: 0]
  ------------------
 9247|  71.4k|        *len = last - start;
 9248|  71.4k|        ret = (xmlChar *) start;
 9249|  71.4k|    } else {
 9250|  1.23k|        if (alloc) *alloc = 1;
  ------------------
  |  Branch (9250:13): [True: 0, False: 1.23k]
  ------------------
 9251|  1.23k|        ret = xmlStrndup(start, last - start);
 9252|  1.23k|    }
 9253|  72.7k|    CUR_PTR = in;
  ------------------
  |  | 2224|  72.7k|#define CUR_PTR ctxt->input->cur
  ------------------
 9254|  72.7k|    ctxt->input->line = line;
 9255|  72.7k|    ctxt->input->col = col;
 9256|  72.7k|    return ret;
 9257|    359|need_complex:
 9258|    359|    if (alloc) *alloc = 1;
  ------------------
  |  Branch (9258:9): [True: 356, False: 3]
  ------------------
 9259|    359|    return xmlParseAttValueComplex(ctxt, len, normalize);
 9260|  73.0k|}
parser.c:xmlParseAttValueComplex:
 4056|    359|xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 4057|    359|    xmlChar limit = 0;
 4058|    359|    xmlChar *buf = NULL;
 4059|    359|    xmlChar *rep = NULL;
 4060|    359|    size_t len = 0;
 4061|    359|    size_t buf_size = 0;
 4062|    359|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4062:24): [True: 0, False: 359]
  ------------------
 4063|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4064|    359|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    718|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4065|    359|    int c, l, in_space = 0;
 4066|    359|    xmlChar *current = NULL;
 4067|    359|    xmlEntityPtr ent;
 4068|       |
 4069|    359|    if (NXT(0) == '"') {
  ------------------
  |  | 2223|    359|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4069:9): [True: 155, False: 204]
  ------------------
 4070|    155|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4071|    155|	limit = '"';
 4072|    155|        NEXT;
  ------------------
  |  | 2275|    155|#define NEXT xmlNextChar(ctxt)
  ------------------
 4073|    204|    } else if (NXT(0) == '\'') {
  ------------------
  |  | 2223|    204|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4073:16): [True: 204, False: 0]
  ------------------
 4074|    204|	limit = '\'';
 4075|    204|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4076|    204|        NEXT;
  ------------------
  |  | 2275|    204|#define NEXT xmlNextChar(ctxt)
  ------------------
 4077|    204|    } else {
 4078|      0|	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 4079|      0|	return(NULL);
 4080|      0|    }
 4081|       |
 4082|       |    /*
 4083|       |     * allocate a translation buffer.
 4084|       |     */
 4085|    359|    buf_size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    359|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4086|    359|    buf = (xmlChar *) xmlMallocAtomic(buf_size);
 4087|    359|    if (buf == NULL) goto mem_error;
  ------------------
  |  Branch (4087:9): [True: 0, False: 359]
  ------------------
 4088|       |
 4089|       |    /*
 4090|       |     * OK loop until we reach one of the ending char or a size limit.
 4091|       |     */
 4092|    359|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    359|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4093|  70.4k|    while (((NXT(0) != limit) && /* checked */
  ------------------
  |  | 2223|  70.4k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4093:13): [True: 70.0k, False: 338]
  ------------------
 4094|  70.4k|            (IS_CHAR(c)) && (c != '<')) &&
  ------------------
  |  |  125|  70.0k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  70.0k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 70.0k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|  70.0k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  70.0k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 70.0k, False: 18]
  |  |  |  |  |  |  |  Branch (108:44): [True: 501, False: 69.5k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  70.0k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 69.5k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  70.0k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 69.5k, False: 21]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  70.0k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4094:13): [True: 70.0k, False: 21]
  |  Branch (4094:29): [True: 70.0k, False: 0]
  ------------------
 4095|  70.4k|            (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (4095:13): [True: 70.0k, False: 0]
  ------------------
 4096|  70.0k|	if (c == '&') {
  ------------------
  |  Branch (4096:6): [True: 7.09k, False: 62.9k]
  ------------------
 4097|  7.09k|	    in_space = 0;
 4098|  7.09k|	    if (NXT(1) == '#') {
  ------------------
  |  | 2223|  7.09k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4098:10): [True: 258, False: 6.83k]
  ------------------
 4099|    258|		int val = xmlParseCharRef(ctxt);
 4100|       |
 4101|    258|		if (val == '&') {
  ------------------
  |  Branch (4101:7): [True: 3, False: 255]
  ------------------
 4102|      3|		    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (4102:11): [True: 3, False: 0]
  ------------------
 4103|      3|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4103:8): [True: 0, False: 3]
  ------------------
 4104|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4105|      0|			}
 4106|      3|			buf[len++] = '&';
 4107|      3|		    } else {
 4108|       |			/*
 4109|       |			 * The reparsing will be done in xmlStringGetNodeList()
 4110|       |			 * called by the attribute() function in SAX.c
 4111|       |			 */
 4112|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4112:8): [True: 0, False: 0]
  ------------------
 4113|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4114|      0|			}
 4115|      0|			buf[len++] = '&';
 4116|      0|			buf[len++] = '#';
 4117|      0|			buf[len++] = '3';
 4118|      0|			buf[len++] = '8';
 4119|      0|			buf[len++] = ';';
 4120|      0|		    }
 4121|    255|		} else if (val != 0) {
  ------------------
  |  Branch (4121:14): [True: 255, False: 0]
  ------------------
 4122|    255|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4122:11): [True: 3, False: 252]
  ------------------
 4123|      6|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      3|#define growBuffer(buffer, n) {						\
  |  | 2775|      3|    xmlChar *tmp;							\
  |  | 2776|      3|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      3|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2778|      3|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      3|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2780|      3|    buffer = tmp;							\
  |  | 2781|      3|    buffer##_size = new_size;                                           \
  |  | 2782|      3|}
  ------------------
 4124|      6|		    }
 4125|    255|		    len += xmlCopyChar(0, &buf[len], val);
 4126|    255|		}
 4127|  6.83k|	    } else {
 4128|  6.83k|		ent = xmlParseEntityRef(ctxt);
 4129|  6.83k|		if ((ent != NULL) &&
  ------------------
  |  Branch (4129:7): [True: 6.83k, False: 0]
  ------------------
 4130|  6.83k|		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (4130:7): [True: 72, False: 6.76k]
  ------------------
 4131|     72|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4131:11): [True: 0, False: 72]
  ------------------
 4132|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4133|      0|		    }
 4134|     72|		    if ((ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (4134:11): [True: 0, False: 72]
  ------------------
 4135|     72|		        (ent->content[0] == '&')) {
  ------------------
  |  Branch (4135:11): [True: 0, False: 0]
  ------------------
 4136|      0|			buf[len++] = '&';
 4137|      0|			buf[len++] = '#';
 4138|      0|			buf[len++] = '3';
 4139|      0|			buf[len++] = '8';
 4140|      0|			buf[len++] = ';';
 4141|     72|		    } else {
 4142|     72|			buf[len++] = ent->content[0];
 4143|     72|		    }
 4144|  6.76k|		} else if ((ent != NULL) &&
  ------------------
  |  Branch (4144:14): [True: 6.76k, False: 0]
  ------------------
 4145|  6.76k|		           (ctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (4145:14): [True: 6.76k, False: 0]
  ------------------
 4146|  6.76k|		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
  ------------------
  |  Branch (4146:11): [True: 6.76k, False: 0]
  ------------------
 4147|  6.76k|                        if (xmlParserEntityCheck(ctxt, ent->length))
  ------------------
  |  Branch (4147:29): [True: 0, False: 6.76k]
  ------------------
 4148|      0|                            goto error;
 4149|       |
 4150|  6.76k|			++ctxt->depth;
 4151|  6.76k|			rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 4152|  6.76k|                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|  6.76k|#define XML_SUBSTITUTE_REF	1
  ------------------
 4153|  6.76k|                                /* check */ 1);
 4154|  6.76k|			--ctxt->depth;
 4155|  6.76k|			if (rep != NULL) {
  ------------------
  |  Branch (4155:8): [True: 6.75k, False: 12]
  ------------------
 4156|  6.75k|			    current = rep;
 4157|  1.42M|			    while (*current != 0) { /* non input consuming */
  ------------------
  |  Branch (4157:15): [True: 1.41M, False: 6.75k]
  ------------------
 4158|  1.41M|                                if ((*current == 0xD) || (*current == 0xA) ||
  ------------------
  |  Branch (4158:37): [True: 18, False: 1.41M]
  |  Branch (4158:58): [True: 18, False: 1.41M]
  ------------------
 4159|  1.41M|                                    (*current == 0x9)) {
  ------------------
  |  Branch (4159:37): [True: 0, False: 1.41M]
  ------------------
 4160|     36|                                    buf[len++] = 0x20;
 4161|     36|                                    current++;
 4162|     36|                                } else
 4163|  1.41M|                                    buf[len++] = *current++;
 4164|  1.41M|				if (len + 10 > buf_size) {
  ------------------
  |  Branch (4164:9): [True: 39, False: 1.41M]
  ------------------
 4165|     78|				    growBuffer(buf, 10);
  ------------------
  |  | 2774|     39|#define growBuffer(buffer, n) {						\
  |  | 2775|     39|    xmlChar *tmp;							\
  |  | 2776|     39|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|     39|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 39]
  |  |  ------------------
  |  | 2778|     39|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|     39|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 39]
  |  |  ------------------
  |  | 2780|     39|    buffer = tmp;							\
  |  | 2781|     39|    buffer##_size = new_size;                                           \
  |  | 2782|     39|}
  ------------------
 4166|     78|				}
 4167|  1.41M|			    }
 4168|  6.75k|			    xmlFree(rep);
 4169|  6.75k|			    rep = NULL;
 4170|  6.75k|			}
 4171|  6.76k|		    } else {
 4172|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4172:8): [True: 0, False: 0]
  ------------------
 4173|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4174|      0|			}
 4175|      0|			if (ent->content != NULL)
  ------------------
  |  Branch (4175:8): [True: 0, False: 0]
  ------------------
 4176|      0|			    buf[len++] = ent->content[0];
 4177|      0|		    }
 4178|  6.76k|		} else if (ent != NULL) {
  ------------------
  |  Branch (4178:14): [True: 0, False: 0]
  ------------------
 4179|      0|		    int i = xmlStrlen(ent->name);
 4180|      0|		    const xmlChar *cur = ent->name;
 4181|       |
 4182|       |		    /*
 4183|       |                     * We also check for recursion and amplification
 4184|       |                     * when entities are not substituted. They're
 4185|       |                     * often expanded later.
 4186|       |		     */
 4187|      0|		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
  ------------------
  |  Branch (4187:11): [True: 0, False: 0]
  ------------------
 4188|      0|			(ent->content != NULL)) {
  ------------------
  |  Branch (4188:4): [True: 0, False: 0]
  ------------------
 4189|      0|                        if ((ent->flags & XML_ENT_CHECKED) == 0) {
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
  |  Branch (4189:29): [True: 0, False: 0]
  ------------------
 4190|      0|                            unsigned long oldCopy = ctxt->sizeentcopy;
 4191|       |
 4192|      0|                            ctxt->sizeentcopy = ent->length;
 4193|       |
 4194|      0|                            ++ctxt->depth;
 4195|      0|                            rep = xmlStringDecodeEntitiesInt(ctxt,
 4196|      0|                                    ent->content, ent->length,
 4197|      0|                                    XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4198|      0|                                    /* check */ 1);
 4199|      0|                            --ctxt->depth;
 4200|       |
 4201|       |                            /*
 4202|       |                             * If we're parsing DTD content, the entity
 4203|       |                             * might reference other entities which
 4204|       |                             * weren't defined yet, so the check isn't
 4205|       |                             * reliable.
 4206|       |                             */
 4207|      0|                            if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (4207:33): [True: 0, False: 0]
  ------------------
 4208|      0|                                ent->flags |= XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 4209|      0|                                ent->expandedSize = ctxt->sizeentcopy;
 4210|      0|                            }
 4211|       |
 4212|      0|                            if (rep != NULL) {
  ------------------
  |  Branch (4212:33): [True: 0, False: 0]
  ------------------
 4213|      0|                                xmlFree(rep);
 4214|      0|                                rep = NULL;
 4215|      0|                            } else {
 4216|      0|                                ent->content[0] = 0;
 4217|      0|                            }
 4218|       |
 4219|      0|                            if (xmlParserEntityCheck(ctxt, oldCopy))
  ------------------
  |  Branch (4219:33): [True: 0, False: 0]
  ------------------
 4220|      0|                                goto error;
 4221|      0|                        } else {
 4222|      0|                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))
  ------------------
  |  Branch (4222:33): [True: 0, False: 0]
  ------------------
 4223|      0|                                goto error;
 4224|      0|                        }
 4225|      0|		    }
 4226|       |
 4227|       |		    /*
 4228|       |		     * Just output the reference
 4229|       |		     */
 4230|      0|		    buf[len++] = '&';
 4231|      0|		    while (len + i + 10 > buf_size) {
  ------------------
  |  Branch (4231:14): [True: 0, False: 0]
  ------------------
 4232|      0|			growBuffer(buf, i + 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4233|      0|		    }
 4234|      0|		    for (;i > 0;i--)
  ------------------
  |  Branch (4234:13): [True: 0, False: 0]
  ------------------
 4235|      0|			buf[len++] = *cur++;
 4236|      0|		    buf[len++] = ';';
 4237|      0|		}
 4238|  6.83k|	    }
 4239|  62.9k|	} else {
 4240|  62.9k|	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
  ------------------
  |  Branch (4240:10): [True: 4.20k, False: 58.7k]
  |  Branch (4240:25): [True: 0, False: 58.7k]
  |  Branch (4240:39): [True: 492, False: 58.2k]
  |  Branch (4240:53): [True: 9, False: 58.2k]
  ------------------
 4241|  4.70k|	        if ((len != 0) || (!normalize)) {
  ------------------
  |  Branch (4241:14): [True: 4.61k, False: 90]
  |  Branch (4241:28): [True: 33, False: 57]
  ------------------
 4242|  4.64k|		    if ((!normalize) || (!in_space)) {
  ------------------
  |  Branch (4242:11): [True: 4.53k, False: 117]
  |  Branch (4242:27): [True: 69, False: 48]
  ------------------
 4243|  4.60k|			COPY_BUF(buf, len, 0x20);
  ------------------
  |  | 2295|  4.60k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [Folded - Ignored]
  |  |  ------------------
  |  | 2296|  4.60k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4244|  4.61k|			while (len + 10 > buf_size) {
  ------------------
  |  Branch (4244:11): [True: 9, False: 4.60k]
  ------------------
 4245|     18|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      9|#define growBuffer(buffer, n) {						\
  |  | 2775|      9|    xmlChar *tmp;							\
  |  | 2776|      9|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      9|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2778|      9|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      9|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 9]
  |  |  ------------------
  |  | 2780|      9|    buffer = tmp;							\
  |  | 2781|      9|    buffer##_size = new_size;                                           \
  |  | 2782|      9|}
  ------------------
 4246|     18|			}
 4247|  4.60k|		    }
 4248|  4.64k|		    in_space = 1;
 4249|  4.64k|		}
 4250|  58.2k|	    } else {
 4251|  58.2k|	        in_space = 0;
 4252|  58.2k|		COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  58.2k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 58.2k, False: 15]
  |  |  ------------------
  |  | 2296|  58.2k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4253|  58.2k|		if (len + 10 > buf_size) {
  ------------------
  |  Branch (4253:7): [True: 95, False: 58.1k]
  ------------------
 4254|    190|		    growBuffer(buf, 10);
  ------------------
  |  | 2774|     95|#define growBuffer(buffer, n) {						\
  |  | 2775|     95|    xmlChar *tmp;							\
  |  | 2776|     95|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|     95|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 95]
  |  |  ------------------
  |  | 2778|     95|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|     95|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 95]
  |  |  ------------------
  |  | 2780|     95|    buffer = tmp;							\
  |  | 2781|     95|    buffer##_size = new_size;                                           \
  |  | 2782|     95|}
  ------------------
 4255|    190|		}
 4256|  58.2k|	    }
 4257|  62.9k|	    NEXTL(l);
  ------------------
  |  | 2284|  62.9k|#define NEXTL(l) do {							\
  |  | 2285|  62.9k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 390, False: 62.5k]
  |  |  ------------------
  |  | 2286|    390|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  62.5k|    } else ctxt->input->col++;						\
  |  | 2288|  62.9k|    ctxt->input->cur += l;				\
  |  | 2289|  62.9k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4258|  62.9k|	}
 4259|  70.0k|	GROW;
  ------------------
  |  | 2270|  70.0k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  70.0k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.12k, False: 64.9k]
  |  |  ------------------
  |  | 2271|  70.0k|	xmlParserGrow(ctxt);
  ------------------
 4260|  70.0k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  70.0k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4261|  70.0k|        if (len > maxLength) {
  ------------------
  |  Branch (4261:13): [True: 0, False: 70.0k]
  ------------------
 4262|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4263|      0|                           "AttValue length too long\n");
 4264|      0|            goto mem_error;
 4265|      0|        }
 4266|  70.0k|    }
 4267|    359|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4267:9): [True: 12, False: 347]
  ------------------
 4268|     12|        goto error;
 4269|       |
 4270|    347|    if ((in_space) && (normalize)) {
  ------------------
  |  Branch (4270:9): [True: 72, False: 275]
  |  Branch (4270:23): [True: 36, False: 36]
  ------------------
 4271|     75|        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
  ------------------
  |  Branch (4271:16): [True: 75, False: 0]
  |  Branch (4271:29): [True: 39, False: 36]
  ------------------
 4272|     36|    }
 4273|    347|    buf[len] = 0;
 4274|    347|    if (RAW == '<') {
  ------------------
  |  | 2221|    347|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4274:9): [True: 0, False: 347]
  ------------------
 4275|      0|	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4276|    347|    } else if (RAW != limit) {
  ------------------
  |  | 2221|    347|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4276:16): [True: 9, False: 338]
  ------------------
 4277|      9|	if ((c != 0) && (!IS_CHAR(c))) {
  ------------------
  |  |  125|      3|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      3|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      3|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      3|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 3, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      3|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      3|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 3]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      3|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4277:6): [True: 3, False: 6]
  |  Branch (4277:18): [True: 3, False: 0]
  ------------------
 4278|      3|	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4279|      3|			   "invalid character in attribute value\n");
 4280|      6|	} else {
 4281|      6|	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4282|      6|			   "AttValue: ' expected\n");
 4283|      6|        }
 4284|      9|    } else
 4285|    338|	NEXT;
  ------------------
  |  | 2275|    338|#define NEXT xmlNextChar(ctxt)
  ------------------
 4286|       |
 4287|    347|    if (attlen != NULL) *attlen = len;
  ------------------
  |  Branch (4287:9): [True: 344, False: 3]
  ------------------
 4288|    347|    return(buf);
 4289|       |
 4290|      0|mem_error:
 4291|      0|    xmlErrMemory(ctxt, NULL);
 4292|     12|error:
 4293|     12|    if (buf != NULL)
  ------------------
  |  Branch (4293:9): [True: 12, False: 0]
  ------------------
 4294|     12|        xmlFree(buf);
 4295|     12|    if (rep != NULL)
  ------------------
  |  Branch (4295:9): [True: 0, False: 12]
  ------------------
 4296|      0|        xmlFree(rep);
 4297|     12|    return(NULL);
 4298|      0|}
parser.c:xmlParseContentInternal:
10210|    581|xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
10211|    581|    int nameNr = ctxt->nameNr;
10212|       |
10213|    581|    GROW;
  ------------------
  |  | 2270|    581|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    581|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 500, False: 81]
  |  |  ------------------
  |  | 2271|    581|	xmlParserGrow(ctxt);
  ------------------
10214|  40.5k|    while ((ctxt->input->cur < ctxt->input->end) &&
  ------------------
  |  Branch (10214:12): [True: 40.1k, False: 361]
  ------------------
10215|  40.5k|	   (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (10215:5): [True: 40.1k, False: 0]
  ------------------
10216|  40.1k|	const xmlChar *cur = ctxt->input->cur;
10217|       |
10218|       |	/*
10219|       |	 * First case : a Processing Instruction.
10220|       |	 */
10221|  40.1k|	if ((*cur == '<') && (cur[1] == '?')) {
  ------------------
  |  Branch (10221:6): [True: 18.5k, False: 21.6k]
  |  Branch (10221:23): [True: 8, False: 18.5k]
  ------------------
10222|      8|	    xmlParsePI(ctxt);
10223|      8|	}
10224|       |
10225|       |	/*
10226|       |	 * Second case : a CDSection
10227|       |	 */
10228|       |	/* 2.6.0 test was *cur not RAW */
10229|  40.1k|	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
  ------------------
  |  | 2239|  40.1k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  80.3k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  80.3k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  80.3k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  80.3k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  80.3k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 18.5k, False: 21.6k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 162, False: 18.3k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  40.1k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 37, False: 125]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 37, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 37, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 37, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 37, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 37, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  40.1k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 37, False: 0]
  |  |  ------------------
  ------------------
10230|     37|	    xmlParseCDSect(ctxt);
10231|     37|	}
10232|       |
10233|       |	/*
10234|       |	 * Third case :  a comment
10235|       |	 */
10236|  40.1k|	else if ((*cur == '<') && (NXT(1) == '!') &&
  ------------------
  |  | 2223|  18.4k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10236:11): [True: 18.4k, False: 21.6k]
  |  Branch (10236:28): [True: 125, False: 18.3k]
  ------------------
10237|  40.1k|		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    125|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|    124|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10237:4): [True: 124, False: 1]
  |  Branch (10237:23): [True: 124, False: 0]
  ------------------
10238|    124|	    xmlParseComment(ctxt);
10239|    124|	    ctxt->instate = XML_PARSER_CONTENT;
10240|    124|	}
10241|       |
10242|       |	/*
10243|       |	 * Fourth case :  a sub-element.
10244|       |	 */
10245|  40.0k|	else if (*cur == '<') {
  ------------------
  |  Branch (10245:11): [True: 18.3k, False: 21.6k]
  ------------------
10246|  18.3k|            if (NXT(1) == '/') {
  ------------------
  |  | 2223|  18.3k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10246:17): [True: 4.18k, False: 14.1k]
  ------------------
10247|  4.18k|                if (ctxt->nameNr <= nameNr)
  ------------------
  |  Branch (10247:21): [True: 220, False: 3.96k]
  ------------------
10248|    220|                    break;
10249|  3.96k|	        xmlParseElementEnd(ctxt);
10250|  14.1k|            } else {
10251|  14.1k|	        xmlParseElementStart(ctxt);
10252|  14.1k|            }
10253|  18.3k|	}
10254|       |
10255|       |	/*
10256|       |	 * Fifth case : a reference. If if has not been resolved,
10257|       |	 *    parsing returns it's Name, create the node
10258|       |	 */
10259|       |
10260|  21.6k|	else if (*cur == '&') {
  ------------------
  |  Branch (10260:11): [True: 3.45k, False: 18.1k]
  ------------------
10261|  3.45k|	    xmlParseReference(ctxt);
10262|  3.45k|	}
10263|       |
10264|       |	/*
10265|       |	 * Last case, text. Note that References are handled directly.
10266|       |	 */
10267|  18.1k|	else {
10268|  18.1k|	    xmlParseCharDataInternal(ctxt, 0);
10269|  18.1k|	}
10270|       |
10271|  39.9k|	SHRINK;
  ------------------
  |  | 2265|  39.9k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 39.9k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  39.9k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  39.9k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 32.1k, False: 7.75k]
  |  |  ------------------
  |  | 2267|  39.9k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  32.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 217, False: 31.9k]
  |  |  ------------------
  |  | 2268|  39.9k|	xmlParserShrink(ctxt);
  ------------------
10272|  39.9k|	GROW;
  ------------------
  |  | 2270|  39.9k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  39.9k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.81k, False: 37.1k]
  |  |  ------------------
  |  | 2271|  39.9k|	xmlParserGrow(ctxt);
  ------------------
10273|  39.9k|    }
10274|    581|}
parser.c:xmlFatalErrMsgStrIntStr:
  416|     18|{
  417|     18|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (417:9): [True: 18, False: 0]
  |  Branch (417:27): [True: 10, False: 8]
  ------------------
  418|     18|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (418:9): [True: 0, False: 10]
  ------------------
  419|      0|	return;
  420|     18|    if (ctxt != NULL)
  ------------------
  |  Branch (420:9): [True: 18, False: 0]
  ------------------
  421|     18|	ctxt->errNo = error;
  422|     18|    __xmlRaiseError(NULL, NULL, NULL,
  423|     18|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  424|     18|                    NULL, 0, (const char *) str1, (const char *) str2,
  425|     18|		    NULL, val, 0, msg, str1, val, str2);
  426|     18|    if (ctxt != NULL) {
  ------------------
  |  Branch (426:9): [True: 18, False: 0]
  ------------------
  427|     18|	ctxt->wellFormed = 0;
  428|     18|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (428:6): [True: 18, False: 0]
  ------------------
  429|     18|	    ctxt->disableSAX = 1;
  430|     18|    }
  431|     18|}
parser.c:xmlParseElementStart:
10351|  14.4k|xmlParseElementStart(xmlParserCtxtPtr ctxt) {
10352|  14.4k|    const xmlChar *name;
10353|  14.4k|    const xmlChar *prefix = NULL;
10354|  14.4k|    const xmlChar *URI = NULL;
10355|  14.4k|    xmlParserNodeInfo node_info;
10356|  14.4k|    int line;
10357|  14.4k|    xmlNodePtr cur;
10358|  14.4k|    int nbNs = 0;
10359|       |
10360|  14.4k|    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&
  ------------------
  |  Branch (10360:9): [True: 0, False: 14.4k]
  ------------------
10361|  14.4k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (10361:9): [True: 0, False: 0]
  ------------------
10362|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
10363|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
10364|      0|			  xmlParserMaxDepth);
10365|      0|	xmlHaltParser(ctxt);
10366|      0|	return(-1);
10367|      0|    }
10368|       |
10369|       |    /* Capture start position */
10370|  14.4k|    if (ctxt->record_info) {
  ------------------
  |  Branch (10370:9): [True: 0, False: 14.4k]
  ------------------
10371|      0|        node_info.begin_pos = ctxt->input->consumed +
10372|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10373|      0|	node_info.begin_line = ctxt->input->line;
10374|      0|    }
10375|       |
10376|  14.4k|    if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (10376:9): [True: 0, False: 14.4k]
  ------------------
10377|      0|	spacePush(ctxt, -1);
10378|  14.4k|    else if (*ctxt->space == -2)
  ------------------
  |  Branch (10378:14): [True: 0, False: 14.4k]
  ------------------
10379|      0|	spacePush(ctxt, -1);
10380|  14.4k|    else
10381|  14.4k|	spacePush(ctxt, *ctxt->space);
10382|       |
10383|  14.4k|    line = ctxt->input->line;
10384|  14.4k|#ifdef LIBXML_SAX1_ENABLED
10385|  14.4k|    if (ctxt->sax2)
  ------------------
  |  Branch (10385:9): [True: 14.4k, False: 0]
  ------------------
10386|  14.4k|#endif /* LIBXML_SAX1_ENABLED */
10387|  14.4k|        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
10388|      0|#ifdef LIBXML_SAX1_ENABLED
10389|      0|    else
10390|      0|	name = xmlParseStartTag(ctxt);
10391|  14.4k|#endif /* LIBXML_SAX1_ENABLED */
10392|  14.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10392:9): [True: 5, False: 14.4k]
  ------------------
10393|      5|	return(-1);
10394|  14.4k|    if (name == NULL) {
  ------------------
  |  Branch (10394:9): [True: 10, False: 14.4k]
  ------------------
10395|     10|	spacePop(ctxt);
10396|     10|        return(-1);
10397|     10|    }
10398|  14.4k|    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
10399|  14.4k|    cur = ctxt->node;
10400|       |
10401|  14.4k|#ifdef LIBXML_VALID_ENABLED
10402|       |    /*
10403|       |     * [ VC: Root Element Type ]
10404|       |     * The Name in the document type declaration must match the element
10405|       |     * type of the root element.
10406|       |     */
10407|  14.4k|    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (10407:9): [True: 0, False: 14.4k]
  |  Branch (10407:27): [True: 0, False: 0]
  |  Branch (10407:47): [True: 0, False: 0]
  ------------------
10408|  14.4k|        ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (10408:9): [True: 0, False: 0]
  |  Branch (10408:23): [True: 0, False: 0]
  ------------------
10409|      0|        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
10410|  14.4k|#endif /* LIBXML_VALID_ENABLED */
10411|       |
10412|       |    /*
10413|       |     * Check for an Empty Element.
10414|       |     */
10415|  14.4k|    if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  14.4k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|  10.2k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10415:9): [True: 10.2k, False: 4.20k]
  |  Branch (10415:25): [True: 10.2k, False: 0]
  ------------------
10416|  10.2k|        SKIP(2);
  ------------------
  |  | 2245|  10.2k|#define SKIP(val) do {							\
  |  | 2246|  10.2k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  10.2k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 22, False: 10.2k]
  |  |  ------------------
  |  | 2248|  10.2k|        xmlParserGrow(ctxt);						\
  |  | 2249|  10.2k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10417|  10.2k|	if (ctxt->sax2) {
  ------------------
  |  Branch (10417:6): [True: 10.2k, False: 0]
  ------------------
10418|  10.2k|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10418:10): [True: 10.2k, False: 0]
  |  Branch (10418:33): [True: 10.2k, False: 0]
  ------------------
10419|  10.2k|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10419:3): [True: 10.1k, False: 52]
  ------------------
10420|  10.1k|		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);
10421|  10.2k|#ifdef LIBXML_SAX1_ENABLED
10422|  10.2k|	} else {
10423|      0|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (10423:10): [True: 0, False: 0]
  |  Branch (10423:33): [True: 0, False: 0]
  ------------------
10424|      0|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10424:3): [True: 0, False: 0]
  ------------------
10425|      0|		ctxt->sax->endElement(ctxt->userData, name);
10426|      0|#endif /* LIBXML_SAX1_ENABLED */
10427|      0|	}
10428|  10.2k|	namePop(ctxt);
10429|  10.2k|	spacePop(ctxt);
10430|  10.2k|	if (nbNs > 0)
  ------------------
  |  Branch (10430:6): [True: 15, False: 10.2k]
  ------------------
10431|     15|	    xmlParserNsPop(ctxt, nbNs);
10432|  10.2k|	if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10432:6): [True: 10.2k, False: 2]
  |  Branch (10432:21): [True: 0, False: 10.2k]
  ------------------
10433|      0|            node_info.node = cur;
10434|      0|            node_info.end_pos = ctxt->input->consumed +
10435|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10436|      0|            node_info.end_line = ctxt->input->line;
10437|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10438|      0|	}
10439|  10.2k|	return(1);
10440|  10.2k|    }
10441|  4.20k|    if (RAW == '>') {
  ------------------
  |  | 2221|  4.20k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10441:9): [True: 4.20k, False: 7]
  ------------------
10442|  4.20k|        NEXT1;
  ------------------
  |  | 2277|  4.20k|#define NEXT1 {								\
  |  | 2278|  4.20k|	ctxt->input->col++;						\
  |  | 2279|  4.20k|	ctxt->input->cur++;						\
  |  | 2280|  4.20k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 1, False: 4.20k]
  |  |  ------------------
  |  | 2281|  4.20k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  4.20k|    }
  ------------------
10443|  4.20k|        if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10443:13): [True: 4.20k, False: 0]
  |  Branch (10443:28): [True: 0, False: 4.20k]
  ------------------
10444|      0|            node_info.node = cur;
10445|      0|            node_info.end_pos = 0;
10446|      0|            node_info.end_line = 0;
10447|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10448|      0|        }
10449|  4.20k|    } else {
10450|      7|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10451|      7|		     "Couldn't find end of Start Tag %s line %d\n",
10452|      7|		                name, line, NULL);
10453|       |
10454|       |	/*
10455|       |	 * end of parsing of this node.
10456|       |	 */
10457|      7|	nodePop(ctxt);
10458|      7|	namePop(ctxt);
10459|      7|	spacePop(ctxt);
10460|      7|	if (nbNs > 0)
  ------------------
  |  Branch (10460:6): [True: 1, False: 6]
  ------------------
10461|      1|	    xmlParserNsPop(ctxt, nbNs);
10462|      7|	return(-1);
10463|      7|    }
10464|       |
10465|  4.20k|    return(0);
10466|  4.20k|}
parser.c:spacePush:
 2154|  43.1k|static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 2155|  43.1k|    if (ctxt->spaceNr >= ctxt->spaceMax) {
  ------------------
  |  Branch (2155:9): [True: 6, False: 43.1k]
  ------------------
 2156|      6|        int *tmp;
 2157|       |
 2158|      6|	ctxt->spaceMax *= 2;
 2159|      6|        tmp = (int *) xmlRealloc(ctxt->spaceTab,
 2160|      6|	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
 2161|      6|        if (tmp == NULL) {
  ------------------
  |  Branch (2161:13): [True: 0, False: 6]
  ------------------
 2162|      0|	    xmlErrMemory(ctxt, NULL);
 2163|      0|	    ctxt->spaceMax /=2;
 2164|      0|	    return(-1);
 2165|      0|	}
 2166|      6|	ctxt->spaceTab = tmp;
 2167|      6|    }
 2168|  43.1k|    ctxt->spaceTab[ctxt->spaceNr] = val;
 2169|  43.1k|    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];
 2170|  43.1k|    return(ctxt->spaceNr++);
 2171|  43.1k|}
parser.c:xmlParseStartTag2:
 9471|  43.1k|                  const xmlChar **URI, int *nbNsPtr) {
 9472|  43.1k|    xmlHashedString hlocalname;
 9473|  43.1k|    xmlHashedString hprefix;
 9474|  43.1k|    xmlHashedString hattname;
 9475|  43.1k|    xmlHashedString haprefix;
 9476|  43.1k|    const xmlChar *localname;
 9477|  43.1k|    const xmlChar *prefix;
 9478|  43.1k|    const xmlChar *attname;
 9479|  43.1k|    const xmlChar *aprefix;
 9480|  43.1k|    const xmlChar *uri;
 9481|  43.1k|    xmlChar *attvalue = NULL;
 9482|  43.1k|    const xmlChar **atts = ctxt->atts;
 9483|  43.1k|    unsigned attrHashSize = 0;
 9484|  43.1k|    int maxatts = ctxt->maxatts;
 9485|  43.1k|    int nratts, nbatts, nbdef, inputid;
 9486|  43.1k|    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;
 9487|  43.1k|    int alloc = 0;
 9488|       |
 9489|  43.1k|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|  43.1k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9489:9): [True: 0, False: 43.1k]
  ------------------
 9490|  43.1k|    NEXT1;
  ------------------
  |  | 2277|  43.1k|#define NEXT1 {								\
  |  | 2278|  43.1k|	ctxt->input->col++;						\
  |  | 2279|  43.1k|	ctxt->input->cur++;						\
  |  | 2280|  43.1k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 3, False: 43.1k]
  |  |  ------------------
  |  | 2281|  43.1k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  43.1k|    }
  ------------------
 9491|       |
 9492|  43.1k|    inputid = ctxt->input->id;
 9493|  43.1k|    nbatts = 0;
 9494|  43.1k|    nratts = 0;
 9495|  43.1k|    nbdef = 0;
 9496|  43.1k|    nbNs = 0;
 9497|  43.1k|    nbTotalDef = 0;
 9498|  43.1k|    attval = 0;
 9499|       |
 9500|  43.1k|    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {
  ------------------
  |  Branch (9500:9): [True: 0, False: 43.1k]
  ------------------
 9501|      0|        xmlErrMemory(ctxt, NULL);
 9502|      0|        return(NULL);
 9503|      0|    }
 9504|       |
 9505|  43.1k|    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);
 9506|  43.1k|    if (hlocalname.name == NULL) {
  ------------------
  |  Branch (9506:9): [True: 26, False: 43.1k]
  ------------------
 9507|     26|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9508|     26|		       "StartTag: invalid element name\n");
 9509|     26|        return(NULL);
 9510|     26|    }
 9511|  43.1k|    localname = hlocalname.name;
 9512|  43.1k|    prefix = hprefix.name;
 9513|       |
 9514|       |    /*
 9515|       |     * Now parse the attributes, it ends up with the ending
 9516|       |     *
 9517|       |     * (S Attribute)* S?
 9518|       |     */
 9519|  43.1k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  43.1k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9520|  43.1k|    GROW;
  ------------------
  |  | 2270|  43.1k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  43.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 21.3k, False: 21.8k]
  |  |  ------------------
  |  | 2271|  43.1k|	xmlParserGrow(ctxt);
  ------------------
 9521|       |
 9522|       |    /*
 9523|       |     * The ctxt->atts array will be ultimately passed to the SAX callback
 9524|       |     * containing five xmlChar pointers for each attribute:
 9525|       |     *
 9526|       |     * [0] attribute name
 9527|       |     * [1] attribute prefix
 9528|       |     * [2] namespace URI
 9529|       |     * [3] attribute value
 9530|       |     * [4] end of attribute value
 9531|       |     *
 9532|       |     * To save memory, we reuse this array temporarily and store integers
 9533|       |     * in these pointer variables.
 9534|       |     *
 9535|       |     * [0] attribute name
 9536|       |     * [1] attribute prefix
 9537|       |     * [2] hash value of attribute prefix, and later namespace index
 9538|       |     * [3] for non-allocated values: ptrdiff_t offset into input buffer
 9539|       |     * [4] for non-allocated values: ptrdiff_t offset into input buffer
 9540|       |     *
 9541|       |     * The ctxt->attallocs array contains an additional unsigned int for
 9542|       |     * each attribute, containing the hash value of the attribute name
 9543|       |     * and the alloc flag in bit 31.
 9544|       |     */
 9545|       |
 9546|  80.2k|    while (((RAW != '>') &&
  ------------------
  |  | 2221|  80.2k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9546:13): [True: 72.6k, False: 7.57k]
  ------------------
 9547|  80.2k|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|  72.6k|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|    792|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9547:6): [True: 71.8k, False: 792]
  |  Branch (9547:22): [True: 0, False: 792]
  ------------------
 9548|  80.2k|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|  71.8k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  71.8k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 71.8k, False: 7]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 71.8k]
  |  |  |  |  ------------------
  |  |  |  |  109|  71.8k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 71.8k]
  |  |  |  |  ------------------
  |  |  |  |  110|  71.8k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 71.8k, False: 7]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9548:29): [True: 71.8k, False: 0]
  ------------------
 9549|  71.8k|	int len = -1;
 9550|       |
 9551|  71.8k|	hattname = xmlParseAttribute2(ctxt, prefix, localname,
 9552|  71.8k|                                          &haprefix, &attvalue, &len,
 9553|  71.8k|                                          &alloc);
 9554|  71.8k|        if (hattname.name == NULL) {
  ------------------
  |  Branch (9554:13): [True: 12, False: 71.8k]
  ------------------
 9555|     12|	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9556|     12|	         "xmlParseStartTag: problem parsing attributes\n");
 9557|     12|	    break;
 9558|     12|	}
 9559|  71.8k|        if (attvalue == NULL)
  ------------------
  |  Branch (9559:13): [True: 3, False: 71.8k]
  ------------------
 9560|      3|            goto next_attr;
 9561|  71.8k|        attname = hattname.name;
 9562|  71.8k|        aprefix = haprefix.name;
 9563|  71.8k|	if (len < 0) len = xmlStrlen(attvalue);
  ------------------
  |  Branch (9563:6): [True: 0, False: 71.8k]
  ------------------
 9564|       |
 9565|  71.8k|        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9565:13): [True: 90, False: 71.7k]
  |  Branch (9565:45): [True: 90, False: 0]
  ------------------
 9566|     90|            xmlHashedString huri;
 9567|     90|            xmlURIPtr parsedUri;
 9568|       |
 9569|     90|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9570|     90|            uri = huri.name;
 9571|     90|            if (uri == NULL) {
  ------------------
  |  Branch (9571:17): [True: 0, False: 90]
  ------------------
 9572|      0|                xmlErrMemory(ctxt, NULL);
 9573|      0|                goto next_attr;
 9574|      0|            }
 9575|     90|            if (*uri != 0) {
  ------------------
  |  Branch (9575:17): [True: 90, False: 0]
  ------------------
 9576|     90|                parsedUri = xmlParseURI((const char *) uri);
 9577|     90|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9577:21): [True: 0, False: 90]
  ------------------
 9578|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9579|      0|                             "xmlns: '%s' is not a valid URI\n",
 9580|      0|                                       uri, NULL, NULL);
 9581|     90|                } else {
 9582|     90|                    if (parsedUri->scheme == NULL) {
  ------------------
  |  Branch (9582:25): [True: 3, False: 87]
  ------------------
 9583|      3|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9584|      3|                                  "xmlns: URI %s is not absolute\n",
 9585|      3|                                  uri, NULL, NULL);
 9586|      3|                    }
 9587|     90|                    xmlFreeURI(parsedUri);
 9588|     90|                }
 9589|     90|                if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9589:21): [True: 0, False: 90]
  ------------------
 9590|      0|                    if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9590:25): [True: 0, False: 0]
  ------------------
 9591|      0|                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9592|      0|                     "xml namespace URI cannot be the default namespace\n",
 9593|      0|                                 NULL, NULL, NULL);
 9594|      0|                    }
 9595|      0|                    goto next_attr;
 9596|      0|                }
 9597|     90|                if ((len == 29) &&
  ------------------
  |  Branch (9597:21): [True: 0, False: 90]
  ------------------
 9598|     90|                    (xmlStrEqual(uri,
  ------------------
  |  Branch (9598:21): [True: 0, False: 0]
  ------------------
 9599|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9600|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9601|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9602|      0|                             NULL, NULL, NULL);
 9603|      0|                    goto next_attr;
 9604|      0|                }
 9605|     90|            }
 9606|       |
 9607|     90|            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9607:17): [True: 87, False: 3]
  ------------------
 9608|     87|                nbNs++;
 9609|  71.7k|        } else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9609:20): [True: 219, False: 71.5k]
  ------------------
 9610|    219|            xmlHashedString huri;
 9611|    219|            xmlURIPtr parsedUri;
 9612|       |
 9613|    219|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9614|    219|            uri = huri.name;
 9615|    219|            if (uri == NULL) {
  ------------------
  |  Branch (9615:17): [True: 0, False: 219]
  ------------------
 9616|      0|                xmlErrMemory(ctxt, NULL);
 9617|      0|                goto next_attr;
 9618|      0|            }
 9619|       |
 9620|    219|            if (attname == ctxt->str_xml) {
  ------------------
  |  Branch (9620:17): [True: 3, False: 216]
  ------------------
 9621|      3|                if (uri != ctxt->str_xml_ns) {
  ------------------
  |  Branch (9621:21): [True: 3, False: 0]
  ------------------
 9622|      3|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9623|      3|                             "xml namespace prefix mapped to wrong URI\n",
 9624|      3|                             NULL, NULL, NULL);
 9625|      3|                }
 9626|       |                /*
 9627|       |                 * Do not keep a namespace definition node
 9628|       |                 */
 9629|      3|                goto next_attr;
 9630|      3|            }
 9631|    216|            if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9631:17): [True: 0, False: 216]
  ------------------
 9632|      0|                if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9632:21): [True: 0, False: 0]
  ------------------
 9633|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9634|      0|                             "xml namespace URI mapped to wrong prefix\n",
 9635|      0|                             NULL, NULL, NULL);
 9636|      0|                }
 9637|      0|                goto next_attr;
 9638|      0|            }
 9639|    216|            if (attname == ctxt->str_xmlns) {
  ------------------
  |  Branch (9639:17): [True: 0, False: 216]
  ------------------
 9640|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9641|      0|                         "redefinition of the xmlns prefix is forbidden\n",
 9642|      0|                         NULL, NULL, NULL);
 9643|      0|                goto next_attr;
 9644|      0|            }
 9645|    216|            if ((len == 29) &&
  ------------------
  |  Branch (9645:17): [True: 6, False: 210]
  ------------------
 9646|    216|                (xmlStrEqual(uri,
  ------------------
  |  Branch (9646:17): [True: 0, False: 6]
  ------------------
 9647|      6|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
 9648|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9649|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9650|      0|                         NULL, NULL, NULL);
 9651|      0|                goto next_attr;
 9652|      0|            }
 9653|    216|            if ((uri == NULL) || (uri[0] == 0)) {
  ------------------
  |  Branch (9653:17): [True: 0, False: 216]
  |  Branch (9653:34): [True: 0, False: 216]
  ------------------
 9654|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9655|      0|                         "xmlns:%s: Empty XML namespace is not allowed\n",
 9656|      0|                              attname, NULL, NULL);
 9657|      0|                goto next_attr;
 9658|    216|            } else {
 9659|    216|                parsedUri = xmlParseURI((const char *) uri);
 9660|    216|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9660:21): [True: 0, False: 216]
  ------------------
 9661|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9662|      0|                         "xmlns:%s: '%s' is not a valid URI\n",
 9663|      0|                                       attname, uri, NULL);
 9664|    216|                } else {
 9665|    216|                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {
  ------------------
  |  Branch (9665:25): [True: 0, False: 216]
  |  Branch (9665:45): [True: 0, False: 0]
  ------------------
 9666|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9667|      0|                                  "xmlns:%s: URI %s is not absolute\n",
 9668|      0|                                  attname, uri, NULL);
 9669|      0|                    }
 9670|    216|                    xmlFreeURI(parsedUri);
 9671|    216|                }
 9672|    216|            }
 9673|       |
 9674|    216|            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9674:17): [True: 213, False: 3]
  ------------------
 9675|    213|                nbNs++;
 9676|  71.5k|        } else {
 9677|       |            /*
 9678|       |             * Populate attributes array, see above for repurposing
 9679|       |             * of xmlChar pointers.
 9680|       |             */
 9681|  71.5k|            if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9681:17): [True: 366, False: 71.1k]
  |  Branch (9681:35): [True: 12, False: 71.1k]
  ------------------
 9682|    378|                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9682:21): [True: 0, False: 378]
  ------------------
 9683|      0|                    goto next_attr;
 9684|      0|                }
 9685|    378|                maxatts = ctxt->maxatts;
 9686|    378|                atts = ctxt->atts;
 9687|    378|            }
 9688|  71.5k|            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |
 9689|  71.5k|                                        ((unsigned) alloc << 31);
 9690|  71.5k|            atts[nbatts++] = attname;
 9691|  71.5k|            atts[nbatts++] = aprefix;
 9692|  71.5k|            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;
 9693|  71.5k|            if (alloc) {
  ------------------
  |  Branch (9693:17): [True: 344, False: 71.1k]
  ------------------
 9694|    344|                atts[nbatts++] = attvalue;
 9695|    344|                attvalue += len;
 9696|    344|                atts[nbatts++] = attvalue;
 9697|  71.1k|            } else {
 9698|       |                /*
 9699|       |                 * attvalue points into the input buffer which can be
 9700|       |                 * reallocated. Store differences to input->base instead.
 9701|       |                 * The pointers will be reconstructed later.
 9702|       |                 */
 9703|  71.1k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  71.1k|#define BASE_PTR ctxt->input->base
  ------------------
 9704|  71.1k|                attvalue += len;
 9705|  71.1k|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|  71.1k|#define BASE_PTR ctxt->input->base
  ------------------
 9706|  71.1k|            }
 9707|       |            /*
 9708|       |             * tag if some deallocation is needed
 9709|       |             */
 9710|  71.5k|            if (alloc != 0) attval = 1;
  ------------------
  |  Branch (9710:17): [True: 344, False: 71.1k]
  ------------------
 9711|  71.5k|            attvalue = NULL; /* moved into atts */
 9712|  71.5k|        }
 9713|       |
 9714|  71.8k|next_attr:
 9715|  71.8k|        if ((attvalue != NULL) && (alloc != 0)) {
  ------------------
  |  Branch (9715:13): [True: 309, False: 71.5k]
  |  Branch (9715:35): [True: 0, False: 309]
  ------------------
 9716|      0|            xmlFree(attvalue);
 9717|      0|            attvalue = NULL;
 9718|      0|        }
 9719|       |
 9720|  71.8k|	GROW
  ------------------
  |  | 2270|  71.8k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  71.8k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 31.9k, False: 39.8k]
  |  |  ------------------
  |  | 2271|  71.8k|	xmlParserGrow(ctxt);
  ------------------
 9721|  71.8k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9721:13): [True: 0, False: 71.8k]
  ------------------
 9722|      0|            break;
 9723|  71.8k|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  71.8k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|  66.9k|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|  29.7k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9723:6): [True: 4.92k, False: 66.9k]
  |  Branch (9723:24): [True: 29.7k, False: 37.1k]
  |  Branch (9723:40): [True: 29.7k, False: 0]
  ------------------
 9724|  34.7k|	    break;
 9725|  37.1k|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|  37.1k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (9725:6): [True: 12, False: 37.1k]
  ------------------
 9726|     12|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9727|     12|			   "attributes construct error\n");
 9728|     12|	    break;
 9729|     12|	}
 9730|  37.1k|        GROW;
  ------------------
  |  | 2270|  37.1k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  37.1k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 14.4k, False: 22.6k]
  |  |  ------------------
  |  | 2271|  37.1k|	xmlParserGrow(ctxt);
  ------------------
 9731|  37.1k|    }
 9732|       |
 9733|  43.1k|    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (9733:9): [True: 0, False: 43.1k]
  ------------------
 9734|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9735|      0|                    "Unexpected change of input\n");
 9736|      0|        localname = NULL;
 9737|      0|        goto done;
 9738|      0|    }
 9739|       |
 9740|       |    /*
 9741|       |     * Namespaces from default attributes
 9742|       |     */
 9743|  43.1k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9743:9): [True: 9.20k, False: 33.8k]
  ------------------
 9744|  9.20k|        xmlDefAttrsPtr defaults;
 9745|       |
 9746|  9.20k|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9747|  9.20k|	if (defaults != NULL) {
  ------------------
  |  Branch (9747:6): [True: 1.11k, False: 8.09k]
  ------------------
 9748|   123k|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9748:18): [True: 122k, False: 1.11k]
  ------------------
 9749|   122k|                xmlDefAttr *attr = &defaults->attrs[i];
 9750|       |
 9751|   122k|	        attname = attr->name.name;
 9752|   122k|		aprefix = attr->prefix.name;
 9753|       |
 9754|   122k|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9754:7): [True: 6, False: 122k]
  |  Branch (9754:39): [True: 6, False: 0]
  ------------------
 9755|      6|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9756|       |
 9757|      6|                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)
  ------------------
  |  Branch (9757:25): [True: 3, False: 3]
  ------------------
 9758|      3|                        nbNs++;
 9759|   122k|		} else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9759:14): [True: 21, False: 122k]
  ------------------
 9760|     21|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9761|       |
 9762|     21|                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,
  ------------------
  |  Branch (9762:25): [True: 12, False: 9]
  ------------------
 9763|     21|                                      NULL, 1) > 0)
 9764|     12|                        nbNs++;
 9765|   122k|		} else {
 9766|   122k|                    nbTotalDef += 1;
 9767|   122k|                }
 9768|   122k|	    }
 9769|  1.11k|	}
 9770|  9.20k|    }
 9771|       |
 9772|       |    /*
 9773|       |     * Resolve attribute namespaces
 9774|       |     */
 9775|   114k|    for (i = 0; i < nbatts; i += 5) {
  ------------------
  |  Branch (9775:17): [True: 71.5k, False: 43.1k]
  ------------------
 9776|  71.5k|        attname = atts[i];
 9777|  71.5k|        aprefix = atts[i+1];
 9778|       |
 9779|       |        /*
 9780|       |	* The default namespace does not apply to attribute names.
 9781|       |	*/
 9782|  71.5k|	if (aprefix == NULL) {
  ------------------
  |  Branch (9782:6): [True: 65.3k, False: 6.17k]
  ------------------
 9783|  65.3k|            nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|  65.3k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9784|  65.3k|        } else if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9784:20): [True: 45, False: 6.12k]
  ------------------
 9785|     45|            nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|     45|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9786|  6.12k|        } else {
 9787|  6.12k|            haprefix.name = aprefix;
 9788|  6.12k|            haprefix.hashValue = (size_t) atts[i+2];
 9789|  6.12k|            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);
 9790|  6.12k|	    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9790:10): [True: 0, False: 6.12k]
  ------------------
 9791|      0|                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9792|      0|		    "Namespace prefix %s for %s on %s is not defined\n",
 9793|      0|		    aprefix, attname, localname);
 9794|      0|                nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9795|      0|            }
 9796|  6.12k|        }
 9797|       |
 9798|  71.5k|        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9799|  71.5k|    }
 9800|       |
 9801|       |    /*
 9802|       |     * Maximum number of attributes including default attributes.
 9803|       |     */
 9804|  43.1k|    maxAtts = nratts + nbTotalDef;
 9805|       |
 9806|       |    /*
 9807|       |     * Verify that attribute names are unique.
 9808|       |     */
 9809|  43.1k|    if (maxAtts > 1) {
  ------------------
  |  Branch (9809:9): [True: 29.5k, False: 13.5k]
  ------------------
 9810|  29.5k|        attrHashSize = 4;
 9811|  33.9k|        while (attrHashSize / 2 < (unsigned) maxAtts)
  ------------------
  |  Branch (9811:16): [True: 4.40k, False: 29.5k]
  ------------------
 9812|  4.40k|            attrHashSize *= 2;
 9813|       |
 9814|  29.5k|        if (attrHashSize > ctxt->attrHashMax) {
  ------------------
  |  Branch (9814:13): [True: 313, False: 29.2k]
  ------------------
 9815|    313|            xmlAttrHashBucket *tmp;
 9816|       |
 9817|    313|            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));
 9818|    313|            if (tmp == NULL) {
  ------------------
  |  Branch (9818:17): [True: 0, False: 313]
  ------------------
 9819|      0|                xmlErrMemory(ctxt, NULL);
 9820|      0|                goto done;
 9821|      0|            }
 9822|       |
 9823|    313|            ctxt->attrHash = tmp;
 9824|    313|            ctxt->attrHashMax = attrHashSize;
 9825|    313|        }
 9826|       |
 9827|  29.5k|        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));
 9828|       |
 9829|  95.3k|        for (i = 0, j = 0; j < nratts; i += 5, j++) {
  ------------------
  |  Branch (9829:28): [True: 65.8k, False: 29.5k]
  ------------------
 9830|  65.8k|            const xmlChar *nsuri;
 9831|  65.8k|            unsigned hashValue, nameHashValue, uriHashValue;
 9832|  65.8k|            int res;
 9833|       |
 9834|  65.8k|            attname = atts[i];
 9835|  65.8k|            aprefix = atts[i+1];
 9836|  65.8k|            nsIndex = (ptrdiff_t) atts[i+2];
 9837|       |            /* Hash values always have bit 31 set, see dict.c */
 9838|  65.8k|            nameHashValue = ctxt->attallocs[j] | 0x80000000;
 9839|       |
 9840|  65.8k|            if (nsIndex == NS_INDEX_EMPTY) {
  ------------------
  |  |   77|  65.8k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9840:17): [True: 59.9k, False: 5.95k]
  ------------------
 9841|  59.9k|                nsuri = NULL;
 9842|  59.9k|                uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|  59.9k|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9843|  59.9k|            } else if (nsIndex == NS_INDEX_XML) {
  ------------------
  |  |   78|  5.95k|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9843:24): [True: 21, False: 5.93k]
  ------------------
 9844|     21|                nsuri = ctxt->str_xml_ns;
 9845|     21|                uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|     21|#define URI_HASH_XML    0xF0451F02
  ------------------
 9846|  5.93k|            } else {
 9847|  5.93k|                nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9848|  5.93k|                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9849|  5.93k|            }
 9850|       |
 9851|  65.8k|            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);
 9852|  65.8k|            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9853|  65.8k|                                    hashValue, i);
 9854|  65.8k|            if (res < 0)
  ------------------
  |  Branch (9854:17): [True: 0, False: 65.8k]
  ------------------
 9855|      0|                continue;
 9856|       |
 9857|       |            /*
 9858|       |             * [ WFC: Unique Att Spec ]
 9859|       |             * No attribute name may appear more than once in the same
 9860|       |             * start-tag or empty-element tag.
 9861|       |             * As extended by the Namespace in XML REC.
 9862|       |             */
 9863|  65.8k|            if (res < INT_MAX) {
  ------------------
  |  Branch (9863:17): [True: 28, False: 65.8k]
  ------------------
 9864|     28|                if (aprefix == atts[res+1]) {
  ------------------
  |  Branch (9864:21): [True: 25, False: 3]
  ------------------
 9865|     25|                    xmlErrAttributeDup(ctxt, aprefix, attname);
 9866|     25|                } else {
 9867|      3|                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9868|      3|                             "Namespaced Attribute %s in '%s' redefined\n",
 9869|      3|                             attname, nsuri, NULL);
 9870|      3|                }
 9871|     28|            }
 9872|  65.8k|        }
 9873|  29.5k|    }
 9874|       |
 9875|       |    /*
 9876|       |     * Default attributes
 9877|       |     */
 9878|  43.1k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9878:9): [True: 9.20k, False: 33.8k]
  ------------------
 9879|  9.20k|        xmlDefAttrsPtr defaults;
 9880|       |
 9881|  9.20k|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9882|  9.20k|	if (defaults != NULL) {
  ------------------
  |  Branch (9882:6): [True: 1.11k, False: 8.09k]
  ------------------
 9883|   123k|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9883:18): [True: 122k, False: 1.11k]
  ------------------
 9884|   122k|                xmlDefAttr *attr = &defaults->attrs[i];
 9885|   122k|                const xmlChar *nsuri;
 9886|   122k|                unsigned hashValue, uriHashValue;
 9887|   122k|                int res;
 9888|       |
 9889|   122k|	        attname = attr->name.name;
 9890|   122k|		aprefix = attr->prefix.name;
 9891|       |
 9892|   122k|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL))
  ------------------
  |  Branch (9892:7): [True: 6, False: 122k]
  |  Branch (9892:39): [True: 6, False: 0]
  ------------------
 9893|      6|                    continue;
 9894|   122k|		if (aprefix == ctxt->str_xmlns)
  ------------------
  |  Branch (9894:7): [True: 21, False: 122k]
  ------------------
 9895|     21|                    continue;
 9896|       |
 9897|   122k|                if (aprefix == NULL) {
  ------------------
  |  Branch (9897:21): [True: 121k, False: 294]
  ------------------
 9898|   121k|                    nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|   121k|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9899|   121k|                    nsuri = NULL;
 9900|   121k|                    uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|   121k|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9901|   122k|                } if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9901:23): [True: 288, False: 121k]
  ------------------
 9902|    288|                    nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|    288|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9903|    288|                    nsuri = ctxt->str_xml_ns;
 9904|    288|                    uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|    288|#define URI_HASH_XML    0xF0451F02
  ------------------
 9905|   121k|                } else if (aprefix != NULL) {
  ------------------
  |  Branch (9905:28): [True: 6, False: 121k]
  ------------------
 9906|      6|                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);
 9907|      6|                    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9907:25): [True: 0, False: 6]
  ------------------
 9908|      0|                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9909|      0|                                 "Namespace prefix %s for %s on %s is not "
 9910|      0|                                 "defined\n",
 9911|      0|                                 aprefix, attname, localname);
 9912|      0|                        nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9913|      0|                        nsuri = NULL;
 9914|      0|                        uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9915|      6|                    } else {
 9916|      6|                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9917|      6|                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9918|      6|                    }
 9919|      6|                }
 9920|       |
 9921|       |                /*
 9922|       |                 * Check whether the attribute exists
 9923|       |                 */
 9924|   122k|                if (maxAtts > 1) {
  ------------------
  |  Branch (9924:21): [True: 122k, False: 153]
  ------------------
 9925|   122k|                    hashValue = xmlDictCombineHash(attr->name.hashValue,
 9926|   122k|                                                   uriHashValue);
 9927|   122k|                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9928|   122k|                                            hashValue, nbatts);
 9929|   122k|                    if (res < 0)
  ------------------
  |  Branch (9929:25): [True: 0, False: 122k]
  ------------------
 9930|      0|                        continue;
 9931|   122k|                    if (res < INT_MAX) {
  ------------------
  |  Branch (9931:25): [True: 33, False: 122k]
  ------------------
 9932|     33|                        if (aprefix == atts[res+1])
  ------------------
  |  Branch (9932:29): [True: 33, False: 0]
  ------------------
 9933|     33|                            continue;
 9934|      0|                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9935|      0|                                 "Namespaced Attribute %s in '%s' redefined\n",
 9936|      0|                                 attname, nsuri, NULL);
 9937|      0|                    }
 9938|   122k|                }
 9939|       |
 9940|   122k|                xmlParserEntityCheck(ctxt, attr->expandedSize);
 9941|       |
 9942|   122k|                if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9942:21): [True: 21, False: 122k]
  |  Branch (9942:39): [True: 15, False: 122k]
  ------------------
 9943|     36|                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9943:25): [True: 0, False: 36]
  ------------------
 9944|      0|                        localname = NULL;
 9945|      0|                        goto done;
 9946|      0|                    }
 9947|     36|                    maxatts = ctxt->maxatts;
 9948|     36|                    atts = ctxt->atts;
 9949|     36|                }
 9950|       |
 9951|   122k|                atts[nbatts++] = attname;
 9952|   122k|                atts[nbatts++] = aprefix;
 9953|   122k|                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9954|   122k|                atts[nbatts++] = attr->value.name;
 9955|   122k|                atts[nbatts++] = attr->valueEnd;
 9956|   122k|                if ((ctxt->standalone == 1) && (attr->external != 0)) {
  ------------------
  |  Branch (9956:21): [True: 0, False: 122k]
  |  Branch (9956:48): [True: 0, False: 0]
  ------------------
 9957|      0|                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9958|      0|                            "standalone: attribute %s on %s defaulted "
 9959|      0|                            "from external subset\n",
 9960|      0|                            attname, localname);
 9961|      0|                }
 9962|   122k|                nbdef++;
 9963|   122k|	    }
 9964|  1.11k|	}
 9965|  9.20k|    }
 9966|       |
 9967|       |    /*
 9968|       |     * Reconstruct attribute pointers
 9969|       |     */
 9970|   236k|    for (i = 0, j = 0; i < nbatts; i += 5, j++) {
  ------------------
  |  Branch (9970:24): [True: 193k, False: 43.1k]
  ------------------
 9971|       |        /* namespace URI */
 9972|   193k|        nsIndex = (ptrdiff_t) atts[i+2];
 9973|   193k|        if (nsIndex == INT_MAX)
  ------------------
  |  Branch (9973:13): [True: 187k, False: 6.46k]
  ------------------
 9974|   187k|            atts[i+2] = NULL;
 9975|  6.46k|        else if (nsIndex == INT_MAX - 1)
  ------------------
  |  Branch (9975:18): [True: 333, False: 6.13k]
  ------------------
 9976|    333|            atts[i+2] = ctxt->str_xml_ns;
 9977|  6.13k|        else
 9978|  6.13k|            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];
 9979|       |
 9980|   193k|        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {
  ------------------
  |  Branch (9980:13): [True: 71.5k, False: 122k]
  |  Branch (9980:29): [True: 71.1k, False: 344]
  ------------------
 9981|  71.1k|            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  /* value */
  ------------------
  |  | 2225|  71.1k|#define BASE_PTR ctxt->input->base
  ------------------
 9982|  71.1k|            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  /* valuend */
  ------------------
  |  | 2225|  71.1k|#define BASE_PTR ctxt->input->base
  ------------------
 9983|  71.1k|        }
 9984|   193k|    }
 9985|       |
 9986|  43.1k|    uri = xmlParserNsLookupUri(ctxt, &hprefix);
 9987|  43.1k|    if ((prefix != NULL) && (uri == NULL)) {
  ------------------
  |  Branch (9987:9): [True: 1.42k, False: 41.6k]
  |  Branch (9987:29): [True: 9, False: 1.41k]
  ------------------
 9988|      9|	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9989|      9|	         "Namespace prefix %s on %s is not defined\n",
 9990|      9|		 prefix, localname, NULL);
 9991|      9|    }
 9992|  43.1k|    *pref = prefix;
 9993|  43.1k|    *URI = uri;
 9994|       |
 9995|       |    /*
 9996|       |     * SAX callback
 9997|       |     */
 9998|  43.1k|    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&
  ------------------
  |  Branch (9998:9): [True: 43.1k, False: 0]
  |  Branch (9998:32): [True: 43.1k, False: 0]
  ------------------
 9999|  43.1k|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (9999:2): [True: 42.9k, False: 118]
  ------------------
10000|  42.9k|	if (nbNs > 0)
  ------------------
  |  Branch (10000:6): [True: 231, False: 42.7k]
  ------------------
10001|    231|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10002|    231|                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),
10003|    231|			  nbatts / 5, nbdef, atts);
10004|  42.7k|	else
10005|  42.7k|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10006|  42.7k|                          0, NULL, nbatts / 5, nbdef, atts);
10007|  42.9k|    }
10008|       |
10009|  43.1k|done:
10010|       |    /*
10011|       |     * Free allocated attribute values
10012|       |     */
10013|  43.1k|    if (attval != 0) {
  ------------------
  |  Branch (10013:9): [True: 329, False: 42.7k]
  ------------------
10014|    790|	for (i = 0, j = 0; j < nratts; i += 5, j++)
  ------------------
  |  Branch (10014:21): [True: 461, False: 329]
  ------------------
10015|    461|	    if (ctxt->attallocs[j] & 0x80000000)
  ------------------
  |  Branch (10015:10): [True: 344, False: 117]
  ------------------
10016|    344|	        xmlFree((xmlChar *) atts[i+3]);
10017|    329|    }
10018|       |
10019|  43.1k|    *nbNsPtr = nbNs;
10020|  43.1k|    return(localname);
10021|  43.1k|}
parser.c:xmlParserNsStartElement:
 1462|  43.1k|xmlParserNsStartElement(xmlParserNsData *nsdb) {
 1463|  43.1k|    if (nsdb->elementId == UINT_MAX)
  ------------------
  |  Branch (1463:9): [True: 0, False: 43.1k]
  ------------------
 1464|      0|        return(-1);
 1465|  43.1k|    nsdb->elementId++;
 1466|       |
 1467|  43.1k|    return(0);
 1468|  43.1k|}
parser.c:xmlParseQNameHashed:
 8943|   114k|xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {
 8944|   114k|    xmlHashedString l, p;
 8945|   114k|    int start;
 8946|       |
 8947|   114k|    l.name = NULL;
 8948|   114k|    p.name = NULL;
 8949|       |
 8950|   114k|    GROW;
  ------------------
  |  | 2270|   114k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   114k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 52.1k, False: 62.8k]
  |  |  ------------------
  |  | 2271|   114k|	xmlParserGrow(ctxt);
  ------------------
 8951|   114k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8951:9): [True: 0, False: 114k]
  ------------------
 8952|      0|        return(l);
 8953|   114k|    start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|   114k|#define CUR_PTR ctxt->input->cur
  ------------------
                  start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|   114k|#define BASE_PTR ctxt->input->base
  ------------------
 8954|       |
 8955|   114k|    l = xmlParseNCName(ctxt);
 8956|   114k|    if ((l.name != NULL) && (CUR == ':')) {
  ------------------
  |  | 2222|   114k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8956:9): [True: 114k, False: 32]
  |  Branch (8956:29): [True: 7.82k, False: 107k]
  ------------------
 8957|  7.82k|        NEXT;
  ------------------
  |  | 2275|  7.82k|#define NEXT xmlNextChar(ctxt)
  ------------------
 8958|  7.82k|	p = l;
 8959|  7.82k|	l = xmlParseNCName(ctxt);
 8960|  7.82k|    }
 8961|   114k|    if ((l.name == NULL) || (CUR == ':')) {
  ------------------
  |  | 2222|   114k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8961:9): [True: 38, False: 114k]
  |  Branch (8961:29): [True: 9, False: 114k]
  ------------------
 8962|     47|        xmlChar *tmp;
 8963|       |
 8964|     47|        l.name = NULL;
 8965|     47|        p.name = NULL;
 8966|     47|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8966:13): [True: 0, False: 47]
  ------------------
 8967|      0|            return(l);
 8968|     47|        if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2222|     47|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2224|     32|#define CUR_PTR ctxt->input->cur
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2225|     32|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (8968:13): [True: 32, False: 15]
  |  Branch (8968:29): [True: 26, False: 6]
  ------------------
 8969|     26|            return(l);
 8970|     21|        tmp = xmlParseNmtoken(ctxt);
 8971|     21|        if (tmp != NULL)
  ------------------
  |  Branch (8971:13): [True: 15, False: 6]
  ------------------
 8972|     15|            xmlFree(tmp);
 8973|     21|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8973:13): [True: 0, False: 21]
  ------------------
 8974|      0|            return(l);
 8975|     21|        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,
  ------------------
  |  | 2225|     21|#define BASE_PTR ctxt->input->base
  ------------------
 8976|     21|                                CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2224|     21|#define CUR_PTR ctxt->input->cur
  ------------------
                                              CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2225|     21|#define BASE_PTR ctxt->input->base
  ------------------
 8977|     21|        xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8978|     21|                 "Failed to parse QName '%s'\n", l.name, NULL, NULL);
 8979|     21|    }
 8980|       |
 8981|   114k|    *prefix = p;
 8982|   114k|    return(l);
 8983|   114k|}
parser.c:xmlParseNCName:
 3624|   122k|xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3625|   122k|    const xmlChar *in, *e;
 3626|   122k|    xmlHashedString ret;
 3627|   122k|    size_t count = 0;
 3628|   122k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3628:24): [True: 0, False: 122k]
  ------------------
 3629|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3630|   122k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|   245k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3631|       |
 3632|   122k|    ret.name = NULL;
 3633|       |
 3634|       |    /*
 3635|       |     * Accelerator for simple ASCII names
 3636|       |     */
 3637|   122k|    in = ctxt->input->cur;
 3638|   122k|    e = ctxt->input->end;
 3639|   122k|    if ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3639:11): [True: 121k, False: 1.42k]
  |  Branch (3639:28): [True: 121k, False: 11]
  ------------------
 3640|   122k|	 ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3640:4): [True: 1.39k, False: 38]
  |  Branch (3640:21): [True: 1.38k, False: 11]
  ------------------
 3641|   122k|	 (*in == '_')) && (in < e)) {
  ------------------
  |  Branch (3641:3): [True: 0, False: 49]
  |  Branch (3641:20): [True: 122k, False: 0]
  ------------------
 3642|   122k|	in++;
 3643|   446k|	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3643:11): [True: 165k, False: 280k]
  |  Branch (3643:28): [True: 165k, False: 69]
  ------------------
 3644|   446k|	        ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3644:11): [True: 1.43k, False: 279k]
  |  Branch (3644:28): [True: 1.25k, False: 180]
  ------------------
 3645|   446k|	        ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3645:11): [True: 243k, False: 36.3k]
  |  Branch (3645:28): [True: 156k, False: 86.6k]
  ------------------
 3646|   446k|	        (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3646:10): [True: 111, False: 122k]
  |  Branch (3646:26): [True: 102, False: 122k]
  ------------------
 3647|   446k|	        (*in == '.')) && (in < e))
  ------------------
  |  Branch (3647:10): [True: 0, False: 122k]
  |  Branch (3647:27): [True: 323k, False: 0]
  ------------------
 3648|   323k|	    in++;
 3649|   122k|	if (in >= e)
  ------------------
  |  Branch (3649:6): [True: 10, False: 122k]
  ------------------
 3650|     10|	    goto complex;
 3651|   122k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3651:6): [True: 122k, False: 0]
  |  Branch (3651:19): [True: 122k, False: 69]
  ------------------
 3652|   122k|	    count = in - ctxt->input->cur;
 3653|   122k|            if (count > maxLength) {
  ------------------
  |  Branch (3653:17): [True: 0, False: 122k]
  ------------------
 3654|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3655|      0|                return(ret);
 3656|      0|            }
 3657|   122k|	    ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);
 3658|   122k|	    ctxt->input->cur = in;
 3659|   122k|	    ctxt->input->col += count;
 3660|   122k|	    if (ret.name == NULL) {
  ------------------
  |  Branch (3660:10): [True: 0, False: 122k]
  ------------------
 3661|      0|	        xmlErrMemory(ctxt, NULL);
 3662|      0|	    }
 3663|   122k|	    return(ret);
 3664|   122k|	}
 3665|   122k|    }
 3666|    128|complex:
 3667|    128|    return(xmlParseNCNameComplex(ctxt));
 3668|   122k|}
parser.c:xmlParseNCNameComplex:
 3569|    128|xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3570|    128|    xmlHashedString ret;
 3571|    128|    int len = 0, l;
 3572|    128|    int c;
 3573|    128|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3573:21): [True: 0, False: 128]
  ------------------
 3574|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3575|    128|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|    128|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3576|    128|    size_t startPosition = 0;
 3577|       |
 3578|    128|    ret.name = NULL;
 3579|    128|    ret.hashValue = 0;
 3580|       |
 3581|       |    /*
 3582|       |     * Handler for more complex cases
 3583|       |     */
 3584|    128|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|    128|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|    128|#define BASE_PTR ctxt->input->base
  ------------------
 3585|    128|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    128|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3586|    128|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3586:9): [True: 3, False: 125]
  |  Branch (3586:23): [True: 0, False: 125]
  |  Branch (3586:37): [True: 0, False: 125]
  ------------------
 3587|    128|	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
  ------------------
  |  Branch (3587:3): [True: 29, False: 96]
  |  Branch (3587:35): [True: 6, False: 90]
  ------------------
 3588|     38|	return(ret);
 3589|     38|    }
 3590|       |
 3591|  84.2k|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3591:12): [True: 84.2k, False: 7]
  |  Branch (3591:26): [True: 84.1k, False: 70]
  |  Branch (3591:40): [True: 84.1k, False: 1]
  ------------------
 3592|  84.2k|	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  ------------------
  |  Branch (3592:6): [True: 84.1k, False: 10]
  |  Branch (3592:32): [True: 84.1k, False: 2]
  ------------------
 3593|  84.1k|        if (len <= INT_MAX - l)
  ------------------
  |  Branch (3593:13): [True: 84.1k, False: 0]
  ------------------
 3594|  84.1k|	    len += l;
 3595|  84.1k|	NEXTL(l);
  ------------------
  |  | 2284|  84.1k|#define NEXTL(l) do {							\
  |  | 2285|  84.1k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 84.1k]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  84.1k|    } else ctxt->input->col++;						\
  |  | 2288|  84.1k|    ctxt->input->cur += l;				\
  |  | 2289|  84.1k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3596|  84.1k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  84.1k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3597|  84.1k|    }
 3598|     90|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3598:9): [True: 0, False: 90]
  ------------------
 3599|      0|        return(ret);
 3600|     90|    if (len > maxLength) {
  ------------------
  |  Branch (3600:9): [True: 0, False: 90]
  ------------------
 3601|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3602|      0|        return(ret);
 3603|      0|    }
 3604|     90|    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);
  ------------------
  |  | 2225|     90|#define BASE_PTR ctxt->input->base
  ------------------
 3605|     90|    return(ret);
 3606|     90|}
parser.c:xmlParseAttribute2:
 9282|  71.8k|{
 9283|  71.8k|    xmlHashedString hname;
 9284|  71.8k|    const xmlChar *prefix, *name;
 9285|  71.8k|    xmlChar *val, *internal_val = NULL;
 9286|  71.8k|    int normalize = 0;
 9287|       |
 9288|  71.8k|    *value = NULL;
 9289|  71.8k|    GROW;
  ------------------
  |  | 2270|  71.8k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  71.8k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 30.9k, False: 40.8k]
  |  |  ------------------
  |  | 2271|  71.8k|	xmlParserGrow(ctxt);
  ------------------
 9290|  71.8k|    hname = xmlParseQNameHashed(ctxt, hprefix);
 9291|  71.8k|    if (hname.name == NULL) {
  ------------------
  |  Branch (9291:9): [True: 0, False: 71.8k]
  ------------------
 9292|      0|        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9293|      0|                       "error parsing attribute name\n");
 9294|      0|        return(hname);
 9295|      0|    }
 9296|  71.8k|    name = hname.name;
 9297|  71.8k|    if (hprefix->name != NULL)
  ------------------
  |  Branch (9297:9): [True: 6.38k, False: 65.4k]
  ------------------
 9298|  6.38k|        prefix = hprefix->name;
 9299|  65.4k|    else
 9300|  65.4k|        prefix = NULL;
 9301|       |
 9302|       |    /*
 9303|       |     * get the type if needed
 9304|       |     */
 9305|  71.8k|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (9305:9): [True: 4.37k, False: 67.4k]
  ------------------
 9306|  4.37k|        int type;
 9307|       |
 9308|  4.37k|        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,
 9309|  4.37k|                                                 pref, elem,
 9310|  4.37k|                                                 prefix, name);
 9311|  4.37k|        if (type != 0)
  ------------------
  |  Branch (9311:13): [True: 3.20k, False: 1.17k]
  ------------------
 9312|  3.20k|            normalize = 1;
 9313|  4.37k|    }
 9314|       |
 9315|       |    /*
 9316|       |     * read the value
 9317|       |     */
 9318|  71.8k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  71.8k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9319|  71.8k|    if (RAW == '=') {
  ------------------
  |  | 2221|  71.8k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9319:9): [True: 71.8k, False: 3]
  ------------------
 9320|  71.8k|        NEXT;
  ------------------
  |  | 2275|  71.8k|#define NEXT xmlNextChar(ctxt)
  ------------------
 9321|  71.8k|        SKIP_BLANKS;
  ------------------
  |  | 2273|  71.8k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9322|  71.8k|        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9323|  71.8k|        if (val == NULL) {
  ------------------
  |  Branch (9323:13): [True: 12, False: 71.8k]
  ------------------
 9324|     12|            hname.name = NULL;
 9325|     12|            return(hname);
 9326|     12|        }
 9327|  71.8k|	if (normalize) {
  ------------------
  |  Branch (9327:6): [True: 3.20k, False: 68.6k]
  ------------------
 9328|       |	    /*
 9329|       |	     * Sometimes a second normalisation pass for spaces is needed
 9330|       |	     * but that only happens if charrefs or entities references
 9331|       |	     * have been used in the attribute value, i.e. the attribute
 9332|       |	     * value have been extracted in an allocated string already.
 9333|       |	     */
 9334|  3.20k|	    if (*alloc) {
  ------------------
  |  Branch (9334:10): [True: 60, False: 3.14k]
  ------------------
 9335|     60|	        const xmlChar *val2;
 9336|       |
 9337|     60|	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9338|     60|		if ((val2 != NULL) && (val2 != val)) {
  ------------------
  |  Branch (9338:7): [True: 15, False: 45]
  |  Branch (9338:25): [True: 15, False: 0]
  ------------------
 9339|     15|		    xmlFree(val);
 9340|     15|		    val = (xmlChar *) val2;
 9341|     15|		}
 9342|     60|	    }
 9343|  3.20k|	}
 9344|  71.8k|        ctxt->instate = XML_PARSER_CONTENT;
 9345|  71.8k|    } else {
 9346|      3|        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9347|      3|                          "Specification mandates value for attribute %s\n",
 9348|      3|                          name);
 9349|      3|        return(hname);
 9350|      3|    }
 9351|       |
 9352|  71.8k|    if (prefix == ctxt->str_xml) {
  ------------------
  |  Branch (9352:9): [True: 45, False: 71.7k]
  ------------------
 9353|       |        /*
 9354|       |         * Check that xml:lang conforms to the specification
 9355|       |         * No more registered as an error, just generate a warning now
 9356|       |         * since this was deprecated in XML second edition
 9357|       |         */
 9358|     45|        if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:13): [True: 0, False: 45]
  |  Branch (9358:33): [True: 0, False: 0]
  ------------------
 9359|      0|            internal_val = xmlStrndup(val, *len);
 9360|      0|            if (!xmlCheckLanguageID(internal_val)) {
  ------------------
  |  Branch (9360:17): [True: 0, False: 0]
  ------------------
 9361|      0|                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9362|      0|                              "Malformed value for xml:lang : %s\n",
 9363|      0|                              internal_val, NULL);
 9364|      0|            }
 9365|      0|        }
 9366|       |
 9367|       |        /*
 9368|       |         * Check that xml:space conforms to the specification
 9369|       |         */
 9370|     45|        if (xmlStrEqual(name, BAD_CAST "space")) {
  ------------------
  |  |   35|     45|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9370:13): [True: 3, False: 42]
  ------------------
 9371|      3|            internal_val = xmlStrndup(val, *len);
 9372|      3|            if (xmlStrEqual(internal_val, BAD_CAST "default"))
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9372:17): [True: 0, False: 3]
  ------------------
 9373|      0|                *(ctxt->space) = 0;
 9374|      3|            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9374:22): [True: 3, False: 0]
  ------------------
 9375|      3|                *(ctxt->space) = 1;
 9376|      0|            else {
 9377|      0|                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9378|      0|                              "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 9379|      0|                              internal_val, NULL);
 9380|      0|            }
 9381|      3|        }
 9382|     45|        if (internal_val) {
  ------------------
  |  Branch (9382:13): [True: 3, False: 42]
  ------------------
 9383|      3|            xmlFree(internal_val);
 9384|      3|        }
 9385|     45|    }
 9386|       |
 9387|  71.8k|    *value = val;
 9388|  71.8k|    return (hname);
 9389|  71.8k|}
parser.c:xmlAttrNormalizeSpace2:
  955|     60|{
  956|     60|    int i;
  957|     60|    int remove_head = 0;
  958|     60|    int need_realloc = 0;
  959|     60|    const xmlChar *cur;
  960|       |
  961|     60|    if ((ctxt == NULL) || (src == NULL) || (len == NULL))
  ------------------
  |  Branch (961:9): [True: 0, False: 60]
  |  Branch (961:27): [True: 0, False: 60]
  |  Branch (961:44): [True: 0, False: 60]
  ------------------
  962|      0|        return(NULL);
  963|     60|    i = *len;
  964|     60|    if (i <= 0)
  ------------------
  |  Branch (964:9): [True: 0, False: 60]
  ------------------
  965|      0|        return(NULL);
  966|       |
  967|     60|    cur = src;
  968|     72|    while (*cur == 0x20) {
  ------------------
  |  Branch (968:12): [True: 12, False: 60]
  ------------------
  969|     12|        cur++;
  970|     12|	remove_head++;
  971|     12|    }
  972|    411|    while (*cur != 0) {
  ------------------
  |  Branch (972:12): [True: 366, False: 45]
  ------------------
  973|    366|	if (*cur == 0x20) {
  ------------------
  |  Branch (973:6): [True: 36, False: 330]
  ------------------
  974|     36|	    cur++;
  975|     36|	    if ((*cur == 0x20) || (*cur == 0)) {
  ------------------
  |  Branch (975:10): [True: 15, False: 21]
  |  Branch (975:28): [True: 0, False: 21]
  ------------------
  976|     15|	        need_realloc = 1;
  977|     15|		break;
  978|     15|	    }
  979|     36|	} else
  980|    330|	    cur++;
  981|    366|    }
  982|     60|    if (need_realloc) {
  ------------------
  |  Branch (982:9): [True: 15, False: 45]
  ------------------
  983|     15|        xmlChar *ret;
  984|       |
  985|     15|	ret = xmlStrndup(src + remove_head, i - remove_head + 1);
  986|     15|	if (ret == NULL) {
  ------------------
  |  Branch (986:6): [True: 0, False: 15]
  ------------------
  987|      0|	    xmlErrMemory(ctxt, NULL);
  988|      0|	    return(NULL);
  989|      0|	}
  990|     15|	xmlAttrNormalizeSpace(ret, ret);
  991|     15|	*len = strlen((const char *)ret);
  992|     15|        return(ret);
  993|     45|    } else if (remove_head) {
  ------------------
  |  Branch (993:16): [True: 0, False: 45]
  ------------------
  994|      0|        *len -= remove_head;
  995|      0|        memmove(src, src + remove_head, 1 + *len);
  996|      0|	return(src);
  997|      0|    }
  998|     45|    return(NULL);
  999|     60|}
parser.c:xmlNsWarn:
  530|      3|{
  531|      3|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (531:9): [True: 3, False: 0]
  |  Branch (531:27): [True: 0, False: 3]
  ------------------
  532|      3|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (532:9): [True: 0, False: 0]
  ------------------
  533|      0|	return;
  534|      3|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  535|      3|                    XML_ERR_WARNING, NULL, 0, (const char *) info1,
  536|      3|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  537|      3|                    info1, info2, info3);
  538|      3|}
parser.c:xmlCtxtGrowAttrs:
 1853|    414|xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1854|    414|    const xmlChar **atts;
 1855|    414|    unsigned *attallocs;
 1856|    414|    int maxatts;
 1857|       |
 1858|    414|    if (nr + 5 > ctxt->maxatts) {
  ------------------
  |  Branch (1858:9): [True: 414, False: 0]
  ------------------
 1859|    414|	maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;
  ------------------
  |  Branch (1859:12): [True: 387, False: 27]
  ------------------
 1860|    414|	atts = (const xmlChar **) xmlMalloc(
 1861|    414|				     maxatts * sizeof(const xmlChar *));
 1862|    414|	if (atts == NULL) goto mem_error;
  ------------------
  |  Branch (1862:6): [True: 0, False: 414]
  ------------------
 1863|    414|	attallocs = xmlRealloc(ctxt->attallocs,
 1864|    414|                               (maxatts / 5) * sizeof(attallocs[0]));
 1865|    414|	if (attallocs == NULL) {
  ------------------
  |  Branch (1865:6): [True: 0, False: 414]
  ------------------
 1866|      0|            xmlFree(atts);
 1867|      0|            goto mem_error;
 1868|      0|        }
 1869|    414|        if (ctxt->maxatts > 0)
  ------------------
  |  Branch (1869:13): [True: 27, False: 387]
  ------------------
 1870|     27|            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));
 1871|    414|        xmlFree(ctxt->atts);
 1872|    414|	ctxt->atts = atts;
 1873|    414|	ctxt->attallocs = attallocs;
 1874|    414|	ctxt->maxatts = maxatts;
 1875|    414|    }
 1876|    414|    return(ctxt->maxatts);
 1877|      0|mem_error:
 1878|      0|    xmlErrMemory(ctxt, NULL);
 1879|      0|    return(-1);
 1880|    414|}
parser.c:xmlAttrHashInsert:
 9407|   187k|                  const xmlChar *uri, unsigned hashValue, int aindex) {
 9408|   187k|    xmlAttrHashBucket *table = ctxt->attrHash;
 9409|   187k|    xmlAttrHashBucket *bucket;
 9410|   187k|    unsigned hindex;
 9411|       |
 9412|   187k|    hindex = hashValue & (size - 1);
 9413|   187k|    bucket = &table[hindex];
 9414|       |
 9415|   214k|    while (bucket->index >= 0) {
  ------------------
  |  Branch (9415:12): [True: 27.0k, False: 187k]
  ------------------
 9416|  27.0k|        const xmlChar **atts = &ctxt->atts[bucket->index];
 9417|       |
 9418|  27.0k|        if (name == atts[0]) {
  ------------------
  |  Branch (9418:13): [True: 64, False: 27.0k]
  ------------------
 9419|     64|            int nsIndex = (int) (ptrdiff_t) atts[2];
 9420|       |
 9421|     64|            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :
  ------------------
  |  |   77|     64|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9421:17): [True: 47, False: 17]
  |  Branch (9421:17): [True: 61, False: 3]
  ------------------
 9422|     64|                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml) :
  ------------------
  |  |   78|     17|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9422:17): [True: 0, False: 17]
  ------------------
 9423|     17|                (uri == ctxt->nsTab[nsIndex * 2 + 1]))
 9424|     61|                return(bucket->index);
 9425|     64|        }
 9426|       |
 9427|  27.0k|        hindex++;
 9428|  27.0k|        bucket++;
 9429|  27.0k|        if (hindex >= size) {
  ------------------
  |  Branch (9429:13): [True: 300, False: 26.7k]
  ------------------
 9430|    300|            hindex = 0;
 9431|    300|            bucket = table;
 9432|    300|        }
 9433|  27.0k|    }
 9434|       |
 9435|   187k|    bucket->index = aindex;
 9436|       |
 9437|   187k|    return(INT_MAX);
 9438|   187k|}
parser.c:xmlParserNsLookupUri:
 1532|  43.4k|xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {
 1533|  43.4k|    const xmlChar *ret;
 1534|  43.4k|    int nsIndex;
 1535|       |
 1536|  43.4k|    if (prefix->name == ctxt->str_xml)
  ------------------
  |  Branch (1536:9): [True: 3, False: 43.4k]
  ------------------
 1537|      3|        return(ctxt->str_xml_ns);
 1538|       |
 1539|  43.4k|    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);
 1540|  43.4k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1540:9): [True: 41.6k, False: 1.74k]
  ------------------
 1541|  41.6k|        return(NULL);
 1542|       |
 1543|  1.74k|    ret = ctxt->nsTab[nsIndex * 2 + 1];
 1544|  1.74k|    if (ret[0] == 0)
  ------------------
  |  Branch (1544:9): [True: 0, False: 1.74k]
  ------------------
 1545|      0|        ret = NULL;
 1546|  1.74k|    return(ret);
 1547|  43.4k|}
parser.c:nameNsPush:
 2024|  22.7k|{
 2025|  22.7k|    xmlStartTag *tag;
 2026|       |
 2027|  22.7k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (2027:9): [True: 3, False: 22.7k]
  ------------------
 2028|      3|        const xmlChar * *tmp;
 2029|      3|        xmlStartTag *tmp2;
 2030|      3|        ctxt->nameMax *= 2;
 2031|      3|        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,
 2032|      3|                                    ctxt->nameMax *
 2033|      3|                                    sizeof(ctxt->nameTab[0]));
 2034|      3|        if (tmp == NULL) {
  ------------------
  |  Branch (2034:13): [True: 0, False: 3]
  ------------------
 2035|      0|	    ctxt->nameMax /= 2;
 2036|      0|	    goto mem_error;
 2037|      0|        }
 2038|      3|	ctxt->nameTab = tmp;
 2039|      3|        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,
 2040|      3|                                    ctxt->nameMax *
 2041|      3|                                    sizeof(ctxt->pushTab[0]));
 2042|      3|        if (tmp2 == NULL) {
  ------------------
  |  Branch (2042:13): [True: 0, False: 3]
  ------------------
 2043|      0|	    ctxt->nameMax /= 2;
 2044|      0|	    goto mem_error;
 2045|      0|        }
 2046|      3|	ctxt->pushTab = tmp2;
 2047|  22.7k|    } else if (ctxt->pushTab == NULL) {
  ------------------
  |  Branch (2047:16): [True: 791, False: 21.9k]
  ------------------
 2048|    791|        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *
 2049|    791|                                            sizeof(ctxt->pushTab[0]));
 2050|    791|        if (ctxt->pushTab == NULL)
  ------------------
  |  Branch (2050:13): [True: 0, False: 791]
  ------------------
 2051|      0|            goto mem_error;
 2052|    791|    }
 2053|  22.7k|    ctxt->nameTab[ctxt->nameNr] = value;
 2054|  22.7k|    ctxt->name = value;
 2055|  22.7k|    tag = &ctxt->pushTab[ctxt->nameNr];
 2056|  22.7k|    tag->prefix = prefix;
 2057|  22.7k|    tag->URI = URI;
 2058|  22.7k|    tag->line = line;
 2059|  22.7k|    tag->nsNr = nsNr;
 2060|  22.7k|    return (ctxt->nameNr++);
 2061|      0|mem_error:
 2062|      0|    xmlErrMemory(ctxt, NULL);
 2063|      0|    return (-1);
 2064|  22.7k|}
parser.c:xmlParseElementEnd:
10475|  4.18k|xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10476|  4.18k|    xmlNodePtr cur = ctxt->node;
10477|       |
10478|  4.18k|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (10478:9): [True: 0, False: 4.18k]
  ------------------
10479|      0|        if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10479:13): [True: 0, False: 0]
  |  Branch (10479:29): [True: 0, False: 0]
  ------------------
10480|      0|            SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10481|      0|        return;
10482|      0|    }
10483|       |
10484|       |    /*
10485|       |     * parse the end of tag: '</' should be here.
10486|       |     */
10487|  4.18k|    if (ctxt->sax2) {
  ------------------
  |  Branch (10487:9): [True: 4.18k, False: 0]
  ------------------
10488|  4.18k|	xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
10489|  4.18k|	namePop(ctxt);
10490|  4.18k|    }
10491|      0|#ifdef LIBXML_SAX1_ENABLED
10492|      0|    else
10493|      0|	xmlParseEndTag1(ctxt, 0);
10494|  4.18k|#endif /* LIBXML_SAX1_ENABLED */
10495|       |
10496|       |    /*
10497|       |     * Capture end position
10498|       |     */
10499|  4.18k|    if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10499:9): [True: 4.18k, False: 0]
  |  Branch (10499:24): [True: 0, False: 4.18k]
  ------------------
10500|      0|        xmlParserNodeInfoPtr node_info;
10501|       |
10502|      0|        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);
10503|      0|        if (node_info != NULL) {
  ------------------
  |  Branch (10503:13): [True: 0, False: 0]
  ------------------
10504|      0|            node_info->end_pos = ctxt->input->consumed +
10505|      0|                                 (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10506|      0|            node_info->end_line = ctxt->input->line;
10507|      0|        }
10508|      0|    }
10509|  4.18k|}
parser.c:xmlParseEndTag2:
10039|  12.4k|xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlStartTag *tag) {
10040|  12.4k|    const xmlChar *name;
10041|       |
10042|  12.4k|    GROW;
  ------------------
  |  | 2270|  12.4k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  12.4k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 6.95k, False: 5.48k]
  |  |  ------------------
  |  | 2271|  12.4k|	xmlParserGrow(ctxt);
  ------------------
10043|  12.4k|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|  12.4k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|  12.4k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10043:9): [True: 0, False: 12.4k]
  |  Branch (10043:25): [True: 0, False: 12.4k]
  ------------------
10044|      0|	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
10045|      0|	return;
10046|      0|    }
10047|  12.4k|    SKIP(2);
  ------------------
  |  | 2245|  12.4k|#define SKIP(val) do {							\
  |  | 2246|  12.4k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  12.4k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12.4k]
  |  |  ------------------
  |  | 2248|  12.4k|        xmlParserGrow(ctxt);						\
  |  | 2249|  12.4k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10048|       |
10049|  12.4k|    if (tag->prefix == NULL)
  ------------------
  |  Branch (10049:9): [True: 11.3k, False: 1.07k]
  ------------------
10050|  11.3k|        name = xmlParseNameAndCompare(ctxt, ctxt->name);
10051|  1.07k|    else
10052|  1.07k|        name = xmlParseQNameAndCompare(ctxt, ctxt->name, tag->prefix);
10053|       |
10054|       |    /*
10055|       |     * We should definitely be at the ending "S? '>'" part
10056|       |     */
10057|  12.4k|    GROW;
  ------------------
  |  | 2270|  12.4k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  12.4k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 7.01k, False: 5.42k]
  |  |  ------------------
  |  | 2271|  12.4k|	xmlParserGrow(ctxt);
  ------------------
10058|  12.4k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10058:9): [True: 0, False: 12.4k]
  ------------------
10059|      0|        return;
10060|  12.4k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  12.4k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10061|  12.4k|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|  12.4k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  12.4k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 12.4k, False: 3]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 12.4k]
  |  |  |  |  ------------------
  |  |  |  |  109|  12.4k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 12.4k]
  |  |  |  |  ------------------
  |  |  |  |  110|  12.4k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 12.4k, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|  12.4k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10061:33): [True: 0, False: 12.4k]
  ------------------
10062|      3|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
10063|      3|    } else
10064|  12.4k|	NEXT1;
  ------------------
  |  | 2277|  12.4k|#define NEXT1 {								\
  |  | 2278|  12.4k|	ctxt->input->col++;						\
  |  | 2279|  12.4k|	ctxt->input->cur++;						\
  |  | 2280|  12.4k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 55, False: 12.3k]
  |  |  ------------------
  |  | 2281|  12.4k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  12.4k|    }
  ------------------
10065|       |
10066|       |    /*
10067|       |     * [ WFC: Element Type Match ]
10068|       |     * The Name in an element's end-tag must match the element type in the
10069|       |     * start-tag.
10070|       |     *
10071|       |     */
10072|  12.4k|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (10072:9): [True: 5, False: 12.4k]
  ------------------
10073|      5|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10073:13): [True: 0, False: 5]
  ------------------
10074|      5|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
10075|      5|		     "Opening and ending tag mismatch: %s line %d and %s\n",
10076|      5|		                ctxt->name, tag->line, name);
10077|      5|    }
10078|       |
10079|       |    /*
10080|       |     * SAX: End of Tag
10081|       |     */
10082|  12.4k|    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10082:9): [True: 12.4k, False: 0]
  |  Branch (10082:32): [True: 12.4k, False: 0]
  ------------------
10083|  12.4k|	(!ctxt->disableSAX))
  ------------------
  |  Branch (10083:2): [True: 12.3k, False: 44]
  ------------------
10084|  12.3k|	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,
10085|  12.3k|                                tag->URI);
10086|       |
10087|  12.4k|    spacePop(ctxt);
10088|  12.4k|    if (tag->nsNr != 0)
  ------------------
  |  Branch (10088:9): [True: 185, False: 12.2k]
  ------------------
10089|    185|	xmlParserNsPop(ctxt, tag->nsNr);
10090|  12.4k|}
parser.c:xmlParseQNameAndCompare:
 9025|  1.07k|                        xmlChar const *prefix) {
 9026|  1.07k|    const xmlChar *cmp;
 9027|  1.07k|    const xmlChar *in;
 9028|  1.07k|    const xmlChar *ret;
 9029|  1.07k|    const xmlChar *prefix2;
 9030|       |
 9031|  1.07k|    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
  ------------------
  |  Branch (9031:9): [True: 0, False: 1.07k]
  ------------------
 9032|       |
 9033|  1.07k|    GROW;
  ------------------
  |  | 2270|  1.07k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.07k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 760, False: 314]
  |  |  ------------------
  |  | 2271|  1.07k|	xmlParserGrow(ctxt);
  ------------------
 9034|  1.07k|    in = ctxt->input->cur;
 9035|       |
 9036|  1.07k|    cmp = prefix;
 9037|  3.32k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9037:12): [True: 3.32k, False: 3]
  |  Branch (9037:24): [True: 2.25k, False: 1.07k]
  ------------------
 9038|  2.25k|	++in;
 9039|  2.25k|	++cmp;
 9040|  2.25k|    }
 9041|  1.07k|    if ((*cmp == 0) && (*in == ':')) {
  ------------------
  |  Branch (9041:9): [True: 1.07k, False: 3]
  |  Branch (9041:24): [True: 1.07k, False: 0]
  ------------------
 9042|  1.07k|        in++;
 9043|  1.07k|	cmp = name;
 9044|  8.79k|	while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9044:9): [True: 8.79k, False: 0]
  |  Branch (9044:21): [True: 7.72k, False: 1.07k]
  ------------------
 9045|  7.72k|	    ++in;
 9046|  7.72k|	    ++cmp;
 9047|  7.72k|	}
 9048|  1.07k|	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9048:6): [True: 1.07k, False: 0]
  |  Branch (9048:20): [True: 1.07k, False: 0]
  ------------------
 9049|       |	    /* success */
 9050|  1.07k|            ctxt->input->col += in - ctxt->input->cur;
 9051|  1.07k|	    ctxt->input->cur = in;
 9052|  1.07k|	    return((const xmlChar*) 1);
 9053|  1.07k|	}
 9054|  1.07k|    }
 9055|       |    /*
 9056|       |     * all strings coms from the dictionary, equality can be done directly
 9057|       |     */
 9058|      3|    ret = xmlParseQName (ctxt, &prefix2);
 9059|      3|    if (ret == NULL)
  ------------------
  |  Branch (9059:9): [True: 0, False: 3]
  ------------------
 9060|      0|        return(NULL);
 9061|      3|    if ((ret == name) && (prefix == prefix2))
  ------------------
  |  Branch (9061:9): [True: 3, False: 0]
  |  Branch (9061:26): [True: 0, False: 3]
  ------------------
 9062|      0|	return((const xmlChar*) 1);
 9063|      3|    return ret;
 9064|      3|}
parser.c:xmlParseQName:
 9000|      3|xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 9001|      3|    xmlHashedString n, p;
 9002|       |
 9003|      3|    n = xmlParseQNameHashed(ctxt, &p);
 9004|      3|    if (n.name == NULL)
  ------------------
  |  Branch (9004:9): [True: 0, False: 3]
  ------------------
 9005|      0|        return(NULL);
 9006|      3|    *prefix = p.name;
 9007|      3|    return(n.name);
 9008|      3|}
parser.c:xmlParseInternalSubset:
 8533|    408|xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8534|       |    /*
 8535|       |     * Is there any DTD definition ?
 8536|       |     */
 8537|    408|    if (RAW == '[') {
  ------------------
  |  | 2221|    408|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8537:9): [True: 408, False: 0]
  ------------------
 8538|    408|        int baseInputNr = ctxt->inputNr;
 8539|    408|        ctxt->instate = XML_PARSER_DTD;
 8540|    408|        NEXT;
  ------------------
  |  | 2275|    408|#define NEXT xmlNextChar(ctxt)
  ------------------
 8541|       |	/*
 8542|       |	 * Parse the succession of Markup declarations and
 8543|       |	 * PEReferences.
 8544|       |	 * Subsequence (markupdecl | PEReference | S)*
 8545|       |	 */
 8546|    408|	SKIP_BLANKS;
  ------------------
  |  | 2273|    408|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8547|   484k|	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&
  ------------------
  |  | 2221|   484k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8547:10): [True: 484k, False: 375]
  |  Branch (8547:26): [True: 0, False: 375]
  ------------------
 8548|   484k|               (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (8548:16): [True: 484k, False: 9]
  ------------------
 8549|       |
 8550|       |            /*
 8551|       |             * Conditional sections are allowed from external entities included
 8552|       |             * by PE References in the internal subset.
 8553|       |             */
 8554|   484k|            if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
  ------------------
  |  Branch (8554:17): [True: 481k, False: 2.75k]
  |  Branch (8554:40): [True: 390k, False: 90.9k]
  ------------------
 8555|   484k|                (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|   390k|#define RAW (*ctxt->input->cur)
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|   390k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|   390k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8555:17): [True: 390k, False: 0]
  |  Branch (8555:33): [True: 390k, False: 0]
  |  Branch (8555:52): [True: 0, False: 390k]
  ------------------
 8556|      0|                xmlParseConditionalSections(ctxt);
 8557|   484k|            } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|   484k|#define RAW (*ctxt->input->cur)
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|   484k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      6|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8557:24): [True: 484k, False: 72]
  |  Branch (8557:41): [True: 484k, False: 6]
  |  Branch (8557:60): [True: 3, False: 3]
  ------------------
 8558|   484k|	        xmlParseMarkupDecl(ctxt);
 8559|   484k|            } else if (RAW == '%') {
  ------------------
  |  | 2221|     75|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8559:24): [True: 51, False: 24]
  ------------------
 8560|     51|	        xmlParsePEReference(ctxt);
 8561|     51|            } else {
 8562|     24|		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8563|     24|                        "xmlParseInternalSubset: error detected in"
 8564|     24|                        " Markup declaration\n");
 8565|     24|                xmlHaltParser(ctxt);
 8566|     24|                return;
 8567|     24|            }
 8568|   484k|	    SKIP_BLANKS;
  ------------------
  |  | 2273|   484k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8569|   484k|            SHRINK;
  ------------------
  |  | 2265|   484k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 161k, False: 322k]
  |  |  |  Branch (2265:38): [True: 320k, False: 1.82k]
  |  |  ------------------
  |  | 2266|   484k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|   482k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 1.36k, False: 480k]
  |  |  ------------------
  |  | 2267|   484k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|  1.36k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 25, False: 1.33k]
  |  |  ------------------
  |  | 2268|   484k|	xmlParserShrink(ctxt);
  ------------------
 8570|   484k|            GROW;
  ------------------
  |  | 2270|   484k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|   484k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 432k, False: 51.3k]
  |  |  ------------------
  |  | 2271|   484k|	xmlParserGrow(ctxt);
  ------------------
 8571|   484k|	}
 8572|    384|	if (RAW == ']') {
  ------------------
  |  | 2221|    384|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8572:6): [True: 375, False: 9]
  ------------------
 8573|    375|	    NEXT;
  ------------------
  |  | 2275|    375|#define NEXT xmlNextChar(ctxt)
  ------------------
 8574|    375|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    375|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8575|    375|	}
 8576|    384|    }
 8577|       |
 8578|       |    /*
 8579|       |     * We should be at the end of the DOCTYPE declaration.
 8580|       |     */
 8581|    384|    if (RAW != '>') {
  ------------------
  |  | 2221|    384|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8581:9): [True: 9, False: 375]
  ------------------
 8582|      9|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8583|      9|	return;
 8584|      9|    }
 8585|    375|    NEXT;
  ------------------
  |  | 2275|    375|#define NEXT xmlNextChar(ctxt)
  ------------------
 8586|    375|}
parser.c:xmlCleanSpecialAttr:
 1181|    533|{
 1182|    533|    if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1182:9): [True: 413, False: 120]
  ------------------
 1183|    413|        return;
 1184|       |
 1185|    120|    xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1186|       |
 1187|    120|    if (xmlHashSize(ctxt->attsSpecial) == 0) {
  ------------------
  |  Branch (1187:9): [True: 39, False: 81]
  ------------------
 1188|     39|        xmlHashFree(ctxt->attsSpecial, NULL);
 1189|     39|        ctxt->attsSpecial = NULL;
 1190|     39|    }
 1191|    120|    return;
 1192|    533|}
parser.c:xmlCleanSpecialAttrCallback:
 1163|  5.28k|                            const xmlChar *unused ATTRIBUTE_UNUSED) {
 1164|  5.28k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1165|       |
 1166|  5.28k|    if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
  ------------------
  |  Branch (1166:9): [True: 1.95k, False: 3.33k]
  ------------------
 1167|  1.95k|        xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);
 1168|  1.95k|    }
 1169|  5.28k|}
parser.c:xmlParseTryOrFinish:
11585|  12.4k|xmlParseTryOrFinish(xmlParserCtxtPtr ctxt, int terminate) {
11586|  12.4k|    int ret = 0;
11587|  12.4k|    size_t avail;
11588|  12.4k|    xmlChar cur, next;
11589|       |
11590|  12.4k|    if (ctxt->input == NULL)
  ------------------
  |  Branch (11590:9): [True: 0, False: 12.4k]
  ------------------
11591|      0|        return(0);
11592|       |
11593|  12.4k|    if ((ctxt->input != NULL) &&
  ------------------
  |  Branch (11593:9): [True: 12.4k, False: 0]
  ------------------
11594|  12.4k|        (ctxt->input->cur - ctxt->input->base > 4096)) {
  ------------------
  |  Branch (11594:9): [True: 388, False: 12.0k]
  ------------------
11595|    388|        xmlParserShrink(ctxt);
11596|    388|    }
11597|       |
11598|   130k|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (11598:12): [True: 130k, False: 10]
  ------------------
11599|   130k|	if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))
  ------------------
  |  Branch (11599:6): [True: 103, False: 130k]
  |  Branch (11599:37): [True: 28, False: 75]
  ------------------
11600|     28|	    return(0);
11601|       |
11602|   130k|        avail = ctxt->input->end - ctxt->input->cur;
11603|   130k|        if (avail < 1)
  ------------------
  |  Branch (11603:13): [True: 1.27k, False: 129k]
  ------------------
11604|  1.27k|	    goto done;
11605|   129k|        switch (ctxt->instate) {
11606|      0|            case XML_PARSER_EOF:
  ------------------
  |  Branch (11606:13): [True: 0, False: 129k]
  ------------------
11607|       |	        /*
11608|       |		 * Document parsing is done !
11609|       |		 */
11610|      0|	        goto done;
11611|    670|            case XML_PARSER_START:
  ------------------
  |  Branch (11611:13): [True: 670, False: 128k]
  ------------------
11612|       |                /*
11613|       |                 * Very first chars read from the document flow.
11614|       |                 */
11615|    670|                if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11615:21): [True: 642, False: 28]
  |  Branch (11615:37): [True: 24, False: 618]
  ------------------
11616|     24|                    goto done;
11617|       |
11618|       |                /*
11619|       |                 * We need more bytes to detect EBCDIC code pages.
11620|       |                 * See xmlDetectEBCDIC.
11621|       |                 */
11622|    646|                if ((CMP4(CUR_PTR, 0x4C, 0x6F, 0xA7, 0x94)) &&
  ------------------
  |  | 2228|    646|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 4, False: 642]
  |  |  |  Branch (2228:41): [True: 4, False: 0]
  |  |  ------------------
  |  | 2229|    646|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 4, False: 0]
  |  |  |  Branch (2229:41): [True: 4, False: 0]
  |  |  ------------------
  ------------------
11623|    646|                    (!terminate) && (avail < 200))
  ------------------
  |  Branch (11623:21): [True: 2, False: 2]
  |  Branch (11623:37): [True: 2, False: 0]
  ------------------
11624|      2|                    goto done;
11625|       |
11626|    644|                xmlDetectEncoding(ctxt);
11627|    644|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11627:21): [True: 0, False: 644]
  ------------------
11628|      0|                    goto done;
11629|    644|                ctxt->instate = XML_PARSER_XML_DECL;
11630|    644|		break;
11631|       |
11632|    644|            case XML_PARSER_XML_DECL:
  ------------------
  |  Branch (11632:13): [True: 644, False: 128k]
  ------------------
11633|    644|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11633:7): [True: 616, False: 28]
  |  Branch (11633:23): [True: 0, False: 616]
  ------------------
11634|      0|		    goto done;
11635|    644|		cur = ctxt->input->cur[0];
11636|    644|		next = ctxt->input->cur[1];
11637|    644|	        if ((cur == '<') && (next == '?')) {
  ------------------
  |  Branch (11637:14): [True: 626, False: 18]
  |  Branch (11637:30): [True: 332, False: 294]
  ------------------
11638|       |		    /* PI or XML decl */
11639|    332|		    if ((!terminate) &&
  ------------------
  |  Branch (11639:11): [True: 330, False: 2]
  ------------------
11640|    332|                        (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11640:25): [True: 0, False: 330]
  ------------------
11641|      0|			goto done;
11642|    332|		    if ((ctxt->input->cur[2] == 'x') &&
  ------------------
  |  Branch (11642:11): [True: 328, False: 4]
  ------------------
11643|    332|			(ctxt->input->cur[3] == 'm') &&
  ------------------
  |  Branch (11643:4): [True: 328, False: 0]
  ------------------
11644|    332|			(ctxt->input->cur[4] == 'l') &&
  ------------------
  |  Branch (11644:4): [True: 326, False: 2]
  ------------------
11645|    332|			(IS_BLANK_CH(ctxt->input->cur[5]))) {
  ------------------
  |  |  151|    326|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    326|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 326, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    326|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    326|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11646|    326|			ret += 5;
11647|    326|			xmlParseXMLDecl(ctxt);
11648|    326|			if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
  ------------------
  |  Branch (11648:8): [True: 0, False: 326]
  ------------------
11649|       |			    /*
11650|       |			     * The XML REC instructs us to stop parsing right
11651|       |			     * here
11652|       |			     */
11653|      0|			    xmlHaltParser(ctxt);
11654|      0|			    return(0);
11655|      0|			}
11656|    326|		    } else {
11657|      6|			ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|      6|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11658|      6|		    }
11659|    332|		} else {
11660|    312|		    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    312|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11661|    312|		    if (ctxt->version == NULL) {
  ------------------
  |  Branch (11661:11): [True: 0, False: 312]
  ------------------
11662|      0|		        xmlErrMemory(ctxt, NULL);
11663|      0|			break;
11664|      0|		    }
11665|    312|		}
11666|    644|                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11666:21): [True: 644, False: 0]
  |  Branch (11666:36): [True: 644, False: 0]
  ------------------
11667|    644|                    ctxt->sax->setDocumentLocator(ctxt->userData,
11668|    644|                                                  &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    644|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    644|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11669|    644|                if ((ctxt->sax) && (ctxt->sax->startDocument) &&
  ------------------
  |  Branch (11669:21): [True: 644, False: 0]
  |  Branch (11669:36): [True: 644, False: 0]
  ------------------
11670|    644|                    (!ctxt->disableSAX))
  ------------------
  |  Branch (11670:21): [True: 644, False: 0]
  ------------------
11671|    644|                    ctxt->sax->startDocument(ctxt->userData);
11672|    644|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11672:21): [True: 0, False: 644]
  ------------------
11673|      0|                    goto done;
11674|    644|                ctxt->instate = XML_PARSER_MISC;
11675|    644|		break;
11676|  34.4k|            case XML_PARSER_START_TAG: {
  ------------------
  |  Branch (11676:13): [True: 34.4k, False: 94.7k]
  ------------------
11677|  34.4k|	        const xmlChar *name;
11678|  34.4k|		const xmlChar *prefix = NULL;
11679|  34.4k|		const xmlChar *URI = NULL;
11680|  34.4k|                int line = ctxt->input->line;
11681|  34.4k|		int nbNs = 0;
11682|       |
11683|  34.4k|		if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11683:7): [True: 34.4k, False: 42]
  |  Branch (11683:23): [True: 0, False: 34.4k]
  ------------------
11684|      0|		    goto done;
11685|  34.4k|		cur = ctxt->input->cur[0];
11686|  34.4k|	        if (cur != '<') {
  ------------------
  |  Branch (11686:14): [True: 18, False: 34.4k]
  ------------------
11687|     18|		    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11688|     18|                                   "Start tag expected, '<' not found");
11689|     18|		    xmlHaltParser(ctxt);
11690|     18|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11690:11): [True: 18, False: 0]
  |  Branch (11690:26): [True: 18, False: 0]
  ------------------
11691|     18|			ctxt->sax->endDocument(ctxt->userData);
11692|     18|		    goto done;
11693|     18|		}
11694|  34.4k|		if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (11694:7): [True: 34.4k, False: 24]
  |  Branch (11694:23): [True: 5.78k, False: 28.6k]
  ------------------
11695|  5.78k|                    goto done;
11696|  28.6k|		if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (11696:7): [True: 0, False: 28.6k]
  ------------------
11697|      0|		    spacePush(ctxt, -1);
11698|  28.6k|		else if (*ctxt->space == -2)
  ------------------
  |  Branch (11698:12): [True: 0, False: 28.6k]
  ------------------
11699|      0|		    spacePush(ctxt, -1);
11700|  28.6k|		else
11701|  28.6k|		    spacePush(ctxt, *ctxt->space);
11702|  28.6k|#ifdef LIBXML_SAX1_ENABLED
11703|  28.6k|		if (ctxt->sax2)
  ------------------
  |  Branch (11703:7): [True: 28.6k, False: 0]
  ------------------
11704|  28.6k|#endif /* LIBXML_SAX1_ENABLED */
11705|  28.6k|		    name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
11706|      0|#ifdef LIBXML_SAX1_ENABLED
11707|      0|		else
11708|      0|		    name = xmlParseStartTag(ctxt);
11709|  28.6k|#endif /* LIBXML_SAX1_ENABLED */
11710|  28.6k|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11710:7): [True: 10, False: 28.6k]
  ------------------
11711|     10|		    goto done;
11712|  28.6k|		if (name == NULL) {
  ------------------
  |  Branch (11712:7): [True: 16, False: 28.6k]
  ------------------
11713|     16|		    spacePop(ctxt);
11714|     16|		    xmlHaltParser(ctxt);
11715|     16|		    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11715:11): [True: 16, False: 0]
  |  Branch (11715:26): [True: 16, False: 0]
  ------------------
11716|     16|			ctxt->sax->endDocument(ctxt->userData);
11717|     16|		    goto done;
11718|     16|		}
11719|  28.6k|#ifdef LIBXML_VALID_ENABLED
11720|       |		/*
11721|       |		 * [ VC: Root Element Type ]
11722|       |		 * The Name in the document type declaration must match
11723|       |		 * the element type of the root element.
11724|       |		 */
11725|  28.6k|		if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (11725:7): [True: 0, False: 28.6k]
  |  Branch (11725:25): [True: 0, False: 0]
  |  Branch (11725:45): [True: 0, False: 0]
  ------------------
11726|  28.6k|		    ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (11726:7): [True: 0, False: 0]
  |  Branch (11726:21): [True: 0, False: 0]
  ------------------
11727|      0|		    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
11728|  28.6k|#endif /* LIBXML_VALID_ENABLED */
11729|       |
11730|       |		/*
11731|       |		 * Check for an Empty Element.
11732|       |		 */
11733|  28.6k|		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  28.6k|#define RAW (*ctxt->input->cur)
  ------------------
              		if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|  20.3k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (11733:7): [True: 20.3k, False: 8.30k]
  |  Branch (11733:23): [True: 20.3k, False: 0]
  ------------------
11734|  20.3k|		    SKIP(2);
  ------------------
  |  | 2245|  20.3k|#define SKIP(val) do {							\
  |  | 2246|  20.3k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  20.3k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 190, False: 20.1k]
  |  |  ------------------
  |  | 2248|  20.3k|        xmlParserGrow(ctxt);						\
  |  | 2249|  20.3k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11735|       |
11736|  20.3k|		    if (ctxt->sax2) {
  ------------------
  |  Branch (11736:11): [True: 20.3k, False: 0]
  ------------------
11737|  20.3k|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11737:8): [True: 20.3k, False: 0]
  ------------------
11738|  20.3k|			    (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (11738:8): [True: 20.3k, False: 0]
  ------------------
11739|  20.3k|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11739:8): [True: 20.3k, False: 8]
  ------------------
11740|  20.3k|			    ctxt->sax->endElementNs(ctxt->userData, name,
11741|  20.3k|			                            prefix, URI);
11742|  20.3k|			if (nbNs > 0)
  ------------------
  |  Branch (11742:8): [True: 30, False: 20.3k]
  ------------------
11743|     30|			    xmlParserNsPop(ctxt, nbNs);
11744|  20.3k|#ifdef LIBXML_SAX1_ENABLED
11745|  20.3k|		    } else {
11746|      0|			if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (11746:8): [True: 0, False: 0]
  ------------------
11747|      0|			    (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (11747:8): [True: 0, False: 0]
  ------------------
11748|      0|			    (!ctxt->disableSAX))
  ------------------
  |  Branch (11748:8): [True: 0, False: 0]
  ------------------
11749|      0|			    ctxt->sax->endElement(ctxt->userData, name);
11750|      0|#endif /* LIBXML_SAX1_ENABLED */
11751|      0|		    }
11752|  20.3k|		    spacePop(ctxt);
11753|  20.3k|		} else if (RAW == '>') {
  ------------------
  |  | 2221|  8.30k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11753:14): [True: 8.29k, False: 12]
  ------------------
11754|  8.29k|		    NEXT;
  ------------------
  |  | 2275|  8.29k|#define NEXT xmlNextChar(ctxt)
  ------------------
11755|  8.29k|                    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
11756|  8.29k|		} else {
11757|     12|		    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,
11758|     12|					 "Couldn't find end of Start Tag %s\n",
11759|     12|					 name);
11760|     12|		    nodePop(ctxt);
11761|     12|		    spacePop(ctxt);
11762|     12|                    if (nbNs > 0)
  ------------------
  |  Branch (11762:25): [True: 2, False: 10]
  ------------------
11763|      2|                        xmlParserNsPop(ctxt, nbNs);
11764|     12|		}
11765|       |
11766|  28.6k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11766:21): [True: 0, False: 28.6k]
  ------------------
11767|      0|                    goto done;
11768|  28.6k|                if (ctxt->nameNr == 0)
  ------------------
  |  Branch (11768:21): [True: 118, False: 28.5k]
  ------------------
11769|    118|                    ctxt->instate = XML_PARSER_EPILOG;
11770|  28.5k|                else
11771|  28.5k|                    ctxt->instate = XML_PARSER_CONTENT;
11772|  28.6k|                break;
11773|  28.6k|	    }
11774|  81.2k|            case XML_PARSER_CONTENT: {
  ------------------
  |  Branch (11774:13): [True: 81.2k, False: 47.9k]
  ------------------
11775|  81.2k|		cur = ctxt->input->cur[0];
11776|       |
11777|  81.2k|		if (cur == '<') {
  ------------------
  |  Branch (11777:7): [True: 36.9k, False: 44.3k]
  ------------------
11778|  36.9k|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11778:25): [True: 36.9k, False: 0]
  |  Branch (11778:41): [True: 181, False: 36.7k]
  ------------------
11779|    181|                        goto done;
11780|  36.7k|		    next = ctxt->input->cur[1];
11781|       |
11782|  36.7k|                    if (next == '/') {
  ------------------
  |  Branch (11782:25): [True: 8.24k, False: 28.4k]
  ------------------
11783|  8.24k|                        ctxt->instate = XML_PARSER_END_TAG;
11784|  8.24k|                        break;
11785|  28.4k|                    } else if (next == '?') {
  ------------------
  |  Branch (11785:32): [True: 16, False: 28.4k]
  ------------------
11786|     16|                        if ((!terminate) &&
  ------------------
  |  Branch (11786:29): [True: 16, False: 0]
  ------------------
11787|     16|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11787:29): [True: 0, False: 16]
  ------------------
11788|      0|                            goto done;
11789|     16|                        xmlParsePI(ctxt);
11790|     16|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11790:29): [True: 0, False: 16]
  ------------------
11791|      0|                            goto done;
11792|     16|                        ctxt->instate = XML_PARSER_CONTENT;
11793|     16|                        break;
11794|  28.4k|                    } else if (next == '!') {
  ------------------
  |  Branch (11794:32): [True: 420, False: 28.0k]
  ------------------
11795|    420|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11795:29): [True: 420, False: 0]
  |  Branch (11795:45): [True: 3, False: 417]
  ------------------
11796|      3|                            goto done;
11797|    417|                        next = ctxt->input->cur[2];
11798|       |
11799|    417|                        if (next == '-') {
  ------------------
  |  Branch (11799:29): [True: 347, False: 70]
  ------------------
11800|    347|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11800:33): [True: 347, False: 0]
  |  Branch (11800:49): [True: 2, False: 345]
  ------------------
11801|      2|                                goto done;
11802|    345|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11802:33): [True: 345, False: 0]
  ------------------
11803|    345|                                if ((!terminate) &&
  ------------------
  |  Branch (11803:37): [True: 345, False: 0]
  ------------------
11804|    345|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11804:37): [True: 97, False: 248]
  ------------------
11805|     97|                                    goto done;
11806|    248|                                xmlParseComment(ctxt);
11807|    248|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11807:37): [True: 0, False: 248]
  ------------------
11808|      0|                                    goto done;
11809|    248|                                ctxt->instate = XML_PARSER_CONTENT;
11810|    248|                                break;
11811|    248|                            }
11812|    345|                        } else if (next == '[') {
  ------------------
  |  Branch (11812:36): [True: 68, False: 2]
  ------------------
11813|     68|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (11813:33): [True: 68, False: 0]
  |  Branch (11813:49): [True: 0, False: 68]
  ------------------
11814|      0|                                goto done;
11815|     68|                            if ((ctxt->input->cur[2] == '[') &&
  ------------------
  |  Branch (11815:33): [True: 68, False: 0]
  ------------------
11816|     68|                                (ctxt->input->cur[3] == 'C') &&
  ------------------
  |  Branch (11816:33): [True: 68, False: 0]
  ------------------
11817|     68|                                (ctxt->input->cur[4] == 'D') &&
  ------------------
  |  Branch (11817:33): [True: 68, False: 0]
  ------------------
11818|     68|                                (ctxt->input->cur[5] == 'A') &&
  ------------------
  |  Branch (11818:33): [True: 68, False: 0]
  ------------------
11819|     68|                                (ctxt->input->cur[6] == 'T') &&
  ------------------
  |  Branch (11819:33): [True: 68, False: 0]
  ------------------
11820|     68|                                (ctxt->input->cur[7] == 'A') &&
  ------------------
  |  Branch (11820:33): [True: 68, False: 0]
  ------------------
11821|     68|                                (ctxt->input->cur[8] == '[')) {
  ------------------
  |  Branch (11821:33): [True: 68, False: 0]
  ------------------
11822|     68|                                SKIP(9);
  ------------------
  |  | 2245|     68|#define SKIP(val) do {							\
  |  | 2246|     68|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     68|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 68]
  |  |  ------------------
  |  | 2248|     68|        xmlParserGrow(ctxt);						\
  |  | 2249|     68|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11823|     68|                                ctxt->instate = XML_PARSER_CDATA_SECTION;
11824|     68|                                break;
11825|     68|                            }
11826|     68|                        }
11827|    417|                    }
11828|  44.3k|		} else if (cur == '&') {
  ------------------
  |  Branch (11828:14): [True: 5.70k, False: 38.6k]
  ------------------
11829|  5.70k|		    if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))
  ------------------
  |  Branch (11829:11): [True: 5.70k, False: 0]
  |  Branch (11829:27): [True: 68, False: 5.63k]
  ------------------
11830|     68|			goto done;
11831|  5.63k|		    xmlParseReference(ctxt);
11832|  5.63k|                    break;
11833|  38.6k|		} else {
11834|       |		    /* TODO Avoid the extra copy, handle directly !!! */
11835|       |		    /*
11836|       |		     * Goal of the following test is:
11837|       |		     *  - minimize calls to the SAX 'character' callback
11838|       |		     *    when they are mergeable
11839|       |		     *  - handle an problem for isBlank when we only parse
11840|       |		     *    a sequence of blank chars and the next one is
11841|       |		     *    not available to check against '<' presence.
11842|       |		     *  - tries to homogenize the differences in SAX
11843|       |		     *    callbacks between the push and pull versions
11844|       |		     *    of the parser.
11845|       |		     */
11846|  38.6k|		    if (avail < XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|  38.6k|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11846:11): [True: 30.7k, False: 7.90k]
  ------------------
11847|  30.7k|			if ((!terminate) && (!xmlParseLookupCharData(ctxt)))
  ------------------
  |  Branch (11847:8): [True: 30.7k, False: 2]
  |  Branch (11847:24): [True: 2.49k, False: 28.2k]
  ------------------
11848|  2.49k|			    goto done;
11849|  30.7k|                    }
11850|  36.1k|                    ctxt->checkIndex = 0;
11851|  36.1k|		    xmlParseCharDataInternal(ctxt, !terminate);
11852|  36.1k|                    break;
11853|  38.6k|		}
11854|       |
11855|  28.0k|                ctxt->instate = XML_PARSER_START_TAG;
11856|  28.0k|		break;
11857|  81.2k|	    }
11858|  8.44k|            case XML_PARSER_END_TAG:
  ------------------
  |  Branch (11858:13): [True: 8.44k, False: 120k]
  ------------------
11859|  8.44k|		if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))
  ------------------
  |  Branch (11859:7): [True: 8.44k, False: 2]
  |  Branch (11859:23): [True: 200, False: 8.24k]
  ------------------
11860|    200|		    goto done;
11861|  8.24k|		if (ctxt->sax2) {
  ------------------
  |  Branch (11861:7): [True: 8.24k, False: 0]
  ------------------
11862|  8.24k|	            xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
11863|  8.24k|		    nameNsPop(ctxt);
11864|  8.24k|		}
11865|      0|#ifdef LIBXML_SAX1_ENABLED
11866|      0|		  else
11867|      0|		    xmlParseEndTag1(ctxt, 0);
11868|  8.24k|#endif /* LIBXML_SAX1_ENABLED */
11869|  8.24k|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11869:21): [True: 0, False: 8.24k]
  ------------------
11870|      0|                    goto done;
11871|  8.24k|		if (ctxt->nameNr == 0) {
  ------------------
  |  Branch (11871:7): [True: 426, False: 7.82k]
  ------------------
11872|    426|		    ctxt->instate = XML_PARSER_EPILOG;
11873|  7.82k|		} else {
11874|  7.82k|		    ctxt->instate = XML_PARSER_CONTENT;
11875|  7.82k|		}
11876|  8.24k|		break;
11877|    247|            case XML_PARSER_CDATA_SECTION: {
  ------------------
  |  Branch (11877:13): [True: 247, False: 128k]
  ------------------
11878|       |	        /*
11879|       |		 * The Push mode need to have the SAX callback for
11880|       |		 * cdataBlock merge back contiguous callbacks.
11881|       |		 */
11882|    247|		const xmlChar *term;
11883|       |
11884|    247|                if (terminate) {
  ------------------
  |  Branch (11884:21): [True: 0, False: 247]
  ------------------
11885|       |                    /*
11886|       |                     * Don't call xmlParseLookupString. If 'terminate'
11887|       |                     * is set, checkIndex is invalid.
11888|       |                     */
11889|      0|                    term = BAD_CAST strstr((const char *) ctxt->input->cur,
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
11890|      0|                                           "]]>");
11891|    247|                } else {
11892|    247|		    term = xmlParseLookupString(ctxt, 0, "]]>", 3);
11893|    247|                }
11894|       |
11895|    247|		if (term == NULL) {
  ------------------
  |  Branch (11895:7): [True: 179, False: 68]
  ------------------
11896|    179|		    int tmp, size;
11897|       |
11898|    179|                    if (terminate) {
  ------------------
  |  Branch (11898:25): [True: 0, False: 179]
  ------------------
11899|       |                        /* Unfinished CDATA section */
11900|      0|                        size = ctxt->input->end - ctxt->input->cur;
11901|    179|                    } else {
11902|    179|                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)
  ------------------
  |  |  166|    179|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (11902:29): [True: 129, False: 50]
  ------------------
11903|    129|                            goto done;
11904|     50|                        ctxt->checkIndex = 0;
11905|       |                        /* XXX: Why don't we pass the full buffer? */
11906|     50|                        size = XML_PARSER_BIG_BUFFER_SIZE;
  ------------------
  |  |  166|     50|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
11907|     50|                    }
11908|     50|                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);
11909|     50|                    if (tmp <= 0) {
  ------------------
  |  Branch (11909:25): [True: 0, False: 50]
  ------------------
11910|      0|                        tmp = -tmp;
11911|      0|                        ctxt->input->cur += tmp;
11912|      0|                        goto encoding_error;
11913|      0|                    }
11914|     50|                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11914:25): [True: 50, False: 0]
  |  Branch (11914:48): [True: 50, False: 0]
  ------------------
11915|     50|                        if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11915:29): [True: 50, False: 0]
  ------------------
11916|     50|                            ctxt->sax->cdataBlock(ctxt->userData,
11917|     50|                                                  ctxt->input->cur, tmp);
11918|      0|                        else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11918:34): [True: 0, False: 0]
  ------------------
11919|      0|                            ctxt->sax->characters(ctxt->userData,
11920|      0|                                                  ctxt->input->cur, tmp);
11921|     50|                    }
11922|     50|                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11922:25): [True: 0, False: 50]
  ------------------
11923|      0|                        goto done;
11924|     50|                    SKIPL(tmp);
  ------------------
  |  | 2251|     50|#define SKIPL(val) do {							\
  |  | 2252|     50|    int skipl;								\
  |  | 2253|  15.0k|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 14.9k, False: 50]
  |  |  ------------------
  |  | 2254|  14.9k|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 0, False: 14.9k]
  |  |  ------------------
  |  | 2255|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|  14.9k|	} else ctxt->input->col++;					\
  |  | 2257|  14.9k|	ctxt->input->cur++;						\
  |  | 2258|  14.9k|    }									\
  |  | 2259|     50|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 50]
  |  |  ------------------
  |  | 2260|     50|        xmlParserGrow(ctxt);						\
  |  | 2261|     50|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11925|     68|		} else {
11926|     68|                    int base = term - CUR_PTR;
  ------------------
  |  | 2224|     68|#define CUR_PTR ctxt->input->cur
  ------------------
11927|     68|		    int tmp;
11928|       |
11929|     68|		    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);
11930|     68|		    if ((tmp < 0) || (tmp != base)) {
  ------------------
  |  Branch (11930:11): [True: 4, False: 64]
  |  Branch (11930:24): [True: 0, False: 64]
  ------------------
11931|      4|			tmp = -tmp;
11932|      4|			ctxt->input->cur += tmp;
11933|      4|			goto encoding_error;
11934|      4|		    }
11935|     64|		    if ((ctxt->sax != NULL) && (base == 0) &&
  ------------------
  |  Branch (11935:11): [True: 64, False: 0]
  |  Branch (11935:34): [True: 2, False: 62]
  ------------------
11936|     64|		        (ctxt->sax->cdataBlock != NULL) &&
  ------------------
  |  Branch (11936:11): [True: 2, False: 0]
  ------------------
11937|     64|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (11937:11): [True: 2, False: 0]
  ------------------
11938|       |			/*
11939|       |			 * Special case to provide identical behaviour
11940|       |			 * between pull and push parsers on enpty CDATA
11941|       |			 * sections
11942|       |			 */
11943|      2|			 if ((ctxt->input->cur - ctxt->input->base >= 9) &&
  ------------------
  |  Branch (11943:9): [True: 2, False: 0]
  ------------------
11944|      2|			     (!strncmp((const char *)&ctxt->input->cur[-9],
  ------------------
  |  Branch (11944:9): [True: 2, False: 0]
  ------------------
11945|      2|			               "<![CDATA[", 9)))
11946|      2|			     ctxt->sax->cdataBlock(ctxt->userData,
11947|      2|			                           BAD_CAST "", 0);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
11948|     62|		    } else if ((ctxt->sax != NULL) && (base > 0) &&
  ------------------
  |  Branch (11948:18): [True: 62, False: 0]
  |  Branch (11948:41): [True: 62, False: 0]
  ------------------
11949|     62|			(!ctxt->disableSAX)) {
  ------------------
  |  Branch (11949:4): [True: 62, False: 0]
  ------------------
11950|     62|			if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (11950:8): [True: 62, False: 0]
  ------------------
11951|     62|			    ctxt->sax->cdataBlock(ctxt->userData,
11952|     62|						  ctxt->input->cur, base);
11953|      0|			else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (11953:13): [True: 0, False: 0]
  ------------------
11954|      0|			    ctxt->sax->characters(ctxt->userData,
11955|      0|						  ctxt->input->cur, base);
11956|     62|		    }
11957|     64|		    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11957:11): [True: 0, False: 64]
  ------------------
11958|      0|			goto done;
11959|     64|		    SKIPL(base + 3);
  ------------------
  |  | 2251|     64|#define SKIPL(val) do {							\
  |  | 2252|     64|    int skipl;								\
  |  | 2253|  11.5k|    for(skipl=0; skipl<val; skipl++) {					\
  |  |  ------------------
  |  |  |  Branch (2253:18): [True: 11.4k, False: 64]
  |  |  ------------------
  |  | 2254|  11.4k|	if (*(ctxt->input->cur) == '\n') {				\
  |  |  ------------------
  |  |  |  Branch (2254:6): [True: 120, False: 11.3k]
  |  |  ------------------
  |  | 2255|    120|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2256|  11.3k|	} else ctxt->input->col++;					\
  |  | 2257|  11.4k|	ctxt->input->cur++;						\
  |  | 2258|  11.4k|    }									\
  |  | 2259|     64|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2259:9): [True: 0, False: 64]
  |  |  ------------------
  |  | 2260|     64|        xmlParserGrow(ctxt);						\
  |  | 2261|     64|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2261:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
11960|     64|		    ctxt->instate = XML_PARSER_CONTENT;
11961|     64|		}
11962|    114|		break;
11963|    247|	    }
11964|    930|            case XML_PARSER_MISC:
  ------------------
  |  Branch (11964:13): [True: 930, False: 128k]
  ------------------
11965|  1.31k|            case XML_PARSER_PROLOG:
  ------------------
  |  Branch (11965:13): [True: 388, False: 128k]
  ------------------
11966|  1.85k|            case XML_PARSER_EPILOG:
  ------------------
  |  Branch (11966:13): [True: 532, False: 128k]
  ------------------
11967|  1.85k|		SKIP_BLANKS;
  ------------------
  |  | 2273|  1.85k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11968|  1.85k|                avail = ctxt->input->end - ctxt->input->cur;
11969|  1.85k|		if (avail < 1)
  ------------------
  |  Branch (11969:7): [True: 517, False: 1.33k]
  ------------------
11970|    517|		    goto done;
11971|  1.33k|		if (ctxt->input->cur[0] == '<') {
  ------------------
  |  Branch (11971:7): [True: 1.31k, False: 20]
  ------------------
11972|  1.31k|                    if ((!terminate) && (avail < 2))
  ------------------
  |  Branch (11972:25): [True: 1.30k, False: 10]
  |  Branch (11972:41): [True: 0, False: 1.30k]
  ------------------
11973|      0|                        goto done;
11974|  1.31k|                    next = ctxt->input->cur[1];
11975|  1.31k|                    if (next == '?') {
  ------------------
  |  Branch (11975:25): [True: 28, False: 1.28k]
  ------------------
11976|     28|                        if ((!terminate) &&
  ------------------
  |  Branch (11976:29): [True: 28, False: 0]
  ------------------
11977|     28|                            (!xmlParseLookupString(ctxt, 2, "?>", 2)))
  ------------------
  |  Branch (11977:29): [True: 2, False: 26]
  ------------------
11978|      2|                            goto done;
11979|     26|                        xmlParsePI(ctxt);
11980|     26|                        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11980:29): [True: 0, False: 26]
  ------------------
11981|      0|                            goto done;
11982|     26|                        break;
11983|  1.28k|                    } else if (next == '!') {
  ------------------
  |  Branch (11983:32): [True: 695, False: 590]
  ------------------
11984|    695|                        if ((!terminate) && (avail < 3))
  ------------------
  |  Branch (11984:29): [True: 695, False: 0]
  |  Branch (11984:45): [True: 0, False: 695]
  ------------------
11985|      0|                            goto done;
11986|       |
11987|    695|                        if (ctxt->input->cur[2] == '-') {
  ------------------
  |  Branch (11987:29): [True: 158, False: 537]
  ------------------
11988|    158|                            if ((!terminate) && (avail < 4))
  ------------------
  |  Branch (11988:33): [True: 158, False: 0]
  |  Branch (11988:49): [True: 0, False: 158]
  ------------------
11989|      0|                                goto done;
11990|    158|                            if (ctxt->input->cur[3] == '-') {
  ------------------
  |  Branch (11990:33): [True: 158, False: 0]
  ------------------
11991|    158|                                if ((!terminate) &&
  ------------------
  |  Branch (11991:37): [True: 158, False: 0]
  ------------------
11992|    158|                                    (!xmlParseLookupString(ctxt, 4, "-->", 3)))
  ------------------
  |  Branch (11992:37): [True: 102, False: 56]
  ------------------
11993|    102|                                    goto done;
11994|     56|                                xmlParseComment(ctxt);
11995|     56|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11995:37): [True: 0, False: 56]
  ------------------
11996|      0|                                    goto done;
11997|     56|                                break;
11998|     56|                            }
11999|    537|                        } else if (ctxt->instate == XML_PARSER_MISC) {
  ------------------
  |  Branch (11999:36): [True: 537, False: 0]
  ------------------
12000|    537|                            if ((!terminate) && (avail < 9))
  ------------------
  |  Branch (12000:33): [True: 537, False: 0]
  |  Branch (12000:49): [True: 0, False: 537]
  ------------------
12001|      0|                                goto done;
12002|    537|                            if ((ctxt->input->cur[2] == 'D') &&
  ------------------
  |  Branch (12002:33): [True: 533, False: 4]
  ------------------
12003|    537|                                (ctxt->input->cur[3] == 'O') &&
  ------------------
  |  Branch (12003:33): [True: 533, False: 0]
  ------------------
12004|    537|                                (ctxt->input->cur[4] == 'C') &&
  ------------------
  |  Branch (12004:33): [True: 533, False: 0]
  ------------------
12005|    537|                                (ctxt->input->cur[5] == 'T') &&
  ------------------
  |  Branch (12005:33): [True: 533, False: 0]
  ------------------
12006|    537|                                (ctxt->input->cur[6] == 'Y') &&
  ------------------
  |  Branch (12006:33): [True: 533, False: 0]
  ------------------
12007|    537|                                (ctxt->input->cur[7] == 'P') &&
  ------------------
  |  Branch (12007:33): [True: 533, False: 0]
  ------------------
12008|    537|                                (ctxt->input->cur[8] == 'E')) {
  ------------------
  |  Branch (12008:33): [True: 533, False: 0]
  ------------------
12009|    533|                                if ((!terminate) && (!xmlParseLookupGt(ctxt)))
  ------------------
  |  Branch (12009:37): [True: 533, False: 0]
  |  Branch (12009:53): [True: 153, False: 380]
  ------------------
12010|    153|                                    goto done;
12011|    380|                                ctxt->inSubset = 1;
12012|    380|                                xmlParseDocTypeDecl(ctxt);
12013|    380|                                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12013:37): [True: 0, False: 380]
  ------------------
12014|      0|                                    goto done;
12015|    380|                                if (RAW == '[') {
  ------------------
  |  | 2221|    380|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (12015:37): [True: 272, False: 108]
  ------------------
12016|    272|                                    ctxt->instate = XML_PARSER_DTD;
12017|    272|                                } else {
12018|       |                                    /*
12019|       |                                     * Create and update the external subset.
12020|       |                                     */
12021|    108|                                    ctxt->inSubset = 2;
12022|    108|                                    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (12022:41): [True: 108, False: 0]
  ------------------
12023|    108|                                        (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12023:41): [True: 108, False: 0]
  ------------------
12024|    108|                                        (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12024:41): [True: 108, False: 0]
  ------------------
12025|    108|                                        ctxt->sax->externalSubset(
12026|    108|                                                ctxt->userData,
12027|    108|                                                ctxt->intSubName,
12028|    108|                                                ctxt->extSubSystem,
12029|    108|                                                ctxt->extSubURI);
12030|    108|                                    ctxt->inSubset = 0;
12031|    108|                                    xmlCleanSpecialAttr(ctxt);
12032|    108|                                    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12032:41): [True: 8, False: 100]
  ------------------
12033|      8|                                        goto done;
12034|    100|                                    ctxt->instate = XML_PARSER_PROLOG;
12035|    100|                                }
12036|    372|                                break;
12037|    380|                            }
12038|    537|                        }
12039|    695|                    }
12040|  1.31k|                }
12041|       |
12042|    614|                if (ctxt->instate == XML_PARSER_EPILOG) {
  ------------------
  |  Branch (12042:21): [True: 2, False: 612]
  ------------------
12043|      2|                    if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (12043:25): [True: 2, False: 0]
  ------------------
12044|      2|                        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
12045|      2|		    ctxt->instate = XML_PARSER_EOF;
12046|      2|                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (12046:25): [True: 2, False: 0]
  |  Branch (12046:40): [True: 2, False: 0]
  ------------------
12047|      2|                        ctxt->sax->endDocument(ctxt->userData);
12048|    612|                } else {
12049|    612|		    ctxt->instate = XML_PARSER_START_TAG;
12050|    612|		}
12051|    614|		break;
12052|  1.59k|            case XML_PARSER_DTD: {
  ------------------
  |  Branch (12052:13): [True: 1.59k, False: 127k]
  ------------------
12053|  1.59k|                if ((!terminate) && (!xmlParseLookupInternalSubset(ctxt)))
  ------------------
  |  Branch (12053:21): [True: 1.58k, False: 10]
  |  Branch (12053:37): [True: 1.32k, False: 262]
  ------------------
12054|  1.32k|                    goto done;
12055|    272|		xmlParseInternalSubset(ctxt);
12056|    272|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12056:7): [True: 22, False: 250]
  ------------------
12057|     22|		    goto done;
12058|    250|		ctxt->inSubset = 2;
12059|    250|		if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (12059:7): [True: 250, False: 0]
  |  Branch (12059:30): [True: 250, False: 0]
  ------------------
12060|    250|		    (ctxt->sax->externalSubset != NULL))
  ------------------
  |  Branch (12060:7): [True: 250, False: 0]
  ------------------
12061|    250|		    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
12062|    250|			    ctxt->extSubSystem, ctxt->extSubURI);
12063|    250|		ctxt->inSubset = 0;
12064|    250|		xmlCleanSpecialAttr(ctxt);
12065|    250|		if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (12065:7): [True: 0, False: 250]
  ------------------
12066|      0|		    goto done;
12067|    250|		ctxt->instate = XML_PARSER_PROLOG;
12068|    250|                break;
12069|    250|	    }
12070|      0|            default:
  ------------------
  |  Branch (12070:13): [True: 0, False: 129k]
  ------------------
12071|      0|		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12072|      0|			"PP: internal error\n");
12073|      0|		ctxt->instate = XML_PARSER_EOF;
12074|      0|		break;
12075|   129k|	}
12076|   129k|    }
12077|  12.4k|done:
12078|  12.4k|    return(ret);
12079|      4|encoding_error:
12080|      4|    if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (12080:9): [True: 0, False: 4]
  ------------------
12081|      0|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12082|      0|		     "Input is not proper UTF-8, indicate encoding !\n",
12083|      0|		     NULL, NULL);
12084|      4|    } else {
12085|      4|        char buffer[150];
12086|       |
12087|      4|	snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
12088|      4|			ctxt->input->cur[0], ctxt->input->cur[1],
12089|      4|			ctxt->input->cur[2], ctxt->input->cur[3]);
12090|      4|	__xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
12091|      4|		     "Input is not proper UTF-8, indicate encoding !\n%s",
12092|      4|		     BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      4|#define BAD_CAST (xmlChar *)
  ------------------
12093|      4|    }
12094|      4|    return(0);
12095|  12.4k|}
parser.c:xmlParseLookupString:
11292|  1.12k|                     const char *str, size_t strLen) {
11293|  1.12k|    const xmlChar *cur, *term;
11294|       |
11295|  1.12k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11295:9): [True: 795, False: 329]
  ------------------
11296|    795|        cur = ctxt->input->cur + startDelta;
11297|    795|    } else {
11298|    329|        cur = ctxt->input->cur + ctxt->checkIndex;
11299|    329|    }
11300|       |
11301|  1.12k|    term = BAD_CAST strstr((const char *) cur, str);
  ------------------
  |  |   35|  1.12k|#define BAD_CAST (xmlChar *)
  ------------------
11302|  1.12k|    if (term == NULL) {
  ------------------
  |  Branch (11302:9): [True: 380, False: 744]
  ------------------
11303|    380|        const xmlChar *end = ctxt->input->end;
11304|    380|        size_t index;
11305|       |
11306|       |        /* Rescan (strLen - 1) characters. */
11307|    380|        if ((size_t) (end - cur) < strLen)
  ------------------
  |  Branch (11307:13): [True: 1, False: 379]
  ------------------
11308|      1|            end = cur;
11309|    379|        else
11310|    379|            end -= strLen - 1;
11311|    380|        index = end - ctxt->input->cur;
11312|    380|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11312:13): [True: 0, False: 380]
  ------------------
11313|      0|            ctxt->checkIndex = 0;
11314|      0|            return(ctxt->input->end - strLen);
11315|      0|        }
11316|    380|        ctxt->checkIndex = index;
11317|    744|    } else {
11318|    744|        ctxt->checkIndex = 0;
11319|    744|    }
11320|       |
11321|  1.12k|    return(term);
11322|  1.12k|}
parser.c:xmlParseLookupGt:
11361|  34.9k|xmlParseLookupGt(xmlParserCtxtPtr ctxt) {
11362|  34.9k|    const xmlChar *cur;
11363|  34.9k|    const xmlChar *end = ctxt->input->end;
11364|  34.9k|    int state = ctxt->endCheckState;
11365|  34.9k|    size_t index;
11366|       |
11367|  34.9k|    if (ctxt->checkIndex == 0)
  ------------------
  |  Branch (11367:9): [True: 29.0k, False: 5.91k]
  ------------------
11368|  29.0k|        cur = ctxt->input->cur + 1;
11369|  5.91k|    else
11370|  5.91k|        cur = ctxt->input->cur + ctxt->checkIndex;
11371|       |
11372|  1.28M|    while (cur < end) {
  ------------------
  |  Branch (11372:12): [True: 1.27M, False: 5.93k]
  ------------------
11373|  1.27M|        if (state) {
  ------------------
  |  Branch (11373:13): [True: 649k, False: 628k]
  ------------------
11374|   649k|            if (*cur == state)
  ------------------
  |  Branch (11374:17): [True: 43.5k, False: 605k]
  ------------------
11375|  43.5k|                state = 0;
11376|   649k|        } else if (*cur == '\'' || *cur == '"') {
  ------------------
  |  Branch (11376:20): [True: 1.71k, False: 626k]
  |  Branch (11376:36): [True: 41.8k, False: 584k]
  ------------------
11377|  43.5k|            state = *cur;
11378|   584k|        } else if (*cur == '>') {
  ------------------
  |  Branch (11378:20): [True: 29.0k, False: 555k]
  ------------------
11379|  29.0k|            ctxt->checkIndex = 0;
11380|  29.0k|            ctxt->endCheckState = 0;
11381|  29.0k|            return(1);
11382|  29.0k|        }
11383|  1.24M|        cur++;
11384|  1.24M|    }
11385|       |
11386|  5.93k|    index = cur - ctxt->input->cur;
11387|  5.93k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11387:9): [True: 0, False: 5.93k]
  ------------------
11388|      0|        ctxt->checkIndex = 0;
11389|      0|        ctxt->endCheckState = 0;
11390|      0|        return(1);
11391|      0|    }
11392|  5.93k|    ctxt->checkIndex = index;
11393|  5.93k|    ctxt->endCheckState = state;
11394|  5.93k|    return(0);
11395|  5.93k|}
parser.c:xmlParseLookupChar:
11257|  14.1k|xmlParseLookupChar(xmlParserCtxtPtr ctxt, int c) {
11258|  14.1k|    const xmlChar *cur;
11259|       |
11260|  14.1k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11260:9): [True: 13.8k, False: 266]
  ------------------
11261|  13.8k|        cur = ctxt->input->cur + 1;
11262|  13.8k|    } else {
11263|    266|        cur = ctxt->input->cur + ctxt->checkIndex;
11264|    266|    }
11265|       |
11266|  14.1k|    if (memchr(cur, c, ctxt->input->end - cur) == NULL) {
  ------------------
  |  Branch (11266:9): [True: 268, False: 13.8k]
  ------------------
11267|    268|        size_t index = ctxt->input->end - ctxt->input->cur;
11268|       |
11269|    268|        if (index > LONG_MAX) {
  ------------------
  |  Branch (11269:13): [True: 0, False: 268]
  ------------------
11270|      0|            ctxt->checkIndex = 0;
11271|      0|            return(1);
11272|      0|        }
11273|    268|        ctxt->checkIndex = index;
11274|    268|        return(0);
11275|  13.8k|    } else {
11276|  13.8k|        ctxt->checkIndex = 0;
11277|  13.8k|        return(1);
11278|  13.8k|    }
11279|  14.1k|}
parser.c:xmlParseLookupCharData:
11331|  30.7k|xmlParseLookupCharData(xmlParserCtxtPtr ctxt) {
11332|  30.7k|    const xmlChar *cur = ctxt->input->cur + ctxt->checkIndex;
11333|  30.7k|    const xmlChar *end = ctxt->input->end;
11334|  30.7k|    size_t index;
11335|       |
11336|   416k|    while (cur < end) {
  ------------------
  |  Branch (11336:12): [True: 414k, False: 2.49k]
  ------------------
11337|   414k|        if ((*cur == '<') || (*cur == '&')) {
  ------------------
  |  Branch (11337:13): [True: 27.2k, False: 386k]
  |  Branch (11337:30): [True: 993, False: 385k]
  ------------------
11338|  28.2k|            ctxt->checkIndex = 0;
11339|  28.2k|            return(1);
11340|  28.2k|        }
11341|   385k|        cur++;
11342|   385k|    }
11343|       |
11344|  2.49k|    index = cur - ctxt->input->cur;
11345|  2.49k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11345:9): [True: 0, False: 2.49k]
  ------------------
11346|      0|        ctxt->checkIndex = 0;
11347|      0|        return(1);
11348|      0|    }
11349|  2.49k|    ctxt->checkIndex = index;
11350|  2.49k|    return(0);
11351|  2.49k|}
parser.c:nameNsPop:
 2076|  8.24k|{
 2077|  8.24k|    const xmlChar *ret;
 2078|       |
 2079|  8.24k|    if (ctxt->nameNr <= 0)
  ------------------
  |  Branch (2079:9): [True: 0, False: 8.24k]
  ------------------
 2080|      0|        return (NULL);
 2081|  8.24k|    ctxt->nameNr--;
 2082|  8.24k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2082:9): [True: 7.82k, False: 426]
  ------------------
 2083|  7.82k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2084|    426|    else
 2085|    426|        ctxt->name = NULL;
 2086|  8.24k|    ret = ctxt->nameTab[ctxt->nameNr];
 2087|  8.24k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2088|  8.24k|    return (ret);
 2089|  8.24k|}
parser.c:xmlCheckCdataPush:
11519|    118|xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {
11520|    118|    int ix;
11521|    118|    unsigned char c;
11522|    118|    int codepoint;
11523|       |
11524|    118|    if ((utf == NULL) || (len <= 0))
  ------------------
  |  Branch (11524:9): [True: 0, False: 118]
  |  Branch (11524:26): [True: 2, False: 116]
  ------------------
11525|      2|        return(0);
11526|       |
11527|  11.9k|    for (ix = 0; ix < len;) {      /* string is 0-terminated */
  ------------------
  |  Branch (11527:18): [True: 11.8k, False: 100]
  ------------------
11528|  11.8k|        c = utf[ix];
11529|  11.8k|        if ((c & 0x80) == 0x00) {	/* 1-byte code, starts with 10 */
  ------------------
  |  Branch (11529:13): [True: 4.65k, False: 7.22k]
  ------------------
11530|  4.65k|	    if (c >= 0x20)
  ------------------
  |  Branch (11530:10): [True: 4.52k, False: 128]
  ------------------
11531|  4.52k|		ix++;
11532|    128|	    else if ((c == 0xA) || (c == 0xD) || (c == 0x9))
  ------------------
  |  Branch (11532:15): [True: 120, False: 8]
  |  Branch (11532:29): [True: 8, False: 0]
  |  Branch (11532:43): [True: 0, False: 0]
  ------------------
11533|    128|	        ix++;
11534|      0|	    else
11535|      0|	        return(-ix);
11536|  7.22k|	} else if ((c & 0xe0) == 0xc0) {/* 2-byte code, starts with 110 */
  ------------------
  |  Branch (11536:13): [True: 2.40k, False: 4.81k]
  ------------------
11537|  2.40k|	    if (ix + 2 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11537:10): [True: 2, False: 2.40k]
  |  Branch (11537:31): [True: 0, False: 2]
  ------------------
11538|  2.40k|	    if ((utf[ix+1] & 0xc0 ) != 0x80)
  ------------------
  |  Branch (11538:10): [True: 0, False: 2.40k]
  ------------------
11539|      0|	        return(-ix);
11540|  2.40k|	    codepoint = (utf[ix] & 0x1f) << 6;
11541|  2.40k|	    codepoint |= utf[ix+1] & 0x3f;
11542|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 4, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      4|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 4, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  109|      4|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |  110|      4|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 2.40k, False: 0]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11542:10): [True: 0, False: 2.40k]
  ------------------
11543|      0|	        return(-ix);
11544|  2.40k|	    ix += 2;
11545|  4.81k|	} else if ((c & 0xf0) == 0xe0) {/* 3-byte code, starts with 1110 */
  ------------------
  |  Branch (11545:13): [True: 2.40k, False: 2.40k]
  ------------------
11546|  2.40k|	    if (ix + 3 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11546:10): [True: 8, False: 2.40k]
  |  Branch (11546:31): [True: 4, False: 4]
  ------------------
11547|  2.40k|	    if (((utf[ix+1] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11547:10): [True: 0, False: 2.40k]
  ------------------
11548|  2.40k|	        ((utf[ix+2] & 0xc0) != 0x80))
  ------------------
  |  Branch (11548:10): [True: 0, False: 2.40k]
  ------------------
11549|      0|		    return(-ix);
11550|  2.40k|	    codepoint = (utf[ix] & 0xf) << 12;
11551|  2.40k|	    codepoint |= (utf[ix+1] & 0x3f) << 6;
11552|  2.40k|	    codepoint |= utf[ix+2] & 0x3f;
11553|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 2.40k, False: 0]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11553:10): [True: 0, False: 2.40k]
  ------------------
11554|      0|	        return(-ix);
11555|  2.40k|	    ix += 3;
11556|  2.40k|	} else if ((c & 0xf8) == 0xf0) {/* 4-byte code, starts with 11110 */
  ------------------
  |  Branch (11556:13): [True: 2.40k, False: 0]
  ------------------
11557|  2.40k|	    if (ix + 4 > len) return(complete ? -ix : ix);
  ------------------
  |  Branch (11557:10): [True: 6, False: 2.40k]
  |  Branch (11557:31): [True: 0, False: 6]
  ------------------
11558|  2.40k|	    if (((utf[ix+1] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11558:10): [True: 0, False: 2.40k]
  ------------------
11559|  2.40k|	        ((utf[ix+2] & 0xc0) != 0x80) ||
  ------------------
  |  Branch (11559:10): [True: 0, False: 2.40k]
  ------------------
11560|  2.40k|		((utf[ix+3] & 0xc0) != 0x80))
  ------------------
  |  Branch (11560:3): [True: 0, False: 2.40k]
  ------------------
11561|      0|		    return(-ix);
11562|  2.40k|	    codepoint = (utf[ix] & 0x7) << 18;
11563|  2.40k|	    codepoint |= (utf[ix+1] & 0x3f) << 12;
11564|  2.40k|	    codepoint |= (utf[ix+2] & 0x3f) << 6;
11565|  2.40k|	    codepoint |= utf[ix+3] & 0x3f;
11566|  2.40k|	    if (!xmlIsCharQ(codepoint))
  ------------------
  |  |  118|  2.40k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  ------------------
  |  |  |  Branch (118:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  119|  2.40k|				 xmlIsChar_ch((c)) :\
  |  |  ------------------
  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  120|  2.40k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  ------------------
  |  |  |  Branch (120:7): [True: 2.40k, False: 0]
  |  |  |  Branch (120:25): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  121|  2.40k|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  ------------------
  |  |  |  Branch (121:7): [True: 2.40k, False: 0]
  |  |  |  Branch (121:26): [True: 0, False: 2.40k]
  |  |  ------------------
  |  |  122|  2.40k|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  ------------------
  |  |  |  Branch (122:7): [True: 2.40k, False: 0]
  |  |  |  Branch (122:27): [True: 2.40k, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (11566:10): [True: 0, False: 2.40k]
  ------------------
11567|      0|	        return(-ix);
11568|  2.40k|	    ix += 4;
11569|  2.40k|	} else				/* unknown encoding */
11570|      0|	    return(-ix);
11571|  11.8k|      }
11572|    100|      return(ix);
11573|    116|}
parser.c:xmlParseLookupInternalSubset:
11405|  1.58k|xmlParseLookupInternalSubset(xmlParserCtxtPtr ctxt) {
11406|       |    /*
11407|       |     * Sorry, but progressive parsing of the internal subset is not
11408|       |     * supported. We first check that the full content of the internal
11409|       |     * subset is available and parsing is launched only at that point.
11410|       |     * Internal subset ends with "']' S? '>'" in an unescaped section and
11411|       |     * not in a ']]>' sequence which are conditional sections.
11412|       |     */
11413|  1.58k|    const xmlChar *cur, *start;
11414|  1.58k|    const xmlChar *end = ctxt->input->end;
11415|  1.58k|    int state = ctxt->endCheckState;
11416|  1.58k|    size_t index;
11417|       |
11418|  1.58k|    if (ctxt->checkIndex == 0) {
  ------------------
  |  Branch (11418:9): [True: 272, False: 1.31k]
  ------------------
11419|    272|        cur = ctxt->input->cur + 1;
11420|  1.31k|    } else {
11421|  1.31k|        cur = ctxt->input->cur + ctxt->checkIndex;
11422|  1.31k|    }
11423|  1.58k|    start = cur;
11424|       |
11425|   307k|    while (cur < end) {
  ------------------
  |  Branch (11425:12): [True: 306k, False: 1.32k]
  ------------------
11426|   306k|        if (state == '-') {
  ------------------
  |  Branch (11426:13): [True: 28.0k, False: 278k]
  ------------------
11427|  28.0k|            if ((*cur == '-') &&
  ------------------
  |  Branch (11427:17): [True: 496, False: 27.6k]
  ------------------
11428|  28.0k|                (cur[1] == '-') &&
  ------------------
  |  Branch (11428:17): [True: 298, False: 198]
  ------------------
11429|  28.0k|                (cur[2] == '>')) {
  ------------------
  |  Branch (11429:17): [True: 296, False: 2]
  ------------------
11430|    296|                state = 0;
11431|    296|                cur += 3;
11432|    296|                start = cur;
11433|    296|                continue;
11434|    296|            }
11435|  28.0k|        }
11436|   278k|        else if (state == ']') {
  ------------------
  |  Branch (11436:18): [True: 262, False: 278k]
  ------------------
11437|    262|            if (*cur == '>') {
  ------------------
  |  Branch (11437:17): [True: 258, False: 4]
  ------------------
11438|    258|                ctxt->checkIndex = 0;
11439|    258|                ctxt->endCheckState = 0;
11440|    258|                return(1);
11441|    258|            }
11442|      4|            if (IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11443|      4|                state = ' ';
11444|      4|            } else if (*cur != ']') {
  ------------------
  |  Branch (11444:24): [True: 0, False: 0]
  ------------------
11445|      0|                state = 0;
11446|      0|                start = cur;
11447|      0|                continue;
11448|      0|            }
11449|      4|        }
11450|   278k|        else if (state == ' ') {
  ------------------
  |  Branch (11450:18): [True: 10, False: 278k]
  ------------------
11451|     10|            if (*cur == '>') {
  ------------------
  |  Branch (11451:17): [True: 4, False: 6]
  ------------------
11452|      4|                ctxt->checkIndex = 0;
11453|      4|                ctxt->endCheckState = 0;
11454|      4|                return(1);
11455|      4|            }
11456|      6|            if (!IS_BLANK_CH(*cur)) {
  ------------------
  |  |  151|      6|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      6|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 6, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      6|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      6|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11457|      0|                state = 0;
11458|      0|                start = cur;
11459|      0|                continue;
11460|      0|            }
11461|      6|        }
11462|   278k|        else if (state != 0) {
  ------------------
  |  Branch (11462:18): [True: 202k, False: 75.8k]
  ------------------
11463|   202k|            if (*cur == state) {
  ------------------
  |  Branch (11463:17): [True: 1.46k, False: 201k]
  ------------------
11464|  1.46k|                state = 0;
11465|  1.46k|                start = cur + 1;
11466|  1.46k|            }
11467|   202k|        }
11468|  75.8k|        else if (*cur == '<') {
  ------------------
  |  Branch (11468:18): [True: 1.82k, False: 73.9k]
  ------------------
11469|  1.82k|            if ((cur[1] == '!') &&
  ------------------
  |  Branch (11469:17): [True: 1.81k, False: 11]
  ------------------
11470|  1.82k|                (cur[2] == '-') &&
  ------------------
  |  Branch (11470:17): [True: 299, False: 1.51k]
  ------------------
11471|  1.82k|                (cur[3] == '-')) {
  ------------------
  |  Branch (11471:17): [True: 296, False: 3]
  ------------------
11472|    296|                state = '-';
11473|    296|                cur += 4;
11474|       |                /* Don't treat <!--> as comment */
11475|    296|                start = cur;
11476|    296|                continue;
11477|    296|            }
11478|  1.82k|        }
11479|  73.9k|        else if ((*cur == '"') || (*cur == '\'') || (*cur == ']')) {
  ------------------
  |  Branch (11479:18): [True: 770, False: 73.2k]
  |  Branch (11479:35): [True: 690, False: 72.5k]
  |  Branch (11479:53): [True: 262, False: 72.2k]
  ------------------
11480|  1.72k|            state = *cur;
11481|  1.72k|        }
11482|       |
11483|   305k|        cur++;
11484|   305k|    }
11485|       |
11486|       |    /*
11487|       |     * Rescan the three last characters to detect "<!--" and "-->"
11488|       |     * split across chunks.
11489|       |     */
11490|  1.32k|    if ((state == 0) || (state == '-')) {
  ------------------
  |  Branch (11490:9): [True: 235, False: 1.09k]
  |  Branch (11490:25): [True: 114, False: 976]
  ------------------
11491|    349|        if (cur - start < 3)
  ------------------
  |  Branch (11491:13): [True: 31, False: 318]
  ------------------
11492|     31|            cur = start;
11493|    318|        else
11494|    318|            cur -= 3;
11495|    349|    }
11496|  1.32k|    index = cur - ctxt->input->cur;
11497|  1.32k|    if (index > LONG_MAX) {
  ------------------
  |  Branch (11497:9): [True: 0, False: 1.32k]
  ------------------
11498|      0|        ctxt->checkIndex = 0;
11499|      0|        ctxt->endCheckState = 0;
11500|      0|        return(1);
11501|      0|    }
11502|  1.32k|    ctxt->checkIndex = index;
11503|  1.32k|    ctxt->endCheckState = state;
11504|  1.32k|    return(0);
11505|  1.32k|}
parser.c:xmlParseExternalEntityPrivate:
12653|     30|		      const xmlChar *ID, xmlNodePtr *list) {
12654|     30|    xmlParserCtxtPtr ctxt;
12655|     30|    xmlDocPtr newDoc;
12656|     30|    xmlNodePtr newRoot;
12657|     30|    xmlParserErrors ret = XML_ERR_OK;
12658|       |
12659|     30|    if (((depth > 40) &&
  ------------------
  |  Branch (12659:10): [True: 0, False: 30]
  ------------------
12660|     30|	((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (12660:3): [True: 0, False: 0]
  |  Branch (12660:24): [True: 0, False: 0]
  ------------------
12661|     30|	(depth > 100)) {
  ------------------
  |  Branch (12661:2): [True: 0, False: 30]
  ------------------
12662|      0|	xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,
12663|      0|                       "Maximum entity nesting depth exceeded");
12664|      0|        return(XML_ERR_ENTITY_LOOP);
12665|      0|    }
12666|       |
12667|     30|    if (list != NULL)
  ------------------
  |  Branch (12667:9): [True: 30, False: 0]
  ------------------
12668|     30|        *list = NULL;
12669|     30|    if ((URL == NULL) && (ID == NULL))
  ------------------
  |  Branch (12669:9): [True: 0, False: 30]
  |  Branch (12669:26): [True: 0, False: 0]
  ------------------
12670|      0|	return(XML_ERR_INTERNAL_ERROR);
12671|     30|    if (doc == NULL)
  ------------------
  |  Branch (12671:9): [True: 0, False: 30]
  ------------------
12672|      0|	return(XML_ERR_INTERNAL_ERROR);
12673|       |
12674|     30|    ctxt = xmlCreateEntityParserCtxtInternal(sax, user_data, URL, ID, NULL,
12675|     30|                                             oldctxt);
12676|     30|    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
  ------------------
  |  Branch (12676:9): [True: 3, False: 27]
  ------------------
12677|     27|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12677:9): [True: 27, False: 0]
  ------------------
12678|     27|        ctxt->nbErrors = oldctxt->nbErrors;
12679|     27|        ctxt->nbWarnings = oldctxt->nbWarnings;
12680|     27|    }
12681|     27|    xmlDetectSAX2(ctxt);
12682|       |
12683|     27|    newDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|     27|#define BAD_CAST (xmlChar *)
  ------------------
12684|     27|    if (newDoc == NULL) {
  ------------------
  |  Branch (12684:9): [True: 0, False: 27]
  ------------------
12685|      0|	xmlFreeParserCtxt(ctxt);
12686|      0|	return(XML_ERR_INTERNAL_ERROR);
12687|      0|    }
12688|     27|    newDoc->properties = XML_DOC_INTERNAL;
12689|     27|    if (doc) {
  ------------------
  |  Branch (12689:9): [True: 27, False: 0]
  ------------------
12690|     27|        newDoc->intSubset = doc->intSubset;
12691|     27|        newDoc->extSubset = doc->extSubset;
12692|     27|        if (doc->dict) {
  ------------------
  |  Branch (12692:13): [True: 27, False: 0]
  ------------------
12693|     27|            newDoc->dict = doc->dict;
12694|     27|            xmlDictReference(newDoc->dict);
12695|     27|        }
12696|     27|        if (doc->URL != NULL) {
  ------------------
  |  Branch (12696:13): [True: 18, False: 9]
  ------------------
12697|     18|            newDoc->URL = xmlStrdup(doc->URL);
12698|     18|        }
12699|     27|    }
12700|     27|    newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST "pseudoroot", NULL);
  ------------------
  |  |   35|     27|#define BAD_CAST (xmlChar *)
  ------------------
12701|     27|    if (newRoot == NULL) {
  ------------------
  |  Branch (12701:9): [True: 0, False: 27]
  ------------------
12702|      0|	if (sax != NULL)
  ------------------
  |  Branch (12702:6): [True: 0, False: 0]
  ------------------
12703|      0|	xmlFreeParserCtxt(ctxt);
12704|      0|	newDoc->intSubset = NULL;
12705|      0|	newDoc->extSubset = NULL;
12706|      0|        xmlFreeDoc(newDoc);
12707|      0|	return(XML_ERR_INTERNAL_ERROR);
12708|      0|    }
12709|     27|    xmlAddChild((xmlNodePtr) newDoc, newRoot);
12710|     27|    nodePush(ctxt, newDoc->children);
12711|     27|    if (doc == NULL) {
  ------------------
  |  Branch (12711:9): [True: 0, False: 27]
  ------------------
12712|      0|        ctxt->myDoc = newDoc;
12713|     27|    } else {
12714|     27|        ctxt->myDoc = doc;
12715|     27|        newRoot->doc = doc;
12716|     27|    }
12717|       |
12718|     27|    xmlDetectEncoding(ctxt);
12719|       |
12720|       |    /*
12721|       |     * Parse a possible text declaration first
12722|       |     */
12723|     27|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|     27|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|     54|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 12, False: 15]
  |  |  |  |  |  Branch (2228:41): [True: 3, False: 9]
  |  |  |  |  ------------------
  |  |  |  | 2229|     27|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 3, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 3, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|      3|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      3|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 3, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      3|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      3|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
12724|      3|	xmlParseTextDecl(ctxt);
12725|       |        /*
12726|       |         * An XML-1.0 document can't reference an entity not XML-1.0
12727|       |         */
12728|      3|        if ((xmlStrEqual(oldctxt->version, BAD_CAST "1.0")) &&
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12728:13): [True: 3, False: 0]
  ------------------
12729|      3|            (!xmlStrEqual(ctxt->input->version, BAD_CAST "1.0"))) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (12729:13): [True: 0, False: 3]
  ------------------
12730|      0|            xmlFatalErrMsg(ctxt, XML_ERR_VERSION_MISMATCH,
12731|      0|                           "Version mismatch between document and entity\n");
12732|      0|        }
12733|      3|    }
12734|       |
12735|     27|    ctxt->instate = XML_PARSER_CONTENT;
12736|     27|    ctxt->depth = depth;
12737|     27|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12737:9): [True: 27, False: 0]
  ------------------
12738|     27|	ctxt->_private = oldctxt->_private;
12739|     27|	ctxt->loadsubset = oldctxt->loadsubset;
12740|     27|	ctxt->validate = oldctxt->validate;
12741|     27|	ctxt->valid = oldctxt->valid;
12742|     27|	ctxt->replaceEntities = oldctxt->replaceEntities;
12743|     27|        if (oldctxt->validate) {
  ------------------
  |  Branch (12743:13): [True: 0, False: 27]
  ------------------
12744|      0|            ctxt->vctxt.error = oldctxt->vctxt.error;
12745|      0|            ctxt->vctxt.warning = oldctxt->vctxt.warning;
12746|      0|            ctxt->vctxt.userData = oldctxt->vctxt.userData;
12747|      0|            ctxt->vctxt.flags = oldctxt->vctxt.flags;
12748|      0|        }
12749|     27|	ctxt->external = oldctxt->external;
12750|     27|        if (ctxt->dict) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (12750:13): [True: 27, False: 0]
  ------------------
12751|     27|        ctxt->dict = oldctxt->dict;
12752|     27|        ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|     27|#define BAD_CAST (xmlChar *)
  ------------------
12753|     27|        ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|     27|#define BAD_CAST (xmlChar *)
  ------------------
12754|     27|        ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|     27|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
12755|     27|        ctxt->dictNames = oldctxt->dictNames;
12756|     27|        ctxt->attsDefault = oldctxt->attsDefault;
12757|     27|        ctxt->attsSpecial = oldctxt->attsSpecial;
12758|     27|        ctxt->linenumbers = oldctxt->linenumbers;
12759|     27|	ctxt->record_info = oldctxt->record_info;
12760|     27|	ctxt->node_seq.maximum = oldctxt->node_seq.maximum;
12761|     27|	ctxt->node_seq.length = oldctxt->node_seq.length;
12762|     27|	ctxt->node_seq.buffer = oldctxt->node_seq.buffer;
12763|     27|    } else {
12764|       |	/*
12765|       |	 * Doing validity checking on chunk without context
12766|       |	 * doesn't make sense
12767|       |	 */
12768|      0|	ctxt->_private = NULL;
12769|      0|	ctxt->validate = 0;
12770|      0|	ctxt->external = 2;
12771|      0|	ctxt->loadsubset = 0;
12772|      0|    }
12773|       |
12774|     27|    xmlParseContent(ctxt);
12775|       |
12776|     27|    if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2221|     27|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (12776:9): [True: 0, False: 27]
  |  Branch (12776:25): [True: 0, False: 0]
  ------------------
12777|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
12778|     27|    } else if (RAW != 0) {
  ------------------
  |  | 2221|     27|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (12778:16): [True: 0, False: 27]
  ------------------
12779|      0|	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
12780|      0|    }
12781|     27|    if (ctxt->node != newDoc->children) {
  ------------------
  |  Branch (12781:9): [True: 3, False: 24]
  ------------------
12782|      3|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
12783|      3|    }
12784|       |
12785|     27|    if (!ctxt->wellFormed) {
  ------------------
  |  Branch (12785:9): [True: 12, False: 15]
  ------------------
12786|     12|	ret = (xmlParserErrors)ctxt->errNo;
12787|     12|        if (oldctxt != NULL) {
  ------------------
  |  Branch (12787:13): [True: 12, False: 0]
  ------------------
12788|     12|            oldctxt->errNo = ctxt->errNo;
12789|     12|            oldctxt->wellFormed = 0;
12790|     12|            xmlCopyError(&ctxt->lastError, &oldctxt->lastError);
12791|     12|        }
12792|     15|    } else {
12793|     15|	if (list != NULL) {
  ------------------
  |  Branch (12793:6): [True: 15, False: 0]
  ------------------
12794|     15|	    xmlNodePtr cur;
12795|       |
12796|       |	    /*
12797|       |	     * Return the newly created nodeset after unlinking it from
12798|       |	     * they pseudo parent.
12799|       |	     */
12800|     15|	    cur = newDoc->children->children;
12801|     15|	    *list = cur;
12802|     39|	    while (cur != NULL) {
  ------------------
  |  Branch (12802:13): [True: 24, False: 15]
  ------------------
12803|     24|		cur->parent = NULL;
12804|     24|		cur = cur->next;
12805|     24|	    }
12806|     15|            newDoc->children->children = NULL;
12807|     15|	}
12808|     15|	ret = XML_ERR_OK;
12809|     15|    }
12810|       |
12811|       |    /*
12812|       |     * Also record the size of the entity parsed
12813|       |     */
12814|     27|    if (ctxt->input != NULL && oldctxt != NULL) {
  ------------------
  |  Branch (12814:9): [True: 27, False: 0]
  |  Branch (12814:32): [True: 27, False: 0]
  ------------------
12815|     27|        unsigned long consumed = ctxt->input->consumed;
12816|       |
12817|     27|        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);
12818|       |
12819|     27|        xmlSaturatedAdd(&oldctxt->sizeentities, consumed);
12820|     27|        xmlSaturatedAdd(&oldctxt->sizeentities, ctxt->sizeentities);
12821|       |
12822|     27|        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);
12823|     27|        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);
12824|     27|    }
12825|       |
12826|     27|    if (oldctxt != NULL) {
  ------------------
  |  Branch (12826:9): [True: 27, False: 0]
  ------------------
12827|     27|        ctxt->dict = NULL;
12828|     27|        ctxt->attsDefault = NULL;
12829|     27|        ctxt->attsSpecial = NULL;
12830|     27|        oldctxt->nbErrors = ctxt->nbErrors;
12831|     27|        oldctxt->nbWarnings = ctxt->nbWarnings;
12832|     27|        oldctxt->validate = ctxt->validate;
12833|     27|        oldctxt->valid = ctxt->valid;
12834|     27|        oldctxt->node_seq.maximum = ctxt->node_seq.maximum;
12835|     27|        oldctxt->node_seq.length = ctxt->node_seq.length;
12836|     27|        oldctxt->node_seq.buffer = ctxt->node_seq.buffer;
12837|     27|    }
12838|     27|    ctxt->node_seq.maximum = 0;
12839|     27|    ctxt->node_seq.length = 0;
12840|     27|    ctxt->node_seq.buffer = NULL;
12841|     27|    xmlFreeParserCtxt(ctxt);
12842|     27|    newDoc->intSubset = NULL;
12843|     27|    newDoc->extSubset = NULL;
12844|     27|    xmlFreeDoc(newDoc);
12845|       |
12846|     27|    return(ret);
12847|     27|}
parser.c:xmlParseBalancedChunkMemoryInternal:
12928|    327|	const xmlChar *string, void *user_data, xmlNodePtr *lst) {
12929|    327|    xmlParserCtxtPtr ctxt;
12930|    327|    xmlDocPtr newDoc = NULL;
12931|    327|    xmlNodePtr newRoot;
12932|    327|    xmlSAXHandlerPtr oldsax = NULL;
12933|    327|    xmlNodePtr content = NULL;
12934|    327|    xmlNodePtr last = NULL;
12935|    327|    xmlParserErrors ret = XML_ERR_OK;
12936|    327|    xmlHashedString hprefix, huri;
12937|    327|    unsigned i;
12938|       |
12939|    327|    if (((oldctxt->depth > 40) && ((oldctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (12939:10): [True: 3, False: 324]
  |  Branch (12939:35): [True: 3, False: 0]
  ------------------
12940|    327|        (oldctxt->depth >  100)) {
  ------------------
  |  Branch (12940:9): [True: 0, False: 324]
  ------------------
12941|      3|	xmlFatalErrMsg(oldctxt, XML_ERR_ENTITY_LOOP,
12942|      3|                       "Maximum entity nesting depth exceeded");
12943|      3|	return(XML_ERR_ENTITY_LOOP);
12944|      3|    }
12945|       |
12946|       |
12947|    324|    if (lst != NULL)
  ------------------
  |  Branch (12947:9): [True: 324, False: 0]
  ------------------
12948|    324|        *lst = NULL;
12949|    324|    if (string == NULL)
  ------------------
  |  Branch (12949:9): [True: 0, False: 324]
  ------------------
12950|      0|        return(XML_ERR_INTERNAL_ERROR);
12951|       |
12952|    324|    ctxt = xmlCreateDocParserCtxt(string);
12953|    324|    if (ctxt == NULL) return(XML_WAR_UNDECLARED_ENTITY);
  ------------------
  |  Branch (12953:9): [True: 0, False: 324]
  ------------------
12954|    324|    ctxt->nbErrors = oldctxt->nbErrors;
12955|    324|    ctxt->nbWarnings = oldctxt->nbWarnings;
12956|    324|    if (user_data != NULL)
  ------------------
  |  Branch (12956:9): [True: 0, False: 324]
  ------------------
12957|      0|	ctxt->userData = user_data;
12958|    324|    else
12959|    324|	ctxt->userData = ctxt;
12960|    324|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (12960:9): [True: 324, False: 0]
  ------------------
12961|    324|    ctxt->dict = oldctxt->dict;
12962|    324|    ctxt->input_id = oldctxt->input_id;
12963|    324|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|    324|#define BAD_CAST (xmlChar *)
  ------------------
12964|    324|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|    324|#define BAD_CAST (xmlChar *)
  ------------------
12965|    324|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|    324|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
12966|       |
12967|       |    /*
12968|       |     * Propagate namespaces down the entity
12969|       |     *
12970|       |     * Making entities and namespaces work correctly requires additional
12971|       |     * changes, see xmlParseReference.
12972|       |     */
12973|       |
12974|       |    /* Default namespace */
12975|    324|    hprefix.name = NULL;
12976|    324|    hprefix.hashValue = 0;
12977|    324|    huri.name = xmlParserNsLookupUri(oldctxt, &hprefix);
12978|    324|    huri.hashValue = 0;
12979|    324|    if (huri.name != NULL)
  ------------------
  |  Branch (12979:9): [True: 3, False: 321]
  ------------------
12980|      3|        xmlParserNsPush(ctxt, NULL, &huri, NULL, 0);
12981|       |
12982|    372|    for (i = 0; i < oldctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (12982:17): [True: 48, False: 324]
  ------------------
12983|     48|        xmlParserNsBucket *bucket = &oldctxt->nsdb->hash[i];
12984|     48|        const xmlChar **ns;
12985|     48|        xmlParserNsExtra *extra;
12986|     48|        unsigned nsIndex;
12987|       |
12988|     48|        if ((bucket->hashValue != 0) &&
  ------------------
  |  Branch (12988:13): [True: 3, False: 45]
  ------------------
12989|     48|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (12989:13): [True: 3, False: 0]
  ------------------
12990|      3|            nsIndex = bucket->index;
12991|      3|            ns = &oldctxt->nsTab[nsIndex * 2];
12992|      3|            extra = &oldctxt->nsdb->extra[nsIndex];
12993|       |
12994|      3|            hprefix.name = ns[0];
12995|      3|            hprefix.hashValue = bucket->hashValue;
12996|      3|            huri.name = ns[1];
12997|      3|            huri.hashValue = extra->uriHashValue;
12998|       |            /*
12999|       |             * Don't copy SAX data to avoid a use-after-free with XML reader.
13000|       |             * This matches the pre-2.12 behavior.
13001|       |             */
13002|      3|            xmlParserNsPush(ctxt, &hprefix, &huri, NULL, 0);
13003|      3|        }
13004|     48|    }
13005|       |
13006|    324|    oldsax = ctxt->sax;
13007|    324|    ctxt->sax = oldctxt->sax;
13008|    324|    xmlDetectSAX2(ctxt);
13009|    324|    ctxt->replaceEntities = oldctxt->replaceEntities;
13010|    324|    ctxt->options = oldctxt->options;
13011|       |
13012|    324|    ctxt->_private = oldctxt->_private;
13013|    324|    if (oldctxt->myDoc == NULL) {
  ------------------
  |  Branch (13013:9): [True: 0, False: 324]
  ------------------
13014|      0|	newDoc = xmlNewDoc(BAD_CAST "1.0");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
13015|      0|	if (newDoc == NULL) {
  ------------------
  |  Branch (13015:6): [True: 0, False: 0]
  ------------------
13016|      0|            ret = XML_ERR_INTERNAL_ERROR;
13017|      0|            goto error;
13018|      0|	}
13019|      0|	newDoc->properties = XML_DOC_INTERNAL;
13020|      0|	newDoc->dict = ctxt->dict;
13021|      0|	xmlDictReference(newDoc->dict);
13022|      0|	ctxt->myDoc = newDoc;
13023|    324|    } else {
13024|    324|	ctxt->myDoc = oldctxt->myDoc;
13025|    324|        content = ctxt->myDoc->children;
13026|    324|	last = ctxt->myDoc->last;
13027|    324|    }
13028|    324|    newRoot = xmlNewDocNode(ctxt->myDoc, NULL, BAD_CAST "pseudoroot", NULL);
  ------------------
  |  |   35|    324|#define BAD_CAST (xmlChar *)
  ------------------
13029|    324|    if (newRoot == NULL) {
  ------------------
  |  Branch (13029:9): [True: 0, False: 324]
  ------------------
13030|      0|        ret = XML_ERR_INTERNAL_ERROR;
13031|      0|        goto error;
13032|      0|    }
13033|    324|    ctxt->myDoc->children = NULL;
13034|    324|    ctxt->myDoc->last = NULL;
13035|    324|    xmlAddChild((xmlNodePtr) ctxt->myDoc, newRoot);
13036|    324|    nodePush(ctxt, ctxt->myDoc->children);
13037|    324|    ctxt->instate = XML_PARSER_CONTENT;
13038|    324|    ctxt->depth = oldctxt->depth;
13039|       |
13040|    324|    ctxt->validate = 0;
13041|    324|    ctxt->loadsubset = oldctxt->loadsubset;
13042|    324|    if ((oldctxt->validate) || (oldctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (13042:9): [True: 0, False: 324]
  |  Branch (13042:32): [True: 324, False: 0]
  ------------------
13043|       |	/*
13044|       |	 * ID/IDREF registration will be done in xmlValidateElement below
13045|       |	 */
13046|    324|	ctxt->loadsubset |= XML_SKIP_IDS;
  ------------------
  |  |  158|    324|#define XML_SKIP_IDS		8
  ------------------
13047|    324|    }
13048|    324|    ctxt->dictNames = oldctxt->dictNames;
13049|    324|    ctxt->attsDefault = oldctxt->attsDefault;
13050|    324|    ctxt->attsSpecial = oldctxt->attsSpecial;
13051|       |
13052|    324|    xmlParseContent(ctxt);
13053|    324|    if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2221|    324|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '/')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (13053:9): [True: 0, False: 324]
  |  Branch (13053:25): [True: 0, False: 0]
  ------------------
13054|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13055|    324|    } else if (RAW != 0) {
  ------------------
  |  | 2221|    324|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (13055:16): [True: 0, False: 324]
  ------------------
13056|      0|	xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);
13057|      0|    }
13058|    324|    if (ctxt->node != ctxt->myDoc->children) {
  ------------------
  |  Branch (13058:9): [True: 0, False: 324]
  ------------------
13059|      0|	xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);
13060|      0|    }
13061|       |
13062|    324|    if (!ctxt->wellFormed) {
  ------------------
  |  Branch (13062:9): [True: 129, False: 195]
  ------------------
13063|    129|	ret = (xmlParserErrors)ctxt->errNo;
13064|    129|        oldctxt->errNo = ctxt->errNo;
13065|    129|        oldctxt->wellFormed = 0;
13066|    129|        xmlCopyError(&ctxt->lastError, &oldctxt->lastError);
13067|    195|    } else {
13068|    195|        ret = XML_ERR_OK;
13069|    195|    }
13070|       |
13071|    324|    if ((lst != NULL) && (ret == XML_ERR_OK)) {
  ------------------
  |  Branch (13071:9): [True: 324, False: 0]
  |  Branch (13071:26): [True: 195, False: 129]
  ------------------
13072|    195|	xmlNodePtr cur;
13073|       |
13074|       |	/*
13075|       |	 * Return the newly created nodeset after unlinking it from
13076|       |	 * they pseudo parent.
13077|       |	 */
13078|    195|	cur = ctxt->myDoc->children->children;
13079|    195|	*lst = cur;
13080|    441|	while (cur != NULL) {
  ------------------
  |  Branch (13080:9): [True: 246, False: 195]
  ------------------
13081|    246|#ifdef LIBXML_VALID_ENABLED
13082|    246|	    if ((oldctxt->validate) && (oldctxt->wellFormed) &&
  ------------------
  |  Branch (13082:10): [True: 0, False: 246]
  |  Branch (13082:33): [True: 0, False: 0]
  ------------------
13083|    246|		(oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&
  ------------------
  |  Branch (13083:3): [True: 0, False: 0]
  |  Branch (13083:23): [True: 0, False: 0]
  ------------------
13084|    246|		(cur->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (13084:3): [True: 0, False: 0]
  ------------------
13085|      0|		oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,
13086|      0|			oldctxt->myDoc, cur);
13087|      0|	    }
13088|    246|#endif /* LIBXML_VALID_ENABLED */
13089|    246|	    cur->parent = NULL;
13090|    246|	    cur = cur->next;
13091|    246|	}
13092|    195|	ctxt->myDoc->children->children = NULL;
13093|    195|    }
13094|    324|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (13094:9): [True: 324, False: 0]
  ------------------
13095|    324|	xmlFreeNode(ctxt->myDoc->children);
13096|    324|        ctxt->myDoc->children = content;
13097|    324|        ctxt->myDoc->last = last;
13098|    324|    }
13099|       |
13100|       |    /*
13101|       |     * Also record the size of the entity parsed
13102|       |     */
13103|    324|    if (ctxt->input != NULL && oldctxt != NULL) {
  ------------------
  |  Branch (13103:9): [True: 324, False: 0]
  |  Branch (13103:32): [True: 324, False: 0]
  ------------------
13104|    324|        unsigned long consumed = ctxt->input->consumed;
13105|       |
13106|    324|        xmlSaturatedAddSizeT(&consumed, ctxt->input->cur - ctxt->input->base);
13107|       |
13108|    324|        xmlSaturatedAdd(&oldctxt->sizeentcopy, consumed);
13109|    324|        xmlSaturatedAdd(&oldctxt->sizeentcopy, ctxt->sizeentcopy);
13110|    324|    }
13111|       |
13112|    324|    oldctxt->nbErrors = ctxt->nbErrors;
13113|    324|    oldctxt->nbWarnings = ctxt->nbWarnings;
13114|       |
13115|    324|error:
13116|    324|    ctxt->sax = oldsax;
13117|    324|    ctxt->dict = NULL;
13118|    324|    ctxt->attsDefault = NULL;
13119|    324|    ctxt->attsSpecial = NULL;
13120|    324|    xmlFreeParserCtxt(ctxt);
13121|    324|    if (newDoc != NULL) {
  ------------------
  |  Branch (13121:9): [True: 0, False: 324]
  ------------------
13122|      0|	xmlFreeDoc(newDoc);
13123|      0|    }
13124|       |
13125|    324|    return(ret);
13126|    324|}
parser.c:xmlParserNsPush:
 1664|    339|                const xmlHashedString *uri, void *saxData, int defAttr) {
 1665|    339|    xmlParserNsBucket *bucket = NULL;
 1666|    339|    xmlParserNsExtra *extra;
 1667|    339|    const xmlChar **ns;
 1668|    339|    unsigned hashValue, nsIndex, oldIndex;
 1669|       |
 1670|    339|    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))
  ------------------
  |  Branch (1670:9): [True: 240, False: 99]
  |  Branch (1670:29): [True: 0, False: 240]
  ------------------
 1671|      0|        return(0);
 1672|       |
 1673|    339|    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {
  ------------------
  |  Branch (1673:9): [True: 216, False: 123]
  |  Branch (1673:40): [True: 0, False: 216]
  ------------------
 1674|      0|        xmlErrMemory(ctxt, NULL);
 1675|      0|        return(-1);
 1676|      0|    }
 1677|       |
 1678|       |    /*
 1679|       |     * Default namespace and 'xml' namespace
 1680|       |     */
 1681|    339|    if ((prefix == NULL) || (prefix->name == NULL)) {
  ------------------
  |  Branch (1681:9): [True: 99, False: 240]
  |  Branch (1681:29): [True: 0, False: 240]
  ------------------
 1682|     99|        oldIndex = ctxt->nsdb->defaultNsIndex;
 1683|       |
 1684|     99|        if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1684:13): [True: 12, False: 87]
  ------------------
 1685|     12|            if (defAttr != 0)
  ------------------
  |  Branch (1685:17): [True: 3, False: 9]
  ------------------
 1686|      3|                return(0);
 1687|       |
 1688|      9|            extra = &ctxt->nsdb->extra[oldIndex];
 1689|       |
 1690|      9|            if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1690:17): [True: 3, False: 6]
  ------------------
 1691|      3|                xmlErrAttributeDup(ctxt, NULL, BAD_CAST "xmlns");
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1692|      3|                return(0);
 1693|      3|            }
 1694|       |
 1695|      6|            if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1695:17): [True: 0, False: 6]
  ------------------
 1696|      6|                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))
  ------------------
  |  Branch (1696:17): [True: 0, False: 0]
  ------------------
 1697|      0|                return(0);
 1698|      6|        }
 1699|       |
 1700|     93|        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;
 1701|     93|        goto populate_entry;
 1702|     99|    }
 1703|       |
 1704|       |    /*
 1705|       |     * Hash table lookup
 1706|       |     */
 1707|    240|    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);
 1708|    240|    if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1708:9): [True: 12, False: 228]
  ------------------
 1709|     12|        extra = &ctxt->nsdb->extra[oldIndex];
 1710|       |
 1711|     12|        if (defAttr != 0)
  ------------------
  |  Branch (1711:13): [True: 9, False: 3]
  ------------------
 1712|      9|            return(0);
 1713|       |
 1714|       |        /*
 1715|       |         * Check for duplicate definitions on the same element.
 1716|       |         */
 1717|      3|        if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1717:13): [True: 3, False: 0]
  ------------------
 1718|      3|            xmlErrAttributeDup(ctxt, BAD_CAST "xmlns", prefix->name);
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1719|      3|            return(0);
 1720|      3|        }
 1721|       |
 1722|      0|        if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1722:13): [True: 0, False: 0]
  ------------------
 1723|      0|            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))
  ------------------
  |  Branch (1723:13): [True: 0, False: 0]
  ------------------
 1724|      0|            return(0);
 1725|       |
 1726|      0|        bucket->index = ctxt->nsNr;
 1727|      0|        goto populate_entry;
 1728|      0|    }
 1729|       |
 1730|       |    /*
 1731|       |     * Insert new bucket
 1732|       |     */
 1733|       |
 1734|    228|    hashValue = prefix->hashValue;
 1735|       |
 1736|       |    /*
 1737|       |     * Grow hash table, 50% fill factor
 1738|       |     */
 1739|    228|    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize / 2) {
  ------------------
  |  Branch (1739:9): [True: 165, False: 63]
  ------------------
 1740|    165|        xmlParserNsBucket *newHash;
 1741|    165|        unsigned newSize, i, index;
 1742|       |
 1743|    165|        if (ctxt->nsdb->hashSize > UINT_MAX / 2) {
  ------------------
  |  Branch (1743:13): [True: 0, False: 165]
  ------------------
 1744|      0|            xmlErrMemory(ctxt, NULL);
 1745|      0|            return(-1);
 1746|      0|        }
 1747|    165|        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;
  ------------------
  |  Branch (1747:19): [True: 0, False: 165]
  ------------------
 1748|    165|        newHash = xmlMalloc(newSize * sizeof(newHash[0]));
 1749|    165|        if (newHash == NULL) {
  ------------------
  |  Branch (1749:13): [True: 0, False: 165]
  ------------------
 1750|      0|            xmlErrMemory(ctxt, NULL);
 1751|      0|            return(-1);
 1752|      0|        }
 1753|    165|        memset(newHash, 0, newSize * sizeof(newHash[0]));
 1754|       |
 1755|    165|        for (i = 0; i < ctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (1755:21): [True: 0, False: 165]
  ------------------
 1756|      0|            unsigned hv = ctxt->nsdb->hash[i].hashValue;
 1757|      0|            unsigned newIndex;
 1758|       |
 1759|      0|            if (hv == 0)
  ------------------
  |  Branch (1759:17): [True: 0, False: 0]
  ------------------
 1760|      0|                continue;
 1761|      0|            newIndex = hv & (newSize - 1);
 1762|       |
 1763|      0|            while (newHash[newIndex].hashValue != 0) {
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|                newIndex++;
 1765|      0|                if (newIndex == newSize)
  ------------------
  |  Branch (1765:21): [True: 0, False: 0]
  ------------------
 1766|      0|                    newIndex = 0;
 1767|      0|            }
 1768|       |
 1769|      0|            newHash[newIndex] = ctxt->nsdb->hash[i];
 1770|      0|        }
 1771|       |
 1772|    165|        xmlFree(ctxt->nsdb->hash);
 1773|    165|        ctxt->nsdb->hash = newHash;
 1774|    165|        ctxt->nsdb->hashSize = newSize;
 1775|       |
 1776|       |        /*
 1777|       |         * Relookup
 1778|       |         */
 1779|    165|        index = hashValue & (newSize - 1);
 1780|       |
 1781|    165|        while (newHash[index].hashValue != 0) {
  ------------------
  |  Branch (1781:16): [True: 0, False: 165]
  ------------------
 1782|      0|            index++;
 1783|      0|            if (index == newSize)
  ------------------
  |  Branch (1783:17): [True: 0, False: 0]
  ------------------
 1784|      0|                index = 0;
 1785|      0|        }
 1786|       |
 1787|    165|        bucket = &newHash[index];
 1788|    165|    }
 1789|       |
 1790|    228|    bucket->hashValue = hashValue;
 1791|    228|    bucket->index = ctxt->nsNr;
 1792|    228|    ctxt->nsdb->hashElems++;
 1793|    228|    oldIndex = INT_MAX;
 1794|       |
 1795|    321|populate_entry:
 1796|    321|    nsIndex = ctxt->nsNr;
 1797|       |
 1798|    321|    ns = &ctxt->nsTab[nsIndex * 2];
 1799|    321|    ns[0] = prefix ? prefix->name : NULL;
  ------------------
  |  Branch (1799:13): [True: 228, False: 93]
  ------------------
 1800|    321|    ns[1] = uri->name;
 1801|       |
 1802|    321|    extra = &ctxt->nsdb->extra[nsIndex];
 1803|    321|    extra->saxData = saxData;
 1804|    321|    extra->prefixHashValue = prefix ? prefix->hashValue : 0;
  ------------------
  |  Branch (1804:30): [True: 228, False: 93]
  ------------------
 1805|    321|    extra->uriHashValue = uri->hashValue;
 1806|    321|    extra->elementId = ctxt->nsdb->elementId;
 1807|    321|    extra->oldIndex = oldIndex;
 1808|       |
 1809|    321|    ctxt->nsNr++;
 1810|       |
 1811|    321|    return(1);
 1812|    228|}
parser.c:xmlParserNsGrow:
 1622|    216|xmlParserNsGrow(xmlParserCtxtPtr ctxt) {
 1623|    216|    const xmlChar **table;
 1624|    216|    xmlParserNsExtra *extra;
 1625|    216|    int newSize;
 1626|       |
 1627|    216|    if (ctxt->nsMax > INT_MAX / 2)
  ------------------
  |  Branch (1627:9): [True: 0, False: 216]
  ------------------
 1628|      0|        goto error;
 1629|    216|    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;
  ------------------
  |  Branch (1629:15): [True: 0, False: 216]
  ------------------
 1630|       |
 1631|    216|    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));
 1632|    216|    if (table == NULL)
  ------------------
  |  Branch (1632:9): [True: 0, False: 216]
  ------------------
 1633|      0|        goto error;
 1634|    216|    ctxt->nsTab = table;
 1635|       |
 1636|    216|    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));
 1637|    216|    if (extra == NULL)
  ------------------
  |  Branch (1637:9): [True: 0, False: 216]
  ------------------
 1638|      0|        goto error;
 1639|    216|    ctxt->nsdb->extra = extra;
 1640|       |
 1641|    216|    ctxt->nsMax = newSize;
 1642|    216|    return(0);
 1643|       |
 1644|      0|error:
 1645|      0|    xmlErrMemory(ctxt, NULL);
 1646|      0|    return(-1);
 1647|    216|}
parser.c:xmlParserNsPop:
 1825|    233|{
 1826|    233|    int i;
 1827|       |
 1828|       |    /* assert(nr <= ctxt->nsNr); */
 1829|       |
 1830|    538|    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {
  ------------------
  |  Branch (1830:30): [True: 305, False: 233]
  ------------------
 1831|    305|        const xmlChar *prefix = ctxt->nsTab[i * 2];
 1832|    305|        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];
 1833|       |
 1834|    305|        if (prefix == NULL) {
  ------------------
  |  Branch (1834:13): [True: 88, False: 217]
  ------------------
 1835|     88|            ctxt->nsdb->defaultNsIndex = extra->oldIndex;
 1836|    217|        } else {
 1837|    217|            xmlHashedString hprefix;
 1838|    217|            xmlParserNsBucket *bucket = NULL;
 1839|       |
 1840|    217|            hprefix.name = prefix;
 1841|    217|            hprefix.hashValue = extra->prefixHashValue;
 1842|    217|            xmlParserNsLookup(ctxt, &hprefix, &bucket);
 1843|       |            /* assert(bucket && bucket->hashValue); */
 1844|    217|            bucket->index = extra->oldIndex;
 1845|    217|        }
 1846|    305|    }
 1847|       |
 1848|    233|    ctxt->nsNr -= nr;
 1849|    233|    return(nr);
 1850|    233|}
parser.c:xmlCreateEntityParserCtxtInternal:
13591|     30|        xmlParserCtxtPtr pctx) {
13592|     30|    xmlParserCtxtPtr ctxt;
13593|     30|    xmlParserInputPtr inputStream;
13594|     30|    char *directory = NULL;
13595|     30|    xmlChar *uri;
13596|       |
13597|     30|    ctxt = xmlNewSAXParserCtxt(sax, userData);
13598|     30|    if (ctxt == NULL) {
  ------------------
  |  Branch (13598:9): [True: 0, False: 30]
  ------------------
13599|      0|	return(NULL);
13600|      0|    }
13601|       |
13602|     30|    if (pctx != NULL) {
  ------------------
  |  Branch (13602:9): [True: 30, False: 0]
  ------------------
13603|     30|        ctxt->options = pctx->options;
13604|     30|        ctxt->_private = pctx->_private;
13605|     30|	ctxt->input_id = pctx->input_id;
13606|     30|    }
13607|       |
13608|       |    /* Don't read from stdin. */
13609|     30|    if (xmlStrcmp(URL, BAD_CAST "-") == 0)
  ------------------
  |  |   35|     30|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (13609:9): [True: 0, False: 30]
  ------------------
13610|      0|        URL = BAD_CAST "./-";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
13611|       |
13612|     30|    uri = xmlBuildURI(URL, base);
13613|       |
13614|     30|    if (uri == NULL) {
  ------------------
  |  Branch (13614:9): [True: 0, False: 30]
  ------------------
13615|      0|	inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);
13616|      0|	if (inputStream == NULL) {
  ------------------
  |  Branch (13616:6): [True: 0, False: 0]
  ------------------
13617|      0|	    xmlFreeParserCtxt(ctxt);
13618|      0|	    return(NULL);
13619|      0|	}
13620|       |
13621|      0|	inputPush(ctxt, inputStream);
13622|       |
13623|      0|	if ((ctxt->directory == NULL) && (directory == NULL))
  ------------------
  |  Branch (13623:6): [True: 0, False: 0]
  |  Branch (13623:35): [True: 0, False: 0]
  ------------------
13624|      0|	    directory = xmlParserGetDirectory((char *)URL);
13625|      0|	if ((ctxt->directory == NULL) && (directory != NULL))
  ------------------
  |  Branch (13625:6): [True: 0, False: 0]
  |  Branch (13625:35): [True: 0, False: 0]
  ------------------
13626|      0|	    ctxt->directory = directory;
13627|     30|    } else {
13628|     30|	inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);
13629|     30|	if (inputStream == NULL) {
  ------------------
  |  Branch (13629:6): [True: 3, False: 27]
  ------------------
13630|      3|	    xmlFree(uri);
13631|      3|	    xmlFreeParserCtxt(ctxt);
13632|      3|	    return(NULL);
13633|      3|	}
13634|       |
13635|     27|	inputPush(ctxt, inputStream);
13636|       |
13637|     27|	if ((ctxt->directory == NULL) && (directory == NULL))
  ------------------
  |  Branch (13637:6): [True: 27, False: 0]
  |  Branch (13637:35): [True: 27, False: 0]
  ------------------
13638|     27|	    directory = xmlParserGetDirectory((char *)uri);
13639|     27|	if ((ctxt->directory == NULL) && (directory != NULL))
  ------------------
  |  Branch (13639:6): [True: 27, False: 0]
  |  Branch (13639:35): [True: 27, False: 0]
  ------------------
13640|     27|	    ctxt->directory = directory;
13641|     27|	xmlFree(uri);
13642|     27|    }
13643|     27|    return(ctxt);
13644|     30|}
parser.c:xmlCtxtUseOptionsInternal:
14554|    968|{
14555|    968|    if (ctxt == NULL)
  ------------------
  |  Branch (14555:9): [True: 0, False: 968]
  ------------------
14556|      0|        return(-1);
14557|    968|    if (encoding != NULL) {
  ------------------
  |  Branch (14557:9): [True: 0, False: 968]
  ------------------
14558|      0|        if (ctxt->encoding != NULL)
  ------------------
  |  Branch (14558:13): [True: 0, False: 0]
  ------------------
14559|      0|	    xmlFree((xmlChar *) ctxt->encoding);
14560|      0|        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);
14561|      0|    }
14562|    968|    if (options & XML_PARSE_RECOVER) {
  ------------------
  |  Branch (14562:9): [True: 0, False: 968]
  ------------------
14563|      0|        ctxt->recovery = 1;
14564|      0|        options -= XML_PARSE_RECOVER;
14565|      0|	ctxt->options |= XML_PARSE_RECOVER;
14566|      0|    } else
14567|    968|        ctxt->recovery = 0;
14568|    968|    if (options & XML_PARSE_DTDLOAD) {
  ------------------
  |  Branch (14568:9): [True: 968, False: 0]
  ------------------
14569|    968|        ctxt->loadsubset = XML_DETECT_IDS;
  ------------------
  |  |  141|    968|#define XML_DETECT_IDS		2
  ------------------
14570|    968|        options -= XML_PARSE_DTDLOAD;
14571|    968|	ctxt->options |= XML_PARSE_DTDLOAD;
14572|    968|    } else
14573|      0|        ctxt->loadsubset = 0;
14574|    968|    if (options & XML_PARSE_DTDATTR) {
  ------------------
  |  Branch (14574:9): [True: 0, False: 968]
  ------------------
14575|      0|        ctxt->loadsubset |= XML_COMPLETE_ATTRS;
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
14576|      0|        options -= XML_PARSE_DTDATTR;
14577|      0|	ctxt->options |= XML_PARSE_DTDATTR;
14578|      0|    }
14579|    968|    if (options & XML_PARSE_NOENT) {
  ------------------
  |  Branch (14579:9): [True: 968, False: 0]
  ------------------
14580|    968|        ctxt->replaceEntities = 1;
14581|       |        /* ctxt->loadsubset |= XML_DETECT_IDS; */
14582|    968|        options -= XML_PARSE_NOENT;
14583|    968|	ctxt->options |= XML_PARSE_NOENT;
14584|    968|    } else
14585|      0|        ctxt->replaceEntities = 0;
14586|    968|    if (options & XML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (14586:9): [True: 0, False: 968]
  ------------------
14587|      0|        ctxt->pedantic = 1;
14588|      0|        options -= XML_PARSE_PEDANTIC;
14589|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
14590|      0|    } else
14591|    968|        ctxt->pedantic = 0;
14592|    968|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (14592:9): [True: 0, False: 968]
  ------------------
14593|      0|        ctxt->keepBlanks = 0;
14594|      0|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
14595|      0|        options -= XML_PARSE_NOBLANKS;
14596|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
14597|      0|    } else
14598|    968|        ctxt->keepBlanks = 1;
14599|    968|    if (options & XML_PARSE_DTDVALID) {
  ------------------
  |  Branch (14599:9): [True: 0, False: 968]
  ------------------
14600|      0|        ctxt->validate = 1;
14601|      0|        if (options & XML_PARSE_NOWARNING)
  ------------------
  |  Branch (14601:13): [True: 0, False: 0]
  ------------------
14602|      0|            ctxt->vctxt.warning = NULL;
14603|      0|        if (options & XML_PARSE_NOERROR)
  ------------------
  |  Branch (14603:13): [True: 0, False: 0]
  ------------------
14604|      0|            ctxt->vctxt.error = NULL;
14605|      0|        options -= XML_PARSE_DTDVALID;
14606|      0|	ctxt->options |= XML_PARSE_DTDVALID;
14607|      0|    } else
14608|    968|        ctxt->validate = 0;
14609|    968|    if (options & XML_PARSE_NOWARNING) {
  ------------------
  |  Branch (14609:9): [True: 0, False: 968]
  ------------------
14610|      0|        ctxt->sax->warning = NULL;
14611|      0|        options -= XML_PARSE_NOWARNING;
14612|      0|    }
14613|    968|    if (options & XML_PARSE_NOERROR) {
  ------------------
  |  Branch (14613:9): [True: 0, False: 968]
  ------------------
14614|      0|        ctxt->sax->error = NULL;
14615|      0|        ctxt->sax->fatalError = NULL;
14616|      0|        options -= XML_PARSE_NOERROR;
14617|      0|    }
14618|    968|#ifdef LIBXML_SAX1_ENABLED
14619|    968|    if (options & XML_PARSE_SAX1) {
  ------------------
  |  Branch (14619:9): [True: 0, False: 968]
  ------------------
14620|      0|        ctxt->sax->startElementNs = NULL;
14621|      0|        ctxt->sax->endElementNs = NULL;
14622|      0|        ctxt->sax->initialized = 1;
14623|      0|        options -= XML_PARSE_SAX1;
14624|      0|	ctxt->options |= XML_PARSE_SAX1;
14625|      0|    }
14626|    968|#endif /* LIBXML_SAX1_ENABLED */
14627|    968|    if (options & XML_PARSE_NODICT) {
  ------------------
  |  Branch (14627:9): [True: 0, False: 968]
  ------------------
14628|      0|        ctxt->dictNames = 0;
14629|      0|        options -= XML_PARSE_NODICT;
14630|      0|	ctxt->options |= XML_PARSE_NODICT;
14631|    968|    } else {
14632|    968|        ctxt->dictNames = 1;
14633|    968|    }
14634|    968|    if (options & XML_PARSE_NOCDATA) {
  ------------------
  |  Branch (14634:9): [True: 0, False: 968]
  ------------------
14635|      0|        ctxt->sax->cdataBlock = NULL;
14636|      0|        options -= XML_PARSE_NOCDATA;
14637|      0|	ctxt->options |= XML_PARSE_NOCDATA;
14638|      0|    }
14639|    968|    if (options & XML_PARSE_NSCLEAN) {
  ------------------
  |  Branch (14639:9): [True: 0, False: 968]
  ------------------
14640|      0|	ctxt->options |= XML_PARSE_NSCLEAN;
14641|      0|        options -= XML_PARSE_NSCLEAN;
14642|      0|    }
14643|    968|    if (options & XML_PARSE_NONET) {
  ------------------
  |  Branch (14643:9): [True: 0, False: 968]
  ------------------
14644|      0|	ctxt->options |= XML_PARSE_NONET;
14645|      0|        options -= XML_PARSE_NONET;
14646|      0|    }
14647|    968|    if (options & XML_PARSE_COMPACT) {
  ------------------
  |  Branch (14647:9): [True: 323, False: 645]
  ------------------
14648|    323|	ctxt->options |= XML_PARSE_COMPACT;
14649|    323|        options -= XML_PARSE_COMPACT;
14650|    323|    }
14651|    968|    if (options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (14651:9): [True: 0, False: 968]
  ------------------
14652|      0|	ctxt->options |= XML_PARSE_OLD10;
14653|      0|        options -= XML_PARSE_OLD10;
14654|      0|    }
14655|    968|    if (options & XML_PARSE_NOBASEFIX) {
  ------------------
  |  Branch (14655:9): [True: 0, False: 968]
  ------------------
14656|      0|	ctxt->options |= XML_PARSE_NOBASEFIX;
14657|      0|        options -= XML_PARSE_NOBASEFIX;
14658|      0|    }
14659|    968|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (14659:9): [True: 0, False: 968]
  ------------------
14660|      0|	ctxt->options |= XML_PARSE_HUGE;
14661|      0|        options -= XML_PARSE_HUGE;
14662|      0|        if (ctxt->dict != NULL)
  ------------------
  |  Branch (14662:13): [True: 0, False: 0]
  ------------------
14663|      0|            xmlDictSetLimit(ctxt->dict, 0);
14664|      0|    }
14665|    968|    if (options & XML_PARSE_OLDSAX) {
  ------------------
  |  Branch (14665:9): [True: 0, False: 968]
  ------------------
14666|      0|	ctxt->options |= XML_PARSE_OLDSAX;
14667|      0|        options -= XML_PARSE_OLDSAX;
14668|      0|    }
14669|    968|    if (options & XML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (14669:9): [True: 0, False: 968]
  ------------------
14670|      0|	ctxt->options |= XML_PARSE_IGNORE_ENC;
14671|      0|        options -= XML_PARSE_IGNORE_ENC;
14672|      0|    }
14673|    968|    if (options & XML_PARSE_BIG_LINES) {
  ------------------
  |  Branch (14673:9): [True: 0, False: 968]
  ------------------
14674|      0|	ctxt->options |= XML_PARSE_BIG_LINES;
14675|      0|        options -= XML_PARSE_BIG_LINES;
14676|      0|    }
14677|    968|    ctxt->linenumbers = 1;
14678|    968|    return (options);
14679|    968|}
parser.c:xmlDoRead:
14731|    322|{
14732|    322|    xmlDocPtr ret;
14733|       |
14734|    322|    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
14735|    322|    if (encoding != NULL) {
  ------------------
  |  Branch (14735:9): [True: 0, False: 322]
  ------------------
14736|      0|        xmlCharEncodingHandlerPtr hdlr;
14737|       |
14738|       |        /*
14739|       |         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the
14740|       |         * caller provided an encoding. Otherwise, we might switch to
14741|       |         * the encoding from the XML declaration which is likely to
14742|       |         * break things. Also see xmlSwitchInputEncoding.
14743|       |         */
14744|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
14745|      0|	if (hdlr != NULL)
  ------------------
  |  Branch (14745:6): [True: 0, False: 0]
  ------------------
14746|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
14747|      0|    }
14748|    322|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (14748:9): [True: 322, False: 0]
  |  Branch (14748:26): [True: 322, False: 0]
  ------------------
14749|    322|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (14749:9): [True: 322, False: 0]
  ------------------
14750|    322|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
14751|    322|    xmlParseDocument(ctxt);
14752|    322|    if ((ctxt->wellFormed) || ctxt->recovery)
  ------------------
  |  Branch (14752:9): [True: 262, False: 60]
  |  Branch (14752:31): [True: 0, False: 60]
  ------------------
14753|    262|        ret = ctxt->myDoc;
14754|     60|    else {
14755|     60|        ret = NULL;
14756|     60|	if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (14756:6): [True: 60, False: 0]
  ------------------
14757|     60|	    xmlFreeDoc(ctxt->myDoc);
14758|     60|	}
14759|     60|    }
14760|    322|    ctxt->myDoc = NULL;
14761|    322|    if (!reuse) {
  ------------------
  |  Branch (14761:9): [True: 322, False: 0]
  ------------------
14762|    322|	xmlFreeParserCtxt(ctxt);
14763|    322|    }
14764|       |
14765|    322|    return (ret);
14766|    322|}

__xmlErrEncoding:
  136|      9|{
  137|      9|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 9, False: 0]
  |  Branch (137:27): [True: 0, False: 9]
  ------------------
  138|      9|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 0]
  ------------------
  139|      0|	return;
  140|      9|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 9, False: 0]
  ------------------
  141|      9|        ctxt->errNo = xmlerr;
  142|      9|    __xmlRaiseError(NULL, NULL, NULL,
  143|      9|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|      9|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|      9|                    NULL, 0, 0, msg, str1, str2);
  146|      9|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 9, False: 0]
  ------------------
  147|      9|        ctxt->wellFormed = 0;
  148|      9|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 9, False: 0]
  ------------------
  149|      9|            ctxt->disableSAX = 1;
  150|      9|    }
  151|      9|}
xmlFatalErr:
  190|     83|{
  191|     83|    const char *errmsg;
  192|       |
  193|     83|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (193:9): [True: 83, False: 0]
  |  Branch (193:27): [True: 48, False: 35]
  ------------------
  194|     83|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (194:9): [True: 24, False: 24]
  ------------------
  195|     24|	return;
  196|     59|    switch (error) {
  197|      0|        case XML_ERR_INVALID_HEX_CHARREF:
  ------------------
  |  Branch (197:9): [True: 0, False: 59]
  ------------------
  198|      0|            errmsg = "CharRef: invalid hexadecimal value";
  199|      0|            break;
  200|      0|        case XML_ERR_INVALID_DEC_CHARREF:
  ------------------
  |  Branch (200:9): [True: 0, False: 59]
  ------------------
  201|      0|            errmsg = "CharRef: invalid decimal value";
  202|      0|            break;
  203|      0|        case XML_ERR_INVALID_CHARREF:
  ------------------
  |  Branch (203:9): [True: 0, False: 59]
  ------------------
  204|      0|            errmsg = "CharRef: invalid value";
  205|      0|            break;
  206|     24|        case XML_ERR_INTERNAL_ERROR:
  ------------------
  |  Branch (206:9): [True: 24, False: 35]
  ------------------
  207|     24|            errmsg = "internal error";
  208|     24|            break;
  209|      0|        case XML_ERR_PEREF_AT_EOF:
  ------------------
  |  Branch (209:9): [True: 0, False: 59]
  ------------------
  210|      0|            errmsg = "PEReference at end of document";
  211|      0|            break;
  212|      0|        case XML_ERR_PEREF_IN_PROLOG:
  ------------------
  |  Branch (212:9): [True: 0, False: 59]
  ------------------
  213|      0|            errmsg = "PEReference in prolog";
  214|      0|            break;
  215|      0|        case XML_ERR_PEREF_IN_EPILOG:
  ------------------
  |  Branch (215:9): [True: 0, False: 59]
  ------------------
  216|      0|            errmsg = "PEReference in epilog";
  217|      0|            break;
  218|      0|        case XML_ERR_PEREF_NO_NAME:
  ------------------
  |  Branch (218:9): [True: 0, False: 59]
  ------------------
  219|      0|            errmsg = "PEReference: no name";
  220|      0|            break;
  221|      3|        case XML_ERR_PEREF_SEMICOL_MISSING:
  ------------------
  |  Branch (221:9): [True: 3, False: 56]
  ------------------
  222|      3|            errmsg = "PEReference: expecting ';'";
  223|      3|            break;
  224|      9|        case XML_ERR_ENTITY_LOOP:
  ------------------
  |  Branch (224:9): [True: 9, False: 50]
  ------------------
  225|      9|            errmsg = "Detected an entity reference loop";
  226|      9|            break;
  227|      0|        case XML_ERR_ENTITY_NOT_STARTED:
  ------------------
  |  Branch (227:9): [True: 0, False: 59]
  ------------------
  228|      0|            errmsg = "EntityValue: \" or ' expected";
  229|      0|            break;
  230|      0|        case XML_ERR_ENTITY_PE_INTERNAL:
  ------------------
  |  Branch (230:9): [True: 0, False: 59]
  ------------------
  231|      0|            errmsg = "PEReferences forbidden in internal subset";
  232|      0|            break;
  233|      0|        case XML_ERR_ENTITY_NOT_FINISHED:
  ------------------
  |  Branch (233:9): [True: 0, False: 59]
  ------------------
  234|      0|            errmsg = "EntityValue: \" or ' expected";
  235|      0|            break;
  236|      0|        case XML_ERR_ATTRIBUTE_NOT_STARTED:
  ------------------
  |  Branch (236:9): [True: 0, False: 59]
  ------------------
  237|      0|            errmsg = "AttValue: \" or ' expected";
  238|      0|            break;
  239|      0|        case XML_ERR_LT_IN_ATTRIBUTE:
  ------------------
  |  Branch (239:9): [True: 0, False: 59]
  ------------------
  240|      0|            errmsg = "Unescaped '<' not allowed in attributes values";
  241|      0|            break;
  242|      0|        case XML_ERR_LITERAL_NOT_STARTED:
  ------------------
  |  Branch (242:9): [True: 0, False: 59]
  ------------------
  243|      0|            errmsg = "SystemLiteral \" or ' expected";
  244|      0|            break;
  245|      0|        case XML_ERR_LITERAL_NOT_FINISHED:
  ------------------
  |  Branch (245:9): [True: 0, False: 59]
  ------------------
  246|      0|            errmsg = "Unfinished System or Public ID \" or ' expected";
  247|      0|            break;
  248|      0|        case XML_ERR_MISPLACED_CDATA_END:
  ------------------
  |  Branch (248:9): [True: 0, False: 59]
  ------------------
  249|      0|            errmsg = "Sequence ']]>' not allowed in content";
  250|      0|            break;
  251|      0|        case XML_ERR_URI_REQUIRED:
  ------------------
  |  Branch (251:9): [True: 0, False: 59]
  ------------------
  252|      0|            errmsg = "SYSTEM or PUBLIC, the URI is missing";
  253|      0|            break;
  254|      0|        case XML_ERR_PUBID_REQUIRED:
  ------------------
  |  Branch (254:9): [True: 0, False: 59]
  ------------------
  255|      0|            errmsg = "PUBLIC, the Public Identifier is missing";
  256|      0|            break;
  257|      0|        case XML_ERR_HYPHEN_IN_COMMENT:
  ------------------
  |  Branch (257:9): [True: 0, False: 59]
  ------------------
  258|      0|            errmsg = "Comment must not contain '--' (double-hyphen)";
  259|      0|            break;
  260|      0|        case XML_ERR_PI_NOT_STARTED:
  ------------------
  |  Branch (260:9): [True: 0, False: 59]
  ------------------
  261|      0|            errmsg = "xmlParsePI : no target name";
  262|      0|            break;
  263|      0|        case XML_ERR_RESERVED_XML_NAME:
  ------------------
  |  Branch (263:9): [True: 0, False: 59]
  ------------------
  264|      0|            errmsg = "Invalid PI name";
  265|      0|            break;
  266|      0|        case XML_ERR_NOTATION_NOT_STARTED:
  ------------------
  |  Branch (266:9): [True: 0, False: 59]
  ------------------
  267|      0|            errmsg = "NOTATION: Name expected here";
  268|      0|            break;
  269|      0|        case XML_ERR_NOTATION_NOT_FINISHED:
  ------------------
  |  Branch (269:9): [True: 0, False: 59]
  ------------------
  270|      0|            errmsg = "'>' required to close NOTATION declaration";
  271|      0|            break;
  272|      3|        case XML_ERR_VALUE_REQUIRED:
  ------------------
  |  Branch (272:9): [True: 3, False: 56]
  ------------------
  273|      3|            errmsg = "Entity value required";
  274|      3|            break;
  275|      0|        case XML_ERR_URI_FRAGMENT:
  ------------------
  |  Branch (275:9): [True: 0, False: 59]
  ------------------
  276|      0|            errmsg = "Fragment not allowed";
  277|      0|            break;
  278|      0|        case XML_ERR_ATTLIST_NOT_STARTED:
  ------------------
  |  Branch (278:9): [True: 0, False: 59]
  ------------------
  279|      0|            errmsg = "'(' required to start ATTLIST enumeration";
  280|      0|            break;
  281|      0|        case XML_ERR_NMTOKEN_REQUIRED:
  ------------------
  |  Branch (281:9): [True: 0, False: 59]
  ------------------
  282|      0|            errmsg = "NmToken expected in ATTLIST enumeration";
  283|      0|            break;
  284|      0|        case XML_ERR_ATTLIST_NOT_FINISHED:
  ------------------
  |  Branch (284:9): [True: 0, False: 59]
  ------------------
  285|      0|            errmsg = "')' required to finish ATTLIST enumeration";
  286|      0|            break;
  287|      0|        case XML_ERR_MIXED_NOT_STARTED:
  ------------------
  |  Branch (287:9): [True: 0, False: 59]
  ------------------
  288|      0|            errmsg = "MixedContentDecl : '|' or ')*' expected";
  289|      0|            break;
  290|      0|        case XML_ERR_PCDATA_REQUIRED:
  ------------------
  |  Branch (290:9): [True: 0, False: 59]
  ------------------
  291|      0|            errmsg = "MixedContentDecl : '#PCDATA' expected";
  292|      0|            break;
  293|      0|        case XML_ERR_ELEMCONTENT_NOT_STARTED:
  ------------------
  |  Branch (293:9): [True: 0, False: 59]
  ------------------
  294|      0|            errmsg = "ContentDecl : Name or '(' expected";
  295|      0|            break;
  296|      3|        case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  ------------------
  |  Branch (296:9): [True: 3, False: 56]
  ------------------
  297|      3|            errmsg = "ContentDecl : ',' '|' or ')' expected";
  298|      3|            break;
  299|      0|        case XML_ERR_PEREF_IN_INT_SUBSET:
  ------------------
  |  Branch (299:9): [True: 0, False: 59]
  ------------------
  300|      0|            errmsg =
  301|      0|                "PEReference: forbidden within markup decl in internal subset";
  302|      0|            break;
  303|      6|        case XML_ERR_GT_REQUIRED:
  ------------------
  |  Branch (303:9): [True: 6, False: 53]
  ------------------
  304|      6|            errmsg = "expected '>'";
  305|      6|            break;
  306|      0|        case XML_ERR_CONDSEC_INVALID:
  ------------------
  |  Branch (306:9): [True: 0, False: 59]
  ------------------
  307|      0|            errmsg = "XML conditional section '[' expected";
  308|      0|            break;
  309|      6|        case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  ------------------
  |  Branch (309:9): [True: 6, False: 53]
  ------------------
  310|      6|            errmsg = "Content error in the external subset";
  311|      6|            break;
  312|      0|        case XML_ERR_CONDSEC_INVALID_KEYWORD:
  ------------------
  |  Branch (312:9): [True: 0, False: 59]
  ------------------
  313|      0|            errmsg =
  314|      0|                "conditional section INCLUDE or IGNORE keyword expected";
  315|      0|            break;
  316|      0|        case XML_ERR_CONDSEC_NOT_FINISHED:
  ------------------
  |  Branch (316:9): [True: 0, False: 59]
  ------------------
  317|      0|            errmsg = "XML conditional section not closed";
  318|      0|            break;
  319|      0|        case XML_ERR_XMLDECL_NOT_STARTED:
  ------------------
  |  Branch (319:9): [True: 0, False: 59]
  ------------------
  320|      0|            errmsg = "Text declaration '<?xml' required";
  321|      0|            break;
  322|      0|        case XML_ERR_XMLDECL_NOT_FINISHED:
  ------------------
  |  Branch (322:9): [True: 0, False: 59]
  ------------------
  323|      0|            errmsg = "parsing XML declaration: '?>' expected";
  324|      0|            break;
  325|      0|        case XML_ERR_EXT_ENTITY_STANDALONE:
  ------------------
  |  Branch (325:9): [True: 0, False: 59]
  ------------------
  326|      0|            errmsg = "external parsed entities cannot be standalone";
  327|      0|            break;
  328|      0|        case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  ------------------
  |  Branch (328:9): [True: 0, False: 59]
  ------------------
  329|      0|            errmsg = "EntityRef: expecting ';'";
  330|      0|            break;
  331|      0|        case XML_ERR_DOCTYPE_NOT_FINISHED:
  ------------------
  |  Branch (331:9): [True: 0, False: 59]
  ------------------
  332|      0|            errmsg = "DOCTYPE improperly terminated";
  333|      0|            break;
  334|      0|        case XML_ERR_LTSLASH_REQUIRED:
  ------------------
  |  Branch (334:9): [True: 0, False: 59]
  ------------------
  335|      0|            errmsg = "EndTag: '</' not found";
  336|      0|            break;
  337|      0|        case XML_ERR_EQUAL_REQUIRED:
  ------------------
  |  Branch (337:9): [True: 0, False: 59]
  ------------------
  338|      0|            errmsg = "expected '='";
  339|      0|            break;
  340|      0|        case XML_ERR_STRING_NOT_CLOSED:
  ------------------
  |  Branch (340:9): [True: 0, False: 59]
  ------------------
  341|      0|            errmsg = "String not closed expecting \" or '";
  342|      0|            break;
  343|      0|        case XML_ERR_STRING_NOT_STARTED:
  ------------------
  |  Branch (343:9): [True: 0, False: 59]
  ------------------
  344|      0|            errmsg = "String not started expecting ' or \"";
  345|      0|            break;
  346|      0|        case XML_ERR_ENCODING_NAME:
  ------------------
  |  Branch (346:9): [True: 0, False: 59]
  ------------------
  347|      0|            errmsg = "Invalid XML encoding name";
  348|      0|            break;
  349|      0|        case XML_ERR_STANDALONE_VALUE:
  ------------------
  |  Branch (349:9): [True: 0, False: 59]
  ------------------
  350|      0|            errmsg = "standalone accepts only 'yes' or 'no'";
  351|      0|            break;
  352|      2|        case XML_ERR_DOCUMENT_EMPTY:
  ------------------
  |  Branch (352:9): [True: 2, False: 57]
  ------------------
  353|      2|            errmsg = "Document is empty";
  354|      2|            break;
  355|      3|        case XML_ERR_DOCUMENT_END:
  ------------------
  |  Branch (355:9): [True: 3, False: 56]
  ------------------
  356|      3|            errmsg = "Extra content at the end of the document";
  357|      3|            break;
  358|      0|        case XML_ERR_NOT_WELL_BALANCED:
  ------------------
  |  Branch (358:9): [True: 0, False: 59]
  ------------------
  359|      0|            errmsg = "chunk is not well balanced";
  360|      0|            break;
  361|      0|        case XML_ERR_EXTRA_CONTENT:
  ------------------
  |  Branch (361:9): [True: 0, False: 59]
  ------------------
  362|      0|            errmsg = "extra content at the end of well balanced chunk";
  363|      0|            break;
  364|      0|        case XML_ERR_VERSION_MISSING:
  ------------------
  |  Branch (364:9): [True: 0, False: 59]
  ------------------
  365|      0|            errmsg = "Malformed declaration expecting version";
  366|      0|            break;
  367|      0|        case XML_ERR_NAME_TOO_LONG:
  ------------------
  |  Branch (367:9): [True: 0, False: 59]
  ------------------
  368|      0|            errmsg = "Name too long";
  369|      0|            break;
  370|      0|        case XML_ERR_INVALID_ENCODING:
  ------------------
  |  Branch (370:9): [True: 0, False: 59]
  ------------------
  371|      0|            errmsg = "Invalid bytes in character encoding";
  372|      0|            break;
  373|      0|        case XML_IO_UNKNOWN:
  ------------------
  |  Branch (373:9): [True: 0, False: 59]
  ------------------
  374|      0|            errmsg = "I/O error";
  375|      0|            break;
  376|       |#if 0
  377|       |        case:
  378|       |            errmsg = "";
  379|       |            break;
  380|       |#endif
  381|      0|        default:
  ------------------
  |  Branch (381:9): [True: 0, False: 59]
  ------------------
  382|      0|            errmsg = "Unregistered error message";
  383|     59|    }
  384|     59|    if (ctxt != NULL)
  ------------------
  |  Branch (384:9): [True: 59, False: 0]
  ------------------
  385|     59|	ctxt->errNo = error;
  386|     59|    if (info == NULL) {
  ------------------
  |  Branch (386:9): [True: 35, False: 24]
  ------------------
  387|     35|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  388|     35|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
  389|     35|                        errmsg);
  390|     35|    } else {
  391|     24|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  392|     24|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
  393|     24|                        errmsg, info);
  394|     24|    }
  395|     59|    if (ctxt != NULL) {
  ------------------
  |  Branch (395:9): [True: 59, False: 0]
  ------------------
  396|     59|	ctxt->wellFormed = 0;
  397|     59|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (397:6): [True: 59, False: 0]
  ------------------
  398|     59|	    ctxt->disableSAX = 1;
  399|     59|    }
  400|     59|}
xmlHaltParser:
  461|  1.16k|xmlHaltParser(xmlParserCtxtPtr ctxt) {
  462|  1.16k|    if (ctxt == NULL)
  ------------------
  |  Branch (462:9): [True: 0, False: 1.16k]
  ------------------
  463|      0|        return;
  464|  1.16k|    ctxt->instate = XML_PARSER_EOF;
  465|  1.16k|    ctxt->disableSAX = 1;
  466|  1.27k|    while (ctxt->inputNr > 1)
  ------------------
  |  Branch (466:12): [True: 108, False: 1.16k]
  ------------------
  467|    108|        xmlFreeInputStream(inputPop(ctxt));
  468|  1.16k|    if (ctxt->input != NULL) {
  ------------------
  |  Branch (468:9): [True: 1.16k, False: 0]
  ------------------
  469|       |        /*
  470|       |	 * in case there was a specific allocation deallocate before
  471|       |	 * overriding base
  472|       |	 */
  473|  1.16k|        if (ctxt->input->free != NULL) {
  ------------------
  |  Branch (473:13): [True: 0, False: 1.16k]
  ------------------
  474|      0|	    ctxt->input->free((xmlChar *) ctxt->input->base);
  475|      0|	    ctxt->input->free = NULL;
  476|      0|	}
  477|  1.16k|        if (ctxt->input->buf != NULL) {
  ------------------
  |  Branch (477:13): [True: 530, False: 634]
  ------------------
  478|    530|            xmlFreeParserInputBuffer(ctxt->input->buf);
  479|    530|            ctxt->input->buf = NULL;
  480|    530|        }
  481|  1.16k|	ctxt->input->cur = BAD_CAST"";
  ------------------
  |  |   35|  1.16k|#define BAD_CAST (xmlChar *)
  ------------------
  482|  1.16k|        ctxt->input->length = 0;
  483|  1.16k|	ctxt->input->base = ctxt->input->cur;
  484|  1.16k|        ctxt->input->end = ctxt->input->cur;
  485|  1.16k|    }
  486|  1.16k|}
xmlParserGrow:
  511|  2.80M|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|  2.80M|    xmlParserInputPtr in = ctxt->input;
  513|  2.80M|    xmlParserInputBufferPtr buf = in->buf;
  514|  2.80M|    ptrdiff_t curEnd = in->end - in->cur;
  515|  2.80M|    ptrdiff_t curBase = in->cur - in->base;
  516|  2.80M|    int ret;
  517|       |
  518|  2.80M|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 984k, False: 1.81M]
  ------------------
  519|   984k|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|  1.81M|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 1.29M, False: 522k]
  |  Branch (521:32): [True: 330k, False: 964k]
  ------------------
  522|   330k|        return(0);
  523|  1.48M|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 1.48M]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  1.48M|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  1.48M|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 1.48M]
  ------------------
  527|  1.48M|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  1.48M|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 1.48M]
  ------------------
  528|  1.48M|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  1.48M|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  1.48M|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 10.0k, False: 1.47M]
  ------------------
  535|  10.0k|        return(0);
  536|       |
  537|  1.47M|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  1.47M|#define INPUT_CHUNK	250
  ------------------
  538|  1.47M|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  1.47M|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 1.47M]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  1.47M|    return(ret);
  548|  1.48M|}
xmlParserShrink:
  600|    814|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|    814|    xmlParserInputPtr in = ctxt->input;
  602|    814|    xmlParserInputBufferPtr buf = in->buf;
  603|    814|    size_t used;
  604|       |
  605|    814|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 814]
  ------------------
  606|      0|        return;
  607|       |
  608|    814|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|    814|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|    814|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 814, False: 0]
  ------------------
  614|    814|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|    814|#define LINE_LEN        80
  ------------------
  615|       |
  616|    814|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 814, False: 0]
  ------------------
  617|    814|            used -= res;
  618|    814|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 814]
  ------------------
  619|    814|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 814]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|    814|            else
  622|    814|                in->consumed += res;
  623|    814|	}
  624|    814|    }
  625|       |
  626|    814|    xmlBufUpdateInput(buf->buffer, in, used);
  627|    814|}
xmlNextChar:
  698|   578k|{
  699|   578k|    const unsigned char *cur;
  700|   578k|    size_t avail;
  701|   578k|    int c;
  702|       |
  703|   578k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 578k]
  |  Branch (703:27): [True: 0, False: 578k]
  ------------------
  704|   578k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 578k]
  ------------------
  705|      0|        return;
  706|       |
  707|   578k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|   578k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|   578k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 429k, False: 148k]
  ------------------
  710|   429k|        xmlParserGrow(ctxt);
  711|   429k|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 429k]
  ------------------
  712|   429k|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 429k]
  ------------------
  713|      0|            return;
  714|   429k|        avail = ctxt->input->end - ctxt->input->cur;
  715|   429k|    }
  716|       |
  717|   578k|    cur = ctxt->input->cur;
  718|   578k|    c = *cur;
  719|       |
  720|   578k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 578k, False: 0]
  ------------------
  721|   578k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 52.9k, False: 525k]
  ------------------
  722|  52.9k|            ctxt->input->cur++;
  723|  52.9k|            ctxt->input->line++;
  724|  52.9k|            ctxt->input->col = 1;
  725|   525k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 5.34k, False: 519k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|  5.34k|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 5.34k, False: 0]
  ------------------
  733|  5.34k|            ctxt->input->line++;
  734|  5.34k|            ctxt->input->col = 1;
  735|  5.34k|            return;
  736|   519k|        } else {
  737|   519k|            ctxt->input->cur++;
  738|   519k|            ctxt->input->col++;
  739|   519k|        }
  740|   578k|    } else {
  741|      0|        ctxt->input->col++;
  742|       |
  743|      0|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 0]
  |  Branch (743:28): [True: 0, False: 0]
  ------------------
  744|      0|            goto encoding_error;
  745|       |
  746|      0|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 0, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|      0|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 0, False: 0]
  ------------------
  749|      0|                goto encoding_error;
  750|      0|            ctxt->input->cur += 2;
  751|      0|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|      0|    }
  773|       |
  774|   572k|    return;
  775|       |
  776|   572k|encoding_error:
  777|       |    /* Only report the first error */
  778|      0|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 0, False: 0]
  ------------------
  779|      0|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 0]
  |  Branch (779:31): [True: 0, False: 0]
  ------------------
  780|      0|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 0]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|      0|        } else {
  785|      0|            char buffer[150];
  786|       |
  787|      0|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|      0|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|      0|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|      0|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|      0|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  793|      0|        }
  794|      0|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      0|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|      0|    }
  796|      0|    ctxt->input->cur++;
  797|      0|    return;
  798|   578k|}
xmlCurrentChar:
  821|   540k|xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  822|   540k|    const unsigned char *cur;
  823|   540k|    size_t avail;
  824|   540k|    int c;
  825|       |
  826|   540k|    if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);
  ------------------
  |  Branch (826:9): [True: 0, False: 540k]
  |  Branch (826:27): [True: 0, False: 540k]
  |  Branch (826:44): [True: 0, False: 540k]
  ------------------
  827|   540k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (827:9): [True: 12, False: 540k]
  ------------------
  828|     12|	return(0);
  829|       |
  830|   540k|    avail = ctxt->input->end - ctxt->input->cur;
  831|       |
  832|   540k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|   540k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (832:9): [True: 37.2k, False: 503k]
  ------------------
  833|  37.2k|        xmlParserGrow(ctxt);
  834|  37.2k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (834:13): [True: 0, False: 37.2k]
  ------------------
  835|      0|            return(0);
  836|  37.2k|        avail = ctxt->input->end - ctxt->input->cur;
  837|  37.2k|    }
  838|       |
  839|   540k|    cur = ctxt->input->cur;
  840|   540k|    c = *cur;
  841|       |
  842|   540k|    if (c < 0x80) {
  ------------------
  |  Branch (842:9): [True: 530k, False: 9.98k]
  ------------------
  843|       |	/* 1-byte code */
  844|   530k|        if (c < 0x20) {
  ------------------
  |  Branch (844:13): [True: 2.80k, False: 527k]
  ------------------
  845|       |            /*
  846|       |             *   2.11 End-of-Line Handling
  847|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  848|       |             *   literal #xD, an XML processor must pass to the application
  849|       |             *   the single character #xA.
  850|       |             */
  851|  2.80k|            if (c == '\r') {
  ------------------
  |  Branch (851:17): [True: 524, False: 2.28k]
  ------------------
  852|    524|                *len = ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (852:25): [True: 512, False: 12]
  ------------------
  853|    524|                c = '\n';
  854|  2.28k|            } else if (c == 0) {
  ------------------
  |  Branch (854:24): [True: 635, False: 1.64k]
  ------------------
  855|    635|                if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (855:21): [True: 635, False: 0]
  ------------------
  856|    635|                    *len = 0;
  857|    635|                } else {
  858|      0|                    *len = 1;
  859|       |                    /*
  860|       |                     * TODO: Null bytes should be handled by callers,
  861|       |                     * but this can be tricky.
  862|       |                     */
  863|      0|                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
  864|      0|                            "Char 0x0 out of allowed range\n", c);
  865|      0|                }
  866|  1.64k|            } else {
  867|  1.64k|                *len = 1;
  868|  1.64k|            }
  869|   527k|        } else {
  870|   527k|            *len = 1;
  871|   527k|        }
  872|       |
  873|   530k|        return(c);
  874|   530k|    } else {
  875|  9.98k|        int val;
  876|       |
  877|  9.98k|        if (avail < 2)
  ------------------
  |  Branch (877:13): [True: 3, False: 9.98k]
  ------------------
  878|      3|            goto incomplete_sequence;
  879|  9.98k|        if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (879:13): [True: 5, False: 9.97k]
  ------------------
  880|      5|            goto encoding_error;
  881|       |
  882|  9.97k|        if (c < 0xe0) {
  ------------------
  |  Branch (882:13): [True: 6.39k, False: 3.57k]
  ------------------
  883|       |            /* 2-byte code */
  884|  6.39k|            if (c < 0xc2)
  ------------------
  |  Branch (884:17): [True: 0, False: 6.39k]
  ------------------
  885|      0|                goto encoding_error;
  886|  6.39k|            val = (c & 0x1f) << 6;
  887|  6.39k|            val |= cur[1] & 0x3f;
  888|  6.39k|            *len = 2;
  889|  6.39k|        } else {
  890|  3.57k|            if (avail < 3)
  ------------------
  |  Branch (890:17): [True: 0, False: 3.57k]
  ------------------
  891|      0|                goto incomplete_sequence;
  892|  3.57k|            if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (892:17): [True: 0, False: 3.57k]
  ------------------
  893|      0|                goto encoding_error;
  894|       |
  895|  3.57k|            if (c < 0xf0) {
  ------------------
  |  Branch (895:17): [True: 2.37k, False: 1.20k]
  ------------------
  896|       |                /* 3-byte code */
  897|  2.37k|                val = (c & 0xf) << 12;
  898|  2.37k|                val |= (cur[1] & 0x3f) << 6;
  899|  2.37k|                val |= cur[2] & 0x3f;
  900|  2.37k|                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))
  ------------------
  |  Branch (900:21): [True: 0, False: 2.37k]
  |  Branch (900:39): [True: 0, False: 2.37k]
  |  Branch (900:58): [True: 0, False: 0]
  ------------------
  901|      0|                    goto encoding_error;
  902|  2.37k|                *len = 3;
  903|  2.37k|            } else {
  904|  1.20k|                if (avail < 4)
  ------------------
  |  Branch (904:21): [True: 0, False: 1.20k]
  ------------------
  905|      0|                    goto incomplete_sequence;
  906|  1.20k|                if ((cur[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (906:21): [True: 0, False: 1.20k]
  ------------------
  907|      0|                    goto encoding_error;
  908|       |
  909|       |                /* 4-byte code */
  910|  1.20k|                val = (c & 0x0f) << 18;
  911|  1.20k|                val |= (cur[1] & 0x3f) << 12;
  912|  1.20k|                val |= (cur[2] & 0x3f) << 6;
  913|  1.20k|                val |= cur[3] & 0x3f;
  914|  1.20k|                if ((val < 0x10000) || (val >= 0x110000))
  ------------------
  |  Branch (914:21): [True: 0, False: 1.20k]
  |  Branch (914:40): [True: 0, False: 1.20k]
  ------------------
  915|      0|                    goto encoding_error;
  916|  1.20k|                *len = 4;
  917|  1.20k|            }
  918|  3.57k|        }
  919|       |
  920|  9.97k|        return(val);
  921|  9.97k|    }
  922|       |
  923|      5|encoding_error:
  924|       |    /* Only report the first error */
  925|      5|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      5|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (925:9): [True: 5, False: 0]
  ------------------
  926|      5|        if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (926:13): [True: 3, False: 2]
  ------------------
  927|      3|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  928|      3|                         "Input is not proper UTF-8, indicate encoding !\n",
  929|      3|                         NULL, NULL);
  930|      3|        } else {
  931|      2|            char buffer[150];
  932|       |
  933|      2|            snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  934|      2|                            ctxt->input->cur[0], ctxt->input->cur[1],
  935|      2|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  936|      2|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  937|      2|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  938|      2|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  939|      2|        }
  940|      5|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      5|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  941|      5|    }
  942|      5|    *len = 1;
  943|      5|    return(0xFFFD); /* U+FFFD Replacement Character */
  944|       |
  945|      3|incomplete_sequence:
  946|       |    /*
  947|       |     * An encoding problem may arise from a truncated input buffer
  948|       |     * splitting a character in the middle. In that case do not raise
  949|       |     * an error but return 0. This should only happen when push parsing
  950|       |     * char data.
  951|       |     */
  952|      3|    *len = 0;
  953|      3|    return(0);
  954|   540k|}
xmlStringCurrentChar:
  972|  12.8M|                     const xmlChar *cur, int *len) {
  973|  12.8M|    int c;
  974|       |
  975|  12.8M|    if ((cur == NULL) || (len == NULL))
  ------------------
  |  Branch (975:9): [True: 0, False: 12.8M]
  |  Branch (975:26): [True: 0, False: 12.8M]
  ------------------
  976|      0|        return(0);
  977|       |
  978|       |    /* cur is zero-terminated, so we can lie about its length. */
  979|  12.8M|    *len = 4;
  980|  12.8M|    c = xmlGetUTF8Char(cur, len);
  981|       |
  982|  12.8M|    return((c < 0) ? 0 : c);
  ------------------
  |  Branch (982:12): [True: 0, False: 12.8M]
  ------------------
  983|  12.8M|}
xmlCopyCharMultiByte:
  995|  9.08k|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|  9.08k|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 9.08k]
  |  Branch (996:26): [True: 0, False: 9.08k]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|  9.08k|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 9.08k, False: 0]
  ------------------
 1007|  9.08k|	xmlChar *savedout = out;
 1008|  9.08k|	int bits;
 1009|  9.08k|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 6.64k, False: 2.44k]
  ------------------
 1010|  2.44k|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 1.24k, False: 1.20k]
  ------------------
 1011|  1.20k|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 1.20k, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|  21.8k|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 12.7k, False: 9.08k]
  ------------------
 1019|  12.7k|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|  9.08k|	return (out - savedout);
 1021|  9.08k|    }
 1022|      0|    *out = val;
 1023|      0|    return 1;
 1024|  9.08k|}
xmlCopyChar:
 1038|    255|xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
 1039|    255|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (1039:9): [True: 0, False: 255]
  |  Branch (1039:26): [True: 0, False: 255]
  ------------------
 1040|       |    /* the len parameter is ignored */
 1041|    255|    if  (val >= 0x80) {
  ------------------
  |  Branch (1041:10): [True: 147, False: 108]
  ------------------
 1042|    147|	return(xmlCopyCharMultiByte (out, val));
 1043|    147|    }
 1044|    108|    *out = val;
 1045|    108|    return 1;
 1046|    255|}
xmlSwitchEncoding:
 1128|     12|{
 1129|     12|    xmlCharEncodingHandlerPtr handler = NULL;
 1130|     12|    int check = 1;
 1131|     12|    int ret;
 1132|       |
 1133|     12|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (1133:9): [True: 0, False: 12]
  |  Branch (1133:27): [True: 0, False: 12]
  ------------------
 1134|      0|        return(-1);
 1135|       |
 1136|     12|    switch (enc) {
 1137|      0|	case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1137:2): [True: 0, False: 12]
  ------------------
 1138|      9|	case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1138:2): [True: 9, False: 3]
  ------------------
 1139|      9|        case XML_CHAR_ENCODING_ASCII:
  ------------------
  |  Branch (1139:9): [True: 0, False: 12]
  ------------------
 1140|      9|            check = 0;
 1141|      9|            break;
 1142|      3|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1142:9): [True: 3, False: 9]
  ------------------
 1143|      3|            handler = xmlDetectEBCDIC(ctxt->input);
 1144|      3|            break;
 1145|      0|        default:
  ------------------
  |  Branch (1145:9): [True: 0, False: 12]
  ------------------
 1146|      0|            handler = xmlGetCharEncodingHandler(enc);
 1147|      0|            break;
 1148|     12|    }
 1149|       |
 1150|     12|    if ((check) && (handler == NULL)) {
  ------------------
  |  Branch (1150:9): [True: 3, False: 9]
  |  Branch (1150:20): [True: 0, False: 3]
  ------------------
 1151|      0|        const char *name = xmlGetCharEncodingName(enc);
 1152|       |
 1153|      0|        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1154|      0|                "encoding not supported: %s\n",
 1155|      0|                BAD_CAST (name ? name : "<null>"), NULL);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1155:27): [True: 0, False: 0]
  ------------------
 1156|       |        /*
 1157|       |         * TODO: We could recover from errors in external entities
 1158|       |         * if we didn't stop the parser. But most callers of this
 1159|       |         * function don't check the return value.
 1160|       |         */
 1161|      0|        xmlStopParser(ctxt);
 1162|      0|        return(-1);
 1163|      0|    }
 1164|       |
 1165|     12|    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);
 1166|       |
 1167|     12|    if ((ret >= 0) && (enc == XML_CHAR_ENCODING_NONE)) {
  ------------------
  |  Branch (1167:9): [True: 12, False: 0]
  |  Branch (1167:23): [True: 0, False: 12]
  ------------------
 1168|      0|        ctxt->input->flags &= ~XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|      0|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1169|      0|    }
 1170|       |
 1171|     12|    return(ret);
 1172|     12|}
xmlSwitchInputEncoding:
 1189|    123|{
 1190|    123|    int nbchars;
 1191|    123|    xmlParserInputBufferPtr in;
 1192|       |
 1193|    123|    if ((input == NULL) || (input->buf == NULL)) {
  ------------------
  |  Branch (1193:9): [True: 0, False: 123]
  |  Branch (1193:28): [True: 0, False: 123]
  ------------------
 1194|      0|        xmlCharEncCloseFunc(handler);
 1195|      0|	return (-1);
 1196|      0|    }
 1197|    123|    in = input->buf;
 1198|       |
 1199|    123|    input->flags |= XML_INPUT_HAS_ENCODING;
  ------------------
  |  |   20|    123|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
 1200|       |
 1201|       |    /*
 1202|       |     * UTF-8 requires no encoding handler.
 1203|       |     */
 1204|    123|    if ((handler != NULL) &&
  ------------------
  |  Branch (1204:9): [True: 114, False: 9]
  ------------------
 1205|    123|        (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    114|#define BAD_CAST (xmlChar *)
  ------------------
                      (xmlStrcasecmp(BAD_CAST handler->name, BAD_CAST "UTF-8") == 0)) {
  ------------------
  |  |   35|    114|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1205:9): [True: 60, False: 54]
  ------------------
 1206|     60|        xmlCharEncCloseFunc(handler);
 1207|     60|        handler = NULL;
 1208|     60|    }
 1209|       |
 1210|    123|    if (in->encoder == handler)
  ------------------
  |  Branch (1210:9): [True: 69, False: 54]
  ------------------
 1211|     69|        return (0);
 1212|       |
 1213|     54|    if (in->encoder != NULL) {
  ------------------
  |  Branch (1213:9): [True: 0, False: 54]
  ------------------
 1214|       |        /*
 1215|       |         * Switching encodings during parsing is a really bad idea,
 1216|       |         * but Chromium can switch between ISO-8859-1 and UTF-16 before
 1217|       |         * separate calls to xmlParseChunk.
 1218|       |         *
 1219|       |         * TODO: We should check whether the "raw" input buffer is empty and
 1220|       |         * convert the old content using the old encoder.
 1221|       |         */
 1222|       |
 1223|      0|        xmlCharEncCloseFunc(in->encoder);
 1224|      0|        in->encoder = handler;
 1225|      0|        return (0);
 1226|      0|    }
 1227|       |
 1228|     54|    in->encoder = handler;
 1229|       |
 1230|       |    /*
 1231|       |     * Is there already some content down the pipe to convert ?
 1232|       |     */
 1233|     54|    if (xmlBufIsEmpty(in->buffer) == 0) {
  ------------------
  |  Branch (1233:9): [True: 54, False: 0]
  ------------------
 1234|     54|        size_t processed;
 1235|       |
 1236|       |        /*
 1237|       |         * Shrink the current input buffer.
 1238|       |         * Move it as the raw buffer and create a new input buffer
 1239|       |         */
 1240|     54|        processed = input->cur - input->base;
 1241|     54|        xmlBufShrink(in->buffer, processed);
 1242|     54|        input->consumed += processed;
 1243|     54|        in->raw = in->buffer;
 1244|     54|        in->buffer = xmlBufCreate();
 1245|     54|        in->rawconsumed = processed;
 1246|       |
 1247|     54|        nbchars = xmlCharEncInput(in);
 1248|     54|        xmlBufResetInput(in->buffer, input);
 1249|     54|        if (nbchars < 0) {
  ------------------
  |  Branch (1249:13): [True: 0, False: 54]
  ------------------
 1250|       |            /* TODO: This could be an out of memory or an encoding error. */
 1251|      0|            xmlErrInternal(ctxt,
 1252|      0|                           "switching encoding: encoder error\n",
 1253|      0|                           NULL);
 1254|      0|            xmlHaltParser(ctxt);
 1255|      0|            return (-1);
 1256|      0|        }
 1257|     54|    }
 1258|     54|    return (0);
 1259|     54|}
xmlSwitchToEncoding:
 1275|    111|{
 1276|    111|    if (ctxt == NULL)
  ------------------
  |  Branch (1276:9): [True: 0, False: 111]
  ------------------
 1277|      0|        return(-1);
 1278|    111|    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));
 1279|    111|}
xmlDetectEncoding:
 1290|  10.9k|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|  10.9k|    const xmlChar *in;
 1292|  10.9k|    xmlCharEncoding enc;
 1293|  10.9k|    int bomSize;
 1294|  10.9k|    int autoFlag = 0;
 1295|       |
 1296|  10.9k|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 10.9k]
  ------------------
 1297|      0|        return;
 1298|  10.9k|    in = ctxt->input->cur;
 1299|  10.9k|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 39, False: 10.9k]
  ------------------
 1300|     39|        return;
 1301|       |
 1302|  10.9k|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|  10.9k|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 10.9k]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|  10.9k|    enc = XML_CHAR_ENCODING_NONE;
 1315|  10.9k|    bomSize = 0;
 1316|       |
 1317|  10.9k|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 159, False: 10.7k]
  ------------------
 1318|      0|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 0, False: 10.9k]
  ------------------
 1319|      0|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 0, False: 0]
  |  Branch (1319:36): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      0|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 0]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      0|            break;
 1327|       |
 1328|  10.7k|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 10.7k, False: 171]
  ------------------
 1329|  10.7k|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 10.7k]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|  10.7k|            break;
 1339|       |
 1340|      3|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 3, False: 10.9k]
  ------------------
 1341|      3|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 3, False: 0]
  |  Branch (1341:29): [True: 3, False: 0]
  |  Branch (1341:48): [True: 3, False: 0]
  ------------------
 1342|      3|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      3|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      3|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      3|            }
 1345|      3|            break;
 1346|       |
 1347|      9|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 9, False: 10.8k]
  ------------------
 1348|      9|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 9, False: 0]
  |  Branch (1348:36): [True: 9, False: 0]
  ------------------
 1349|      9|                enc = XML_CHAR_ENCODING_UTF8;
 1350|      9|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|      9|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|      9|                bomSize = 3;
 1352|      9|            }
 1353|      9|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 10.9k]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 10.9k]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|  10.9k|    }
 1371|       |
 1372|  10.9k|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 9, False: 10.8k]
  ------------------
 1373|      9|        ctxt->input->cur += bomSize;
 1374|      9|    }
 1375|       |
 1376|  10.9k|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 12, False: 10.8k]
  ------------------
 1377|     12|        ctxt->input->flags |= autoFlag;
 1378|     12|        xmlSwitchEncoding(ctxt, enc);
 1379|     12|    }
 1380|  10.9k|}
xmlSetDeclaredEncoding:
 1395|    117|xmlSetDeclaredEncoding(xmlParserCtxtPtr ctxt, xmlChar *encoding) {
 1396|    117|    if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1396:9): [True: 0, False: 117]
  ------------------
 1397|      0|        xmlFree((xmlChar *) ctxt->encoding);
 1398|    117|    ctxt->encoding = encoding;
 1399|       |
 1400|    117|    if (((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) &&
  ------------------
  |  |   20|    117|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1400:9): [True: 111, False: 6]
  ------------------
 1401|    117|        ((ctxt->options & XML_PARSE_IGNORE_ENC) == 0)) {
  ------------------
  |  Branch (1401:9): [True: 111, False: 0]
  ------------------
 1402|    111|        xmlCharEncodingHandlerPtr handler;
 1403|       |
 1404|    111|        handler = xmlFindCharEncodingHandler((const char *) encoding);
 1405|    111|        if (handler == NULL) {
  ------------------
  |  Branch (1405:13): [True: 0, False: 111]
  ------------------
 1406|      0|            __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,
 1407|      0|                             "Unsupported encoding: %s\n",
 1408|      0|                             encoding, NULL);
 1409|      0|            return;
 1410|      0|        }
 1411|       |
 1412|    111|        xmlSwitchToEncoding(ctxt, handler);
 1413|    111|        ctxt->input->flags |= XML_INPUT_USES_ENC_DECL;
  ------------------
  |  |   26|    111|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
 1414|    111|    } else if (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      6|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1414:16): [True: 6, False: 0]
  ------------------
 1415|      6|        static const char *allowedUTF8[] = {
 1416|      6|            "UTF-8", "UTF8", NULL
 1417|      6|        };
 1418|      6|        static const char *allowedUTF16LE[] = {
 1419|      6|            "UTF-16", "UTF-16LE", "UTF16", NULL
 1420|      6|        };
 1421|      6|        static const char *allowedUTF16BE[] = {
 1422|      6|            "UTF-16", "UTF-16BE", "UTF16", NULL
 1423|      6|        };
 1424|      6|        const char **allowed = NULL;
 1425|      6|        const char *autoEnc = NULL;
 1426|       |
 1427|      6|        switch (ctxt->input->flags & XML_INPUT_AUTO_ENCODING) {
  ------------------
  |  |   21|      6|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (1427:17): [True: 3, False: 3]
  ------------------
 1428|      3|            case XML_INPUT_AUTO_UTF8:
  ------------------
  |  |   22|      3|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
  |  Branch (1428:13): [True: 3, False: 3]
  ------------------
 1429|      3|                allowed = allowedUTF8;
 1430|      3|                autoEnc = "UTF-8";
 1431|      3|                break;
 1432|      0|            case XML_INPUT_AUTO_UTF16LE:
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
  |  Branch (1432:13): [True: 0, False: 6]
  ------------------
 1433|      0|                allowed = allowedUTF16LE;
 1434|      0|                autoEnc = "UTF-16LE";
 1435|      0|                break;
 1436|      0|            case XML_INPUT_AUTO_UTF16BE:
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
  |  Branch (1436:13): [True: 0, False: 6]
  ------------------
 1437|      0|                allowed = allowedUTF16BE;
 1438|      0|                autoEnc = "UTF-16BE";
 1439|      0|                break;
 1440|      6|        }
 1441|       |
 1442|      6|        if (allowed != NULL) {
  ------------------
  |  Branch (1442:13): [True: 3, False: 3]
  ------------------
 1443|      3|            const char **p;
 1444|      3|            int match = 0;
 1445|       |
 1446|      3|            for (p = allowed; *p != NULL; p++) {
  ------------------
  |  Branch (1446:31): [True: 3, False: 0]
  ------------------
 1447|      3|                if (xmlStrcasecmp(encoding, BAD_CAST *p) == 0) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1447:21): [True: 3, False: 0]
  ------------------
 1448|      3|                    match = 1;
 1449|      3|                    break;
 1450|      3|                }
 1451|      3|            }
 1452|       |
 1453|      3|            if (match == 0) {
  ------------------
  |  Branch (1453:17): [True: 0, False: 3]
  ------------------
 1454|      0|                xmlWarningMsg(ctxt, XML_WAR_ENCODING_MISMATCH,
 1455|      0|                              "Encoding '%s' doesn't match "
 1456|      0|                              "auto-detected '%s'\n",
 1457|      0|                              encoding, BAD_CAST autoEnc);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1458|      0|            }
 1459|      3|        }
 1460|      6|    }
 1461|    117|}
xmlFreeInputStream:
 1476|   104k|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|   104k|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 104k]
  ------------------
 1478|       |
 1479|   104k|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 10.6k, False: 93.7k]
  ------------------
 1480|   104k|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 104k]
  ------------------
 1481|   104k|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 18, False: 104k]
  ------------------
 1482|   104k|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 104k]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|   104k|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 10.7k, False: 93.6k]
  ------------------
 1485|  10.7k|        xmlFreeParserInputBuffer(input->buf);
 1486|   104k|    xmlFree(input);
 1487|   104k|}
xmlNewInputStream:
 1498|   104k|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|   104k|    xmlParserInputPtr input;
 1500|       |
 1501|   104k|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|   104k|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 104k]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|   104k|    memset(input, 0, sizeof(xmlParserInput));
 1507|   104k|    input->line = 1;
 1508|   104k|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|   104k|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 104k, False: 0]
  ------------------
 1516|   104k|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 104k]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|   104k|        input->id = ctxt->input_id++;
 1521|   104k|    }
 1522|       |
 1523|   104k|    return(input);
 1524|   104k|}
xmlNewEntityInputStream:
 1572|   103k|xmlNewEntityInputStream(xmlParserCtxtPtr ctxt, xmlEntityPtr entity) {
 1573|   103k|    xmlParserInputPtr input;
 1574|       |
 1575|   103k|    if (entity == NULL) {
  ------------------
  |  Branch (1575:9): [True: 0, False: 103k]
  ------------------
 1576|      0|        xmlErrInternal(ctxt, "xmlNewEntityInputStream entity = NULL\n",
 1577|      0|	               NULL);
 1578|      0|	return(NULL);
 1579|      0|    }
 1580|   103k|    if (xmlParserDebugEntities)
  ------------------
  |  |  870|   103k|  #define xmlParserDebugEntities XML_GLOBAL_MACRO(xmlParserDebugEntities)
  |  |  ------------------
  |  |  |  |  500|   103k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 103k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1581|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1582|      0|		"new input from entity: %s\n", entity->name);
 1583|   103k|    if (entity->content == NULL) {
  ------------------
  |  Branch (1583:9): [True: 9.88k, False: 93.1k]
  ------------------
 1584|  9.88k|	switch (entity->etype) {
  ------------------
  |  Branch (1584:10): [True: 0, False: 9.88k]
  ------------------
 1585|      0|            case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:
  ------------------
  |  Branch (1585:13): [True: 0, False: 9.88k]
  ------------------
 1586|      0|	        xmlErrInternal(ctxt, "Cannot parse entity %s\n",
 1587|      0|		               entity->name);
 1588|      0|                break;
 1589|      0|            case XML_EXTERNAL_GENERAL_PARSED_ENTITY:
  ------------------
  |  Branch (1589:13): [True: 0, False: 9.88k]
  ------------------
 1590|  9.88k|            case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1590:13): [True: 9.88k, False: 0]
  ------------------
 1591|  9.88k|		input = xmlLoadExternalEntity((char *) entity->URI,
 1592|  9.88k|		       (char *) entity->ExternalID, ctxt);
 1593|  9.88k|                if (input != NULL)
  ------------------
  |  Branch (1593:21): [True: 9.88k, False: 0]
  ------------------
 1594|  9.88k|                    input->entity = entity;
 1595|  9.88k|                return(input);
 1596|      0|            case XML_INTERNAL_GENERAL_ENTITY:
  ------------------
  |  Branch (1596:13): [True: 0, False: 9.88k]
  ------------------
 1597|      0|	        xmlErrInternal(ctxt,
 1598|      0|		      "Internal entity %s without content !\n",
 1599|      0|		               entity->name);
 1600|      0|                break;
 1601|      0|            case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (1601:13): [True: 0, False: 9.88k]
  ------------------
 1602|      0|	        xmlErrInternal(ctxt,
 1603|      0|		      "Internal parameter entity %s without content !\n",
 1604|      0|		               entity->name);
 1605|      0|                break;
 1606|      0|            case XML_INTERNAL_PREDEFINED_ENTITY:
  ------------------
  |  Branch (1606:13): [True: 0, False: 9.88k]
  ------------------
 1607|      0|	        xmlErrInternal(ctxt,
 1608|      0|		      "Predefined entity %s without content !\n",
 1609|      0|		               entity->name);
 1610|      0|                break;
 1611|  9.88k|	}
 1612|      0|	return(NULL);
 1613|  9.88k|    }
 1614|  93.1k|    input = xmlNewInputStream(ctxt);
 1615|  93.1k|    if (input == NULL) {
  ------------------
  |  Branch (1615:9): [True: 0, False: 93.1k]
  ------------------
 1616|      0|	return(NULL);
 1617|      0|    }
 1618|  93.1k|    if (entity->URI != NULL)
  ------------------
  |  Branch (1618:9): [True: 0, False: 93.1k]
  ------------------
 1619|      0|	input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);
 1620|  93.1k|    input->base = entity->content;
 1621|  93.1k|    if (entity->length == 0)
  ------------------
  |  Branch (1621:9): [True: 0, False: 93.1k]
  ------------------
 1622|      0|        entity->length = xmlStrlen(entity->content);
 1623|  93.1k|    input->cur = entity->content;
 1624|  93.1k|    input->length = entity->length;
 1625|  93.1k|    input->end = &entity->content[input->length];
 1626|  93.1k|    input->entity = entity;
 1627|  93.1k|    return(input);
 1628|  93.1k|}
xmlFreeParserCtxt:
 1967|  1.32k|{
 1968|  1.32k|    xmlParserInputPtr input;
 1969|       |
 1970|  1.32k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 1.32k]
  ------------------
 1971|       |
 1972|  2.64k|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 1.31k, False: 1.32k]
  ------------------
 1973|  1.31k|        xmlFreeInputStream(input);
 1974|  1.31k|    }
 1975|  1.32k|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 1.32k, False: 0]
  ------------------
 1976|  1.32k|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 1.32k, False: 0]
  ------------------
 1977|  1.32k|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 1.32k, False: 0]
  ------------------
 1978|  1.32k|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 1.32k]
  ------------------
 1979|  1.32k|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 1.32k, False: 0]
  ------------------
 1980|  1.32k|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 966, False: 356]
  ------------------
 1981|  1.32k|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 105, False: 1.21k]
  ------------------
 1982|  1.32k|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 201, False: 1.12k]
  ------------------
 1983|  1.32k|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 120, False: 1.20k]
  ------------------
 1984|  1.32k|#ifdef LIBXML_SAX1_ENABLED
 1985|  1.32k|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 1.32k, False: 0]
  ------------------
 1986|  1.32k|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|  1.32k|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 1.32k, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|  1.32k|        xmlFree(ctxt->sax);
 1991|  1.32k|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 350, False: 972]
  ------------------
 1992|  1.32k|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 1.32k]
  ------------------
 1993|  1.32k|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 387, False: 935]
  ------------------
 1994|  1.32k|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 971, False: 351]
  ------------------
 1995|  1.32k|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 216, False: 1.10k]
  ------------------
 1996|  1.32k|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 1.32k, False: 0]
  ------------------
 1997|  1.32k|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 229, False: 1.09k]
  ------------------
 1998|  1.32k|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 791, False: 531]
  ------------------
 1999|  1.32k|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 387, False: 935]
  ------------------
 2000|  1.32k|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 54, False: 1.26k]
  ------------------
 2001|     54|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|  1.32k|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 81, False: 1.24k]
  ------------------
 2003|     81|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|  1.32k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 283, False: 1.03k]
  ------------------
 2005|    283|        xmlNodePtr cur, next;
 2006|       |
 2007|    283|	cur = ctxt->freeElems;
 2008|    566|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 283, False: 283]
  ------------------
 2009|    283|	    next = cur->next;
 2010|    283|	    xmlFree(cur);
 2011|    283|	    cur = next;
 2012|    283|	}
 2013|    283|    }
 2014|  1.32k|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 116, False: 1.20k]
  ------------------
 2015|    116|        xmlAttrPtr cur, next;
 2016|       |
 2017|    116|	cur = ctxt->freeAttrs;
 2018|    232|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 116, False: 116]
  ------------------
 2019|    116|	    next = cur->next;
 2020|    116|	    xmlFree(cur);
 2021|    116|	    cur = next;
 2022|    116|	}
 2023|    116|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|  1.32k|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 395, False: 927]
  ------------------
 2028|    395|        xmlFree(ctxt->lastError.message);
 2029|  1.32k|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 179, False: 1.14k]
  ------------------
 2030|    179|        xmlFree(ctxt->lastError.file);
 2031|  1.32k|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 137, False: 1.18k]
  ------------------
 2032|    137|        xmlFree(ctxt->lastError.str1);
 2033|  1.32k|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 34, False: 1.28k]
  ------------------
 2034|     34|        xmlFree(ctxt->lastError.str2);
 2035|  1.32k|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 3, False: 1.31k]
  ------------------
 2036|      3|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|  1.32k|#ifdef LIBXML_CATALOG_ENABLED
 2039|  1.32k|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 1.32k]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|  1.32k|#endif
 2042|  1.32k|    xmlFree(ctxt);
 2043|  1.32k|}
xmlNewParserCtxt:
 2055|    646|{
 2056|    646|    return(xmlNewSAXParserCtxt(NULL, NULL));
 2057|    646|}
xmlNewSAXParserCtxt:
 2072|  1.32k|{
 2073|  1.32k|    xmlParserCtxtPtr ctxt;
 2074|       |
 2075|  1.32k|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 2076|  1.32k|    if (ctxt == NULL) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 1.32k]
  ------------------
 2077|      0|	xmlErrMemory(NULL, "cannot allocate parser context\n");
 2078|      0|	return(NULL);
 2079|      0|    }
 2080|  1.32k|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 2081|  1.32k|    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (2081:9): [True: 0, False: 1.32k]
  ------------------
 2082|      0|        xmlFreeParserCtxt(ctxt);
 2083|      0|	return(NULL);
 2084|      0|    }
 2085|  1.32k|    return(ctxt);
 2086|  1.32k|}
xmlInitNodeInfoSeq:
 2149|  1.32k|{
 2150|  1.32k|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 1.32k]
  ------------------
 2151|      0|        return;
 2152|  1.32k|    seq->length = 0;
 2153|  1.32k|    seq->maximum = 0;
 2154|  1.32k|    seq->buffer = NULL;
 2155|  1.32k|}
parserInternals.c:xmlDetectEBCDIC:
 1055|      3|xmlDetectEBCDIC(xmlParserInputPtr input) {
 1056|      3|    xmlChar out[200];
 1057|      3|    xmlCharEncodingHandlerPtr handler;
 1058|      3|    int inlen, outlen, res, i;
 1059|       |
 1060|       |    /*
 1061|       |     * To detect the EBCDIC code page, we convert the first 200 bytes
 1062|       |     * to EBCDIC-US and try to find the encoding declaration.
 1063|       |     */
 1064|      3|    handler = xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC);
 1065|      3|    if (handler == NULL)
  ------------------
  |  Branch (1065:9): [True: 0, False: 3]
  ------------------
 1066|      0|        return(NULL);
 1067|      3|    outlen = sizeof(out) - 1;
 1068|      3|    inlen = input->end - input->cur;
 1069|      3|    res = xmlEncInputChunk(handler, out, &outlen, input->cur, &inlen);
 1070|      3|    if (res < 0)
  ------------------
  |  Branch (1070:9): [True: 0, False: 3]
  ------------------
 1071|      0|        return(handler);
 1072|      3|    out[outlen] = 0;
 1073|       |
 1074|     63|    for (i = 0; i < outlen; i++) {
  ------------------
  |  Branch (1074:17): [True: 63, False: 0]
  ------------------
 1075|     63|        if (out[i] == '>')
  ------------------
  |  Branch (1075:13): [True: 0, False: 63]
  ------------------
 1076|      0|            break;
 1077|     63|        if ((out[i] == 'e') &&
  ------------------
  |  Branch (1077:13): [True: 6, False: 57]
  ------------------
 1078|     63|            (xmlStrncmp(out + i, BAD_CAST "encoding", 8) == 0)) {
  ------------------
  |  |   35|      6|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1078:13): [True: 3, False: 3]
  ------------------
 1079|      3|            int start, cur, quote;
 1080|       |
 1081|      3|            i += 8;
 1082|      3|            while (IS_BLANK_CH(out[i]))
 1083|      0|                i += 1;
 1084|      3|            if (out[i++] != '=')
  ------------------
  |  Branch (1084:17): [True: 0, False: 3]
  ------------------
 1085|      0|                break;
 1086|      3|            while (IS_BLANK_CH(out[i]))
 1087|      0|                i += 1;
 1088|      3|            quote = out[i++];
 1089|      3|            if ((quote != '\'') && (quote != '"'))
  ------------------
  |  Branch (1089:17): [True: 3, False: 0]
  |  Branch (1089:36): [True: 0, False: 3]
  ------------------
 1090|      0|                break;
 1091|      3|            start = i;
 1092|      3|            cur = out[i];
 1093|     27|            while (((cur >= 'a') && (cur <= 'z')) ||
  ------------------
  |  Branch (1093:21): [True: 0, False: 27]
  |  Branch (1093:37): [True: 0, False: 0]
  ------------------
 1094|     27|                   ((cur >= 'A') && (cur <= 'Z')) ||
  ------------------
  |  Branch (1094:21): [True: 9, False: 18]
  |  Branch (1094:37): [True: 9, False: 0]
  ------------------
 1095|     27|                   ((cur >= '0') && (cur <= '9')) ||
  ------------------
  |  Branch (1095:21): [True: 12, False: 6]
  |  Branch (1095:37): [True: 12, False: 0]
  ------------------
 1096|     27|                   (cur == '.') || (cur == '_') ||
  ------------------
  |  Branch (1096:20): [True: 0, False: 6]
  |  Branch (1096:36): [True: 0, False: 6]
  ------------------
 1097|     27|                   (cur == '-'))
  ------------------
  |  Branch (1097:20): [True: 3, False: 3]
  ------------------
 1098|     24|                cur = out[++i];
 1099|      3|            if (cur != quote)
  ------------------
  |  Branch (1099:17): [True: 0, False: 3]
  ------------------
 1100|      0|                break;
 1101|      3|            out[i] = 0;
 1102|      3|            xmlCharEncCloseFunc(handler);
 1103|      3|            return(xmlFindCharEncodingHandler((char *) out + start));
 1104|      3|        }
 1105|     63|    }
 1106|       |
 1107|       |    /*
 1108|       |     * ICU handlers are stateful, so we have to recreate them.
 1109|       |     */
 1110|      0|    xmlCharEncCloseFunc(handler);
 1111|      0|    return(xmlGetCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC));
 1112|      3|}
parserInternals.c:xmlInitSAXParserCtxt:
 1746|  1.32k|{
 1747|  1.32k|    xmlParserInputPtr input;
 1748|       |
 1749|  1.32k|    if(ctxt==NULL) {
  ------------------
  |  Branch (1749:8): [True: 0, False: 1.32k]
  ------------------
 1750|      0|        xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
 1751|      0|        return(-1);
 1752|      0|    }
 1753|       |
 1754|  1.32k|    xmlInitParser();
 1755|       |
 1756|  1.32k|    if (ctxt->dict == NULL)
  ------------------
  |  Branch (1756:9): [True: 1.32k, False: 0]
  ------------------
 1757|  1.32k|	ctxt->dict = xmlDictCreate();
 1758|  1.32k|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (1758:9): [True: 0, False: 1.32k]
  ------------------
 1759|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1760|      0|	return(-1);
 1761|      0|    }
 1762|  1.32k|    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
  ------------------
  |  |   71|  1.32k|#define XML_MAX_DICTIONARY_LIMIT 10000000
  ------------------
 1763|       |
 1764|  1.32k|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (1764:9): [True: 1.32k, False: 0]
  ------------------
 1765|  1.32k|	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1766|  1.32k|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (1766:9): [True: 0, False: 1.32k]
  ------------------
 1767|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1768|      0|	return(-1);
 1769|      0|    }
 1770|  1.32k|    if (sax == NULL) {
  ------------------
  |  Branch (1770:9): [True: 969, False: 353]
  ------------------
 1771|    969|	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1772|    969|        xmlSAXVersion(ctxt->sax, 2);
 1773|    969|        ctxt->userData = ctxt;
 1774|    969|    } else {
 1775|    353|	if (sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    353|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1775:6): [True: 353, False: 0]
  ------------------
 1776|    353|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
 1777|    353|        } else {
 1778|      0|	    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1779|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
 1780|      0|        }
 1781|    353|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (1781:26): [True: 0, False: 353]
  ------------------
 1782|    353|    }
 1783|       |
 1784|  1.32k|    ctxt->maxatts = 0;
 1785|  1.32k|    ctxt->atts = NULL;
 1786|       |    /* Allocate the Input stack */
 1787|  1.32k|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1787:9): [True: 1.32k, False: 0]
  ------------------
 1788|  1.32k|	ctxt->inputTab = (xmlParserInputPtr *)
 1789|  1.32k|		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
 1790|  1.32k|	ctxt->inputMax = 5;
 1791|  1.32k|    }
 1792|  1.32k|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1792:9): [True: 0, False: 1.32k]
  ------------------
 1793|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1794|      0|	ctxt->inputNr = 0;
 1795|      0|	ctxt->inputMax = 0;
 1796|      0|	ctxt->input = NULL;
 1797|      0|	return(-1);
 1798|      0|    }
 1799|  1.32k|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1799:12): [True: 0, False: 1.32k]
  ------------------
 1800|      0|        xmlFreeInputStream(input);
 1801|      0|    }
 1802|  1.32k|    ctxt->inputNr = 0;
 1803|  1.32k|    ctxt->input = NULL;
 1804|       |
 1805|  1.32k|    ctxt->version = NULL;
 1806|  1.32k|    ctxt->encoding = NULL;
 1807|  1.32k|    ctxt->standalone = -1;
 1808|  1.32k|    ctxt->hasExternalSubset = 0;
 1809|  1.32k|    ctxt->hasPErefs = 0;
 1810|  1.32k|    ctxt->html = 0;
 1811|  1.32k|    ctxt->external = 0;
 1812|  1.32k|    ctxt->instate = XML_PARSER_START;
 1813|  1.32k|    ctxt->token = 0;
 1814|  1.32k|    ctxt->directory = NULL;
 1815|       |
 1816|       |    /* Allocate the Node stack */
 1817|  1.32k|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1817:9): [True: 1.32k, False: 0]
  ------------------
 1818|  1.32k|	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
 1819|  1.32k|	ctxt->nodeMax = 10;
 1820|  1.32k|    }
 1821|  1.32k|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 1.32k]
  ------------------
 1822|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1823|      0|	ctxt->nodeNr = 0;
 1824|      0|	ctxt->nodeMax = 0;
 1825|      0|	ctxt->node = NULL;
 1826|      0|	ctxt->inputNr = 0;
 1827|      0|	ctxt->inputMax = 0;
 1828|      0|	ctxt->input = NULL;
 1829|      0|	return(-1);
 1830|      0|    }
 1831|  1.32k|    ctxt->nodeNr = 0;
 1832|  1.32k|    ctxt->node = NULL;
 1833|       |
 1834|       |    /* Allocate the Name stack */
 1835|  1.32k|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1835:9): [True: 1.32k, False: 0]
  ------------------
 1836|  1.32k|	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 1837|  1.32k|	ctxt->nameMax = 10;
 1838|  1.32k|    }
 1839|  1.32k|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 1.32k]
  ------------------
 1840|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1841|      0|	ctxt->nodeNr = 0;
 1842|      0|	ctxt->nodeMax = 0;
 1843|      0|	ctxt->node = NULL;
 1844|      0|	ctxt->inputNr = 0;
 1845|      0|	ctxt->inputMax = 0;
 1846|      0|	ctxt->input = NULL;
 1847|      0|	ctxt->nameNr = 0;
 1848|      0|	ctxt->nameMax = 0;
 1849|      0|	ctxt->name = NULL;
 1850|      0|	return(-1);
 1851|      0|    }
 1852|  1.32k|    ctxt->nameNr = 0;
 1853|  1.32k|    ctxt->name = NULL;
 1854|       |
 1855|       |    /* Allocate the space stack */
 1856|  1.32k|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1856:9): [True: 1.32k, False: 0]
  ------------------
 1857|  1.32k|	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
 1858|  1.32k|	ctxt->spaceMax = 10;
 1859|  1.32k|    }
 1860|  1.32k|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1860:9): [True: 0, False: 1.32k]
  ------------------
 1861|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1862|      0|	ctxt->nodeNr = 0;
 1863|      0|	ctxt->nodeMax = 0;
 1864|      0|	ctxt->node = NULL;
 1865|      0|	ctxt->inputNr = 0;
 1866|      0|	ctxt->inputMax = 0;
 1867|      0|	ctxt->input = NULL;
 1868|      0|	ctxt->nameNr = 0;
 1869|      0|	ctxt->nameMax = 0;
 1870|      0|	ctxt->name = NULL;
 1871|      0|	ctxt->spaceNr = 0;
 1872|      0|	ctxt->spaceMax = 0;
 1873|      0|	ctxt->space = NULL;
 1874|      0|	return(-1);
 1875|      0|    }
 1876|  1.32k|    ctxt->spaceNr = 1;
 1877|  1.32k|    ctxt->spaceMax = 10;
 1878|  1.32k|    ctxt->spaceTab[0] = -1;
 1879|  1.32k|    ctxt->space = &ctxt->spaceTab[0];
 1880|  1.32k|    ctxt->myDoc = NULL;
 1881|  1.32k|    ctxt->wellFormed = 1;
 1882|  1.32k|    ctxt->nsWellFormed = 1;
 1883|  1.32k|    ctxt->valid = 1;
 1884|  1.32k|    ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
  ------------------
  |  |  869|  1.32k|  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1885|  1.32k|    if (ctxt->loadsubset) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 1.32k]
  ------------------
 1886|      0|        ctxt->options |= XML_PARSE_DTDLOAD;
 1887|      0|    }
 1888|  1.32k|    ctxt->validate = xmlDoValidityCheckingDefaultValue;
  ------------------
  |  |  863|  1.32k|    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1889|  1.32k|    ctxt->pedantic = xmlPedanticParserDefaultValue;
  ------------------
  |  |  872|  1.32k|    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1890|  1.32k|    if (ctxt->pedantic) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 1.32k]
  ------------------
 1891|      0|        ctxt->options |= XML_PARSE_PEDANTIC;
 1892|      0|    }
 1893|  1.32k|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|  1.32k|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1894|  1.32k|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|  1.32k|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1895|  1.32k|    if (ctxt->keepBlanks == 0) {
  ------------------
  |  Branch (1895:9): [True: 0, False: 1.32k]
  ------------------
 1896|      0|	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 1897|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
 1898|      0|    }
 1899|       |
 1900|  1.32k|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|  1.32k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 1901|  1.32k|    ctxt->vctxt.userData = ctxt;
 1902|  1.32k|    ctxt->vctxt.error = xmlParserValidityError;
 1903|  1.32k|    ctxt->vctxt.warning = xmlParserValidityWarning;
 1904|  1.32k|    if (ctxt->validate) {
  ------------------
  |  Branch (1904:9): [True: 0, False: 1.32k]
  ------------------
 1905|      0|	if (xmlGetWarningsDefaultValue == 0)
  ------------------
  |  |  865|      0|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1905:6): [True: 0, False: 0]
  ------------------
 1906|      0|	    ctxt->vctxt.warning = NULL;
 1907|      0|	else
 1908|      0|	    ctxt->vctxt.warning = xmlParserValidityWarning;
 1909|      0|	ctxt->vctxt.nodeMax = 0;
 1910|      0|        ctxt->options |= XML_PARSE_DTDVALID;
 1911|      0|    }
 1912|  1.32k|    ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
  ------------------
  |  |  874|  1.32k|    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)
  |  |  ------------------
  |  |  |  |  500|  1.32k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1913|  1.32k|    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (1913:9): [True: 0, False: 1.32k]
  ------------------
 1914|      0|        ctxt->options |= XML_PARSE_NOENT;
 1915|      0|    }
 1916|  1.32k|    ctxt->record_info = 0;
 1917|  1.32k|    ctxt->checkIndex = 0;
 1918|  1.32k|    ctxt->inSubset = 0;
 1919|  1.32k|    ctxt->errNo = XML_ERR_OK;
 1920|  1.32k|    ctxt->depth = 0;
 1921|  1.32k|    ctxt->catalogs = NULL;
 1922|  1.32k|    ctxt->sizeentities = 0;
 1923|  1.32k|    ctxt->sizeentcopy = 0;
 1924|  1.32k|    ctxt->input_id = 1;
 1925|  1.32k|    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;
  ------------------
  |  |   52|  1.32k|#define XML_MAX_AMPLIFICATION_DEFAULT 5
  ------------------
 1926|  1.32k|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 1927|       |
 1928|  1.32k|    if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1928:9): [True: 1.32k, False: 0]
  ------------------
 1929|  1.32k|        ctxt->nsdb = xmlParserNsCreate();
 1930|  1.32k|        if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1930:13): [True: 0, False: 1.32k]
  ------------------
 1931|      0|            xmlErrMemory(ctxt, NULL);
 1932|      0|            return(-1);
 1933|      0|        }
 1934|  1.32k|    }
 1935|       |
 1936|  1.32k|    return(0);
 1937|  1.32k|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|  5.25k|{
  203|  5.25k|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 5.25k]
  ------------------
  204|      0|        return;
  205|  5.25k|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|  5.25k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  5.25k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 5.25k, False: 0]
  ------------------
  211|  5.25k|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|  5.25k|}
xmlMutexUnlock:
  226|  5.25k|{
  227|  5.25k|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 5.25k]
  ------------------
  228|      0|        return;
  229|  5.25k|#ifdef HAVE_POSIX_THREADS
  230|  5.25k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  5.25k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 5.25k, False: 0]
  ------------------
  231|  5.25k|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|  5.25k|}
xmlNewRMutex:
  249|      2|{
  250|      2|    xmlRMutexPtr tok;
  251|       |
  252|      2|    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)
  ------------------
  |  Branch (252:9): [True: 0, False: 2]
  ------------------
  253|      0|        return (NULL);
  254|      2|#ifdef HAVE_POSIX_THREADS
  255|      2|    if (XML_IS_NEVER_THREADED() == 0) {
  ------------------
  |  |   85|      2|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (255:9): [True: 2, False: 0]
  ------------------
  256|      2|        pthread_mutex_init(&tok->lock, NULL);
  257|      2|        tok->held = 0;
  258|      2|        tok->waiters = 0;
  259|      2|        pthread_cond_init(&tok->cv, NULL);
  260|      2|    }
  261|       |#elif defined HAVE_WIN32_THREADS
  262|       |    InitializeCriticalSection(&tok->cs);
  263|       |#endif
  264|      2|    return (tok);
  265|      2|}
xmlRMutexLock:
  298|      2|{
  299|      2|    if (tok == NULL)
  ------------------
  |  Branch (299:9): [True: 0, False: 2]
  ------------------
  300|      0|        return;
  301|      2|#ifdef HAVE_POSIX_THREADS
  302|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (302:9): [True: 0, False: 2]
  ------------------
  303|      0|        return;
  304|       |
  305|      2|    pthread_mutex_lock(&tok->lock);
  306|      2|    if (tok->held) {
  ------------------
  |  Branch (306:9): [True: 0, False: 2]
  ------------------
  307|      0|        if (pthread_equal(tok->tid, pthread_self())) {
  ------------------
  |  Branch (307:13): [True: 0, False: 0]
  ------------------
  308|      0|            tok->held++;
  309|      0|            pthread_mutex_unlock(&tok->lock);
  310|      0|            return;
  311|      0|        } else {
  312|      0|            tok->waiters++;
  313|      0|            while (tok->held)
  ------------------
  |  Branch (313:20): [True: 0, False: 0]
  ------------------
  314|      0|                pthread_cond_wait(&tok->cv, &tok->lock);
  315|      0|            tok->waiters--;
  316|      0|        }
  317|      0|    }
  318|      2|    tok->tid = pthread_self();
  319|      2|    tok->held = 1;
  320|      2|    pthread_mutex_unlock(&tok->lock);
  321|       |#elif defined HAVE_WIN32_THREADS
  322|       |    EnterCriticalSection(&tok->cs);
  323|       |#endif
  324|      2|}
xmlRMutexUnlock:
  334|      2|{
  335|      2|    if (tok == NULL)
  ------------------
  |  Branch (335:9): [True: 0, False: 2]
  ------------------
  336|      0|        return;
  337|      2|#ifdef HAVE_POSIX_THREADS
  338|      2|    if (XML_IS_THREADED() == 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (338:9): [True: 0, False: 2]
  ------------------
  339|      0|        return;
  340|       |
  341|      2|    pthread_mutex_lock(&tok->lock);
  342|      2|    tok->held--;
  343|      2|    if (tok->held == 0) {
  ------------------
  |  Branch (343:9): [True: 2, False: 0]
  ------------------
  344|      2|        if (tok->waiters)
  ------------------
  |  Branch (344:13): [True: 0, False: 2]
  ------------------
  345|      0|            pthread_cond_signal(&tok->cv);
  346|      2|        memset(&tok->tid, 0, sizeof(tok->tid));
  347|      2|    }
  348|      2|    pthread_mutex_unlock(&tok->lock);
  349|       |#elif defined HAVE_WIN32_THREADS
  350|       |    LeaveCriticalSection(&tok->cs);
  351|       |#endif
  352|      2|}
xmlInitParser:
  569|  4.85k|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|  4.85k|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 4.84k, False: 2]
  ------------------
  574|  4.84k|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

xmlBuildQName:
  218|    438|	      xmlChar *memory, int len) {
  219|    438|    int lenn, lenp;
  220|    438|    xmlChar *ret;
  221|       |
  222|    438|    if (ncname == NULL) return(NULL);
  ------------------
  |  Branch (222:9): [True: 0, False: 438]
  ------------------
  223|    438|    if (prefix == NULL) return((xmlChar *) ncname);
  ------------------
  |  Branch (223:9): [True: 0, False: 438]
  ------------------
  224|       |
  225|    438|    lenn = strlen((char *) ncname);
  226|    438|    lenp = strlen((char *) prefix);
  227|       |
  228|    438|    if ((memory == NULL) || (len < lenn + lenp + 2)) {
  ------------------
  |  Branch (228:9): [True: 0, False: 438]
  |  Branch (228:29): [True: 0, False: 438]
  ------------------
  229|      0|	ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);
  230|      0|	if (ret == NULL) {
  ------------------
  |  Branch (230:6): [True: 0, False: 0]
  ------------------
  231|      0|	    xmlTreeErrMemory("building QName");
  232|      0|	    return(NULL);
  233|      0|	}
  234|    438|    } else {
  235|    438|	ret = memory;
  236|    438|    }
  237|    438|    memcpy(&ret[0], prefix, lenp);
  238|    438|    ret[lenp] = ':';
  239|    438|    memcpy(&ret[lenp + 1], ncname, lenn);
  240|    438|    ret[lenn + lenp + 1] = 0;
  241|    438|    return(ret);
  242|    438|}
xmlSplitQName2:
  262|  16.0k|xmlSplitQName2(const xmlChar *name, xmlChar **prefix) {
  263|  16.0k|    int len = 0;
  264|  16.0k|    xmlChar *ret = NULL;
  265|       |
  266|  16.0k|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (266:9): [True: 0, False: 16.0k]
  ------------------
  267|  16.0k|    *prefix = NULL;
  268|  16.0k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (268:9): [True: 0, False: 16.0k]
  ------------------
  269|       |
  270|       |#ifndef XML_XML_NAMESPACE
  271|       |    /* xml: prefix is not really a namespace */
  272|       |    if ((name[0] == 'x') && (name[1] == 'm') &&
  273|       |        (name[2] == 'l') && (name[3] == ':'))
  274|       |	return(NULL);
  275|       |#endif
  276|       |
  277|       |    /* nasty but valid */
  278|  16.0k|    if (name[0] == ':')
  ------------------
  |  Branch (278:9): [True: 0, False: 16.0k]
  ------------------
  279|      0|	return(NULL);
  280|       |
  281|       |    /*
  282|       |     * we are not trying to validate but just to cut, and yes it will
  283|       |     * work even if this is as set of UTF-8 encoded chars
  284|       |     */
  285|  92.1k|    while ((name[len] != 0) && (name[len] != ':'))
  ------------------
  |  Branch (285:12): [True: 76.5k, False: 15.6k]
  |  Branch (285:32): [True: 76.1k, False: 384]
  ------------------
  286|  76.1k|	len++;
  287|       |
  288|  16.0k|    if (name[len] == 0)
  ------------------
  |  Branch (288:9): [True: 15.6k, False: 384]
  ------------------
  289|  15.6k|	return(NULL);
  290|       |
  291|    384|    *prefix = xmlStrndup(name, len);
  292|    384|    if (*prefix == NULL) {
  ------------------
  |  Branch (292:9): [True: 0, False: 384]
  ------------------
  293|      0|	xmlTreeErrMemory("QName split");
  294|      0|	return(NULL);
  295|      0|    }
  296|    384|    ret = xmlStrdup(&name[len + 1]);
  297|    384|    if (ret == NULL) {
  ------------------
  |  Branch (297:9): [True: 0, False: 384]
  ------------------
  298|      0|	xmlTreeErrMemory("QName split");
  299|      0|	if (*prefix != NULL) {
  ------------------
  |  Branch (299:6): [True: 0, False: 0]
  ------------------
  300|      0|	    xmlFree(*prefix);
  301|      0|	    *prefix = NULL;
  302|      0|	}
  303|      0|	return(NULL);
  304|      0|    }
  305|       |
  306|    384|    return(ret);
  307|    384|}
xmlSplitQName3:
  322|  9.16k|xmlSplitQName3(const xmlChar *name, int *len) {
  323|  9.16k|    int l = 0;
  324|       |
  325|  9.16k|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (325:9): [True: 0, False: 9.16k]
  ------------------
  326|  9.16k|    if (len == NULL) return(NULL);
  ------------------
  |  Branch (326:9): [True: 0, False: 9.16k]
  ------------------
  327|       |
  328|       |    /* nasty but valid */
  329|  9.16k|    if (name[0] == ':')
  ------------------
  |  Branch (329:9): [True: 0, False: 9.16k]
  ------------------
  330|      0|	return(NULL);
  331|       |
  332|       |    /*
  333|       |     * we are not trying to validate but just to cut, and yes it will
  334|       |     * work even if this is as set of UTF-8 encoded chars
  335|       |     */
  336|  65.2k|    while ((name[l] != 0) && (name[l] != ':'))
  ------------------
  |  Branch (336:12): [True: 56.2k, False: 8.99k]
  |  Branch (336:30): [True: 56.0k, False: 177]
  ------------------
  337|  56.0k|	l++;
  338|       |
  339|  9.16k|    if (name[l] == 0)
  ------------------
  |  Branch (339:9): [True: 8.99k, False: 177]
  ------------------
  340|  8.99k|	return(NULL);
  341|       |
  342|    177|    *len = l;
  343|       |
  344|    177|    return(&name[l+1]);
  345|  9.16k|}
xmlValidateNCName:
  366|     21|xmlValidateNCName(const xmlChar *value, int space) {
  367|     21|    const xmlChar *cur = value;
  368|     21|    int c,l;
  369|       |
  370|     21|    if (value == NULL)
  ------------------
  |  Branch (370:9): [True: 0, False: 21]
  ------------------
  371|      0|        return(-1);
  372|       |
  373|       |    /*
  374|       |     * First quick algorithm for ASCII range
  375|       |     */
  376|     21|    if (space)
  ------------------
  |  Branch (376:9): [True: 21, False: 0]
  ------------------
  377|     21|	while (IS_BLANK_CH(*cur)) cur++;
  378|     21|    if (((*cur >= 'a') && (*cur <= 'z')) || ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (378:10): [True: 18, False: 3]
  |  Branch (378:27): [True: 18, False: 0]
  |  Branch (378:46): [True: 0, False: 3]
  |  Branch (378:63): [True: 0, False: 0]
  ------------------
  379|     21|	(*cur == '_'))
  ------------------
  |  Branch (379:2): [True: 0, False: 3]
  ------------------
  380|     18|	cur++;
  381|      3|    else
  382|      3|	goto try_complex;
  383|     54|    while (((*cur >= 'a') && (*cur <= 'z')) ||
  ------------------
  |  Branch (383:13): [True: 36, False: 18]
  |  Branch (383:30): [True: 36, False: 0]
  ------------------
  384|     54|	   ((*cur >= 'A') && (*cur <= 'Z')) ||
  ------------------
  |  Branch (384:6): [True: 0, False: 18]
  |  Branch (384:23): [True: 0, False: 0]
  ------------------
  385|     54|	   ((*cur >= '0') && (*cur <= '9')) ||
  ------------------
  |  Branch (385:6): [True: 0, False: 18]
  |  Branch (385:23): [True: 0, False: 0]
  ------------------
  386|     54|	   (*cur == '_') || (*cur == '-') || (*cur == '.'))
  ------------------
  |  Branch (386:5): [True: 0, False: 18]
  |  Branch (386:22): [True: 0, False: 18]
  |  Branch (386:39): [True: 0, False: 18]
  ------------------
  387|     36|	cur++;
  388|     18|    if (space)
  ------------------
  |  Branch (388:9): [True: 18, False: 0]
  ------------------
  389|     18|	while (IS_BLANK_CH(*cur)) cur++;
  390|     18|    if (*cur == 0)
  ------------------
  |  Branch (390:9): [True: 18, False: 0]
  ------------------
  391|     18|	return(0);
  392|       |
  393|      3|try_complex:
  394|       |    /*
  395|       |     * Second check for chars outside the ASCII range
  396|       |     */
  397|      3|    cur = value;
  398|      3|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      3|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  399|      3|    if (space) {
  ------------------
  |  Branch (399:9): [True: 3, False: 0]
  ------------------
  400|      3|	while (IS_BLANK(c)) {
  401|      0|	    cur += l;
  402|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  403|      0|	}
  404|      3|    }
  405|      3|    if ((!IS_LETTER(c)) && (c != '_'))
  ------------------
  |  |  240|      3|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      3|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      6|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 3]
  |  |  |  |  |  |  |  Branch (76:28): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      6|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      3|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      3|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      3|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      3|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      3|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 3]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      6|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      3|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      3|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 3]
  |  |  |  |  |  |  |  Branch (184:31): [True: 3, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      3|				 0 :\
  |  |  |  |  |  |  186|      3|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (405:28): [True: 3, False: 0]
  ------------------
  406|      3|	return(1);
  407|      0|    cur += l;
  408|      0|    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  409|      0|    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:25): [True: 0, False: 0]
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (409:43): [True: 0, False: 0]
  ------------------
  410|      0|	   (c == '-') || (c == '_') || IS_COMBINING(c) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (410:5): [True: 0, False: 0]
  |  Branch (410:19): [True: 0, False: 0]
  ------------------
  411|      0|	   IS_EXTENDER(c)) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  412|      0|	cur += l;
  413|      0|	c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  414|      0|    }
  415|      0|    if (space) {
  ------------------
  |  Branch (415:9): [True: 0, False: 0]
  ------------------
  416|      0|	while (IS_BLANK(c)) {
  417|      0|	    cur += l;
  418|      0|	    c = CUR_SCHAR(cur, l);
  ------------------
  |  |  353|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(NULL, s, &l)
  ------------------
  419|      0|	}
  420|      0|    }
  421|      0|    if (c != 0)
  ------------------
  |  Branch (421:9): [True: 0, False: 0]
  ------------------
  422|      0|	return(1);
  423|       |
  424|      0|    return(0);
  425|      0|}
xmlNewNs:
  726|    327|xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {
  727|    327|    xmlNsPtr cur;
  728|       |
  729|    327|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (729:9): [True: 6, False: 321]
  |  Branch (729:27): [True: 0, False: 6]
  ------------------
  730|      0|	return(NULL);
  731|       |
  732|    327|    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|    231|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (732:9): [True: 231, False: 96]
  |  Branch (732:29): [True: 0, False: 231]
  ------------------
  733|       |        /* xml namespace is predefined, no need to add it */
  734|      0|        if (xmlStrEqual(href, XML_XML_NAMESPACE))
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|            return(NULL);
  736|       |
  737|       |        /*
  738|       |         * Problem, this is an attempt to bind xml prefix to a wrong
  739|       |         * namespace, which breaks
  740|       |         * Namespace constraint: Reserved Prefixes and Namespace Names
  741|       |         * from XML namespace. But documents authors may not care in
  742|       |         * their context so let's proceed.
  743|       |         */
  744|      0|    }
  745|       |
  746|       |    /*
  747|       |     * Allocate a new Namespace and fill the fields.
  748|       |     */
  749|    327|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
  750|    327|    if (cur == NULL) {
  ------------------
  |  Branch (750:9): [True: 0, False: 327]
  ------------------
  751|      0|	xmlTreeErrMemory("building namespace");
  752|      0|	return(NULL);
  753|      0|    }
  754|    327|    memset(cur, 0, sizeof(xmlNs));
  755|    327|    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|    327|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  756|       |
  757|    327|    if (href != NULL)
  ------------------
  |  Branch (757:9): [True: 309, False: 18]
  ------------------
  758|    309|	cur->href = xmlStrdup(href);
  759|    327|    if (prefix != NULL)
  ------------------
  |  Branch (759:9): [True: 231, False: 96]
  ------------------
  760|    231|	cur->prefix = xmlStrdup(prefix);
  761|       |
  762|       |    /*
  763|       |     * Add it at the end to preserve parsing order ...
  764|       |     * and checks for existing use of the prefix
  765|       |     */
  766|    327|    if (node != NULL) {
  ------------------
  |  Branch (766:9): [True: 6, False: 321]
  ------------------
  767|      6|	if (node->nsDef == NULL) {
  ------------------
  |  Branch (767:6): [True: 6, False: 0]
  ------------------
  768|      6|	    node->nsDef = cur;
  769|      6|	} else {
  770|      0|	    xmlNsPtr prev = node->nsDef;
  771|       |
  772|      0|	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (772:11): [True: 0, False: 0]
  |  Branch (772:37): [True: 0, False: 0]
  ------------------
  773|      0|		(xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (773:3): [True: 0, False: 0]
  ------------------
  774|      0|		xmlFreeNs(cur);
  775|      0|		return(NULL);
  776|      0|	    }
  777|      0|	    while (prev->next != NULL) {
  ------------------
  |  Branch (777:13): [True: 0, False: 0]
  ------------------
  778|      0|	        prev = prev->next;
  779|      0|		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (779:8): [True: 0, False: 0]
  |  Branch (779:34): [True: 0, False: 0]
  ------------------
  780|      0|		    (xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (780:7): [True: 0, False: 0]
  ------------------
  781|      0|		    xmlFreeNs(cur);
  782|      0|		    return(NULL);
  783|      0|		}
  784|      0|	    }
  785|      0|	    prev->next = cur;
  786|      0|	}
  787|      6|    }
  788|    327|    return(cur);
  789|    327|}
xmlFreeNs:
  815|    363|xmlFreeNs(xmlNsPtr cur) {
  816|    363|    if (cur == NULL) {
  ------------------
  |  Branch (816:9): [True: 0, False: 363]
  ------------------
  817|      0|	return;
  818|      0|    }
  819|    363|    if (cur->href != NULL) xmlFree((char *) cur->href);
  ------------------
  |  Branch (819:9): [True: 345, False: 18]
  ------------------
  820|    363|    if (cur->prefix != NULL) xmlFree((char *) cur->prefix);
  ------------------
  |  Branch (820:9): [True: 267, False: 96]
  ------------------
  821|    363|    xmlFree(cur);
  822|    363|}
xmlFreeNsList:
  831|    285|xmlFreeNsList(xmlNsPtr cur) {
  832|    285|    xmlNsPtr next;
  833|    285|    if (cur == NULL) {
  ------------------
  |  Branch (833:9): [True: 0, False: 285]
  ------------------
  834|      0|	return;
  835|      0|    }
  836|    648|    while (cur != NULL) {
  ------------------
  |  Branch (836:12): [True: 363, False: 285]
  ------------------
  837|    363|        next = cur->next;
  838|    363|        xmlFreeNs(cur);
  839|    363|	cur = next;
  840|    363|    }
  841|    285|}
xmlNewDtd:
  857|     63|                    const xmlChar *ExternalID, const xmlChar *SystemID) {
  858|     63|    xmlDtdPtr cur;
  859|       |
  860|     63|    if ((doc != NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (860:9): [True: 63, False: 0]
  |  Branch (860:26): [True: 0, False: 63]
  ------------------
  861|      0|	return(NULL);
  862|      0|    }
  863|       |
  864|       |    /*
  865|       |     * Allocate a new DTD and fill the fields.
  866|       |     */
  867|     63|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  868|     63|    if (cur == NULL) {
  ------------------
  |  Branch (868:9): [True: 0, False: 63]
  ------------------
  869|      0|	xmlTreeErrMemory("building DTD");
  870|      0|	return(NULL);
  871|      0|    }
  872|     63|    memset(cur, 0 , sizeof(xmlDtd));
  873|     63|    cur->type = XML_DTD_NODE;
  874|       |
  875|     63|    if (name != NULL)
  ------------------
  |  Branch (875:9): [True: 63, False: 0]
  ------------------
  876|     63|	cur->name = xmlStrdup(name);
  877|     63|    if (ExternalID != NULL)
  ------------------
  |  Branch (877:9): [True: 6, False: 57]
  ------------------
  878|      6|	cur->ExternalID = xmlStrdup(ExternalID);
  879|     63|    if (SystemID != NULL)
  ------------------
  |  Branch (879:9): [True: 63, False: 0]
  ------------------
  880|     63|	cur->SystemID = xmlStrdup(SystemID);
  881|     63|    if (doc != NULL)
  ------------------
  |  Branch (881:9): [True: 63, False: 0]
  ------------------
  882|     63|	doc->extSubset = cur;
  883|     63|    cur->doc = doc;
  884|       |
  885|     63|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (885:9): [True: 0, False: 63]
  |  Branch (885:37): [True: 0, False: 0]
  ------------------
  886|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  887|     63|    return(cur);
  888|     63|}
xmlGetIntSubset:
  899|  1.40k|xmlGetIntSubset(const xmlDoc *doc) {
  900|  1.40k|    xmlNodePtr cur;
  901|       |
  902|  1.40k|    if (doc == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 1.40k]
  ------------------
  903|      0|	return(NULL);
  904|  1.40k|    cur = doc->children;
  905|  1.55k|    while (cur != NULL) {
  ------------------
  |  Branch (905:12): [True: 314, False: 1.23k]
  ------------------
  906|    314|	if (cur->type == XML_DTD_NODE)
  ------------------
  |  Branch (906:6): [True: 163, False: 151]
  ------------------
  907|    163|	    return((xmlDtdPtr) cur);
  908|    151|	cur = cur->next;
  909|    151|    }
  910|  1.23k|    return((xmlDtdPtr) doc->intSubset);
  911|  1.40k|}
xmlCreateIntSubset:
  925|    570|                   const xmlChar *ExternalID, const xmlChar *SystemID) {
  926|    570|    xmlDtdPtr cur;
  927|       |
  928|    570|    if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {
  ------------------
  |  Branch (928:9): [True: 570, False: 0]
  |  Branch (928:26): [True: 0, False: 570]
  ------------------
  929|      0|	return(NULL);
  930|      0|    }
  931|       |
  932|       |    /*
  933|       |     * Allocate a new DTD and fill the fields.
  934|       |     */
  935|    570|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  936|    570|    if (cur == NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 570]
  ------------------
  937|      0|	xmlTreeErrMemory("building internal subset");
  938|      0|	return(NULL);
  939|      0|    }
  940|    570|    memset(cur, 0, sizeof(xmlDtd));
  941|    570|    cur->type = XML_DTD_NODE;
  942|       |
  943|    570|    if (name != NULL) {
  ------------------
  |  Branch (943:9): [True: 570, False: 0]
  ------------------
  944|    570|	cur->name = xmlStrdup(name);
  945|    570|	if (cur->name == NULL) {
  ------------------
  |  Branch (945:6): [True: 0, False: 570]
  ------------------
  946|      0|	    xmlTreeErrMemory("building internal subset");
  947|      0|	    xmlFree(cur);
  948|      0|	    return(NULL);
  949|      0|	}
  950|    570|    }
  951|    570|    if (ExternalID != NULL) {
  ------------------
  |  Branch (951:9): [True: 120, False: 450]
  ------------------
  952|    120|	cur->ExternalID = xmlStrdup(ExternalID);
  953|    120|	if (cur->ExternalID  == NULL) {
  ------------------
  |  Branch (953:6): [True: 0, False: 120]
  ------------------
  954|      0|	    xmlTreeErrMemory("building internal subset");
  955|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (955:10): [True: 0, False: 0]
  ------------------
  956|      0|	        xmlFree((char *)cur->name);
  957|      0|	    xmlFree(cur);
  958|      0|	    return(NULL);
  959|      0|	}
  960|    120|    }
  961|    570|    if (SystemID != NULL) {
  ------------------
  |  Branch (961:9): [True: 201, False: 369]
  ------------------
  962|    201|	cur->SystemID = xmlStrdup(SystemID);
  963|    201|	if (cur->SystemID == NULL) {
  ------------------
  |  Branch (963:6): [True: 0, False: 201]
  ------------------
  964|      0|	    xmlTreeErrMemory("building internal subset");
  965|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (965:10): [True: 0, False: 0]
  ------------------
  966|      0|	        xmlFree((char *)cur->name);
  967|      0|	    if (cur->ExternalID != NULL)
  ------------------
  |  Branch (967:10): [True: 0, False: 0]
  ------------------
  968|      0|	        xmlFree((char *)cur->ExternalID);
  969|      0|	    xmlFree(cur);
  970|      0|	    return(NULL);
  971|      0|	}
  972|    201|    }
  973|    570|    if (doc != NULL) {
  ------------------
  |  Branch (973:9): [True: 570, False: 0]
  ------------------
  974|    570|	doc->intSubset = cur;
  975|    570|	cur->parent = doc;
  976|    570|	cur->doc = doc;
  977|    570|	if (doc->children == NULL) {
  ------------------
  |  Branch (977:6): [True: 552, False: 18]
  ------------------
  978|    552|	    doc->children = (xmlNodePtr) cur;
  979|    552|	    doc->last = (xmlNodePtr) cur;
  980|    552|	} else {
  981|     18|	    if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (981:10): [True: 0, False: 18]
  ------------------
  982|      0|		xmlNodePtr prev;
  983|       |
  984|      0|		prev = doc->children;
  985|      0|		prev->prev = (xmlNodePtr) cur;
  986|      0|		cur->next = prev;
  987|      0|		doc->children = (xmlNodePtr) cur;
  988|     18|	    } else {
  989|     18|		xmlNodePtr next;
  990|       |
  991|     18|		next = doc->children;
  992|     36|		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (992:10): [True: 18, False: 18]
  |  Branch (992:28): [True: 18, False: 0]
  ------------------
  993|     18|		    next = next->next;
  994|     18|		if (next == NULL) {
  ------------------
  |  Branch (994:7): [True: 18, False: 0]
  ------------------
  995|     18|		    cur->prev = doc->last;
  996|     18|		    cur->prev->next = (xmlNodePtr) cur;
  997|     18|		    cur->next = NULL;
  998|     18|		    doc->last = (xmlNodePtr) cur;
  999|     18|		} else {
 1000|      0|		    cur->next = next;
 1001|      0|		    cur->prev = next->prev;
 1002|      0|		    if (cur->prev == NULL)
  ------------------
  |  Branch (1002:11): [True: 0, False: 0]
  ------------------
 1003|      0|			doc->children = (xmlNodePtr) cur;
 1004|      0|		    else
 1005|      0|			cur->prev->next = (xmlNodePtr) cur;
 1006|      0|		    next->prev = (xmlNodePtr) cur;
 1007|      0|		}
 1008|     18|	    }
 1009|     18|	}
 1010|    570|    }
 1011|       |
 1012|    570|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1012:9): [True: 0, False: 570]
  |  Branch (1012:37): [True: 0, False: 0]
  ------------------
 1013|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1014|    570|    return(cur);
 1015|    570|}
xmlFreeDtd:
 1072|    633|xmlFreeDtd(xmlDtdPtr cur) {
 1073|    633|    xmlDictPtr dict = NULL;
 1074|       |
 1075|    633|    if (cur == NULL) {
  ------------------
  |  Branch (1075:9): [True: 0, False: 633]
  ------------------
 1076|      0|	return;
 1077|      0|    }
 1078|    633|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (1078:9): [True: 633, False: 0]
  ------------------
 1079|       |
 1080|    633|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1080:9): [True: 0, False: 633]
  |  Branch (1080:37): [True: 0, False: 0]
  ------------------
 1081|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1082|       |
 1083|    633|    if (cur->children != NULL) {
  ------------------
  |  Branch (1083:9): [True: 465, False: 168]
  ------------------
 1084|    465|	xmlNodePtr next, c = cur->children;
 1085|       |
 1086|       |	/*
 1087|       |	 * Cleanup all nodes which are not part of the specific lists
 1088|       |	 * of notations, elements, attributes and entities.
 1089|       |	 */
 1090|   492k|        while (c != NULL) {
  ------------------
  |  Branch (1090:16): [True: 491k, False: 465]
  ------------------
 1091|   491k|	    next = c->next;
 1092|   491k|	    if ((c->type != XML_NOTATION_NODE) &&
  ------------------
  |  Branch (1092:10): [True: 491k, False: 0]
  ------------------
 1093|   491k|	        (c->type != XML_ELEMENT_DECL) &&
  ------------------
  |  Branch (1093:10): [True: 489k, False: 2.33k]
  ------------------
 1094|   491k|		(c->type != XML_ATTRIBUTE_DECL) &&
  ------------------
  |  Branch (1094:3): [True: 483k, False: 5.83k]
  ------------------
 1095|   491k|		(c->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (1095:3): [True: 482k, False: 1.74k]
  ------------------
 1096|   482k|		xmlUnlinkNode(c);
 1097|   482k|		xmlFreeNode(c);
 1098|   482k|	    }
 1099|   491k|	    c = next;
 1100|   491k|	}
 1101|    465|    }
 1102|    633|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    633|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 633, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 633]
  |  |  ------------------
  |  | 1026|    633|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 633, False: 0]
  |  |  ------------------
  |  | 1027|    633|	    xmlFree((char *)(str));
  ------------------
 1103|    633|    DICT_FREE(cur->SystemID)
  ------------------
  |  | 1025|    633|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 264, False: 369]
  |  |  |  Branch (1025:16): [True: 0, False: 264]
  |  |  ------------------
  |  | 1026|    264|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 264, False: 0]
  |  |  ------------------
  |  | 1027|    633|	    xmlFree((char *)(str));
  ------------------
 1104|    633|    DICT_FREE(cur->ExternalID)
  ------------------
  |  | 1025|    633|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 126, False: 507]
  |  |  |  Branch (1025:16): [True: 0, False: 126]
  |  |  ------------------
  |  | 1026|    126|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 126, False: 0]
  |  |  ------------------
  |  | 1027|    633|	    xmlFree((char *)(str));
  ------------------
 1105|       |    /* TODO !!! */
 1106|    633|    if (cur->notations != NULL)
  ------------------
  |  Branch (1106:9): [True: 0, False: 633]
  ------------------
 1107|      0|        xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);
 1108|       |
 1109|    633|    if (cur->elements != NULL)
  ------------------
  |  Branch (1109:9): [True: 354, False: 279]
  ------------------
 1110|    354|        xmlFreeElementTable((xmlElementTablePtr) cur->elements);
 1111|    633|    if (cur->attributes != NULL)
  ------------------
  |  Branch (1111:9): [True: 126, False: 507]
  ------------------
 1112|    126|        xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);
 1113|    633|    if (cur->entities != NULL)
  ------------------
  |  Branch (1113:9): [True: 162, False: 471]
  ------------------
 1114|    162|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);
 1115|    633|    if (cur->pentities != NULL)
  ------------------
  |  Branch (1115:9): [True: 96, False: 537]
  ------------------
 1116|     96|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);
 1117|       |
 1118|    633|    xmlFree(cur);
 1119|    633|}
xmlNewDoc:
 1130|    993|xmlNewDoc(const xmlChar *version) {
 1131|    993|    xmlDocPtr cur;
 1132|       |
 1133|    993|    if (version == NULL)
  ------------------
  |  Branch (1133:9): [True: 0, False: 993]
  ------------------
 1134|      0|	version = (const xmlChar *) "1.0";
 1135|       |
 1136|       |    /*
 1137|       |     * Allocate a new document and fill the fields.
 1138|       |     */
 1139|    993|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 1140|    993|    if (cur == NULL) {
  ------------------
  |  Branch (1140:9): [True: 0, False: 993]
  ------------------
 1141|      0|	xmlTreeErrMemory("building doc");
 1142|      0|	return(NULL);
 1143|      0|    }
 1144|    993|    memset(cur, 0, sizeof(xmlDoc));
 1145|    993|    cur->type = XML_DOCUMENT_NODE;
 1146|       |
 1147|    993|    cur->version = xmlStrdup(version);
 1148|    993|    if (cur->version == NULL) {
  ------------------
  |  Branch (1148:9): [True: 0, False: 993]
  ------------------
 1149|      0|	xmlTreeErrMemory("building doc");
 1150|      0|	xmlFree(cur);
 1151|      0|	return(NULL);
 1152|      0|    }
 1153|    993|    cur->standalone = -1;
 1154|    993|    cur->compression = -1; /* not initialized */
 1155|    993|    cur->doc = cur;
 1156|    993|    cur->parseFlags = 0;
 1157|    993|    cur->properties = XML_DOC_USERBUILT;
 1158|       |    /*
 1159|       |     * The in memory encoding is always UTF8
 1160|       |     * This field will never change and would
 1161|       |     * be obsolete if not for binary compatibility.
 1162|       |     */
 1163|    993|    cur->charset = XML_CHAR_ENCODING_UTF8;
 1164|       |
 1165|    993|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1165:9): [True: 0, False: 993]
  |  Branch (1165:37): [True: 0, False: 0]
  ------------------
 1166|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1167|    993|    return(cur);
 1168|    993|}
xmlFreeDoc:
 1177|    733|xmlFreeDoc(xmlDocPtr cur) {
 1178|    733|    xmlDtdPtr extSubset, intSubset;
 1179|    733|    xmlDictPtr dict = NULL;
 1180|       |
 1181|    733|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 62, False: 671]
  ------------------
 1182|     62|	return;
 1183|     62|    }
 1184|       |
 1185|    671|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 671, False: 0]
  ------------------
 1186|       |
 1187|    671|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 671]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|    671|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 30, False: 641]
  ------------------
 1194|    671|    cur->ids = NULL;
 1195|    671|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 10, False: 661]
  ------------------
 1196|    671|    cur->refs = NULL;
 1197|    671|    extSubset = cur->extSubset;
 1198|    671|    intSubset = cur->intSubset;
 1199|    671|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 291, False: 380]
  ------------------
 1200|    291|	extSubset = NULL;
 1201|    671|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 42, False: 629]
  ------------------
 1202|     42|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|     42|	cur->extSubset = NULL;
 1204|     42|	xmlFreeDtd(extSubset);
 1205|     42|    }
 1206|    671|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 380, False: 291]
  ------------------
 1207|    380|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|    380|	cur->intSubset = NULL;
 1209|    380|	xmlFreeDtd(intSubset);
 1210|    380|    }
 1211|       |
 1212|    671|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 599, False: 72]
  ------------------
 1213|    671|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 24, False: 647]
  ------------------
 1214|       |
 1215|    671|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|    671|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 671, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 671]
  |  |  ------------------
  |  | 1026|    671|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 671, False: 0]
  |  |  ------------------
  |  | 1027|    671|	    xmlFree((char *)(str));
  ------------------
 1216|    671|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    671|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 671]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    671|	    xmlFree((char *)(str));
  ------------------
 1217|    671|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|    671|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 65, False: 606]
  |  |  |  Branch (1025:16): [True: 0, False: 65]
  |  |  ------------------
  |  | 1026|     65|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 65, False: 0]
  |  |  ------------------
  |  | 1027|    671|	    xmlFree((char *)(str));
  ------------------
 1218|    671|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|    671|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 662, False: 9]
  |  |  |  Branch (1025:16): [True: 0, False: 662]
  |  |  ------------------
  |  | 1026|    662|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 662, False: 0]
  |  |  ------------------
  |  | 1027|    671|	    xmlFree((char *)(str));
  ------------------
 1219|    671|    xmlFree(cur);
 1220|    671|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 671, False: 0]
  ------------------
 1221|    671|}
xmlNodeListGetString:
 1673|      6|{
 1674|      6|    const xmlNode *node = list;
 1675|      6|    xmlChar *ret = NULL;
 1676|      6|    xmlEntityPtr ent;
 1677|      6|    int attr;
 1678|       |
 1679|      6|    if (list == NULL)
  ------------------
  |  Branch (1679:9): [True: 0, False: 6]
  ------------------
 1680|      0|        return (NULL);
 1681|      6|    if ((list->parent != NULL) && (list->parent->type == XML_ATTRIBUTE_NODE))
  ------------------
  |  Branch (1681:9): [True: 6, False: 0]
  |  Branch (1681:35): [True: 6, False: 0]
  ------------------
 1682|      6|        attr = 1;
 1683|      0|    else
 1684|      0|        attr = 0;
 1685|       |
 1686|     12|    while (node != NULL) {
  ------------------
  |  Branch (1686:12): [True: 6, False: 6]
  ------------------
 1687|      6|        if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1687:13): [True: 6, False: 0]
  ------------------
 1688|      6|            (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1688:13): [True: 0, False: 0]
  ------------------
 1689|      6|            if (inLine) {
  ------------------
  |  Branch (1689:17): [True: 6, False: 0]
  ------------------
 1690|      6|                ret = xmlStrcat(ret, node->content);
 1691|      6|            } else {
 1692|      0|                xmlChar *buffer;
 1693|       |
 1694|      0|		if (attr)
  ------------------
  |  Branch (1694:7): [True: 0, False: 0]
  ------------------
 1695|      0|		    buffer = xmlEncodeAttributeEntities(doc, node->content);
 1696|      0|		else
 1697|      0|		    buffer = xmlEncodeEntitiesReentrant(doc, node->content);
 1698|      0|                if (buffer != NULL) {
  ------------------
  |  Branch (1698:21): [True: 0, False: 0]
  ------------------
 1699|      0|                    ret = xmlStrcat(ret, buffer);
 1700|      0|                    xmlFree(buffer);
 1701|      0|                }
 1702|      0|            }
 1703|      6|        } else if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (1703:20): [True: 0, False: 0]
  ------------------
 1704|      0|            if (inLine) {
  ------------------
  |  Branch (1704:17): [True: 0, False: 0]
  ------------------
 1705|      0|                ent = xmlGetDocEntity(doc, node->name);
 1706|      0|                if (ent != NULL) {
  ------------------
  |  Branch (1706:21): [True: 0, False: 0]
  ------------------
 1707|      0|                    xmlChar *buffer;
 1708|       |
 1709|       |                    /* an entity content can be any "well balanced chunk",
 1710|       |                     * i.e. the result of the content [43] production:
 1711|       |                     * http://www.w3.org/TR/REC-xml#NT-content.
 1712|       |                     * So it can contain text, CDATA section or nested
 1713|       |                     * entity reference nodes (among others).
 1714|       |                     * -> we recursive  call xmlNodeListGetString()
 1715|       |                     * which handles these types */
 1716|      0|                    buffer = xmlNodeListGetString(doc, ent->children, 1);
 1717|      0|                    if (buffer != NULL) {
  ------------------
  |  Branch (1717:25): [True: 0, False: 0]
  ------------------
 1718|      0|                        ret = xmlStrcat(ret, buffer);
 1719|      0|                        xmlFree(buffer);
 1720|      0|                    }
 1721|      0|                } else {
 1722|      0|                    ret = xmlStrcat(ret, node->content);
 1723|      0|                }
 1724|      0|            } else {
 1725|      0|                xmlChar buf[2];
 1726|       |
 1727|      0|                buf[0] = '&';
 1728|      0|                buf[1] = 0;
 1729|      0|                ret = xmlStrncat(ret, buf, 1);
 1730|      0|                ret = xmlStrcat(ret, node->name);
 1731|      0|                buf[0] = ';';
 1732|      0|                buf[1] = 0;
 1733|      0|                ret = xmlStrncat(ret, buf, 1);
 1734|      0|            }
 1735|      0|        }
 1736|       |#if 0
 1737|       |        else {
 1738|       |            xmlGenericError(xmlGenericErrorContext,
 1739|       |                            "xmlGetNodeListString : invalid node type %d\n",
 1740|       |                            node->type);
 1741|       |        }
 1742|       |#endif
 1743|      6|        node = node->next;
 1744|      6|    }
 1745|      6|    return (ret);
 1746|      6|}
xmlNewDocProp:
 1997|      9|xmlNewDocProp(xmlDocPtr doc, const xmlChar *name, const xmlChar *value) {
 1998|      9|    xmlAttrPtr cur;
 1999|       |
 2000|      9|    if (name == NULL) {
  ------------------
  |  Branch (2000:9): [True: 0, False: 9]
  ------------------
 2001|      0|	return(NULL);
 2002|      0|    }
 2003|       |
 2004|       |    /*
 2005|       |     * Allocate a new property and fill the fields.
 2006|       |     */
 2007|      9|    cur = (xmlAttrPtr) xmlMalloc(sizeof(xmlAttr));
 2008|      9|    if (cur == NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 9]
  ------------------
 2009|      0|	xmlTreeErrMemory("building attribute");
 2010|      0|	return(NULL);
 2011|      0|    }
 2012|      9|    memset(cur, 0, sizeof(xmlAttr));
 2013|      9|    cur->type = XML_ATTRIBUTE_NODE;
 2014|       |
 2015|      9|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2015:9): [True: 9, False: 0]
  |  Branch (2015:26): [True: 9, False: 0]
  ------------------
 2016|      9|	cur->name = xmlDictLookup(doc->dict, name, -1);
 2017|      0|    else
 2018|      0|	cur->name = xmlStrdup(name);
 2019|      9|    cur->doc = doc;
 2020|      9|    if (value != NULL) {
  ------------------
  |  Branch (2020:9): [True: 0, False: 9]
  ------------------
 2021|      0|	xmlNodePtr tmp;
 2022|       |
 2023|      0|	cur->children = xmlStringGetNodeList(doc, value);
 2024|      0|	cur->last = NULL;
 2025|       |
 2026|      0|	tmp = cur->children;
 2027|      0|	while (tmp != NULL) {
  ------------------
  |  Branch (2027:9): [True: 0, False: 0]
  ------------------
 2028|      0|	    tmp->parent = (xmlNodePtr) cur;
 2029|      0|	    if (tmp->next == NULL)
  ------------------
  |  Branch (2029:10): [True: 0, False: 0]
  ------------------
 2030|      0|		cur->last = tmp;
 2031|      0|	    tmp = tmp->next;
 2032|      0|	}
 2033|      0|    }
 2034|       |
 2035|      9|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2035:9): [True: 0, False: 9]
  |  Branch (2035:37): [True: 0, False: 0]
  ------------------
 2036|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2037|      9|    return(cur);
 2038|      9|}
xmlFreePropList:
 2047|  23.1k|xmlFreePropList(xmlAttrPtr cur) {
 2048|  23.1k|    xmlAttrPtr next;
 2049|  23.1k|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 23.1k]
  ------------------
 2050|  65.8k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 42.7k, False: 23.1k]
  ------------------
 2051|  42.7k|        next = cur->next;
 2052|  42.7k|        xmlFreeProp(cur);
 2053|  42.7k|	cur = next;
 2054|  42.7k|    }
 2055|  23.1k|}
xmlFreeProp:
 2064|  42.7k|xmlFreeProp(xmlAttrPtr cur) {
 2065|  42.7k|    xmlDictPtr dict = NULL;
 2066|  42.7k|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 42.7k]
  ------------------
 2067|       |
 2068|  42.7k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 42.7k, False: 0]
  ------------------
 2069|       |
 2070|  42.7k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 42.7k]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|  42.7k|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 42.7k, False: 0]
  |  Branch (2074:31): [True: 660, False: 42.0k]
  ------------------
 2075|    660|	    xmlRemoveID(cur->doc, cur);
 2076|    660|    }
 2077|  42.7k|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 42.7k, False: 0]
  ------------------
 2078|  42.7k|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|  42.7k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 42.7k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 42.7k]
  |  |  ------------------
  |  | 1026|  42.7k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 42.7k]
  |  |  ------------------
  |  | 1027|  42.7k|	    xmlFree((char *)(str));
  ------------------
 2079|  42.7k|    xmlFree(cur);
 2080|  42.7k|}
xmlNewDocPI:
 2131|     63|xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
 2132|     63|    xmlNodePtr cur;
 2133|       |
 2134|     63|    if (name == NULL) {
  ------------------
  |  Branch (2134:9): [True: 0, False: 63]
  ------------------
 2135|      0|	return(NULL);
 2136|      0|    }
 2137|       |
 2138|       |    /*
 2139|       |     * Allocate a new node and fill the fields.
 2140|       |     */
 2141|     63|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2142|     63|    if (cur == NULL) {
  ------------------
  |  Branch (2142:9): [True: 0, False: 63]
  ------------------
 2143|      0|	xmlTreeErrMemory("building PI");
 2144|      0|	return(NULL);
 2145|      0|    }
 2146|     63|    memset(cur, 0, sizeof(xmlNode));
 2147|     63|    cur->type = XML_PI_NODE;
 2148|       |
 2149|     63|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2149:9): [True: 63, False: 0]
  |  Branch (2149:26): [True: 63, False: 0]
  ------------------
 2150|     63|        cur->name = xmlDictLookup(doc->dict, name, -1);
 2151|      0|    else
 2152|      0|	cur->name = xmlStrdup(name);
 2153|     63|    if (content != NULL) {
  ------------------
  |  Branch (2153:9): [True: 60, False: 3]
  ------------------
 2154|     60|	cur->content = xmlStrdup(content);
 2155|     60|    }
 2156|     63|    cur->doc = doc;
 2157|       |
 2158|     63|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2158:9): [True: 0, False: 63]
  |  Branch (2158:37): [True: 0, False: 0]
  ------------------
 2159|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2160|     63|    return(cur);
 2161|     63|}
xmlNewNodeEatName:
 2232|  42.5k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  42.5k|    xmlNodePtr cur;
 2234|       |
 2235|  42.5k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 0, False: 42.5k]
  ------------------
 2236|      0|	return(NULL);
 2237|      0|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  42.5k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  42.5k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 42.5k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  42.5k|    memset(cur, 0, sizeof(xmlNode));
 2249|  42.5k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  42.5k|    cur->name = name;
 2252|  42.5k|    cur->ns = ns;
 2253|       |
 2254|  42.5k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 42.5k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  42.5k|    return(cur);
 2257|  42.5k|}
xmlNewDocNode:
 2277|    351|              const xmlChar *name, const xmlChar *content) {
 2278|    351|    xmlNodePtr cur;
 2279|       |
 2280|    351|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2280:9): [True: 351, False: 0]
  |  Branch (2280:26): [True: 351, False: 0]
  ------------------
 2281|    351|        cur = xmlNewNodeEatName(ns, (xmlChar *)
 2282|    351|	                        xmlDictLookup(doc->dict, name, -1));
 2283|      0|    else
 2284|      0|	cur = xmlNewNode(ns, name);
 2285|    351|    if (cur != NULL) {
  ------------------
  |  Branch (2285:9): [True: 351, False: 0]
  ------------------
 2286|    351|        cur->doc = doc;
 2287|    351|	if (content != NULL) {
  ------------------
  |  Branch (2287:6): [True: 0, False: 351]
  ------------------
 2288|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2289|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2290|      0|	}
 2291|    351|    }
 2292|       |
 2293|    351|    return(cur);
 2294|    351|}
xmlNewDocNodeEatName:
 2314|  42.1k|              xmlChar *name, const xmlChar *content) {
 2315|  42.1k|    xmlNodePtr cur;
 2316|       |
 2317|  42.1k|    cur = xmlNewNodeEatName(ns, name);
 2318|  42.1k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 42.1k, False: 0]
  ------------------
 2319|  42.1k|        cur->doc = doc;
 2320|  42.1k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 42.1k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  42.1k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      0|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 0]
  ------------------
 2327|      0|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      0|    }
 2331|  42.1k|    return(cur);
 2332|  42.1k|}
xmlNewText:
 2404|     67|xmlNewText(const xmlChar *content) {
 2405|     67|    xmlNodePtr cur;
 2406|       |
 2407|       |    /*
 2408|       |     * Allocate a new node and fill the fields.
 2409|       |     */
 2410|     67|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2411|     67|    if (cur == NULL) {
  ------------------
  |  Branch (2411:9): [True: 0, False: 67]
  ------------------
 2412|      0|	xmlTreeErrMemory("building text");
 2413|      0|	return(NULL);
 2414|      0|    }
 2415|     67|    memset(cur, 0, sizeof(xmlNode));
 2416|     67|    cur->type = XML_TEXT_NODE;
 2417|       |
 2418|     67|    cur->name = xmlStringText;
 2419|     67|    if (content != NULL) {
  ------------------
  |  Branch (2419:9): [True: 67, False: 0]
  ------------------
 2420|     67|	cur->content = xmlStrdup(content);
 2421|     67|    }
 2422|       |
 2423|     67|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2423:9): [True: 0, False: 67]
  |  Branch (2423:37): [True: 0, False: 0]
  ------------------
 2424|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2425|     67|    return(cur);
 2426|     67|}
xmlNewReference:
 2554|      3|xmlNewReference(const xmlDoc *doc, const xmlChar *name) {
 2555|      3|    xmlNodePtr cur;
 2556|      3|    xmlEntityPtr ent;
 2557|       |
 2558|      3|    if (name == NULL)
  ------------------
  |  Branch (2558:9): [True: 0, False: 3]
  ------------------
 2559|      0|        return(NULL);
 2560|       |
 2561|       |    /*
 2562|       |     * Allocate a new node and fill the fields.
 2563|       |     */
 2564|      3|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2565|      3|    if (cur == NULL) {
  ------------------
  |  Branch (2565:9): [True: 0, False: 3]
  ------------------
 2566|      0|	xmlTreeErrMemory("building reference");
 2567|      0|	return(NULL);
 2568|      0|    }
 2569|      3|    memset(cur, 0, sizeof(xmlNode));
 2570|      3|    cur->type = XML_ENTITY_REF_NODE;
 2571|       |
 2572|      3|    cur->doc = (xmlDoc *)doc;
 2573|      3|    if (name[0] == '&') {
  ------------------
  |  Branch (2573:9): [True: 0, False: 3]
  ------------------
 2574|      0|        int len;
 2575|      0|        name++;
 2576|      0|	len = xmlStrlen(name);
 2577|      0|	if (name[len - 1] == ';')
  ------------------
  |  Branch (2577:6): [True: 0, False: 0]
  ------------------
 2578|      0|	    cur->name = xmlStrndup(name, len - 1);
 2579|      0|	else
 2580|      0|	    cur->name = xmlStrndup(name, len);
 2581|      0|    } else
 2582|      3|	cur->name = xmlStrdup(name);
 2583|       |
 2584|      3|    ent = xmlGetDocEntity(doc, cur->name);
 2585|      3|    if (ent != NULL) {
  ------------------
  |  Branch (2585:9): [True: 0, False: 3]
  ------------------
 2586|      0|	cur->content = ent->content;
 2587|       |	/*
 2588|       |	 * The parent pointer in entity is a DTD pointer and thus is NOT
 2589|       |	 * updated.  Not sure if this is 100% correct.
 2590|       |	 *  -George
 2591|       |	 */
 2592|      0|	cur->children = (xmlNodePtr) ent;
 2593|      0|	cur->last = (xmlNodePtr) ent;
 2594|      0|    }
 2595|       |
 2596|      3|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2596:9): [True: 0, False: 3]
  |  Branch (2596:37): [True: 0, False: 0]
  ------------------
 2597|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2598|      3|    return(cur);
 2599|      3|}
xmlNewDocText:
 2610|     67|xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {
 2611|     67|    xmlNodePtr cur;
 2612|       |
 2613|     67|    cur = xmlNewText(content);
 2614|     67|    if (cur != NULL) cur->doc = (xmlDoc *)doc;
  ------------------
  |  Branch (2614:9): [True: 67, False: 0]
  ------------------
 2615|     67|    return(cur);
 2616|     67|}
xmlNewComment:
 2682|   482k|xmlNewComment(const xmlChar *content) {
 2683|   482k|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|   482k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|   482k|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 482k]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|   482k|    memset(cur, 0, sizeof(xmlNode));
 2694|   482k|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|   482k|    cur->name = xmlStringComment;
 2697|   482k|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 482k, False: 0]
  ------------------
 2698|   482k|	cur->content = xmlStrdup(content);
 2699|   482k|    }
 2700|       |
 2701|   482k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 482k]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|   482k|    return(cur);
 2704|   482k|}
xmlNewCDataBlock:
 2716|     99|xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {
 2717|     99|    xmlNodePtr cur;
 2718|       |
 2719|       |    /*
 2720|       |     * Allocate a new node and fill the fields.
 2721|       |     */
 2722|     99|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2723|     99|    if (cur == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 99]
  ------------------
 2724|      0|	xmlTreeErrMemory("building CDATA");
 2725|      0|	return(NULL);
 2726|      0|    }
 2727|     99|    memset(cur, 0, sizeof(xmlNode));
 2728|     99|    cur->type = XML_CDATA_SECTION_NODE;
 2729|     99|    cur->doc = doc;
 2730|       |
 2731|     99|    if (content != NULL) {
  ------------------
  |  Branch (2731:9): [True: 99, False: 0]
  ------------------
 2732|     99|	cur->content = xmlStrndup(content, len);
 2733|     99|    }
 2734|       |
 2735|     99|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2735:9): [True: 0, False: 99]
  |  Branch (2735:37): [True: 0, False: 0]
  ------------------
 2736|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2737|     99|    return(cur);
 2738|     99|}
xmlNewDocComment:
 2749|   482k|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|   482k|    xmlNodePtr cur;
 2751|       |
 2752|   482k|    cur = xmlNewComment(content);
 2753|   482k|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 482k, False: 0]
  ------------------
 2754|   482k|    return(cur);
 2755|   482k|}
xmlAddChild:
 3279|   581k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|   581k|    xmlNodePtr prev;
 3281|       |
 3282|   581k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 581k]
  |  Branch (3282:29): [True: 0, False: 581k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|   581k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 581k]
  |  Branch (3286:26): [True: 0, False: 581k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|   581k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 581k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|   581k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 55.0k, False: 526k]
  ------------------
 3298|  55.0k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 55.0k]
  ------------------
 3299|  55.0k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  55.0k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  55.0k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 49.2k, False: 5.83k]
  |  Branch (3305:32): [True: 8.10k, False: 41.0k]
  ------------------
 3306|  55.0k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 8.10k, False: 0]
  ------------------
 3307|  55.0k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 8.10k, False: 0]
  ------------------
 3308|  8.10k|	    xmlNodeAddContent(parent->last, cur->content);
 3309|  8.10k|	    xmlFreeNode(cur);
 3310|  8.10k|	    return(parent->last);
 3311|  8.10k|	}
 3312|  55.0k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|   573k|    prev = cur->parent;
 3318|   573k|    cur->parent = parent;
 3319|   573k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 573k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|   573k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 93, False: 573k]
  ------------------
 3326|     93|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|   573k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 573k]
  ------------------
 3332|   573k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|   573k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|   573k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 573k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|   573k|    } else {
 3370|   573k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 7.92k, False: 565k]
  ------------------
 3371|  7.92k|	    parent->children = cur;
 3372|  7.92k|	    parent->last = cur;
 3373|   565k|	} else {
 3374|   565k|	    prev = parent->last;
 3375|   565k|	    prev->next = cur;
 3376|   565k|	    cur->prev = prev;
 3377|   565k|	    parent->last = cur;
 3378|   565k|	}
 3379|   573k|    }
 3380|   573k|    return(cur);
 3381|   573k|}
xmlFreeNodeList:
 3602|  43.6k|xmlFreeNodeList(xmlNodePtr cur) {
 3603|  43.6k|    xmlNodePtr next;
 3604|  43.6k|    xmlNodePtr parent;
 3605|  43.6k|    xmlDictPtr dict = NULL;
 3606|  43.6k|    size_t depth = 0;
 3607|       |
 3608|  43.6k|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 141, False: 43.5k]
  ------------------
 3609|  43.5k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 43.5k]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|  43.5k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 43.5k, False: 0]
  ------------------
 3614|   106k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|   115k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 8.33k, False: 106k]
  ------------------
 3616|   115k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 8.33k, False: 0]
  ------------------
 3617|   115k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 8.33k, False: 0]
  ------------------
 3618|   115k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 8.33k, False: 0]
  ------------------
 3619|   115k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 8.33k, False: 0]
  ------------------
 3620|  8.33k|            cur = cur->children;
 3621|  8.33k|            depth += 1;
 3622|  8.33k|        }
 3623|       |
 3624|   106k|        next = cur->next;
 3625|   106k|        parent = cur->parent;
 3626|   106k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 106k]
  ------------------
 3627|   106k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 106k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|   106k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 106k, False: 0]
  ------------------
 3630|       |
 3631|   106k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 106k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|   106k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 28.8k, False: 78.0k]
  ------------------
 3635|   106k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 0, False: 78.0k]
  ------------------
 3636|   106k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 0, False: 78.0k]
  ------------------
 3637|   106k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 23.1k, False: 5.68k]
  ------------------
 3638|  23.1k|		xmlFreePropList(cur->properties);
 3639|   106k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 78.0k, False: 28.8k]
  ------------------
 3640|   106k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 78.0k, False: 0]
  ------------------
 3641|   106k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 78.0k, False: 0]
  ------------------
 3642|   106k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 78.0k, False: 2]
  ------------------
 3643|   106k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 77.9k, False: 47]
  ------------------
 3644|  77.9k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|  77.9k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 77.9k, False: 2]
  |  |  |  Branch (1025:16): [True: 0, False: 77.9k]
  |  |  ------------------
  |  | 1026|  77.9k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 40.3k, False: 37.6k]
  |  |  ------------------
  |  | 1027|  77.9k|	    xmlFree((char *)(str));
  ------------------
 3645|  77.9k|	    }
 3646|   106k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 28.8k, False: 78.0k]
  ------------------
 3647|   106k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 0, False: 78.0k]
  ------------------
 3648|   106k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 0, False: 78.0k]
  ------------------
 3649|   106k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 168, False: 28.6k]
  ------------------
 3650|    168|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|   106k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 106k, False: 69]
  ------------------
 3659|   106k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 29.1k, False: 77.6k]
  ------------------
 3660|   106k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 28.8k, False: 302]
  ------------------
 3661|  28.8k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  28.8k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 28.8k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 28.8k]
  |  |  ------------------
  |  | 1026|  28.8k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 2, False: 28.8k]
  |  |  ------------------
  |  | 1027|  28.8k|	    xmlFree((char *)(str));
  ------------------
 3662|   106k|	    xmlFree(cur);
 3663|   106k|	}
 3664|       |
 3665|   106k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 54.9k, False: 51.8k]
  ------------------
 3666|  54.9k|	    cur = next;
 3667|  54.9k|        } else {
 3668|  51.8k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 43.5k, False: 8.33k]
  |  Branch (3668:33): [True: 0, False: 8.33k]
  ------------------
 3669|  43.5k|                break;
 3670|  8.33k|            depth -= 1;
 3671|  8.33k|            cur = parent;
 3672|  8.33k|            cur->children = NULL;
 3673|  8.33k|        }
 3674|   106k|    }
 3675|  43.5k|}
xmlFreeNode:
 3685|   490k|xmlFreeNode(xmlNodePtr cur) {
 3686|   490k|    xmlDictPtr dict = NULL;
 3687|       |
 3688|   490k|    if (cur == NULL) return;
  ------------------
  |  Branch (3688:9): [True: 0, False: 490k]
  ------------------
 3689|       |
 3690|       |    /* use xmlFreeDtd for DTD nodes */
 3691|   490k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3691:9): [True: 0, False: 490k]
  ------------------
 3692|      0|	xmlFreeDtd((xmlDtdPtr) cur);
 3693|      0|	return;
 3694|      0|    }
 3695|   490k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3695:9): [True: 0, False: 490k]
  ------------------
 3696|      0|	xmlFreeNs((xmlNsPtr) cur);
 3697|      0|        return;
 3698|      0|    }
 3699|   490k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3699:9): [True: 0, False: 490k]
  ------------------
 3700|      0|	xmlFreeProp((xmlAttrPtr) cur);
 3701|      0|	return;
 3702|      0|    }
 3703|       |
 3704|   490k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3704:9): [True: 0, False: 490k]
  |  Branch (3704:37): [True: 0, False: 0]
  ------------------
 3705|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3706|       |
 3707|   490k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3707:9): [True: 490k, False: 0]
  ------------------
 3708|       |
 3709|   490k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3709:9): [True: 0, False: 490k]
  ------------------
 3710|      0|        xmlEntityPtr ent = (xmlEntityPtr) cur;
 3711|      0|	DICT_FREE(ent->SystemID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3712|      0|	DICT_FREE(ent->ExternalID);
  ------------------
  |  | 1025|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|      0|	    xmlFree((char *)(str));
  ------------------
 3713|      0|    }
 3714|   490k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (3714:9): [True: 3, False: 490k]
  ------------------
 3715|   490k|	(cur->type != XML_ENTITY_REF_NODE))
  ------------------
  |  Branch (3715:2): [True: 3, False: 0]
  ------------------
 3716|      3|	xmlFreeNodeList(cur->children);
 3717|       |
 3718|   490k|    if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3718:9): [True: 324, False: 490k]
  ------------------
 3719|   490k|        (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3719:9): [True: 0, False: 490k]
  ------------------
 3720|   490k|        (cur->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (3720:9): [True: 0, False: 490k]
  ------------------
 3721|    324|        if (cur->properties != NULL)
  ------------------
  |  Branch (3721:13): [True: 0, False: 324]
  ------------------
 3722|      0|            xmlFreePropList(cur->properties);
 3723|    324|        if (cur->nsDef != NULL)
  ------------------
  |  Branch (3723:13): [True: 0, False: 324]
  ------------------
 3724|      0|            xmlFreeNsList(cur->nsDef);
 3725|   490k|    } else if ((cur->content != NULL) &&
  ------------------
  |  Branch (3725:16): [True: 490k, False: 1]
  ------------------
 3726|   490k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3726:16): [True: 490k, False: 0]
  ------------------
 3727|   490k|               (cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3727:16): [True: 490k, False: 2]
  ------------------
 3728|   490k|        DICT_FREE(cur->content)
  ------------------
  |  | 1025|   490k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 490k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 490k]
  |  |  ------------------
  |  | 1026|   490k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 490k, False: 5]
  |  |  ------------------
  |  | 1027|   490k|	    xmlFree((char *)(str));
  ------------------
 3729|   490k|    }
 3730|       |
 3731|       |    /*
 3732|       |     * When a node is a text node or a comment, it uses a global static
 3733|       |     * variable for the name of the node.
 3734|       |     * Otherwise the node name might come from the document's dictionary
 3735|       |     */
 3736|   490k|    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3736:9): [True: 490k, False: 0]
  ------------------
 3737|   490k|        (cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3737:9): [True: 482k, False: 8.17k]
  ------------------
 3738|   490k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3738:9): [True: 324, False: 482k]
  ------------------
 3739|    324|	DICT_FREE(cur->name)
  ------------------
  |  | 1025|    324|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 324, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 324]
  |  |  ------------------
  |  | 1026|    324|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 324]
  |  |  ------------------
  |  | 1027|    324|	    xmlFree((char *)(str));
  ------------------
 3740|       |
 3741|   490k|    xmlFree(cur);
 3742|   490k|}
xmlUnlinkNode:
 3755|   522k|xmlUnlinkNode(xmlNodePtr cur) {
 3756|   522k|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 522k]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|   522k|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 522k]
  ------------------
 3760|      0|        return;
 3761|   522k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 633, False: 522k]
  ------------------
 3762|    633|	xmlDocPtr doc;
 3763|    633|	doc = cur->doc;
 3764|    633|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 633, False: 0]
  ------------------
 3765|    633|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 570, False: 63]
  ------------------
 3766|    570|		doc->intSubset = NULL;
 3767|    633|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 63, False: 570]
  ------------------
 3768|     63|		doc->extSubset = NULL;
 3769|    633|	}
 3770|    633|    }
 3771|   522k|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 522k]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|   522k|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 522k, False: 87]
  ------------------
 3794|   522k|	xmlNodePtr parent;
 3795|   522k|	parent = cur->parent;
 3796|   522k|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 0, False: 522k]
  ------------------
 3797|      0|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 0, False: 0]
  ------------------
 3798|      0|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|   522k|	} else {
 3800|   522k|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 32.8k, False: 489k]
  ------------------
 3801|  32.8k|		parent->children = cur->next;
 3802|   522k|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 5.15k, False: 517k]
  ------------------
 3803|  5.15k|		parent->last = cur->prev;
 3804|   522k|	}
 3805|   522k|	cur->parent = NULL;
 3806|   522k|    }
 3807|   522k|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 517k, False: 5.24k]
  ------------------
 3808|   517k|        cur->next->prev = cur->prev;
 3809|   522k|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 489k, False: 32.9k]
  ------------------
 3810|   489k|        cur->prev->next = cur->next;
 3811|   522k|    cur->next = cur->prev = NULL;
 3812|   522k|}
xmlCopyNamespace:
 3889|     12|xmlCopyNamespace(xmlNsPtr cur) {
 3890|     12|    xmlNsPtr ret;
 3891|       |
 3892|     12|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3892:9): [True: 0, False: 12]
  ------------------
 3893|     12|    switch (cur->type) {
 3894|     12|	case XML_LOCAL_NAMESPACE:
  ------------------
  |  |  370|     12|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  |  Branch (3894:2): [True: 12, False: 0]
  ------------------
 3895|     12|	    ret = xmlNewNs(NULL, cur->href, cur->prefix);
 3896|     12|	    break;
 3897|      0|	default:
  ------------------
  |  Branch (3897:2): [True: 0, False: 12]
  ------------------
 3898|      0|	    return(NULL);
 3899|     12|    }
 3900|     12|    return(ret);
 3901|     12|}
xmlCopyNamespaceList:
 3912|     12|xmlCopyNamespaceList(xmlNsPtr cur) {
 3913|     12|    xmlNsPtr ret = NULL;
 3914|     12|    xmlNsPtr p = NULL,q;
 3915|       |
 3916|     24|    while (cur != NULL) {
  ------------------
  |  Branch (3916:12): [True: 12, False: 12]
  ------------------
 3917|     12|        q = xmlCopyNamespace(cur);
 3918|     12|        if (q == NULL) {
  ------------------
  |  Branch (3918:13): [True: 0, False: 12]
  ------------------
 3919|      0|            xmlFreeNsList(ret);
 3920|      0|            return(NULL);
 3921|      0|        }
 3922|     12|	if (p == NULL) {
  ------------------
  |  Branch (3922:6): [True: 12, False: 0]
  ------------------
 3923|     12|	    ret = p = q;
 3924|     12|	} else {
 3925|      0|	    p->next = q;
 3926|      0|	    p = q;
 3927|      0|	}
 3928|     12|	cur = cur->next;
 3929|     12|    }
 3930|     12|    return(ret);
 3931|     12|}
xmlCopyProp:
 4041|      9|xmlCopyProp(xmlNodePtr target, xmlAttrPtr cur) {
 4042|      9|	return xmlCopyPropInternal(NULL, target, cur);
 4043|      9|}
xmlCopyPropList:
 4055|      9|xmlCopyPropList(xmlNodePtr target, xmlAttrPtr cur) {
 4056|      9|    xmlAttrPtr ret = NULL;
 4057|      9|    xmlAttrPtr p = NULL,q;
 4058|       |
 4059|      9|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (4059:9): [True: 9, False: 0]
  |  Branch (4059:29): [True: 0, False: 9]
  ------------------
 4060|      0|        return(NULL);
 4061|     18|    while (cur != NULL) {
  ------------------
  |  Branch (4061:12): [True: 9, False: 9]
  ------------------
 4062|      9|        q = xmlCopyProp(target, cur);
 4063|      9|	if (q == NULL) {
  ------------------
  |  Branch (4063:6): [True: 0, False: 9]
  ------------------
 4064|      0|            xmlFreePropList(ret);
 4065|      0|	    return(NULL);
 4066|      0|        }
 4067|      9|	if (p == NULL) {
  ------------------
  |  Branch (4067:6): [True: 9, False: 0]
  ------------------
 4068|      9|	    ret = p = q;
 4069|      9|	} else {
 4070|      0|	    p->next = q;
 4071|      0|	    q->prev = p;
 4072|      0|	    p = q;
 4073|      0|	}
 4074|      9|	cur = cur->next;
 4075|      9|    }
 4076|      9|    return(ret);
 4077|      9|}
xmlStaticCopyNode:
 4100|  8.54k|                  int extended) {
 4101|  8.54k|    xmlNodePtr ret;
 4102|       |
 4103|  8.54k|    if (node == NULL) return(NULL);
  ------------------
  |  Branch (4103:9): [True: 0, False: 8.54k]
  ------------------
 4104|  8.54k|    switch (node->type) {
  ------------------
  |  Branch (4104:13): [True: 0, False: 8.54k]
  ------------------
 4105|  8.39k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (4105:9): [True: 8.39k, False: 150]
  ------------------
 4106|  8.39k|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (4106:9): [True: 3, False: 8.54k]
  ------------------
 4107|  8.54k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (4107:9): [True: 147, False: 8.39k]
  ------------------
 4108|  8.54k|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (4108:9): [True: 0, False: 8.54k]
  ------------------
 4109|  8.54k|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (4109:9): [True: 0, False: 8.54k]
  ------------------
 4110|  8.54k|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (4110:9): [True: 0, False: 8.54k]
  ------------------
 4111|  8.54k|        case XML_PI_NODE:
  ------------------
  |  Branch (4111:9): [True: 0, False: 8.54k]
  ------------------
 4112|  8.54k|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (4112:9): [True: 0, False: 8.54k]
  ------------------
 4113|  8.54k|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (4113:9): [True: 0, False: 8.54k]
  ------------------
 4114|  8.54k|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (4114:9): [True: 0, False: 8.54k]
  ------------------
 4115|  8.54k|	    break;
 4116|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (4116:9): [True: 0, False: 8.54k]
  ------------------
 4117|      0|		return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));
 4118|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (4118:9): [True: 0, False: 8.54k]
  ------------------
 4119|      0|	    return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));
 4120|       |
 4121|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (4121:9): [True: 0, False: 8.54k]
  ------------------
 4122|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (4122:9): [True: 0, False: 8.54k]
  ------------------
 4123|      0|#ifdef LIBXML_TREE_ENABLED
 4124|      0|	    return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));
 4125|      0|#endif /* LIBXML_TREE_ENABLED */
 4126|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (4126:9): [True: 0, False: 8.54k]
  ------------------
 4127|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (4127:9): [True: 0, False: 8.54k]
  ------------------
 4128|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (4128:9): [True: 0, False: 8.54k]
  ------------------
 4129|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (4129:9): [True: 0, False: 8.54k]
  ------------------
 4130|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (4130:9): [True: 0, False: 8.54k]
  ------------------
 4131|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (4131:9): [True: 0, False: 8.54k]
  ------------------
 4132|      0|            return(NULL);
 4133|  8.54k|    }
 4134|       |
 4135|       |    /*
 4136|       |     * Allocate a new node and fill the fields.
 4137|       |     */
 4138|  8.54k|    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 4139|  8.54k|    if (ret == NULL) {
  ------------------
  |  Branch (4139:9): [True: 0, False: 8.54k]
  ------------------
 4140|      0|	xmlTreeErrMemory("copying node");
 4141|      0|	return(NULL);
 4142|      0|    }
 4143|  8.54k|    memset(ret, 0, sizeof(xmlNode));
 4144|  8.54k|    ret->type = node->type;
 4145|       |
 4146|  8.54k|    ret->doc = doc;
 4147|  8.54k|    ret->parent = parent;
 4148|  8.54k|    if (node->name == xmlStringText)
  ------------------
  |  Branch (4148:9): [True: 8.39k, False: 150]
  ------------------
 4149|  8.39k|	ret->name = xmlStringText;
 4150|    150|    else if (node->name == xmlStringTextNoenc)
  ------------------
  |  Branch (4150:14): [True: 0, False: 150]
  ------------------
 4151|      0|	ret->name = xmlStringTextNoenc;
 4152|    150|    else if (node->name == xmlStringComment)
  ------------------
  |  Branch (4152:14): [True: 0, False: 150]
  ------------------
 4153|      0|	ret->name = xmlStringComment;
 4154|    150|    else if (node->name != NULL) {
  ------------------
  |  Branch (4154:14): [True: 147, False: 3]
  ------------------
 4155|    147|        if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (4155:13): [True: 147, False: 0]
  |  Branch (4155:30): [True: 147, False: 0]
  ------------------
 4156|    147|	    ret->name = xmlDictLookup(doc->dict, node->name, -1);
 4157|      0|	else
 4158|      0|	    ret->name = xmlStrdup(node->name);
 4159|    147|    }
 4160|  8.54k|    if ((node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4160:9): [True: 8.39k, False: 147]
  ------------------
 4161|  8.54k|	(node->content != NULL) &&
  ------------------
  |  Branch (4161:2): [True: 8.39k, False: 0]
  ------------------
 4162|  8.54k|	(node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4162:2): [True: 8.39k, False: 0]
  ------------------
 4163|  8.54k|	(node->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (4163:2): [True: 8.39k, False: 0]
  ------------------
 4164|  8.54k|	(node->type != XML_XINCLUDE_START)) {
  ------------------
  |  Branch (4164:2): [True: 8.39k, False: 0]
  ------------------
 4165|  8.39k|	ret->content = xmlStrdup(node->content);
 4166|  8.39k|    }else{
 4167|    147|      if (node->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4167:11): [True: 147, False: 0]
  ------------------
 4168|    147|        ret->line = node->line;
 4169|    147|    }
 4170|  8.54k|    if (parent != NULL) {
  ------------------
  |  Branch (4170:9): [True: 93, False: 8.45k]
  ------------------
 4171|     93|	xmlNodePtr tmp;
 4172|       |
 4173|       |	/*
 4174|       |	 * this is a tricky part for the node register thing:
 4175|       |	 * in case ret does get coalesced in xmlAddChild
 4176|       |	 * the deregister-node callback is called; so we register ret now already
 4177|       |	 */
 4178|     93|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4178:6): [True: 0, False: 93]
  |  Branch (4178:34): [True: 0, False: 0]
  ------------------
 4179|      0|	    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4180|       |
 4181|       |        /*
 4182|       |         * Note that since ret->parent is already set, xmlAddChild will
 4183|       |         * return early and not actually insert the node. It will only
 4184|       |         * coalesce text nodes and unnecessarily call xmlSetTreeDoc.
 4185|       |         * Assuming that the subtree to be copied always has its text
 4186|       |         * nodes coalesced, the somewhat confusing call to xmlAddChild
 4187|       |         * could be removed.
 4188|       |         */
 4189|     93|        tmp = xmlAddChild(parent, ret);
 4190|       |	/* node could have coalesced */
 4191|     93|	if (tmp != ret)
  ------------------
  |  Branch (4191:6): [True: 0, False: 93]
  ------------------
 4192|      0|	    return(tmp);
 4193|     93|    }
 4194|       |
 4195|  8.54k|    if (!extended)
  ------------------
  |  Branch (4195:9): [True: 0, False: 8.54k]
  ------------------
 4196|      0|	goto out;
 4197|  8.54k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4197:10): [True: 147, False: 8.39k]
  ------------------
 4198|  8.54k|         (node->type == XML_XINCLUDE_START)) && (node->nsDef != NULL))
  ------------------
  |  Branch (4198:10): [True: 0, False: 8.39k]
  |  Branch (4198:49): [True: 12, False: 135]
  ------------------
 4199|     12|        ret->nsDef = xmlCopyNamespaceList(node->nsDef);
 4200|       |
 4201|  8.54k|    if (node->ns != NULL) {
  ------------------
  |  Branch (4201:9): [True: 0, False: 8.54k]
  ------------------
 4202|      0|        xmlNsPtr ns;
 4203|       |
 4204|      0|	ns = xmlSearchNs(doc, ret, node->ns->prefix);
 4205|      0|	if (ns == NULL) {
  ------------------
  |  Branch (4205:6): [True: 0, False: 0]
  ------------------
 4206|       |	    /*
 4207|       |	     * Humm, we are copying an element whose namespace is defined
 4208|       |	     * out of the new tree scope. Search it in the original tree
 4209|       |	     * and add it at the top of the new tree.
 4210|       |             *
 4211|       |             * TODO: Searching the original tree seems unnecessary. We
 4212|       |             * already have a namespace URI.
 4213|       |	     */
 4214|      0|	    ns = xmlSearchNs(node->doc, node, node->ns->prefix);
 4215|      0|	    if (ns != NULL) {
  ------------------
  |  Branch (4215:10): [True: 0, False: 0]
  ------------------
 4216|      0|	        xmlNodePtr root = ret;
 4217|       |
 4218|      0|		while (root->parent != NULL) root = root->parent;
  ------------------
  |  Branch (4218:10): [True: 0, False: 0]
  ------------------
 4219|      0|		ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 4220|      0|            } else {
 4221|      0|                ret->ns = xmlNewReconciledNs(doc, ret, node->ns);
 4222|      0|	    }
 4223|      0|	} else {
 4224|       |	    /*
 4225|       |	     * reference the existing namespace definition in our own tree.
 4226|       |	     */
 4227|      0|	    ret->ns = ns;
 4228|      0|	}
 4229|      0|    }
 4230|  8.54k|    if (((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4230:10): [True: 147, False: 8.39k]
  ------------------
 4231|  8.54k|         (node->type == XML_XINCLUDE_START)) && (node->properties != NULL))
  ------------------
  |  Branch (4231:10): [True: 0, False: 8.39k]
  |  Branch (4231:49): [True: 9, False: 138]
  ------------------
 4232|      9|        ret->properties = xmlCopyPropList(ret, node->properties);
 4233|  8.54k|    if (node->type == XML_ENTITY_REF_NODE) {
  ------------------
  |  Branch (4233:9): [True: 0, False: 8.54k]
  ------------------
 4234|      0|	if ((doc == NULL) || (node->doc != doc)) {
  ------------------
  |  Branch (4234:6): [True: 0, False: 0]
  |  Branch (4234:23): [True: 0, False: 0]
  ------------------
 4235|       |	    /*
 4236|       |	     * The copied node will go into a separate document, so
 4237|       |	     * to avoid dangling references to the ENTITY_DECL node
 4238|       |	     * we cannot keep the reference. Try to find it in the
 4239|       |	     * target document.
 4240|       |	     */
 4241|      0|	    ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);
 4242|      0|	} else {
 4243|      0|            ret->children = node->children;
 4244|      0|	}
 4245|      0|	ret->last = ret->children;
 4246|  8.54k|    } else if ((node->children != NULL) && (extended != 2)) {
  ------------------
  |  Branch (4246:16): [True: 84, False: 8.46k]
  |  Branch (4246:44): [True: 84, False: 0]
  ------------------
 4247|     84|        xmlNodePtr cur, insert;
 4248|       |
 4249|     84|        cur = node->children;
 4250|     84|        insert = ret;
 4251|    168|        while (cur != NULL) {
  ------------------
  |  Branch (4251:16): [True: 84, False: 84]
  ------------------
 4252|     84|            xmlNodePtr copy = xmlStaticCopyNode(cur, doc, insert, 2);
 4253|     84|            if (copy == NULL) {
  ------------------
  |  Branch (4253:17): [True: 0, False: 84]
  ------------------
 4254|      0|                xmlFreeNode(ret);
 4255|      0|                return(NULL);
 4256|      0|            }
 4257|       |
 4258|       |            /* Check for coalesced text nodes */
 4259|     84|            if (insert->last != copy) {
  ------------------
  |  Branch (4259:17): [True: 84, False: 0]
  ------------------
 4260|     84|                if (insert->last == NULL) {
  ------------------
  |  Branch (4260:21): [True: 84, False: 0]
  ------------------
 4261|     84|                    insert->children = copy;
 4262|     84|                } else {
 4263|      0|                    copy->prev = insert->last;
 4264|      0|                    insert->last->next = copy;
 4265|      0|                }
 4266|     84|                insert->last = copy;
 4267|     84|            }
 4268|       |
 4269|     84|            if ((cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (4269:17): [True: 84, False: 0]
  ------------------
 4270|     84|                (cur->children != NULL)) {
  ------------------
  |  Branch (4270:17): [True: 0, False: 84]
  ------------------
 4271|      0|                cur = cur->children;
 4272|      0|                insert = copy;
 4273|      0|                continue;
 4274|      0|            }
 4275|       |
 4276|     84|            while (1) {
  ------------------
  |  Branch (4276:20): [Folded - Ignored]
  ------------------
 4277|     84|                if (cur->next != NULL) {
  ------------------
  |  Branch (4277:21): [True: 0, False: 84]
  ------------------
 4278|      0|                    cur = cur->next;
 4279|      0|                    break;
 4280|      0|                }
 4281|       |
 4282|     84|                cur = cur->parent;
 4283|     84|                insert = insert->parent;
 4284|     84|                if (cur == node) {
  ------------------
  |  Branch (4284:21): [True: 84, False: 0]
  ------------------
 4285|     84|                    cur = NULL;
 4286|     84|                    break;
 4287|     84|                }
 4288|     84|            }
 4289|     84|        }
 4290|     84|    }
 4291|       |
 4292|  8.54k|out:
 4293|       |    /* if parent != NULL we already registered the node above */
 4294|  8.54k|    if ((parent == NULL) &&
  ------------------
  |  Branch (4294:9): [True: 8.45k, False: 93]
  ------------------
 4295|  8.54k|        ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue)))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (4295:10): [True: 0, False: 8.45k]
  |  Branch (4295:38): [True: 0, False: 0]
  ------------------
 4296|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4297|  8.54k|    return(ret);
 4298|  8.54k|}
xmlStaticCopyNodeList:
 4301|      9|xmlStaticCopyNodeList(xmlNodePtr node, xmlDocPtr doc, xmlNodePtr parent) {
 4302|      9|    xmlNodePtr ret = NULL;
 4303|      9|    xmlNodePtr p = NULL,q;
 4304|      9|    xmlDtdPtr newSubset = NULL;
 4305|       |
 4306|     18|    while (node != NULL) {
  ------------------
  |  Branch (4306:12): [True: 9, False: 9]
  ------------------
 4307|      9|	if (node->type == XML_DTD_NODE ) {
  ------------------
  |  Branch (4307:6): [True: 0, False: 9]
  ------------------
 4308|      0|#ifdef LIBXML_TREE_ENABLED
 4309|      0|	    if ((doc == NULL) || (doc->intSubset != NULL)) {
  ------------------
  |  Branch (4309:10): [True: 0, False: 0]
  |  Branch (4309:27): [True: 0, False: 0]
  ------------------
 4310|      0|		node = node->next;
 4311|      0|		continue;
 4312|      0|	    }
 4313|      0|            q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );
 4314|      0|            if (q == NULL) goto error;
  ------------------
  |  Branch (4314:17): [True: 0, False: 0]
  ------------------
 4315|      0|            q->doc = doc;
 4316|      0|            q->parent = parent;
 4317|      0|            newSubset = (xmlDtdPtr) q;
 4318|       |#else
 4319|       |            node = node->next;
 4320|       |            continue;
 4321|       |#endif /* LIBXML_TREE_ENABLED */
 4322|      9|	} else {
 4323|      9|	    q = xmlStaticCopyNode(node, doc, parent, 1);
 4324|      9|	    if (q == NULL) goto error;
  ------------------
  |  Branch (4324:10): [True: 0, False: 9]
  ------------------
 4325|      9|        }
 4326|      9|	if (ret == NULL) {
  ------------------
  |  Branch (4326:6): [True: 9, False: 0]
  ------------------
 4327|      9|	    q->prev = NULL;
 4328|      9|	    ret = p = q;
 4329|      9|	} else if (p != q) {
  ------------------
  |  Branch (4329:13): [True: 0, False: 0]
  ------------------
 4330|       |	/* the test is required if xmlStaticCopyNode coalesced 2 text nodes */
 4331|      0|	    p->next = q;
 4332|      0|	    q->prev = p;
 4333|      0|	    p = q;
 4334|      0|	}
 4335|      9|	node = node->next;
 4336|      9|    }
 4337|      9|    if (newSubset != NULL)
  ------------------
  |  Branch (4337:9): [True: 0, False: 9]
  ------------------
 4338|      0|        doc->intSubset = newSubset;
 4339|      9|    return(ret);
 4340|      0|error:
 4341|      0|    xmlFreeNodeList(ret);
 4342|      0|    return(NULL);
 4343|      9|}
xmlDocCopyNode:
 4377|  8.45k|xmlDocCopyNode(xmlNodePtr node, xmlDocPtr doc, int extended) {
 4378|  8.45k|    xmlNodePtr ret;
 4379|       |
 4380|  8.45k|    ret = xmlStaticCopyNode(node, doc, NULL, extended);
 4381|  8.45k|    return(ret);
 4382|  8.45k|}
xmlGetLineNo:
 4629|  2.98k|{
 4630|  2.98k|    return(xmlGetLineNoInternal(node, 0));
 4631|  2.98k|}
xmlNodeGetSpacePreserve:
 5081|  13.7k|xmlNodeGetSpacePreserve(const xmlNode *cur) {
 5082|  13.7k|    xmlChar *space;
 5083|       |
 5084|  13.7k|    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (5084:9): [True: 0, False: 13.7k]
  |  Branch (5084:26): [True: 13.7k, False: 0]
  ------------------
 5085|  13.7k|        return(-1);
 5086|      0|    while (cur != NULL) {
  ------------------
  |  Branch (5086:12): [True: 0, False: 0]
  ------------------
 5087|      0|	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	space = xmlGetNsProp(cur, BAD_CAST "space", XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5088|      0|	if (space != NULL) {
  ------------------
  |  Branch (5088:6): [True: 0, False: 0]
  ------------------
 5089|      0|	    if (xmlStrEqual(space, BAD_CAST "preserve")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5089:10): [True: 0, False: 0]
  ------------------
 5090|      0|		xmlFree(space);
 5091|      0|		return(1);
 5092|      0|	    }
 5093|      0|	    if (xmlStrEqual(space, BAD_CAST "default")) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (5093:10): [True: 0, False: 0]
  ------------------
 5094|      0|		xmlFree(space);
 5095|      0|		return(0);
 5096|      0|	    }
 5097|      0|	    xmlFree(space);
 5098|      0|	}
 5099|      0|	cur = cur->parent;
 5100|      0|    }
 5101|      0|    return(-1);
 5102|      0|}
xmlNodeAddContentLen:
 5736|  8.10k|xmlNodeAddContentLen(xmlNodePtr cur, const xmlChar *content, int len) {
 5737|  8.10k|    if (cur == NULL) {
  ------------------
  |  Branch (5737:9): [True: 0, False: 8.10k]
  ------------------
 5738|      0|	return;
 5739|      0|    }
 5740|  8.10k|    if (len <= 0) return;
  ------------------
  |  Branch (5740:9): [True: 0, False: 8.10k]
  ------------------
 5741|  8.10k|    switch (cur->type) {
  ------------------
  |  Branch (5741:13): [True: 0, False: 8.10k]
  ------------------
 5742|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5742:9): [True: 0, False: 8.10k]
  ------------------
 5743|      0|        case XML_ELEMENT_NODE: {
  ------------------
  |  Branch (5743:9): [True: 0, False: 8.10k]
  ------------------
 5744|      0|	    xmlNodePtr last, newNode, tmp;
 5745|       |
 5746|      0|	    last = cur->last;
 5747|      0|	    newNode = xmlNewDocTextLen(cur->doc, content, len);
 5748|      0|	    if (newNode != NULL) {
  ------------------
  |  Branch (5748:10): [True: 0, False: 0]
  ------------------
 5749|      0|		tmp = xmlAddChild(cur, newNode);
 5750|      0|		if (tmp != newNode)
  ------------------
  |  Branch (5750:7): [True: 0, False: 0]
  ------------------
 5751|      0|		    return;
 5752|      0|	        if ((last != NULL) && (last->next == newNode)) {
  ------------------
  |  Branch (5752:14): [True: 0, False: 0]
  |  Branch (5752:32): [True: 0, False: 0]
  ------------------
 5753|      0|		    xmlTextMerge(last, newNode);
 5754|      0|		}
 5755|      0|	    }
 5756|      0|	    break;
 5757|      0|	}
 5758|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5758:9): [True: 0, False: 8.10k]
  ------------------
 5759|      0|	    break;
 5760|  8.10k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5760:9): [True: 8.10k, False: 0]
  ------------------
 5761|  8.10k|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5761:9): [True: 0, False: 8.10k]
  ------------------
 5762|  8.10k|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5762:9): [True: 0, False: 8.10k]
  ------------------
 5763|  8.10k|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5763:9): [True: 0, False: 8.10k]
  ------------------
 5764|  8.10k|        case XML_PI_NODE:
  ------------------
  |  Branch (5764:9): [True: 0, False: 8.10k]
  ------------------
 5765|  8.10k|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5765:9): [True: 0, False: 8.10k]
  ------------------
 5766|  8.10k|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5766:9): [True: 0, False: 8.10k]
  ------------------
 5767|  8.10k|	    if (content != NULL) {
  ------------------
  |  Branch (5767:10): [True: 8.10k, False: 0]
  ------------------
 5768|  8.10k|	        if ((cur->content == (xmlChar *) &(cur->properties)) ||
  ------------------
  |  Branch (5768:14): [True: 21, False: 8.08k]
  ------------------
 5769|  8.10k|		    ((cur->doc != NULL) && (cur->doc->dict != NULL) &&
  ------------------
  |  Branch (5769:8): [True: 8.08k, False: 0]
  |  Branch (5769:30): [True: 8.08k, False: 0]
  ------------------
 5770|  8.08k|			    xmlDictOwns(cur->doc->dict, cur->content))) {
  ------------------
  |  Branch (5770:8): [True: 0, False: 8.08k]
  ------------------
 5771|     21|		    cur->content = xmlStrncatNew(cur->content, content, len);
 5772|     21|		    cur->properties = NULL;
 5773|  8.08k|		} else {
 5774|  8.08k|		    cur->content = xmlStrncat(cur->content, content, len);
 5775|  8.08k|                }
 5776|  8.10k|            }
 5777|  8.10k|	    break;
 5778|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5778:9): [True: 0, False: 8.10k]
  ------------------
 5779|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5779:9): [True: 0, False: 8.10k]
  ------------------
 5780|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5780:9): [True: 0, False: 8.10k]
  ------------------
 5781|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5781:9): [True: 0, False: 8.10k]
  ------------------
 5782|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5782:2): [True: 0, False: 8.10k]
  ------------------
 5783|      0|	case XML_XINCLUDE_START:
  ------------------
  |  Branch (5783:2): [True: 0, False: 8.10k]
  ------------------
 5784|      0|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (5784:2): [True: 0, False: 8.10k]
  ------------------
 5785|      0|	    break;
 5786|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5786:9): [True: 0, False: 8.10k]
  ------------------
 5787|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5787:9): [True: 0, False: 8.10k]
  ------------------
 5788|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5788:9): [True: 0, False: 8.10k]
  ------------------
 5789|      0|	    break;
 5790|  8.10k|    }
 5791|  8.10k|}
xmlNodeAddContent:
 5804|  8.10k|xmlNodeAddContent(xmlNodePtr cur, const xmlChar *content) {
 5805|  8.10k|    int len;
 5806|       |
 5807|  8.10k|    if (cur == NULL) {
  ------------------
  |  Branch (5807:9): [True: 0, False: 8.10k]
  ------------------
 5808|      0|	return;
 5809|      0|    }
 5810|  8.10k|    if (content == NULL) return;
  ------------------
  |  Branch (5810:9): [True: 0, False: 8.10k]
  ------------------
 5811|  8.10k|    len = xmlStrlen(content);
 5812|  8.10k|    xmlNodeAddContentLen(cur, content, len);
 5813|  8.10k|}
xmlSearchNs:
 5946|     48|xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {
 5947|       |
 5948|     48|    xmlNsPtr cur;
 5949|     48|    const xmlNode *orig = node;
 5950|       |
 5951|     48|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);
  ------------------
  |  Branch (5951:9): [True: 0, False: 48]
  |  Branch (5951:27): [True: 0, False: 48]
  ------------------
 5952|     48|    if ((nameSpace != NULL) &&
  ------------------
  |  Branch (5952:9): [True: 48, False: 0]
  ------------------
 5953|     48|	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
  ------------------
  |  Branch (5953:2): [True: 48, False: 0]
  ------------------
 5954|     48|	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (5954:6): [True: 0, False: 48]
  |  Branch (5954:23): [True: 0, False: 0]
  ------------------
 5955|       |	    /*
 5956|       |	     * The XML-1.0 namespace is normally held on the root
 5957|       |	     * element. In this case exceptionally create it on the
 5958|       |	     * node element.
 5959|       |	     */
 5960|      0|	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5961|      0|	    if (cur == NULL) {
  ------------------
  |  Branch (5961:10): [True: 0, False: 0]
  ------------------
 5962|      0|		xmlTreeErrMemory("searching namespace");
 5963|      0|		return(NULL);
 5964|      0|	    }
 5965|      0|	    memset(cur, 0, sizeof(xmlNs));
 5966|      0|	    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5967|      0|	    cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5968|      0|	    cur->prefix = xmlStrdup((const xmlChar *)"xml");
 5969|      0|	    cur->next = node->nsDef;
 5970|      0|	    node->nsDef = cur;
 5971|      0|	    return(cur);
 5972|      0|	}
 5973|     48|	if (doc == NULL) {
  ------------------
  |  Branch (5973:6): [True: 0, False: 48]
  ------------------
 5974|      0|	    doc = node->doc;
 5975|      0|	    if (doc == NULL)
  ------------------
  |  Branch (5975:10): [True: 0, False: 0]
  ------------------
 5976|      0|		return(NULL);
 5977|      0|	}
 5978|       |	/*
 5979|       |	* Return the XML namespace declaration held by the doc.
 5980|       |	*/
 5981|     48|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (5981:6): [True: 36, False: 12]
  ------------------
 5982|     36|	    return(xmlTreeEnsureXMLDecl(doc));
 5983|     12|	else
 5984|     12|	    return(doc->oldNs);
 5985|     48|    }
 5986|      0|    while (node != NULL) {
  ------------------
  |  Branch (5986:12): [True: 0, False: 0]
  ------------------
 5987|      0|	if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (5987:6): [True: 0, False: 0]
  ------------------
 5988|      0|	    (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (5988:6): [True: 0, False: 0]
  ------------------
 5989|      0|	    (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (5989:6): [True: 0, False: 0]
  ------------------
 5990|      0|	    return(NULL);
 5991|      0|	if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5991:6): [True: 0, False: 0]
  ------------------
 5992|      0|	    cur = node->nsDef;
 5993|      0|	    while (cur != NULL) {
  ------------------
  |  Branch (5993:13): [True: 0, False: 0]
  ------------------
 5994|      0|		if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (5994:7): [True: 0, False: 0]
  |  Branch (5994:32): [True: 0, False: 0]
  ------------------
 5995|      0|		    (cur->href != NULL))
  ------------------
  |  Branch (5995:7): [True: 0, False: 0]
  ------------------
 5996|      0|		    return(cur);
 5997|      0|		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (5997:7): [True: 0, False: 0]
  |  Branch (5997:32): [True: 0, False: 0]
  ------------------
 5998|      0|		    (cur->href != NULL) &&
  ------------------
  |  Branch (5998:7): [True: 0, False: 0]
  ------------------
 5999|      0|		    (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (5999:7): [True: 0, False: 0]
  ------------------
 6000|      0|		    return(cur);
 6001|      0|		cur = cur->next;
 6002|      0|	    }
 6003|      0|	    if (orig != node) {
  ------------------
  |  Branch (6003:10): [True: 0, False: 0]
  ------------------
 6004|      0|	        cur = node->ns;
 6005|      0|	        if (cur != NULL) {
  ------------------
  |  Branch (6005:14): [True: 0, False: 0]
  ------------------
 6006|      0|		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (6006:11): [True: 0, False: 0]
  |  Branch (6006:36): [True: 0, False: 0]
  ------------------
 6007|      0|		        (cur->href != NULL))
  ------------------
  |  Branch (6007:11): [True: 0, False: 0]
  ------------------
 6008|      0|		        return(cur);
 6009|      0|		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (6009:11): [True: 0, False: 0]
  |  Branch (6009:36): [True: 0, False: 0]
  ------------------
 6010|      0|		        (cur->href != NULL) &&
  ------------------
  |  Branch (6010:11): [True: 0, False: 0]
  ------------------
 6011|      0|		        (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (6011:11): [True: 0, False: 0]
  ------------------
 6012|      0|		        return(cur);
 6013|      0|	        }
 6014|      0|	    }
 6015|      0|	}
 6016|      0|	node = node->parent;
 6017|      0|    }
 6018|      0|    return(NULL);
 6019|      0|}
xmlIsBlankNode:
 6886|  17.3k|xmlIsBlankNode(const xmlNode *node) {
 6887|  17.3k|    const xmlChar *cur;
 6888|  17.3k|    if (node == NULL) return(0);
  ------------------
  |  Branch (6888:9): [True: 0, False: 17.3k]
  ------------------
 6889|       |
 6890|  17.3k|    if ((node->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (6890:9): [True: 0, False: 17.3k]
  ------------------
 6891|  17.3k|        (node->type != XML_CDATA_SECTION_NODE))
  ------------------
  |  Branch (6891:9): [True: 0, False: 0]
  ------------------
 6892|      0|	return(0);
 6893|  17.3k|    if (node->content == NULL) return(1);
  ------------------
  |  Branch (6893:9): [True: 0, False: 17.3k]
  ------------------
 6894|  17.3k|    cur = node->content;
 6895|  87.6k|    while (*cur != 0) {
  ------------------
  |  Branch (6895:12): [True: 73.9k, False: 13.7k]
  ------------------
 6896|  73.9k|	if (!IS_BLANK_CH(*cur)) return(0);
  ------------------
  |  |  151|  73.9k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  73.9k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 9.18k, False: 64.7k]
  |  |  |  |  ------------------
  |  |  |  |   89|  73.9k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 64.7k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 61.1k, False: 3.59k]
  |  |  |  |  ------------------
  |  |  |  |   90|  73.9k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 3.59k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 6897|  70.3k|	cur++;
 6898|  70.3k|    }
 6899|       |
 6900|  13.7k|    return(1);
 6901|  17.3k|}
xmlTextConcat:
 6915|  1.41k|xmlTextConcat(xmlNodePtr node, const xmlChar *content, int len) {
 6916|  1.41k|    if (node == NULL) return(-1);
  ------------------
  |  Branch (6916:9): [True: 0, False: 1.41k]
  ------------------
 6917|       |
 6918|  1.41k|    if ((node->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (6918:9): [True: 0, False: 1.41k]
  ------------------
 6919|  1.41k|        (node->type != XML_CDATA_SECTION_NODE) &&
  ------------------
  |  Branch (6919:9): [True: 0, False: 0]
  ------------------
 6920|  1.41k|	(node->type != XML_COMMENT_NODE) &&
  ------------------
  |  Branch (6920:2): [True: 0, False: 0]
  ------------------
 6921|  1.41k|	(node->type != XML_PI_NODE)) {
  ------------------
  |  Branch (6921:2): [True: 0, False: 0]
  ------------------
 6922|      0|        return(-1);
 6923|      0|    }
 6924|       |    /* need to check if content is currently in the dictionary */
 6925|  1.41k|    if ((node->content == (xmlChar *) &(node->properties)) ||
  ------------------
  |  Branch (6925:9): [True: 0, False: 1.41k]
  ------------------
 6926|  1.41k|        ((node->doc != NULL) && (node->doc->dict != NULL) &&
  ------------------
  |  Branch (6926:10): [True: 1.41k, False: 0]
  |  Branch (6926:33): [True: 1.41k, False: 0]
  ------------------
 6927|  1.41k|		xmlDictOwns(node->doc->dict, node->content))) {
  ------------------
  |  Branch (6927:3): [True: 0, False: 1.41k]
  ------------------
 6928|      0|	node->content = xmlStrncatNew(node->content, content, len);
 6929|  1.41k|    } else {
 6930|  1.41k|        node->content = xmlStrncat(node->content, content, len);
 6931|  1.41k|    }
 6932|  1.41k|    node->properties = NULL;
 6933|  1.41k|    if (node->content == NULL)
  ------------------
  |  Branch (6933:9): [True: 0, False: 1.41k]
  ------------------
 6934|      0|        return(-1);
 6935|  1.41k|    return(0);
 6936|  1.41k|}
xmlBufferCreate:
 6951|  1.18k|xmlBufferCreate(void) {
 6952|  1.18k|    xmlBufferPtr ret;
 6953|       |
 6954|  1.18k|    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));
 6955|  1.18k|    if (ret == NULL) {
  ------------------
  |  Branch (6955:9): [True: 0, False: 1.18k]
  ------------------
 6956|      0|	xmlTreeErrMemory("creating buffer");
 6957|      0|        return(NULL);
 6958|      0|    }
 6959|  1.18k|    ret->use = 0;
 6960|  1.18k|    ret->size = xmlDefaultBufferSize;
  ------------------
  |  |  680|  1.18k|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|  1.18k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 6961|  1.18k|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|  1.18k|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|  1.18k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 6962|  1.18k|    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
 6963|  1.18k|    if (ret->content == NULL) {
  ------------------
  |  Branch (6963:9): [True: 0, False: 1.18k]
  ------------------
 6964|      0|	xmlTreeErrMemory("creating buffer");
 6965|      0|	xmlFree(ret);
 6966|      0|        return(NULL);
 6967|      0|    }
 6968|  1.18k|    ret->content[0] = 0;
 6969|  1.18k|    ret->contentIO = NULL;
 6970|  1.18k|    return(ret);
 6971|  1.18k|}
xmlBufferSetAllocationScheme:
 7058|  1.18k|                             xmlBufferAllocationScheme scheme) {
 7059|  1.18k|    if (buf == NULL) {
  ------------------
  |  Branch (7059:9): [True: 0, False: 1.18k]
  ------------------
 7060|      0|        return;
 7061|      0|    }
 7062|  1.18k|    if (buf->alloc == XML_BUFFER_ALLOC_IO) return;
  ------------------
  |  Branch (7062:9): [True: 0, False: 1.18k]
  ------------------
 7063|  1.18k|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (7063:9): [True: 1.18k, False: 0]
  ------------------
 7064|  1.18k|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (7064:9): [True: 0, False: 0]
  ------------------
 7065|  1.18k|        (scheme == XML_BUFFER_ALLOC_HYBRID))
  ------------------
  |  Branch (7065:9): [True: 0, False: 0]
  ------------------
 7066|  1.18k|	buf->alloc = scheme;
 7067|  1.18k|}
xmlBufferFree:
 7077|  1.18k|xmlBufferFree(xmlBufferPtr buf) {
 7078|  1.18k|    if (buf == NULL) {
  ------------------
  |  Branch (7078:9): [True: 0, False: 1.18k]
  ------------------
 7079|      0|	return;
 7080|      0|    }
 7081|       |
 7082|  1.18k|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (7082:9): [True: 0, False: 1.18k]
  ------------------
 7083|  1.18k|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (7083:9): [True: 0, False: 0]
  ------------------
 7084|      0|        xmlFree(buf->contentIO);
 7085|  1.18k|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (7085:16): [True: 1.18k, False: 0]
  ------------------
 7086|  1.18k|        xmlFree(buf->content);
 7087|  1.18k|    }
 7088|  1.18k|    xmlFree(buf);
 7089|  1.18k|}
xmlBufferResize:
 7280|      1|{
 7281|      1|    unsigned int newSize;
 7282|      1|    xmlChar* rebuf = NULL;
 7283|      1|    size_t start_buf;
 7284|       |
 7285|      1|    if (buf == NULL)
  ------------------
  |  Branch (7285:9): [True: 0, False: 1]
  ------------------
 7286|      0|        return(0);
 7287|       |
 7288|       |    /* Don't resize if we don't have to */
 7289|      1|    if (size < buf->size)
  ------------------
  |  Branch (7289:9): [True: 0, False: 1]
  ------------------
 7290|      0|        return 1;
 7291|       |
 7292|      1|    if (size > UINT_MAX - 10) {
  ------------------
  |  Branch (7292:9): [True: 0, False: 1]
  ------------------
 7293|      0|        xmlTreeErrMemory("growing buffer past UINT_MAX");
 7294|      0|        return 0;
 7295|      0|    }
 7296|       |
 7297|       |    /* figure out new size */
 7298|      1|    switch (buf->alloc){
 7299|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (7299:2): [True: 0, False: 1]
  ------------------
 7300|      1|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (7300:2): [True: 1, False: 0]
  ------------------
 7301|       |	    /*take care of empty case*/
 7302|      1|            if (buf->size == 0)
  ------------------
  |  Branch (7302:17): [True: 0, False: 1]
  ------------------
 7303|      0|                newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);
  ------------------
  |  Branch (7303:28): [True: 0, False: 0]
  ------------------
 7304|      1|            else
 7305|      1|                newSize = buf->size;
 7306|      2|	    while (size > newSize) {
  ------------------
  |  Branch (7306:13): [True: 1, False: 1]
  ------------------
 7307|      1|	        if (newSize > UINT_MAX / 2) {
  ------------------
  |  Branch (7307:14): [True: 0, False: 1]
  ------------------
 7308|      0|	            xmlTreeErrMemory("growing buffer");
 7309|      0|	            return 0;
 7310|      0|	        }
 7311|      1|	        newSize *= 2;
 7312|      1|	    }
 7313|      1|	    break;
 7314|      1|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (7314:2): [True: 0, False: 1]
  ------------------
 7315|      0|	    newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);
  ------------------
  |  Branch (7315:17): [True: 0, False: 0]
  ------------------
 7316|      0|	    break;
 7317|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (7317:9): [True: 0, False: 1]
  ------------------
 7318|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (7318:17): [True: 0, False: 0]
  ------------------
 7319|      0|                newSize = size;
 7320|      0|            else {
 7321|      0|                newSize = buf->size;
 7322|      0|                while (size > newSize) {
  ------------------
  |  Branch (7322:24): [True: 0, False: 0]
  ------------------
 7323|      0|                    if (newSize > UINT_MAX / 2) {
  ------------------
  |  Branch (7323:25): [True: 0, False: 0]
  ------------------
 7324|      0|                        xmlTreeErrMemory("growing buffer");
 7325|      0|                        return 0;
 7326|      0|                    }
 7327|      0|                    newSize *= 2;
 7328|      0|                }
 7329|      0|            }
 7330|      0|            break;
 7331|       |
 7332|      0|	default:
  ------------------
  |  Branch (7332:2): [True: 0, False: 1]
  ------------------
 7333|      0|	    newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);
  ------------------
  |  Branch (7333:17): [True: 0, False: 0]
  ------------------
 7334|      0|	    break;
 7335|      1|    }
 7336|       |
 7337|      1|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (7337:9): [True: 0, False: 1]
  |  Branch (7337:48): [True: 0, False: 0]
  ------------------
 7338|      0|        start_buf = buf->content - buf->contentIO;
 7339|       |
 7340|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (7340:13): [True: 0, False: 0]
  ------------------
 7341|       |	    /* move data back to start */
 7342|      0|	    memmove(buf->contentIO, buf->content, buf->use);
 7343|      0|	    buf->content = buf->contentIO;
 7344|      0|	    buf->content[buf->use] = 0;
 7345|      0|	    buf->size += start_buf;
 7346|      0|	} else {
 7347|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
 7348|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (7348:10): [True: 0, False: 0]
  ------------------
 7349|      0|		xmlTreeErrMemory("growing buffer");
 7350|      0|		return 0;
 7351|      0|	    }
 7352|      0|	    buf->contentIO = rebuf;
 7353|      0|	    buf->content = rebuf + start_buf;
 7354|      0|	}
 7355|      1|    } else {
 7356|      1|	if (buf->content == NULL) {
  ------------------
  |  Branch (7356:6): [True: 0, False: 1]
  ------------------
 7357|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
 7358|      0|	    buf->use = 0;
 7359|      0|	    rebuf[buf->use] = 0;
 7360|      1|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (7360:13): [True: 1, False: 0]
  ------------------
 7361|      1|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
 7362|      1|        } else {
 7363|       |	    /*
 7364|       |	     * if we are reallocating a buffer far from being full, it's
 7365|       |	     * better to make a new allocation and copy only the used range
 7366|       |	     * and free the old one.
 7367|       |	     */
 7368|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
 7369|      0|	    if (rebuf != NULL) {
  ------------------
  |  Branch (7369:10): [True: 0, False: 0]
  ------------------
 7370|      0|		memcpy(rebuf, buf->content, buf->use);
 7371|      0|		xmlFree(buf->content);
 7372|      0|		rebuf[buf->use] = 0;
 7373|      0|	    }
 7374|      0|	}
 7375|      1|	if (rebuf == NULL) {
  ------------------
  |  Branch (7375:6): [True: 0, False: 1]
  ------------------
 7376|      0|	    xmlTreeErrMemory("growing buffer");
 7377|      0|	    return 0;
 7378|      0|	}
 7379|      1|	buf->content = rebuf;
 7380|      1|    }
 7381|      1|    buf->size = newSize;
 7382|       |
 7383|      1|    return 1;
 7384|      1|}
xmlBufferAdd:
 7399|  10.1k|xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {
 7400|  10.1k|    unsigned int needSize;
 7401|       |
 7402|  10.1k|    if ((str == NULL) || (buf == NULL)) {
  ------------------
  |  Branch (7402:9): [True: 0, False: 10.1k]
  |  Branch (7402:26): [True: 0, False: 10.1k]
  ------------------
 7403|      0|	return -1;
 7404|      0|    }
 7405|  10.1k|    if (len < -1) {
  ------------------
  |  Branch (7405:9): [True: 0, False: 10.1k]
  ------------------
 7406|      0|	return -1;
 7407|      0|    }
 7408|  10.1k|    if (len == 0) return 0;
  ------------------
  |  Branch (7408:9): [True: 0, False: 10.1k]
  ------------------
 7409|       |
 7410|  10.1k|    if (len < 0)
  ------------------
  |  Branch (7410:9): [True: 10.1k, False: 0]
  ------------------
 7411|  10.1k|        len = xmlStrlen(str);
 7412|       |
 7413|  10.1k|    if (len < 0) return -1;
  ------------------
  |  Branch (7413:9): [True: 0, False: 10.1k]
  ------------------
 7414|  10.1k|    if (len == 0) return 0;
  ------------------
  |  Branch (7414:9): [True: 0, False: 10.1k]
  ------------------
 7415|       |
 7416|       |    /* Note that both buf->size and buf->use can be zero here. */
 7417|  10.1k|    if ((unsigned) len >= buf->size - buf->use) {
  ------------------
  |  Branch (7417:9): [True: 1, False: 10.1k]
  ------------------
 7418|      1|        if ((unsigned) len >= UINT_MAX - buf->use) {
  ------------------
  |  Branch (7418:13): [True: 0, False: 1]
  ------------------
 7419|      0|            xmlTreeErrMemory("growing buffer past UINT_MAX");
 7420|      0|            return XML_ERR_NO_MEMORY;
 7421|      0|        }
 7422|      1|        needSize = buf->use + len + 1;
 7423|      1|        if (!xmlBufferResize(buf, needSize)){
  ------------------
  |  Branch (7423:13): [True: 0, False: 1]
  ------------------
 7424|      0|	    xmlTreeErrMemory("growing buffer");
 7425|      0|            return XML_ERR_NO_MEMORY;
 7426|      0|        }
 7427|      1|    }
 7428|       |
 7429|  10.1k|    memmove(&buf->content[buf->use], str, len);
 7430|  10.1k|    buf->use += len;
 7431|  10.1k|    buf->content[buf->use] = 0;
 7432|  10.1k|    return 0;
 7433|  10.1k|}
xmlBufferCat:
 7512|  10.1k|xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {
 7513|  10.1k|    if (buf == NULL)
  ------------------
  |  Branch (7513:9): [True: 0, False: 10.1k]
  ------------------
 7514|      0|        return(-1);
 7515|  10.1k|    if (str == NULL) return -1;
  ------------------
  |  Branch (7515:9): [True: 0, False: 10.1k]
  ------------------
 7516|  10.1k|    return xmlBufferAdd(buf, str, -1);
 7517|  10.1k|}
xmlBufferCCat:
 7530|  7.01k|xmlBufferCCat(xmlBufferPtr buf, const char *str) {
 7531|  7.01k|    return xmlBufferCat(buf, (const xmlChar *) str);
 7532|  7.01k|}
xmlBufferWriteCHAR:
 7543|  2.85k|xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {
 7544|  2.85k|    if (buf == NULL)
  ------------------
  |  Branch (7544:9): [True: 0, False: 2.85k]
  ------------------
 7545|      0|        return;
 7546|  2.85k|    xmlBufferCat(buf, string);
 7547|  2.85k|}
xmlBufferWriteChar:
 7558|  6.53k|xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {
 7559|  6.53k|    if (buf == NULL)
  ------------------
  |  Branch (7559:9): [True: 0, False: 6.53k]
  ------------------
 7560|      0|        return;
 7561|  6.53k|    xmlBufferCCat(buf, string);
 7562|  6.53k|}
xmlBufferWriteQuotedString:
 7575|    240|xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {
 7576|    240|    const xmlChar *cur, *base;
 7577|    240|    if (buf == NULL)
  ------------------
  |  Branch (7577:9): [True: 0, False: 240]
  ------------------
 7578|      0|        return;
 7579|    240|    if (xmlStrchr(string, '\"')) {
  ------------------
  |  Branch (7579:9): [True: 3, False: 237]
  ------------------
 7580|      3|        if (xmlStrchr(string, '\'')) {
  ------------------
  |  Branch (7580:13): [True: 0, False: 3]
  ------------------
 7581|      0|	    xmlBufferCCat(buf, "\"");
 7582|      0|            base = cur = string;
 7583|      0|            while(*cur != 0){
  ------------------
  |  Branch (7583:19): [True: 0, False: 0]
  ------------------
 7584|      0|                if(*cur == '"'){
  ------------------
  |  Branch (7584:20): [True: 0, False: 0]
  ------------------
 7585|      0|                    if (base != cur)
  ------------------
  |  Branch (7585:25): [True: 0, False: 0]
  ------------------
 7586|      0|                        xmlBufferAdd(buf, base, cur - base);
 7587|      0|                    xmlBufferAdd(buf, BAD_CAST "&quot;", 6);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7588|      0|                    cur++;
 7589|      0|                    base = cur;
 7590|      0|                }
 7591|      0|                else {
 7592|      0|                    cur++;
 7593|      0|                }
 7594|      0|            }
 7595|      0|            if (base != cur)
  ------------------
  |  Branch (7595:17): [True: 0, False: 0]
  ------------------
 7596|      0|                xmlBufferAdd(buf, base, cur - base);
 7597|      0|	    xmlBufferCCat(buf, "\"");
 7598|      0|	}
 7599|      3|        else{
 7600|      3|	    xmlBufferCCat(buf, "\'");
 7601|      3|            xmlBufferCat(buf, string);
 7602|      3|	    xmlBufferCCat(buf, "\'");
 7603|      3|        }
 7604|    237|    } else {
 7605|    237|        xmlBufferCCat(buf, "\"");
 7606|    237|        xmlBufferCat(buf, string);
 7607|    237|        xmlBufferCCat(buf, "\"");
 7608|    237|    }
 7609|    240|}
xmlIsXHTML:
10026|    163|xmlIsXHTML(const xmlChar *systemID, const xmlChar *publicID) {
10027|    163|    if ((systemID == NULL) && (publicID == NULL))
  ------------------
  |  Branch (10027:9): [True: 102, False: 61]
  |  Branch (10027:31): [True: 102, False: 0]
  ------------------
10028|    102|	return(-1);
10029|     61|    if (publicID != NULL) {
  ------------------
  |  Branch (10029:9): [True: 40, False: 21]
  ------------------
10030|     40|	if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);
  ------------------
  |  |10003|     40|#define XHTML_STRICT_PUBLIC_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     40|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10004|     40|   "-//W3C//DTD XHTML 1.0 Strict//EN"
  ------------------
  |  Branch (10030:6): [True: 2, False: 38]
  ------------------
10031|     38|	if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);
  ------------------
  |  |10007|     38|#define XHTML_FRAME_PUBLIC_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     38|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10008|     38|   "-//W3C//DTD XHTML 1.0 Frameset//EN"
  ------------------
  |  Branch (10031:6): [True: 0, False: 38]
  ------------------
10032|     38|	if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);
  ------------------
  |  |10011|     38|#define XHTML_TRANS_PUBLIC_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     38|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10012|     38|   "-//W3C//DTD XHTML 1.0 Transitional//EN"
  ------------------
  |  Branch (10032:6): [True: 0, False: 38]
  ------------------
10033|     38|    }
10034|     59|    if (systemID != NULL) {
  ------------------
  |  Branch (10034:9): [True: 59, False: 0]
  ------------------
10035|     59|	if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);
  ------------------
  |  |10005|     59|#define XHTML_STRICT_SYSTEM_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     59|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10006|     59|   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
  ------------------
  |  Branch (10035:6): [True: 0, False: 59]
  ------------------
10036|     59|	if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);
  ------------------
  |  |10009|     59|#define XHTML_FRAME_SYSTEM_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     59|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10010|     59|   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"
  ------------------
  |  Branch (10036:6): [True: 0, False: 59]
  ------------------
10037|     59|	if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);
  ------------------
  |  |10013|     59|#define XHTML_TRANS_SYSTEM_ID BAD_CAST \
  |  |  ------------------
  |  |  |  |   35|     59|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |10014|     59|   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
  ------------------
  |  Branch (10037:6): [True: 0, False: 59]
  ------------------
10038|     59|    }
10039|     59|    return(0);
10040|     59|}
tree.c:xmlCopyPropInternal:
 3934|      9|xmlCopyPropInternal(xmlDocPtr doc, xmlNodePtr target, xmlAttrPtr cur) {
 3935|      9|    xmlAttrPtr ret;
 3936|       |
 3937|      9|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3937:9): [True: 0, False: 9]
  ------------------
 3938|      9|    if ((target != NULL) && (target->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (3938:9): [True: 9, False: 0]
  |  Branch (3938:29): [True: 0, False: 9]
  ------------------
 3939|      0|        return(NULL);
 3940|      9|    if (target != NULL)
  ------------------
  |  Branch (3940:9): [True: 9, False: 0]
  ------------------
 3941|      9|	ret = xmlNewDocProp(target->doc, cur->name, NULL);
 3942|      0|    else if (doc != NULL)
  ------------------
  |  Branch (3942:14): [True: 0, False: 0]
  ------------------
 3943|      0|	ret = xmlNewDocProp(doc, cur->name, NULL);
 3944|      0|    else if (cur->parent != NULL)
  ------------------
  |  Branch (3944:14): [True: 0, False: 0]
  ------------------
 3945|      0|	ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);
 3946|      0|    else if (cur->children != NULL)
  ------------------
  |  Branch (3946:14): [True: 0, False: 0]
  ------------------
 3947|      0|	ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);
 3948|      0|    else
 3949|      0|	ret = xmlNewDocProp(NULL, cur->name, NULL);
 3950|      9|    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (3950:9): [True: 0, False: 9]
  ------------------
 3951|      9|    ret->parent = target;
 3952|       |
 3953|      9|    if ((cur->ns != NULL) && (target != NULL)) {
  ------------------
  |  Branch (3953:9): [True: 0, False: 9]
  |  Branch (3953:30): [True: 0, False: 0]
  ------------------
 3954|      0|      xmlNsPtr ns;
 3955|       |
 3956|      0|      ns = xmlSearchNs(target->doc, target, cur->ns->prefix);
 3957|      0|      if (ns == NULL) {
  ------------------
  |  Branch (3957:11): [True: 0, False: 0]
  ------------------
 3958|       |        /*
 3959|       |         * Humm, we are copying an element whose namespace is defined
 3960|       |         * out of the new tree scope. Search it in the original tree
 3961|       |         * and add it at the top of the new tree
 3962|       |         */
 3963|      0|        ns = xmlSearchNs(cur->doc, cur->parent, cur->ns->prefix);
 3964|      0|        if (ns != NULL) {
  ------------------
  |  Branch (3964:13): [True: 0, False: 0]
  ------------------
 3965|      0|          xmlNodePtr root = target;
 3966|      0|          xmlNodePtr pred = NULL;
 3967|       |
 3968|      0|          while (root->parent != NULL) {
  ------------------
  |  Branch (3968:18): [True: 0, False: 0]
  ------------------
 3969|      0|            pred = root;
 3970|      0|            root = root->parent;
 3971|      0|          }
 3972|      0|          if (root == (xmlNodePtr) target->doc) {
  ------------------
  |  Branch (3972:15): [True: 0, False: 0]
  ------------------
 3973|       |            /* correct possibly cycling above the document elt */
 3974|      0|            root = pred;
 3975|      0|          }
 3976|      0|          ret->ns = xmlNewNs(root, ns->href, ns->prefix);
 3977|      0|        }
 3978|      0|      } else {
 3979|       |        /*
 3980|       |         * we have to find something appropriate here since
 3981|       |         * we can't be sure, that the namespace we found is identified
 3982|       |         * by the prefix
 3983|       |         */
 3984|      0|        if (xmlStrEqual(ns->href, cur->ns->href)) {
  ------------------
  |  Branch (3984:13): [True: 0, False: 0]
  ------------------
 3985|       |          /* this is the nice case */
 3986|      0|          ret->ns = ns;
 3987|      0|        } else {
 3988|       |          /*
 3989|       |           * we are in trouble: we need a new reconciled namespace.
 3990|       |           * This is expensive
 3991|       |           */
 3992|      0|          ret->ns = xmlNewReconciledNs(target->doc, target, cur->ns);
 3993|      0|        }
 3994|      0|      }
 3995|       |
 3996|      0|    } else
 3997|      9|        ret->ns = NULL;
 3998|       |
 3999|      9|    if (cur->children != NULL) {
  ------------------
  |  Branch (3999:9): [True: 9, False: 0]
  ------------------
 4000|      9|	xmlNodePtr tmp;
 4001|       |
 4002|      9|	ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);
 4003|      9|	ret->last = NULL;
 4004|      9|	tmp = ret->children;
 4005|     18|	while (tmp != NULL) {
  ------------------
  |  Branch (4005:9): [True: 9, False: 9]
  ------------------
 4006|       |	    /* tmp->parent = (xmlNodePtr)ret; */
 4007|      9|	    if (tmp->next == NULL)
  ------------------
  |  Branch (4007:10): [True: 9, False: 0]
  ------------------
 4008|      9|	        ret->last = tmp;
 4009|      9|	    tmp = tmp->next;
 4010|      9|	}
 4011|      9|    }
 4012|       |    /*
 4013|       |     * Try to handle IDs
 4014|       |     */
 4015|      9|    if ((target!= NULL) && (cur!= NULL) &&
  ------------------
  |  Branch (4015:9): [True: 9, False: 0]
  |  Branch (4015:28): [True: 9, False: 0]
  ------------------
 4016|      9|	(target->doc != NULL) && (cur->doc != NULL) &&
  ------------------
  |  Branch (4016:2): [True: 9, False: 0]
  |  Branch (4016:27): [True: 9, False: 0]
  ------------------
 4017|      9|	(cur->doc->ids != NULL) && (cur->parent != NULL)) {
  ------------------
  |  Branch (4017:2): [True: 6, False: 3]
  |  Branch (4017:29): [True: 6, False: 0]
  ------------------
 4018|      6|	if (xmlIsID(cur->doc, cur->parent, cur)) {
  ------------------
  |  Branch (4018:6): [True: 6, False: 0]
  ------------------
 4019|      6|	    xmlChar *id;
 4020|       |
 4021|      6|	    id = xmlNodeListGetString(cur->doc, cur->children, 1);
 4022|      6|	    if (id != NULL) {
  ------------------
  |  Branch (4022:10): [True: 6, False: 0]
  ------------------
 4023|      6|		xmlAddID(NULL, target->doc, id, ret);
 4024|      6|		xmlFree(id);
 4025|      6|	    }
 4026|      6|	}
 4027|      6|    }
 4028|      9|    return(ret);
 4029|      9|}
tree.c:xmlGetLineNoInternal:
 4579|  2.98k|{
 4580|  2.98k|    long result = -1;
 4581|       |
 4582|  2.98k|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 2.98k]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|  2.98k|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 0, False: 2.98k]
  ------------------
 4586|      0|        return result;
 4587|  2.98k|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 2.98k, False: 0]
  ------------------
 4588|  2.98k|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|  2.98k|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|  2.98k|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|  2.98k|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 2.98k]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|  2.98k|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 2.98k, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|  2.98k|	    result = (long) node->line;
 4604|  2.98k|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|  2.98k|    return result;
 4615|  2.98k|}
tree.c:xmlTreeEnsureXMLDecl:
 5907|     36|{
 5908|     36|    if (doc == NULL)
  ------------------
  |  Branch (5908:9): [True: 0, False: 36]
  ------------------
 5909|      0|	return (NULL);
 5910|     36|    if (doc->oldNs != NULL)
  ------------------
  |  Branch (5910:9): [True: 0, False: 36]
  ------------------
 5911|      0|	return (doc->oldNs);
 5912|     36|    {
 5913|     36|	xmlNsPtr ns;
 5914|     36|	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5915|     36|	if (ns == NULL) {
  ------------------
  |  Branch (5915:6): [True: 0, False: 36]
  ------------------
 5916|      0|	    xmlTreeErrMemory(
 5917|      0|		"allocating the XML namespace");
 5918|      0|	    return (NULL);
 5919|      0|	}
 5920|     36|	memset(ns, 0, sizeof(xmlNs));
 5921|     36|	ns->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|     36|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5922|     36|	ns->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|     36|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5923|     36|	ns->prefix = xmlStrdup((const xmlChar *)"xml");
 5924|     36|	doc->oldNs = ns;
 5925|     36|	return (ns);
 5926|     36|    }
 5927|     36|}

xmlParseURI:
  947|  11.4k|xmlParseURI(const char *str) {
  948|  11.4k|    xmlURIPtr uri;
  949|  11.4k|    int ret;
  950|       |
  951|  11.4k|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 0, False: 11.4k]
  ------------------
  952|      0|	return(NULL);
  953|  11.4k|    uri = xmlCreateURI();
  954|  11.4k|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 11.4k, False: 0]
  ------------------
  955|  11.4k|	ret = xmlParse3986URIReference(uri, str);
  956|  11.4k|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 0, False: 11.4k]
  ------------------
  957|      0|	    xmlFreeURI(uri);
  958|      0|	    return(NULL);
  959|      0|	}
  960|  11.4k|    }
  961|  11.4k|    return(uri);
  962|  11.4k|}
xmlParseURIReference:
  977|    394|xmlParseURIReference(xmlURIPtr uri, const char *str) {
  978|    394|    return(xmlParse3986URIReference(uri, str));
  979|    394|}
xmlCreateURI:
 1027|  11.9k|xmlCreateURI(void) {
 1028|  11.9k|    xmlURIPtr ret;
 1029|       |
 1030|  11.9k|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|  11.9k|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 0, False: 11.9k]
  ------------------
 1032|      0|        xmlURIErrMemory("creating URI structure\n");
 1033|      0|	return(NULL);
 1034|      0|    }
 1035|  11.9k|    memset(ret, 0, sizeof(xmlURI));
 1036|  11.9k|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|  11.9k|#define PORT_EMPTY           0
  ------------------
 1037|  11.9k|    return(ret);
 1038|  11.9k|}
xmlSaveUri:
 1074|    177|xmlSaveUri(xmlURIPtr uri) {
 1075|    177|    xmlChar *ret = NULL;
 1076|    177|    xmlChar *temp;
 1077|    177|    const char *p;
 1078|    177|    int len;
 1079|    177|    int max;
 1080|       |
 1081|    177|    if (uri == NULL) return(NULL);
  ------------------
  |  Branch (1081:9): [True: 0, False: 177]
  ------------------
 1082|       |
 1083|       |
 1084|    177|    max = 80;
 1085|    177|    ret = (xmlChar *) xmlMallocAtomic(max + 1);
 1086|    177|    if (ret == NULL) {
  ------------------
  |  Branch (1086:9): [True: 0, False: 177]
  ------------------
 1087|      0|        xmlURIErrMemory("saving URI\n");
 1088|      0|	return(NULL);
 1089|      0|    }
 1090|    177|    len = 0;
 1091|       |
 1092|    177|    if (uri->scheme != NULL) {
  ------------------
  |  Branch (1092:9): [True: 0, False: 177]
  ------------------
 1093|      0|	p = uri->scheme;
 1094|      0|	while (*p != 0) {
  ------------------
  |  Branch (1094:9): [True: 0, False: 0]
  ------------------
 1095|      0|	    if (len >= max) {
  ------------------
  |  Branch (1095:10): [True: 0, False: 0]
  ------------------
 1096|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1097|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1097:21): [True: 0, False: 0]
  ------------------
 1098|      0|		ret = temp;
 1099|      0|	    }
 1100|      0|	    ret[len++] = *p++;
 1101|      0|	}
 1102|      0|	if (len >= max) {
  ------------------
  |  Branch (1102:6): [True: 0, False: 0]
  ------------------
 1103|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1104|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1104:17): [True: 0, False: 0]
  ------------------
 1105|      0|            ret = temp;
 1106|      0|	}
 1107|      0|	ret[len++] = ':';
 1108|      0|    }
 1109|    177|    if (uri->opaque != NULL) {
  ------------------
  |  Branch (1109:9): [True: 0, False: 177]
  ------------------
 1110|      0|	p = uri->opaque;
 1111|      0|	while (*p != 0) {
  ------------------
  |  Branch (1111:9): [True: 0, False: 0]
  ------------------
 1112|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1112:10): [True: 0, False: 0]
  ------------------
 1113|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1114|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1114:21): [True: 0, False: 0]
  ------------------
 1115|      0|                ret = temp;
 1116|      0|	    }
 1117|      0|	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
              	    if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1118|      0|		ret[len++] = *p++;
 1119|      0|	    else {
 1120|      0|		int val = *(unsigned char *)p++;
 1121|      0|		int hi = val / 0x10, lo = val % 0x10;
 1122|      0|		ret[len++] = '%';
 1123|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1123:22): [True: 0, False: 0]
  ------------------
 1124|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1124:22): [True: 0, False: 0]
  ------------------
 1125|      0|	    }
 1126|      0|	}
 1127|    177|    } else {
 1128|    177|	if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    177|#define PORT_EMPTY           0
  ------------------
  |  Branch (1128:6): [True: 0, False: 177]
  |  Branch (1128:31): [True: 0, False: 177]
  ------------------
 1129|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1129:10): [True: 0, False: 0]
  ------------------
 1130|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1131|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1131:21): [True: 0, False: 0]
  ------------------
 1132|      0|                ret = temp;
 1133|      0|	    }
 1134|      0|	    ret[len++] = '/';
 1135|      0|	    ret[len++] = '/';
 1136|      0|	    if (uri->user != NULL) {
  ------------------
  |  Branch (1136:10): [True: 0, False: 0]
  ------------------
 1137|      0|		p = uri->user;
 1138|      0|		while (*p != 0) {
  ------------------
  |  Branch (1138:10): [True: 0, False: 0]
  ------------------
 1139|      0|		    if (len + 3 >= max) {
  ------------------
  |  Branch (1139:11): [True: 0, False: 0]
  ------------------
 1140|      0|                        temp = xmlSaveUriRealloc(ret, &max);
 1141|      0|                        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1141:29): [True: 0, False: 0]
  ------------------
 1142|      0|                        ret = temp;
 1143|      0|		    }
 1144|      0|		    if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1145|      0|			((*(p) == ';')) || ((*(p) == ':')) ||
  ------------------
  |  Branch (1145:4): [True: 0, False: 0]
  |  Branch (1145:23): [True: 0, False: 0]
  ------------------
 1146|      0|			((*(p) == '&')) || ((*(p) == '=')) ||
  ------------------
  |  Branch (1146:4): [True: 0, False: 0]
  |  Branch (1146:23): [True: 0, False: 0]
  ------------------
 1147|      0|			((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1147:4): [True: 0, False: 0]
  |  Branch (1147:23): [True: 0, False: 0]
  ------------------
 1148|      0|			((*(p) == ',')))
  ------------------
  |  Branch (1148:4): [True: 0, False: 0]
  ------------------
 1149|      0|			ret[len++] = *p++;
 1150|      0|		    else {
 1151|      0|			int val = *(unsigned char *)p++;
 1152|      0|			int hi = val / 0x10, lo = val % 0x10;
 1153|      0|			ret[len++] = '%';
 1154|      0|			ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1154:23): [True: 0, False: 0]
  ------------------
 1155|      0|			ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1155:23): [True: 0, False: 0]
  ------------------
 1156|      0|		    }
 1157|      0|		}
 1158|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1158:7): [True: 0, False: 0]
  ------------------
 1159|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1160|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1160:25): [True: 0, False: 0]
  ------------------
 1161|      0|                    ret = temp;
 1162|      0|		}
 1163|      0|		ret[len++] = '@';
 1164|      0|	    }
 1165|      0|	    if (uri->server != NULL) {
  ------------------
  |  Branch (1165:10): [True: 0, False: 0]
  ------------------
 1166|      0|		p = uri->server;
 1167|      0|		while (*p != 0) {
  ------------------
  |  Branch (1167:10): [True: 0, False: 0]
  ------------------
 1168|      0|		    if (len >= max) {
  ------------------
  |  Branch (1168:11): [True: 0, False: 0]
  ------------------
 1169|      0|			temp = xmlSaveUriRealloc(ret, &max);
 1170|      0|			if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1170:8): [True: 0, False: 0]
  ------------------
 1171|      0|			ret = temp;
 1172|      0|		    }
 1173|       |                    /* TODO: escaping? */
 1174|      0|		    ret[len++] = (xmlChar) *p++;
 1175|      0|		}
 1176|      0|	    }
 1177|      0|            if (uri->port > 0) {
  ------------------
  |  Branch (1177:17): [True: 0, False: 0]
  ------------------
 1178|      0|                if (len + 10 >= max) {
  ------------------
  |  Branch (1178:21): [True: 0, False: 0]
  ------------------
 1179|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1180|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1180:25): [True: 0, False: 0]
  ------------------
 1181|      0|                    ret = temp;
 1182|      0|                }
 1183|      0|                len += snprintf((char *) &ret[len], max - len, ":%d", uri->port);
 1184|      0|            }
 1185|    177|	} else if (uri->authority != NULL) {
  ------------------
  |  Branch (1185:13): [True: 0, False: 177]
  ------------------
 1186|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1186:10): [True: 0, False: 0]
  ------------------
 1187|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1188|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1188:21): [True: 0, False: 0]
  ------------------
 1189|      0|                ret = temp;
 1190|      0|	    }
 1191|      0|	    ret[len++] = '/';
 1192|      0|	    ret[len++] = '/';
 1193|      0|	    p = uri->authority;
 1194|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1194:13): [True: 0, False: 0]
  ------------------
 1195|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1195:7): [True: 0, False: 0]
  ------------------
 1196|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1197|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1197:25): [True: 0, False: 0]
  ------------------
 1198|      0|                    ret = temp;
 1199|      0|		}
 1200|      0|		if ((IS_UNRESERVED(*(p))) ||
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1201|      0|                    ((*(p) == '$')) || ((*(p) == ',')) || ((*(p) == ';')) ||
  ------------------
  |  Branch (1201:21): [True: 0, False: 0]
  |  Branch (1201:40): [True: 0, False: 0]
  |  Branch (1201:59): [True: 0, False: 0]
  ------------------
 1202|      0|                    ((*(p) == ':')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1202:21): [True: 0, False: 0]
  |  Branch (1202:40): [True: 0, False: 0]
  |  Branch (1202:59): [True: 0, False: 0]
  ------------------
 1203|      0|                    ((*(p) == '=')) || ((*(p) == '+')))
  ------------------
  |  Branch (1203:21): [True: 0, False: 0]
  |  Branch (1203:40): [True: 0, False: 0]
  ------------------
 1204|      0|		    ret[len++] = *p++;
 1205|      0|		else {
 1206|      0|		    int val = *(unsigned char *)p++;
 1207|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1208|      0|		    ret[len++] = '%';
 1209|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1209:26): [True: 0, False: 0]
  ------------------
 1210|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1210:26): [True: 0, False: 0]
  ------------------
 1211|      0|		}
 1212|      0|	    }
 1213|    177|	} else if (uri->scheme != NULL) {
  ------------------
  |  Branch (1213:13): [True: 0, False: 177]
  ------------------
 1214|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1214:10): [True: 0, False: 0]
  ------------------
 1215|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1216|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1216:21): [True: 0, False: 0]
  ------------------
 1217|      0|                ret = temp;
 1218|      0|	    }
 1219|      0|	}
 1220|    177|	if (uri->path != NULL) {
  ------------------
  |  Branch (1220:6): [True: 177, False: 0]
  ------------------
 1221|    177|	    p = uri->path;
 1222|       |	    /*
 1223|       |	     * the colon in file:///d: should not be escaped or
 1224|       |	     * Windows accesses fail later.
 1225|       |	     */
 1226|    177|	    if ((uri->scheme != NULL) &&
  ------------------
  |  Branch (1226:10): [True: 0, False: 177]
  ------------------
 1227|    177|		(p[0] == '/') &&
  ------------------
  |  Branch (1227:3): [True: 0, False: 0]
  ------------------
 1228|    177|		(((p[1] >= 'a') && (p[1] <= 'z')) ||
  ------------------
  |  Branch (1228:5): [True: 0, False: 0]
  |  Branch (1228:22): [True: 0, False: 0]
  ------------------
 1229|      0|		 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&
  ------------------
  |  Branch (1229:5): [True: 0, False: 0]
  |  Branch (1229:22): [True: 0, False: 0]
  ------------------
 1230|    177|		(p[2] == ':') &&
  ------------------
  |  Branch (1230:3): [True: 0, False: 0]
  ------------------
 1231|    177|	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
              	        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST "file"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1231:10): [True: 0, False: 0]
  ------------------
 1232|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1232:7): [True: 0, False: 0]
  ------------------
 1233|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1234|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1234:25): [True: 0, False: 0]
  ------------------
 1235|      0|                    ret = temp;
 1236|      0|		}
 1237|      0|		ret[len++] = *p++;
 1238|      0|		ret[len++] = *p++;
 1239|      0|		ret[len++] = *p++;
 1240|      0|	    }
 1241|  2.34k|	    while (*p != 0) {
  ------------------
  |  Branch (1241:13): [True: 2.17k, False: 177]
  ------------------
 1242|  2.17k|		if (len + 3 >= max) {
  ------------------
  |  Branch (1242:7): [True: 0, False: 2.17k]
  ------------------
 1243|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1244|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1244:25): [True: 0, False: 0]
  ------------------
 1245|      0|                    ret = temp;
 1246|      0|		}
 1247|  2.17k|		if ((IS_UNRESERVED(*(p))) || ((*(p) == '/')) ||
  ------------------
  |  |  125|  2.17k|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|  4.34k|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|  4.34k|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|  4.34k|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 1.65k, False: 516]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 1.65k, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|    516|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 39, False: 477]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 12, False: 27]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|    504|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 210, False: 294]
  |  |  |  |  |  |  |  Branch (87:38): [True: 183, False: 27]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|    321|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 24, False: 297]
  |  |  |  |  |  Branch (99:37): [True: 27, False: 270]
  |  |  |  |  |  Branch (99:53): [True: 171, False: 99]
  |  |  |  |  ------------------
  |  |  |  |  100|    321|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 99]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 99]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 99]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 99]
  |  |  |  |  ------------------
  |  |  |  |  101|    321|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 99]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 99]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1247:32): [True: 99, False: 0]
  ------------------
 1248|  2.17k|                    ((*(p) == ';')) || ((*(p) == '@')) || ((*(p) == '&')) ||
  ------------------
  |  Branch (1248:21): [True: 0, False: 0]
  |  Branch (1248:40): [True: 0, False: 0]
  |  Branch (1248:59): [True: 0, False: 0]
  ------------------
 1249|  2.17k|	            ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||
  ------------------
  |  Branch (1249:14): [True: 0, False: 0]
  |  Branch (1249:33): [True: 0, False: 0]
  |  Branch (1249:52): [True: 0, False: 0]
  ------------------
 1250|  2.17k|	            ((*(p) == ',')))
  ------------------
  |  Branch (1250:14): [True: 0, False: 0]
  ------------------
 1251|  2.17k|		    ret[len++] = *p++;
 1252|      0|		else {
 1253|      0|		    int val = *(unsigned char *)p++;
 1254|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1255|      0|		    ret[len++] = '%';
 1256|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1256:26): [True: 0, False: 0]
  ------------------
 1257|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1257:26): [True: 0, False: 0]
  ------------------
 1258|      0|		}
 1259|  2.17k|	    }
 1260|    177|	}
 1261|    177|	if (uri->query_raw != NULL) {
  ------------------
  |  Branch (1261:6): [True: 0, False: 177]
  ------------------
 1262|      0|	    if (len + 1 >= max) {
  ------------------
  |  Branch (1262:10): [True: 0, False: 0]
  ------------------
 1263|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1264|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1264:21): [True: 0, False: 0]
  ------------------
 1265|      0|                ret = temp;
 1266|      0|	    }
 1267|      0|	    ret[len++] = '?';
 1268|      0|	    p = uri->query_raw;
 1269|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1269:13): [True: 0, False: 0]
  ------------------
 1270|      0|		if (len + 1 >= max) {
  ------------------
  |  Branch (1270:7): [True: 0, False: 0]
  ------------------
 1271|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1272|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1272:25): [True: 0, False: 0]
  ------------------
 1273|      0|                    ret = temp;
 1274|      0|		}
 1275|      0|		ret[len++] = *p++;
 1276|      0|	    }
 1277|    177|	} else if (uri->query != NULL) {
  ------------------
  |  Branch (1277:13): [True: 0, False: 177]
  ------------------
 1278|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1278:10): [True: 0, False: 0]
  ------------------
 1279|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1280|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1280:21): [True: 0, False: 0]
  ------------------
 1281|      0|                ret = temp;
 1282|      0|	    }
 1283|      0|	    ret[len++] = '?';
 1284|      0|	    p = uri->query;
 1285|      0|	    while (*p != 0) {
  ------------------
  |  Branch (1285:13): [True: 0, False: 0]
  ------------------
 1286|      0|		if (len + 3 >= max) {
  ------------------
  |  Branch (1286:7): [True: 0, False: 0]
  ------------------
 1287|      0|                    temp = xmlSaveUriRealloc(ret, &max);
 1288|      0|                    if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1288:25): [True: 0, False: 0]
  ------------------
 1289|      0|                    ret = temp;
 1290|      0|		}
 1291|      0|		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              		if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1292|      0|		    ret[len++] = *p++;
 1293|      0|		else {
 1294|      0|		    int val = *(unsigned char *)p++;
 1295|      0|		    int hi = val / 0x10, lo = val % 0x10;
 1296|      0|		    ret[len++] = '%';
 1297|      0|		    ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1297:26): [True: 0, False: 0]
  ------------------
 1298|      0|		    ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1298:26): [True: 0, False: 0]
  ------------------
 1299|      0|		}
 1300|      0|	    }
 1301|      0|	}
 1302|    177|    }
 1303|    177|    if (uri->fragment != NULL) {
  ------------------
  |  Branch (1303:9): [True: 0, False: 177]
  ------------------
 1304|      0|	if (len + 3 >= max) {
  ------------------
  |  Branch (1304:6): [True: 0, False: 0]
  ------------------
 1305|      0|            temp = xmlSaveUriRealloc(ret, &max);
 1306|      0|            if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1306:17): [True: 0, False: 0]
  ------------------
 1307|      0|            ret = temp;
 1308|      0|	}
 1309|      0|	ret[len++] = '#';
 1310|      0|	p = uri->fragment;
 1311|      0|	while (*p != 0) {
  ------------------
  |  Branch (1311:9): [True: 0, False: 0]
  ------------------
 1312|      0|	    if (len + 3 >= max) {
  ------------------
  |  Branch (1312:10): [True: 0, False: 0]
  ------------------
 1313|      0|                temp = xmlSaveUriRealloc(ret, &max);
 1314|      0|                if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1314:21): [True: 0, False: 0]
  ------------------
 1315|      0|                ret = temp;
 1316|      0|	    }
 1317|      0|	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  125|      0|#define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   93|      0|#define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   63|      0|#define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   72|      0|#define IS_LOWALPHA(x) (((x) >= 'a') && ((x) <= 'z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (72:25): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (72:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |               #define IS_ALPHA(x) (IS_LOWALPHA(x) || IS_UPALPHA(x))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   79|      0|#define IS_UPALPHA(x) (((x) >= 'A') && ((x) <= 'Z'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (79:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (79:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |               #define IS_ALPHANUM(x) (IS_ALPHA(x) || IS_DIGIT(x))
  |  |  |  |  ------------------
  |  |  |  |  |  |   87|      0|#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (87:22): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (87:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_UNRESERVED(x) (IS_ALPHANUM(x) || IS_MARK(x))
  |  |  ------------------
  |  |  |  |   99|      0|#define IS_MARK(x) (((x) == '-') || ((x) == '_') || ((x) == '.') ||     \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (99:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (99:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  100|      0|    ((x) == '!') || ((x) == '~') || ((x) == '*') || ((x) == '\'') ||    \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (100:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:21): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:37): [True: 0, False: 0]
  |  |  |  |  |  Branch (100:53): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  101|      0|    ((x) == '(') || ((x) == ')'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (101:5): [True: 0, False: 0]
  |  |  |  |  |  Branch (101:21): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))
  ------------------
  |  |  116|      0|#define IS_RESERVED(x) (((x) == ';') || ((x) == '/') || ((x) == '?') || \
  |  |  ------------------
  |  |  |  Branch (116:25): [True: 0, False: 0]
  |  |  |  Branch (116:41): [True: 0, False: 0]
  |  |  |  Branch (116:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  117|      0|        ((x) == ':') || ((x) == '@') || ((x) == '&') || ((x) == '=') || \
  |  |  ------------------
  |  |  |  Branch (117:9): [True: 0, False: 0]
  |  |  |  Branch (117:25): [True: 0, False: 0]
  |  |  |  Branch (117:41): [True: 0, False: 0]
  |  |  |  Branch (117:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  118|      0|        ((x) == '+') || ((x) == '$') || ((x) == ',') || ((x) == '[') || \
  |  |  ------------------
  |  |  |  Branch (118:9): [True: 0, False: 0]
  |  |  |  Branch (118:25): [True: 0, False: 0]
  |  |  |  Branch (118:41): [True: 0, False: 0]
  |  |  |  Branch (118:57): [True: 0, False: 0]
  |  |  ------------------
  |  |  119|      0|        ((x) == ']'))
  |  |  ------------------
  |  |  |  Branch (119:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1318|      0|		ret[len++] = *p++;
 1319|      0|	    else {
 1320|      0|		int val = *(unsigned char *)p++;
 1321|      0|		int hi = val / 0x10, lo = val % 0x10;
 1322|      0|		ret[len++] = '%';
 1323|      0|		ret[len++] = hi + (hi > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1323:22): [True: 0, False: 0]
  ------------------
 1324|      0|		ret[len++] = lo + (lo > 9? 'A'-10 : '0');
  ------------------
  |  Branch (1324:22): [True: 0, False: 0]
  ------------------
 1325|      0|	    }
 1326|      0|	}
 1327|      0|    }
 1328|    177|    if (len >= max) {
  ------------------
  |  Branch (1328:9): [True: 0, False: 177]
  ------------------
 1329|      0|        temp = xmlSaveUriRealloc(ret, &max);
 1330|      0|        if (temp == NULL) goto mem_error;
  ------------------
  |  Branch (1330:13): [True: 0, False: 0]
  ------------------
 1331|      0|        ret = temp;
 1332|      0|    }
 1333|    177|    ret[len] = 0;
 1334|    177|    return(ret);
 1335|       |
 1336|      0|mem_error:
 1337|      0|    xmlFree(ret);
 1338|      0|    return(NULL);
 1339|    177|}
xmlFreeURI:
 1396|  11.9k|xmlFreeURI(xmlURIPtr uri) {
 1397|  11.9k|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 0, False: 11.9k]
  ------------------
 1398|       |
 1399|  11.9k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 537, False: 11.4k]
  ------------------
 1400|  11.9k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 489, False: 11.4k]
  ------------------
 1401|  11.9k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 0, False: 11.9k]
  ------------------
 1402|  11.9k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 11.9k, False: 12]
  ------------------
 1403|  11.9k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 15, False: 11.9k]
  ------------------
 1404|  11.9k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 11.9k]
  ------------------
 1405|  11.9k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 11.9k]
  ------------------
 1406|  11.9k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 0, False: 11.9k]
  ------------------
 1407|  11.9k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 0, False: 11.9k]
  ------------------
 1408|  11.9k|    xmlFree(uri);
 1409|  11.9k|}
xmlNormalizeURIPath:
 1429|     98|xmlNormalizeURIPath(char *path) {
 1430|     98|    char *cur, *out;
 1431|       |
 1432|     98|    if (path == NULL)
  ------------------
  |  Branch (1432:9): [True: 0, False: 98]
  ------------------
 1433|      0|	return(-1);
 1434|       |
 1435|       |    /* Skip all initial "/" chars.  We want to get to the beginning of the
 1436|       |     * first non-empty segment.
 1437|       |     */
 1438|     98|    cur = path;
 1439|     98|    while (cur[0] == '/')
  ------------------
  |  Branch (1439:12): [True: 0, False: 98]
  ------------------
 1440|      0|      ++cur;
 1441|     98|    if (cur[0] == '\0')
  ------------------
  |  Branch (1441:9): [True: 0, False: 98]
  ------------------
 1442|      0|      return(0);
 1443|       |
 1444|       |    /* Keep everything we've seen so far.  */
 1445|     98|    out = cur;
 1446|       |
 1447|       |    /*
 1448|       |     * Analyze each segment in sequence for cases (c) and (d).
 1449|       |     */
 1450|    152|    while (cur[0] != '\0') {
  ------------------
  |  Branch (1450:12): [True: 152, False: 0]
  ------------------
 1451|       |	/*
 1452|       |	 * c) All occurrences of "./", where "." is a complete path segment,
 1453|       |	 *    are removed from the buffer string.
 1454|       |	 */
 1455|    152|	if ((cur[0] == '.') && (cur[1] == '/')) {
  ------------------
  |  Branch (1455:6): [True: 0, False: 152]
  |  Branch (1455:25): [True: 0, False: 0]
  ------------------
 1456|      0|	    cur += 2;
 1457|       |	    /* '//' normalization should be done at this point too */
 1458|      0|	    while (cur[0] == '/')
  ------------------
  |  Branch (1458:13): [True: 0, False: 0]
  ------------------
 1459|      0|		cur++;
 1460|      0|	    continue;
 1461|      0|	}
 1462|       |
 1463|       |	/*
 1464|       |	 * d) If the buffer string ends with "." as a complete path segment,
 1465|       |	 *    that "." is removed.
 1466|       |	 */
 1467|    152|	if ((cur[0] == '.') && (cur[1] == '\0'))
  ------------------
  |  Branch (1467:6): [True: 0, False: 152]
  |  Branch (1467:25): [True: 0, False: 0]
  ------------------
 1468|      0|	    break;
 1469|       |
 1470|       |	/* Otherwise keep the segment.  */
 1471|  1.33k|	while (cur[0] != '/') {
  ------------------
  |  Branch (1471:9): [True: 1.28k, False: 54]
  ------------------
 1472|  1.28k|            if (cur[0] == '\0')
  ------------------
  |  Branch (1472:17): [True: 98, False: 1.18k]
  ------------------
 1473|     98|              goto done_cd;
 1474|  1.18k|	    (out++)[0] = (cur++)[0];
 1475|  1.18k|	}
 1476|       |	/* normalize // */
 1477|     54|	while ((cur[0] == '/') && (cur[1] == '/'))
  ------------------
  |  Branch (1477:9): [True: 54, False: 0]
  |  Branch (1477:28): [True: 0, False: 54]
  ------------------
 1478|      0|	    cur++;
 1479|       |
 1480|     54|        (out++)[0] = (cur++)[0];
 1481|     54|    }
 1482|     98| done_cd:
 1483|     98|    out[0] = '\0';
 1484|       |
 1485|       |    /* Reset to the beginning of the first segment for the next sequence.  */
 1486|     98|    cur = path;
 1487|     98|    while (cur[0] == '/')
  ------------------
  |  Branch (1487:12): [True: 0, False: 98]
  ------------------
 1488|      0|      ++cur;
 1489|     98|    if (cur[0] == '\0')
  ------------------
  |  Branch (1489:9): [True: 0, False: 98]
  ------------------
 1490|      0|	return(0);
 1491|       |
 1492|       |    /*
 1493|       |     * Analyze each segment in sequence for cases (e) and (f).
 1494|       |     *
 1495|       |     * e) All occurrences of "<segment>/../", where <segment> is a
 1496|       |     *    complete path segment not equal to "..", are removed from the
 1497|       |     *    buffer string.  Removal of these path segments is performed
 1498|       |     *    iteratively, removing the leftmost matching pattern on each
 1499|       |     *    iteration, until no matching pattern remains.
 1500|       |     *
 1501|       |     * f) If the buffer string ends with "<segment>/..", where <segment>
 1502|       |     *    is a complete path segment not equal to "..", that
 1503|       |     *    "<segment>/.." is removed.
 1504|       |     *
 1505|       |     * To satisfy the "iterative" clause in (e), we need to collapse the
 1506|       |     * string every time we find something that needs to be removed.  Thus,
 1507|       |     * we don't need to keep two pointers into the string: we only need a
 1508|       |     * "current position" pointer.
 1509|       |     */
 1510|    152|    while (1) {
  ------------------
  |  Branch (1510:12): [Folded - Ignored]
  ------------------
 1511|    152|        char *segp, *tmp;
 1512|       |
 1513|       |        /* At the beginning of each iteration of this loop, "cur" points to
 1514|       |         * the first character of the segment we want to examine.
 1515|       |         */
 1516|       |
 1517|       |        /* Find the end of the current segment.  */
 1518|    152|        segp = cur;
 1519|  1.33k|        while ((segp[0] != '/') && (segp[0] != '\0'))
  ------------------
  |  Branch (1519:16): [True: 1.28k, False: 54]
  |  Branch (1519:36): [True: 1.18k, False: 98]
  ------------------
 1520|  1.18k|          ++segp;
 1521|       |
 1522|       |        /* If this is the last segment, we're done (we need at least two
 1523|       |         * segments to meet the criteria for the (e) and (f) cases).
 1524|       |         */
 1525|    152|        if (segp[0] == '\0')
  ------------------
  |  Branch (1525:13): [True: 98, False: 54]
  ------------------
 1526|     98|          break;
 1527|       |
 1528|       |        /* If the first segment is "..", or if the next segment _isn't_ "..",
 1529|       |         * keep this segment and try the next one.
 1530|       |         */
 1531|     54|        ++segp;
 1532|     54|        if (((cur[0] == '.') && (cur[1] == '.') && (segp == cur+3))
  ------------------
  |  Branch (1532:14): [True: 0, False: 54]
  |  Branch (1532:33): [True: 0, False: 0]
  |  Branch (1532:52): [True: 0, False: 0]
  ------------------
 1533|     54|            || ((segp[0] != '.') || (segp[1] != '.')
  ------------------
  |  Branch (1533:17): [True: 54, False: 0]
  |  Branch (1533:37): [True: 0, False: 0]
  ------------------
 1534|     54|                || ((segp[2] != '/') && (segp[2] != '\0')))) {
  ------------------
  |  Branch (1534:21): [True: 0, False: 0]
  |  Branch (1534:41): [True: 0, False: 0]
  ------------------
 1535|     54|          cur = segp;
 1536|     54|          continue;
 1537|     54|        }
 1538|       |
 1539|       |        /* If we get here, remove this segment and the next one and back up
 1540|       |         * to the previous segment (if there is one), to implement the
 1541|       |         * "iteratively" clause.  It's pretty much impossible to back up
 1542|       |         * while maintaining two pointers into the buffer, so just compact
 1543|       |         * the whole buffer now.
 1544|       |         */
 1545|       |
 1546|       |        /* If this is the end of the buffer, we're done.  */
 1547|      0|        if (segp[2] == '\0') {
  ------------------
  |  Branch (1547:13): [True: 0, False: 0]
  ------------------
 1548|      0|          cur[0] = '\0';
 1549|      0|          break;
 1550|      0|        }
 1551|       |        /* Valgrind complained, strcpy(cur, segp + 3); */
 1552|       |        /* string will overlap, do not use strcpy */
 1553|      0|        tmp = cur;
 1554|      0|        segp += 3;
 1555|      0|        while ((*tmp++ = *segp++) != 0)
  ------------------
  |  Branch (1555:16): [True: 0, False: 0]
  ------------------
 1556|      0|          ;
 1557|       |
 1558|       |        /* If there are no previous segments, then keep going from here.  */
 1559|      0|        segp = cur;
 1560|      0|        while ((segp > path) && ((--segp)[0] == '/'))
  ------------------
  |  Branch (1560:16): [True: 0, False: 0]
  |  Branch (1560:33): [True: 0, False: 0]
  ------------------
 1561|      0|          ;
 1562|      0|        if (segp == path)
  ------------------
  |  Branch (1562:13): [True: 0, False: 0]
  ------------------
 1563|      0|          continue;
 1564|       |
 1565|       |        /* "segp" is pointing to the end of a previous segment; find it's
 1566|       |         * start.  We need to back up to the previous segment and start
 1567|       |         * over with that to handle things like "foo/bar/../..".  If we
 1568|       |         * don't do this, then on the first pass we'll remove the "bar/..",
 1569|       |         * but be pointing at the second ".." so we won't realize we can also
 1570|       |         * remove the "foo/..".
 1571|       |         */
 1572|      0|        cur = segp;
 1573|      0|        while ((cur > path) && (cur[-1] != '/'))
  ------------------
  |  Branch (1573:16): [True: 0, False: 0]
  |  Branch (1573:32): [True: 0, False: 0]
  ------------------
 1574|      0|          --cur;
 1575|      0|    }
 1576|     98|    out[0] = '\0';
 1577|       |
 1578|       |    /*
 1579|       |     * g) If the resulting buffer string still begins with one or more
 1580|       |     *    complete path segments of "..", then the reference is
 1581|       |     *    considered to be in error. Implementations may handle this
 1582|       |     *    error by retaining these components in the resolved path (i.e.,
 1583|       |     *    treating them as part of the final URI), by removing them from
 1584|       |     *    the resolved path (i.e., discarding relative levels above the
 1585|       |     *    root), or by avoiding traversal of the reference.
 1586|       |     *
 1587|       |     * We discard them from the final path.
 1588|       |     */
 1589|     98|    if (path[0] == '/') {
  ------------------
  |  Branch (1589:9): [True: 0, False: 98]
  ------------------
 1590|      0|      cur = path;
 1591|      0|      while ((cur[0] == '/') && (cur[1] == '.') && (cur[2] == '.')
  ------------------
  |  Branch (1591:14): [True: 0, False: 0]
  |  Branch (1591:33): [True: 0, False: 0]
  |  Branch (1591:52): [True: 0, False: 0]
  ------------------
 1592|      0|             && ((cur[3] == '/') || (cur[3] == '\0')))
  ------------------
  |  Branch (1592:18): [True: 0, False: 0]
  |  Branch (1592:37): [True: 0, False: 0]
  ------------------
 1593|      0|	cur += 3;
 1594|       |
 1595|      0|      if (cur != path) {
  ------------------
  |  Branch (1595:11): [True: 0, False: 0]
  ------------------
 1596|      0|	out = path;
 1597|      0|	while (cur[0] != '\0')
  ------------------
  |  Branch (1597:9): [True: 0, False: 0]
  ------------------
 1598|      0|          (out++)[0] = (cur++)[0];
 1599|      0|	out[0] = 0;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|     98|    return(0);
 1604|     98|}
xmlURIUnescapeString:
 1629|  12.3k|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|  12.3k|    char *ret, *out;
 1631|  12.3k|    const char *in;
 1632|       |
 1633|  12.3k|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 0, False: 12.3k]
  ------------------
 1634|      0|	return(NULL);
 1635|  12.3k|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 12, False: 12.3k]
  ------------------
 1636|  12.3k|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 12.3k]
  ------------------
 1637|       |
 1638|  12.3k|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 12.3k, False: 0]
  ------------------
 1639|  12.3k|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|  12.3k|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 0, False: 12.3k]
  ------------------
 1641|      0|            xmlURIErrMemory("unescaping URI value\n");
 1642|      0|	    return(NULL);
 1643|      0|	}
 1644|  12.3k|    } else
 1645|      0|	ret = target;
 1646|  12.3k|    in = str;
 1647|  12.3k|    out = ret;
 1648|   105k|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 93.5k, False: 12.3k]
  ------------------
 1649|  93.5k|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 68.9k, False: 24.6k]
  |  Branch (1649:19): [True: 0, False: 68.9k]
  |  Branch (1649:35): [True: 0, False: 0]
  |  Branch (1649:54): [True: 0, False: 0]
  ------------------
 1650|      0|            int c = 0;
 1651|      0|	    in++;
 1652|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 0, False: 0]
  |  Branch (1652:26): [True: 0, False: 0]
  ------------------
 1653|      0|	        c = (*in - '0');
 1654|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 0]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 0, False: 0]
  |  Branch (1656:31): [True: 0, False: 0]
  ------------------
 1657|      0|	        c = (*in - 'A') + 10;
 1658|      0|	    in++;
 1659|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 0, False: 0]
  |  Branch (1659:26): [True: 0, False: 0]
  ------------------
 1660|      0|	        c = c * 16 + (*in - '0');
 1661|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 0]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 0, False: 0]
  |  Branch (1663:31): [True: 0, False: 0]
  ------------------
 1664|      0|	        c = c * 16 + (*in - 'A') + 10;
 1665|      0|	    in++;
 1666|      0|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|      0|	    *out++ = (char) c;
 1669|  93.5k|	} else {
 1670|  93.5k|	    *out++ = *in++;
 1671|  93.5k|	    len--;
 1672|  93.5k|	}
 1673|  93.5k|    }
 1674|  12.3k|    *out = 0;
 1675|  12.3k|    return(ret);
 1676|  12.3k|}
xmlBuildURI:
 1902|    294|xmlBuildURI(const xmlChar *URI, const xmlChar *base) {
 1903|    294|    xmlChar *val = NULL;
 1904|    294|    int ret, len, indx, cur, out;
 1905|    294|    xmlURIPtr ref = NULL;
 1906|    294|    xmlURIPtr bas = NULL;
 1907|    294|    xmlURIPtr res = NULL;
 1908|       |
 1909|       |    /*
 1910|       |     * 1) The URI reference is parsed into the potential four components and
 1911|       |     *    fragment identifier, as described in Section 4.3.
 1912|       |     *
 1913|       |     *    NOTE that a completely empty URI is treated by modern browsers
 1914|       |     *    as a reference to "." rather than as a synonym for the current
 1915|       |     *    URI.  Should we do that here?
 1916|       |     */
 1917|    294|    if (URI == NULL)
  ------------------
  |  Branch (1917:9): [True: 0, False: 294]
  ------------------
 1918|      0|	ret = -1;
 1919|    294|    else {
 1920|    294|	if (*URI) {
  ------------------
  |  Branch (1920:6): [True: 294, False: 0]
  ------------------
 1921|    294|	    ref = xmlCreateURI();
 1922|    294|	    if (ref == NULL)
  ------------------
  |  Branch (1922:10): [True: 0, False: 294]
  ------------------
 1923|      0|		goto done;
 1924|    294|	    ret = xmlParseURIReference(ref, (const char *) URI);
 1925|    294|	}
 1926|      0|	else
 1927|      0|	    ret = 0;
 1928|    294|    }
 1929|    294|    if (ret != 0)
  ------------------
  |  Branch (1929:9): [True: 0, False: 294]
  ------------------
 1930|      0|	goto done;
 1931|    294|    if ((ref != NULL) && (ref->scheme != NULL)) {
  ------------------
  |  Branch (1931:9): [True: 294, False: 0]
  |  Branch (1931:26): [True: 117, False: 177]
  ------------------
 1932|       |	/*
 1933|       |	 * The URI is absolute don't modify.
 1934|       |	 */
 1935|    117|	val = xmlStrdup(URI);
 1936|    117|	goto done;
 1937|    117|    }
 1938|    177|    if (base == NULL)
  ------------------
  |  Branch (1938:9): [True: 77, False: 100]
  ------------------
 1939|     77|	ret = -1;
 1940|    100|    else {
 1941|    100|	bas = xmlCreateURI();
 1942|    100|	if (bas == NULL)
  ------------------
  |  Branch (1942:6): [True: 0, False: 100]
  ------------------
 1943|      0|	    goto done;
 1944|    100|	ret = xmlParseURIReference(bas, (const char *) base);
 1945|    100|    }
 1946|    177|    if (ret != 0) {
  ------------------
  |  Branch (1946:9): [True: 77, False: 100]
  ------------------
 1947|     77|	if (ref)
  ------------------
  |  Branch (1947:6): [True: 77, False: 0]
  ------------------
 1948|     77|	    val = xmlSaveUri(ref);
 1949|     77|	goto done;
 1950|     77|    }
 1951|    100|    if (ref == NULL) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 100]
  ------------------
 1952|       |	/*
 1953|       |	 * the base fragment must be ignored
 1954|       |	 */
 1955|      0|	if (bas->fragment != NULL) {
  ------------------
  |  Branch (1955:6): [True: 0, False: 0]
  ------------------
 1956|      0|	    xmlFree(bas->fragment);
 1957|      0|	    bas->fragment = NULL;
 1958|      0|	}
 1959|      0|	val = xmlSaveUri(bas);
 1960|      0|	goto done;
 1961|      0|    }
 1962|       |
 1963|       |    /*
 1964|       |     * 2) If the path component is empty and the scheme, authority, and
 1965|       |     *    query components are undefined, then it is a reference to the
 1966|       |     *    current document and we are done.  Otherwise, the reference URI's
 1967|       |     *    query and fragment components are defined as found (or not found)
 1968|       |     *    within the URI reference and not inherited from the base URI.
 1969|       |     *
 1970|       |     *    NOTE that in modern browsers, the parsing differs from the above
 1971|       |     *    in the following aspect:  the query component is allowed to be
 1972|       |     *    defined while still treating this as a reference to the current
 1973|       |     *    document.
 1974|       |     */
 1975|    100|    res = xmlCreateURI();
 1976|    100|    if (res == NULL)
  ------------------
  |  Branch (1976:9): [True: 0, False: 100]
  ------------------
 1977|      0|	goto done;
 1978|    100|    if ((ref->scheme == NULL) && (ref->path == NULL) &&
  ------------------
  |  Branch (1978:9): [True: 100, False: 0]
  |  Branch (1978:34): [True: 0, False: 100]
  ------------------
 1979|    100|	((ref->authority == NULL) && (ref->server == NULL) &&
  ------------------
  |  Branch (1979:3): [True: 0, False: 0]
  |  Branch (1979:31): [True: 0, False: 0]
  ------------------
 1980|      0|         (ref->port == PORT_EMPTY))) {
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (1980:10): [True: 0, False: 0]
  ------------------
 1981|      0|	if (bas->scheme != NULL)
  ------------------
  |  Branch (1981:6): [True: 0, False: 0]
  ------------------
 1982|      0|	    res->scheme = xmlMemStrdup(bas->scheme);
 1983|      0|	if (bas->authority != NULL)
  ------------------
  |  Branch (1983:6): [True: 0, False: 0]
  ------------------
 1984|      0|	    res->authority = xmlMemStrdup(bas->authority);
 1985|      0|	else {
 1986|      0|	    if (bas->server != NULL)
  ------------------
  |  Branch (1986:10): [True: 0, False: 0]
  ------------------
 1987|      0|		res->server = xmlMemStrdup(bas->server);
 1988|      0|	    if (bas->user != NULL)
  ------------------
  |  Branch (1988:10): [True: 0, False: 0]
  ------------------
 1989|      0|		res->user = xmlMemStrdup(bas->user);
 1990|      0|	    res->port = bas->port;
 1991|      0|	}
 1992|      0|	if (bas->path != NULL)
  ------------------
  |  Branch (1992:6): [True: 0, False: 0]
  ------------------
 1993|      0|	    res->path = xmlMemStrdup(bas->path);
 1994|      0|	if (ref->query_raw != NULL)
  ------------------
  |  Branch (1994:6): [True: 0, False: 0]
  ------------------
 1995|      0|	    res->query_raw = xmlMemStrdup (ref->query_raw);
 1996|      0|	else if (ref->query != NULL)
  ------------------
  |  Branch (1996:11): [True: 0, False: 0]
  ------------------
 1997|      0|	    res->query = xmlMemStrdup(ref->query);
 1998|      0|	else if (bas->query_raw != NULL)
  ------------------
  |  Branch (1998:11): [True: 0, False: 0]
  ------------------
 1999|      0|	    res->query_raw = xmlMemStrdup(bas->query_raw);
 2000|      0|	else if (bas->query != NULL)
  ------------------
  |  Branch (2000:11): [True: 0, False: 0]
  ------------------
 2001|      0|	    res->query = xmlMemStrdup(bas->query);
 2002|      0|	if (ref->fragment != NULL)
  ------------------
  |  Branch (2002:6): [True: 0, False: 0]
  ------------------
 2003|      0|	    res->fragment = xmlMemStrdup(ref->fragment);
 2004|      0|	goto step_7;
 2005|      0|    }
 2006|       |
 2007|       |    /*
 2008|       |     * 3) If the scheme component is defined, indicating that the reference
 2009|       |     *    starts with a scheme name, then the reference is interpreted as an
 2010|       |     *    absolute URI and we are done.  Otherwise, the reference URI's
 2011|       |     *    scheme is inherited from the base URI's scheme component.
 2012|       |     */
 2013|    100|    if (ref->scheme != NULL) {
  ------------------
  |  Branch (2013:9): [True: 0, False: 100]
  ------------------
 2014|      0|	val = xmlSaveUri(ref);
 2015|      0|	goto done;
 2016|      0|    }
 2017|    100|    if (bas->scheme != NULL)
  ------------------
  |  Branch (2017:9): [True: 0, False: 100]
  ------------------
 2018|      0|	res->scheme = xmlMemStrdup(bas->scheme);
 2019|       |
 2020|    100|    if (ref->query_raw != NULL)
  ------------------
  |  Branch (2020:9): [True: 0, False: 100]
  ------------------
 2021|      0|	res->query_raw = xmlMemStrdup(ref->query_raw);
 2022|    100|    else if (ref->query != NULL)
  ------------------
  |  Branch (2022:14): [True: 0, False: 100]
  ------------------
 2023|      0|	res->query = xmlMemStrdup(ref->query);
 2024|    100|    if (ref->fragment != NULL)
  ------------------
  |  Branch (2024:9): [True: 0, False: 100]
  ------------------
 2025|      0|	res->fragment = xmlMemStrdup(ref->fragment);
 2026|       |
 2027|       |    /*
 2028|       |     * 4) If the authority component is defined, then the reference is a
 2029|       |     *    network-path and we skip to step 7.  Otherwise, the reference
 2030|       |     *    URI's authority is inherited from the base URI's authority
 2031|       |     *    component, which will also be undefined if the URI scheme does not
 2032|       |     *    use an authority component.
 2033|       |     */
 2034|    100|    if ((ref->authority != NULL) || (ref->server != NULL) ||
  ------------------
  |  Branch (2034:9): [True: 0, False: 100]
  |  Branch (2034:37): [True: 0, False: 100]
  ------------------
 2035|    100|         (ref->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    100|#define PORT_EMPTY           0
  ------------------
  |  Branch (2035:10): [True: 0, False: 100]
  ------------------
 2036|      0|	if (ref->authority != NULL)
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|      0|	    res->authority = xmlMemStrdup(ref->authority);
 2038|      0|	else {
 2039|      0|            if (ref->server != NULL)
  ------------------
  |  Branch (2039:17): [True: 0, False: 0]
  ------------------
 2040|      0|                res->server = xmlMemStrdup(ref->server);
 2041|      0|	    if (ref->user != NULL)
  ------------------
  |  Branch (2041:10): [True: 0, False: 0]
  ------------------
 2042|      0|		res->user = xmlMemStrdup(ref->user);
 2043|      0|            res->port = ref->port;
 2044|      0|	}
 2045|      0|	if (ref->path != NULL)
  ------------------
  |  Branch (2045:6): [True: 0, False: 0]
  ------------------
 2046|      0|	    res->path = xmlMemStrdup(ref->path);
 2047|      0|	goto step_7;
 2048|      0|    }
 2049|    100|    if (bas->authority != NULL)
  ------------------
  |  Branch (2049:9): [True: 0, False: 100]
  ------------------
 2050|      0|	res->authority = xmlMemStrdup(bas->authority);
 2051|    100|    else if ((bas->server != NULL) || (bas->port != PORT_EMPTY)) {
  ------------------
  |  |   37|    100|#define PORT_EMPTY           0
  ------------------
  |  Branch (2051:14): [True: 0, False: 100]
  |  Branch (2051:39): [True: 0, False: 100]
  ------------------
 2052|      0|	if (bas->server != NULL)
  ------------------
  |  Branch (2052:6): [True: 0, False: 0]
  ------------------
 2053|      0|	    res->server = xmlMemStrdup(bas->server);
 2054|      0|	if (bas->user != NULL)
  ------------------
  |  Branch (2054:6): [True: 0, False: 0]
  ------------------
 2055|      0|	    res->user = xmlMemStrdup(bas->user);
 2056|      0|	res->port = bas->port;
 2057|      0|    }
 2058|       |
 2059|       |    /*
 2060|       |     * 5) If the path component begins with a slash character ("/"), then
 2061|       |     *    the reference is an absolute-path and we skip to step 7.
 2062|       |     */
 2063|    100|    if ((ref->path != NULL) && (ref->path[0] == '/')) {
  ------------------
  |  Branch (2063:9): [True: 100, False: 0]
  |  Branch (2063:32): [True: 2, False: 98]
  ------------------
 2064|      2|	res->path = xmlMemStrdup(ref->path);
 2065|      2|	goto step_7;
 2066|      2|    }
 2067|       |
 2068|       |
 2069|       |    /*
 2070|       |     * 6) If this step is reached, then we are resolving a relative-path
 2071|       |     *    reference.  The relative path needs to be merged with the base
 2072|       |     *    URI's path.  Although there are many ways to do this, we will
 2073|       |     *    describe a simple method using a separate string buffer.
 2074|       |     *
 2075|       |     * Allocate a buffer large enough for the result string.
 2076|       |     */
 2077|     98|    len = 2; /* extra / and 0 */
 2078|     98|    if (ref->path != NULL)
  ------------------
  |  Branch (2078:9): [True: 98, False: 0]
  ------------------
 2079|     98|	len += strlen(ref->path);
 2080|     98|    if (bas->path != NULL)
  ------------------
  |  Branch (2080:9): [True: 98, False: 0]
  ------------------
 2081|     98|	len += strlen(bas->path);
 2082|     98|    res->path = (char *) xmlMallocAtomic(len);
 2083|     98|    if (res->path == NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 98]
  ------------------
 2084|      0|        xmlURIErrMemory("resolving URI against base\n");
 2085|      0|	goto done;
 2086|      0|    }
 2087|     98|    res->path[0] = 0;
 2088|       |
 2089|       |    /*
 2090|       |     * a) All but the last segment of the base URI's path component is
 2091|       |     *    copied to the buffer.  In other words, any characters after the
 2092|       |     *    last (right-most) slash character, if any, are excluded.
 2093|       |     */
 2094|     98|    cur = 0;
 2095|     98|    out = 0;
 2096|     98|    if (bas->path != NULL) {
  ------------------
  |  Branch (2096:9): [True: 98, False: 0]
  ------------------
 2097|    104|	while (bas->path[cur] != 0) {
  ------------------
  |  Branch (2097:9): [True: 104, False: 0]
  ------------------
 2098|  1.18k|	    while ((bas->path[cur] != 0) && (bas->path[cur] != '/'))
  ------------------
  |  Branch (2098:13): [True: 1.08k, False: 98]
  |  Branch (2098:38): [True: 1.08k, False: 6]
  ------------------
 2099|  1.08k|		cur++;
 2100|    104|	    if (bas->path[cur] == 0)
  ------------------
  |  Branch (2100:10): [True: 98, False: 6]
  ------------------
 2101|     98|		break;
 2102|       |
 2103|      6|	    cur++;
 2104|     36|	    while (out < cur) {
  ------------------
  |  Branch (2104:13): [True: 30, False: 6]
  ------------------
 2105|     30|		res->path[out] = bas->path[out];
 2106|     30|		out++;
 2107|     30|	    }
 2108|      6|	}
 2109|     98|    }
 2110|     98|    res->path[out] = 0;
 2111|       |
 2112|       |    /*
 2113|       |     * b) The reference's path component is appended to the buffer
 2114|       |     *    string.
 2115|       |     */
 2116|     98|    if (ref->path != NULL && ref->path[0] != 0) {
  ------------------
  |  Branch (2116:9): [True: 98, False: 0]
  |  Branch (2116:30): [True: 98, False: 0]
  ------------------
 2117|     98|	indx = 0;
 2118|       |	/*
 2119|       |	 * Ensure the path includes a '/'
 2120|       |	 */
 2121|     98|	if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))
  ------------------
  |  |   37|     92|#define PORT_EMPTY           0
  ------------------
  |  Branch (2121:6): [True: 92, False: 6]
  |  Branch (2121:21): [True: 0, False: 92]
  |  Branch (2121:46): [True: 0, False: 92]
  ------------------
 2122|      0|	    res->path[out++] = '/';
 2123|  1.30k|	while (ref->path[indx] != 0) {
  ------------------
  |  Branch (2123:9): [True: 1.21k, False: 98]
  ------------------
 2124|  1.21k|	    res->path[out++] = ref->path[indx++];
 2125|  1.21k|	}
 2126|     98|    }
 2127|     98|    res->path[out] = 0;
 2128|       |
 2129|       |    /*
 2130|       |     * Steps c) to h) are really path normalization steps
 2131|       |     */
 2132|     98|    xmlNormalizeURIPath(res->path);
 2133|       |
 2134|    100|step_7:
 2135|       |
 2136|       |    /*
 2137|       |     * 7) The resulting URI components, including any inherited from the
 2138|       |     *    base URI, are recombined to give the absolute form of the URI
 2139|       |     *    reference.
 2140|       |     */
 2141|    100|    val = xmlSaveUri(res);
 2142|       |
 2143|    294|done:
 2144|    294|    if (ref != NULL)
  ------------------
  |  Branch (2144:9): [True: 294, False: 0]
  ------------------
 2145|    294|	xmlFreeURI(ref);
 2146|    294|    if (bas != NULL)
  ------------------
  |  Branch (2146:9): [True: 100, False: 194]
  ------------------
 2147|    100|	xmlFreeURI(bas);
 2148|    294|    if (res != NULL)
  ------------------
  |  Branch (2148:9): [True: 100, False: 194]
  ------------------
 2149|    100|	xmlFreeURI(res);
 2150|    294|    return(val);
 2151|    100|}
xmlCanonicPath:
 2395|  10.4k|{
 2396|       |/*
 2397|       | * For Windows implementations, additional work needs to be done to
 2398|       | * replace backslashes in pathnames with "forward slashes"
 2399|       | */
 2400|       |#if defined(_WIN32)
 2401|       |    int len = 0;
 2402|       |    char *p = NULL;
 2403|       |#endif
 2404|  10.4k|    xmlURIPtr uri;
 2405|  10.4k|    xmlChar *ret;
 2406|  10.4k|    const xmlChar *absuri;
 2407|       |
 2408|  10.4k|    if (path == NULL)
  ------------------
  |  Branch (2408:9): [True: 0, False: 10.4k]
  ------------------
 2409|      0|	return(NULL);
 2410|       |
 2411|       |#if defined(_WIN32)
 2412|       |    /*
 2413|       |     * We must not change the backslashes to slashes if the the path
 2414|       |     * starts with \\?\
 2415|       |     * Those paths can be up to 32k characters long.
 2416|       |     * Was added specifically for OpenOffice, those paths can't be converted
 2417|       |     * to URIs anyway.
 2418|       |     */
 2419|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
 2420|       |        (path[3] == '\\') )
 2421|       |	return xmlStrdup((const xmlChar *) path);
 2422|       |#endif
 2423|       |
 2424|       |	/* sanitize filename starting with // so it can be used as URI */
 2425|  10.4k|    if ((path[0] == '/') && (path[1] == '/') && (path[2] != '/'))
  ------------------
  |  Branch (2425:9): [True: 3, False: 10.4k]
  |  Branch (2425:29): [True: 0, False: 3]
  |  Branch (2425:49): [True: 0, False: 0]
  ------------------
 2426|      0|        path++;
 2427|       |
 2428|  10.4k|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2428:9): [True: 10.4k, False: 0]
  ------------------
 2429|  10.4k|	xmlFreeURI(uri);
 2430|  10.4k|	return xmlStrdup(path);
 2431|  10.4k|    }
 2432|       |
 2433|       |    /* Check if this is an "absolute uri" */
 2434|      0|    absuri = xmlStrstr(path, BAD_CAST "://");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2435|      0|    if (absuri != NULL) {
  ------------------
  |  Branch (2435:9): [True: 0, False: 0]
  ------------------
 2436|      0|        int l, j;
 2437|      0|	unsigned char c;
 2438|      0|	xmlChar *escURI;
 2439|       |
 2440|       |        /*
 2441|       |	 * this looks like an URI where some parts have not been
 2442|       |	 * escaped leading to a parsing problem.  Check that the first
 2443|       |	 * part matches a protocol.
 2444|       |	 */
 2445|      0|	l = absuri - path;
 2446|       |	/* Bypass if first part (part before the '://') is > 20 chars */
 2447|      0|	if ((l <= 0) || (l > 20))
  ------------------
  |  Branch (2447:6): [True: 0, False: 0]
  |  Branch (2447:18): [True: 0, False: 0]
  ------------------
 2448|      0|	    goto path_processing;
 2449|       |	/* Bypass if any non-alpha characters are present in first part */
 2450|      0|	for (j = 0;j < l;j++) {
  ------------------
  |  Branch (2450:13): [True: 0, False: 0]
  ------------------
 2451|      0|	    c = path[j];
 2452|      0|	    if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))
  ------------------
  |  Branch (2452:13): [True: 0, False: 0]
  |  Branch (2452:27): [True: 0, False: 0]
  |  Branch (2452:43): [True: 0, False: 0]
  |  Branch (2452:57): [True: 0, False: 0]
  ------------------
 2453|      0|	        goto path_processing;
 2454|      0|	}
 2455|       |
 2456|       |	/* Escape all except the characters specified in the supplied path */
 2457|      0|        escURI = xmlURIEscapeStr(path, BAD_CAST ":/?_.#&;=");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2458|      0|	if (escURI != NULL) {
  ------------------
  |  Branch (2458:6): [True: 0, False: 0]
  ------------------
 2459|       |	    /* Try parsing the escaped path */
 2460|      0|	    uri = xmlParseURI((const char *) escURI);
 2461|       |	    /* If successful, return the escaped string */
 2462|      0|	    if (uri != NULL) {
  ------------------
  |  Branch (2462:10): [True: 0, False: 0]
  ------------------
 2463|      0|	        xmlFreeURI(uri);
 2464|      0|		return escURI;
 2465|      0|	    }
 2466|      0|            xmlFree(escURI);
 2467|      0|	}
 2468|      0|    }
 2469|       |
 2470|      0|path_processing:
 2471|       |/* For Windows implementations, replace backslashes with 'forward slashes' */
 2472|       |#if defined(_WIN32)
 2473|       |    /*
 2474|       |     * Create a URI structure
 2475|       |     */
 2476|       |    uri = xmlCreateURI();
 2477|       |    if (uri == NULL) {		/* Guard against 'out of memory' */
 2478|       |        return(NULL);
 2479|       |    }
 2480|       |
 2481|       |    len = xmlStrlen(path);
 2482|       |    if ((len > 2) && IS_WINDOWS_PATH(path)) {
 2483|       |        /* make the scheme 'file' */
 2484|       |	uri->scheme = (char *) xmlStrdup(BAD_CAST "file");
 2485|       |	/* allocate space for leading '/' + path + string terminator */
 2486|       |	uri->path = xmlMallocAtomic(len + 2);
 2487|       |	if (uri->path == NULL) {
 2488|       |	    xmlFreeURI(uri);	/* Guard against 'out of memory' */
 2489|       |	    return(NULL);
 2490|       |	}
 2491|       |	/* Put in leading '/' plus path */
 2492|       |	uri->path[0] = '/';
 2493|       |	p = uri->path + 1;
 2494|       |	strncpy(p, (char *) path, len + 1);
 2495|       |    } else {
 2496|       |	uri->path = (char *) xmlStrdup(path);
 2497|       |	if (uri->path == NULL) {
 2498|       |	    xmlFreeURI(uri);
 2499|       |	    return(NULL);
 2500|       |	}
 2501|       |	p = uri->path;
 2502|       |    }
 2503|       |    /* Now change all occurrences of '\' to '/' */
 2504|       |    while (*p != '\0') {
 2505|       |	if (*p == '\\')
 2506|       |	    *p = '/';
 2507|       |	p++;
 2508|       |    }
 2509|       |
 2510|       |    if (uri->scheme == NULL) {
 2511|       |	ret = xmlStrdup((const xmlChar *) uri->path);
 2512|       |    } else {
 2513|       |	ret = xmlSaveUri(uri);
 2514|       |    }
 2515|       |
 2516|       |    xmlFreeURI(uri);
 2517|       |#else
 2518|      0|    ret = xmlStrdup((const xmlChar *) path);
 2519|      0|#endif
 2520|      0|    return(ret);
 2521|      0|}
xmlPathToURI:
 2536|    644|{
 2537|    644|    xmlURIPtr uri;
 2538|    644|    xmlURI temp;
 2539|    644|    xmlChar *ret, *cal;
 2540|       |
 2541|    644|    if (path == NULL)
  ------------------
  |  Branch (2541:9): [True: 0, False: 644]
  ------------------
 2542|      0|        return(NULL);
 2543|       |
 2544|    644|    if ((uri = xmlParseURI((const char *) path)) != NULL) {
  ------------------
  |  Branch (2544:9): [True: 644, False: 0]
  ------------------
 2545|    644|	xmlFreeURI(uri);
 2546|    644|	return xmlStrdup(path);
 2547|    644|    }
 2548|      0|    cal = xmlCanonicPath(path);
 2549|      0|    if (cal == NULL)
  ------------------
  |  Branch (2549:9): [True: 0, False: 0]
  ------------------
 2550|      0|        return(NULL);
 2551|       |#if defined(_WIN32)
 2552|       |    /* xmlCanonicPath can return an URI on Windows (is that the intended behaviour?)
 2553|       |       If 'cal' is a valid URI already then we are done here, as continuing would make
 2554|       |       it invalid. */
 2555|       |    if ((uri = xmlParseURI((const char *) cal)) != NULL) {
 2556|       |	xmlFreeURI(uri);
 2557|       |	return cal;
 2558|       |    }
 2559|       |    /* 'cal' can contain a relative path with backslashes. If that is processed
 2560|       |       by xmlSaveURI, they will be escaped and the external entity loader machinery
 2561|       |       will fail. So convert them to slashes. Misuse 'ret' for walking. */
 2562|       |    ret = cal;
 2563|       |    while (*ret != '\0') {
 2564|       |	if (*ret == '\\')
 2565|       |	    *ret = '/';
 2566|       |	ret++;
 2567|       |    }
 2568|       |#endif
 2569|      0|    memset(&temp, 0, sizeof(temp));
 2570|      0|    temp.path = (char *) cal;
 2571|      0|    ret = xmlSaveUri(&temp);
 2572|      0|    xmlFree(cal);
 2573|      0|    return(ret);
 2574|      0|}
uri.c:xmlParse3986URIReference:
  913|  11.8k|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|  11.8k|    int ret;
  915|       |
  916|  11.8k|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 11.8k]
  ------------------
  917|      0|	return(-1);
  918|  11.8k|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|  11.8k|    ret = xmlParse3986URI(uri, str);
  925|  11.8k|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 11.3k, False: 537]
  ------------------
  926|  11.3k|	xmlCleanURI(uri);
  927|  11.3k|        ret = xmlParse3986RelativeRef(uri, str);
  928|  11.3k|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 0, False: 11.3k]
  ------------------
  929|      0|	    xmlCleanURI(uri);
  930|      0|	    return(ret);
  931|      0|	}
  932|  11.3k|    }
  933|  11.8k|    return(0);
  934|  11.8k|}
uri.c:xmlCleanURI:
 1366|  23.1k|xmlCleanURI(xmlURIPtr uri) {
 1367|  23.1k|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 23.1k]
  ------------------
 1368|       |
 1369|  23.1k|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 11.2k, False: 11.9k]
  ------------------
 1370|  23.1k|    uri->scheme = NULL;
 1371|  23.1k|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 0, False: 23.1k]
  ------------------
 1372|  23.1k|    uri->server = NULL;
 1373|  23.1k|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 0, False: 23.1k]
  ------------------
 1374|  23.1k|    uri->user = NULL;
 1375|  23.1k|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 0, False: 23.1k]
  ------------------
 1376|  23.1k|    uri->path = NULL;
 1377|  23.1k|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 0, False: 23.1k]
  ------------------
 1378|  23.1k|    uri->fragment = NULL;
 1379|  23.1k|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 23.1k]
  ------------------
 1380|  23.1k|    uri->opaque = NULL;
 1381|  23.1k|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 23.1k]
  ------------------
 1382|  23.1k|    uri->authority = NULL;
 1383|  23.1k|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 0, False: 23.1k]
  ------------------
 1384|  23.1k|    uri->query = NULL;
 1385|  23.1k|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 0, False: 23.1k]
  ------------------
 1386|  23.1k|    uri->query_raw = NULL;
 1387|  23.1k|}
uri.c:xmlParse3986URI:
  872|  11.8k|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|  11.8k|    int ret;
  874|       |
  875|  11.8k|    ret = xmlParse3986Scheme(uri, &str);
  876|  11.8k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 76, False: 11.7k]
  ------------------
  877|  11.7k|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 11.2k, False: 537]
  ------------------
  878|  11.2k|	return(1);
  879|  11.2k|    }
  880|    537|    str++;
  881|    537|    ret = xmlParse3986HierPart(uri, &str);
  882|    537|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 0, False: 537]
  ------------------
  883|    537|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 0, False: 537]
  ------------------
  884|      0|	str++;
  885|      0|	ret = xmlParse3986Query(uri, &str);
  886|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 0]
  ------------------
  887|      0|    }
  888|    537|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 15, False: 522]
  ------------------
  889|     15|	str++;
  890|     15|	ret = xmlParse3986Fragment(uri, &str);
  891|     15|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 15]
  ------------------
  892|     15|    }
  893|    537|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 0, False: 537]
  ------------------
  894|      0|	xmlCleanURI(uri);
  895|      0|	return(1);
  896|      0|    }
  897|    537|    return(0);
  898|    537|}
uri.c:xmlParse3986Scheme:
  213|  11.8k|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|  11.8k|    const char *cur;
  215|       |
  216|  11.8k|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 11.8k]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|  11.8k|    cur = *str;
  220|  11.8k|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|  11.8k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 11.6k, False: 167]
  |  |  |  Branch (152:41): [True: 11.6k, False: 0]
  |  |  ------------------
  |  |  153|  11.8k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 91, False: 76]
  |  |  |  Branch (153:41): [True: 91, False: 0]
  |  |  ------------------
  ------------------
  221|     76|	return(2);
  222|  11.7k|    cur++;
  223|  71.8k|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|   143k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 38.2k, False: 33.5k]
  |  |  |  Branch (152:41): [True: 38.2k, False: 0]
  |  |  ------------------
  |  |  153|   143k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 401, False: 33.1k]
  |  |  |  Branch (153:41): [True: 224, False: 177]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|   105k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 11.5k, False: 21.8k]
  |  |  |  Branch (151:40): [True: 10.8k, False: 714]
  |  |  ------------------
  ------------------
  224|  71.8k|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 0, False: 22.5k]
  |  Branch (224:29): [True: 231, False: 22.3k]
  |  Branch (224:46): [True: 10.5k, False: 11.7k]
  ------------------
  225|  11.7k|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 11.7k, False: 0]
  ------------------
  226|  11.7k|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 11.7k]
  ------------------
  227|  11.7k|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|  11.7k|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|  11.7k|    }
  229|  11.7k|    *str = cur;
  230|  11.7k|    return(0);
  231|  11.8k|}
uri.c:xmlParse3986HierPart:
  765|    537|{
  766|    537|    const char *cur;
  767|    537|    int ret;
  768|       |
  769|    537|    cur = *str;
  770|       |
  771|    537|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 489, False: 48]
  |  Branch (771:26): [True: 489, False: 0]
  ------------------
  772|    489|        cur += 2;
  773|    489|	ret = xmlParse3986Authority(uri, &cur);
  774|    489|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 0, False: 489]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|    489|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 0, False: 489]
  |  Branch (778:31): [True: 0, False: 0]
  ------------------
  779|      0|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|      0|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|    489|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|    489|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 489]
  ------------------
  782|    489|	*str = cur;
  783|    489|	return(0);
  784|    489|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 0, False: 48]
  ------------------
  785|      0|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 0]
  ------------------
  787|     48|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|     48|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     96|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     48|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 48, False: 0]
  |  |  |  |  |  |  |  Branch (152:41): [True: 48, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     48|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|     48|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     48|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     48|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     48|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  788|     48|        ret = xmlParse3986PathRootless(uri, &cur);
  789|     48|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 48]
  ------------------
  790|     48|    } else {
  791|       |	/* path-empty is effectively empty */
  792|      0|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 0, False: 0]
  ------------------
  793|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 0]
  ------------------
  794|      0|	    uri->path = NULL;
  795|      0|	}
  796|      0|    }
  797|     48|    *str = cur;
  798|     48|    return (0);
  799|    537|}
uri.c:xmlParse3986Authority:
  521|    489|{
  522|    489|    const char *cur;
  523|    489|    int ret;
  524|       |
  525|    489|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|    489|    ret = xmlParse3986Userinfo(uri, &cur);
  530|    489|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 489, False: 0]
  |  Branch (530:23): [True: 0, False: 0]
  ------------------
  531|    489|        cur = *str;
  532|      0|    else
  533|      0|        cur++;
  534|    489|    ret = xmlParse3986Host(uri, &cur);
  535|    489|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 0, False: 489]
  ------------------
  536|    489|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 0, False: 489]
  ------------------
  537|      0|        cur++;
  538|      0|        ret = xmlParse3986Port(uri, &cur);
  539|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|    }
  541|    489|    *str = cur;
  542|    489|    return(0);
  543|    489|}
uri.c:xmlParse3986Userinfo:
  370|    489|{
  371|    489|    const char *cur;
  372|       |
  373|    489|    cur = *str;
  374|  5.97k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|  11.9k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  5.97k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 4.27k, False: 1.69k]
  |  |  |  |  |  Branch (152:41): [True: 4.27k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  5.97k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 1.69k]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.69k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 285, False: 1.41k]
  |  |  |  |  |  Branch (151:40): [True: 285, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 1.41k]
  |  |  ------------------
  |  |  186|  5.97k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 924, False: 489]
  |  |  |  Branch (186:27): [True: 0, False: 489]
  |  |  |  Branch (186:46): [True: 0, False: 489]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|  6.45k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 489]
  |  |  ------------------
  ------------------
  375|  5.97k|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|  6.45k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 489]
  |  |  |  Branch (163:27): [True: 0, False: 489]
  |  |  |  Branch (163:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  164|    489|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 489]
  |  |  |  Branch (164:27): [True: 0, False: 489]
  |  |  |  Branch (164:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  165|    489|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 489]
  |  |  |  Branch (165:27): [True: 0, False: 489]
  |  |  |  Branch (165:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  166|    489|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 489]
  |  |  |  Branch (166:27): [True: 0, False: 489]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 0, False: 489]
  ------------------
  376|  5.48k|	NEXT(cur);
  ------------------
  |  |  131|  5.48k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 5.48k]
  |  |  ------------------
  ------------------
  377|    489|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 0, False: 489]
  ------------------
  378|      0|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 0, False: 0]
  ------------------
  379|      0|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 0]
  ------------------
  380|      0|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 0, False: 0]
  ------------------
  381|      0|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|      0|	    else
  383|      0|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|      0|	}
  385|      0|	*str = cur;
  386|      0|	return(0);
  387|      0|    }
  388|    489|    return(1);
  389|    489|}
uri.c:xmlParse3986Host:
  445|    489|{
  446|    489|    const char *cur = *str;
  447|    489|    const char *host;
  448|       |
  449|    489|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|    489|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 0, False: 489]
  ------------------
  454|      0|        cur++;
  455|      0|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 0, False: 0]
  |  Branch (455:26): [True: 0, False: 0]
  ------------------
  456|      0|	    cur++;
  457|      0|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 0, False: 0]
  ------------------
  458|      0|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      0|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|    489|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|    489|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 489, False: 0]
  |  |  |  Branch (151:40): [True: 0, False: 489]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|  5.97k|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|  11.9k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|  5.97k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 4.27k, False: 1.69k]
  |  |  |  |  |  Branch (152:41): [True: 4.27k, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|  5.97k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 1.69k]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|  1.69k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 285, False: 1.41k]
  |  |  |  |  |  Branch (151:40): [True: 285, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 1.41k]
  |  |  ------------------
  |  |  186|  5.97k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 924, False: 489]
  |  |  |  Branch (186:27): [True: 0, False: 489]
  |  |  |  Branch (186:46): [True: 0, False: 489]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|  6.45k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 489]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|    489|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 489]
  |  |  |  Branch (163:27): [True: 0, False: 489]
  |  |  |  Branch (163:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  164|    489|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 489]
  |  |  |  Branch (164:27): [True: 0, False: 489]
  |  |  |  Branch (164:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  165|    489|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 489]
  |  |  |  Branch (165:27): [True: 0, False: 489]
  |  |  |  Branch (165:46): [True: 0, False: 489]
  |  |  ------------------
  |  |  166|    489|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 489]
  |  |  |  Branch (166:27): [True: 0, False: 489]
  |  |  ------------------
  ------------------
  489|  5.48k|        NEXT(cur);
  ------------------
  |  |  131|  5.97k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 5.48k]
  |  |  ------------------
  ------------------
  490|    489|found:
  491|    489|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 489, False: 0]
  ------------------
  492|    489|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 489]
  ------------------
  493|    489|	uri->authority = NULL;
  494|    489|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 489]
  ------------------
  495|    489|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 489, False: 0]
  ------------------
  496|    489|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 0, False: 489]
  ------------------
  497|      0|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|    489|	    else
  499|    489|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|    489|	} else
  501|      0|	    uri->server = NULL;
  502|    489|    }
  503|    489|    *str = cur;
  504|    489|    return(0);
  505|    489|}
uri.c:xmlParse3986PathAbEmpty:
  592|    489|{
  593|    489|    const char *cur;
  594|    489|    int ret;
  595|       |
  596|    489|    cur = *str;
  597|       |
  598|  1.79k|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 1.30k, False: 489]
  ------------------
  599|  1.30k|        cur++;
  600|  1.30k|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|  1.30k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 1.30k]
  ------------------
  602|  1.30k|    }
  603|    489|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 489, False: 0]
  ------------------
  604|    489|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 489]
  ------------------
  605|    489|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 477, False: 12]
  ------------------
  606|    477|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 0, False: 477]
  ------------------
  607|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|    477|            else
  609|    477|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|    477|        } else {
  611|     12|            uri->path = NULL;
  612|     12|        }
  613|    489|    }
  614|    489|    *str = cur;
  615|    489|    return (0);
  616|    489|}
uri.c:xmlParse3986Segment:
  563|  12.8k|{
  564|  12.8k|    const char *cur;
  565|       |
  566|  12.8k|    cur = *str;
  567|  12.8k|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|  12.8k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  25.7k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  12.8k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 11.9k, False: 917]
  |  |  |  |  |  |  |  Branch (152:41): [True: 11.9k, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  12.8k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 670, False: 265]
  |  |  |  |  |  |  |  Branch (153:41): [True: 652, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|    283|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 151, False: 132]
  |  |  |  |  |  |  |  Branch (151:40): [True: 133, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 150]
  |  |  |  |  ------------------
  |  |  |  |  186|  12.8k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 150]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 150]
  |  |  |  |  |  Branch (186:46): [True: 18, False: 132]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  12.9k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  12.9k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 132]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 132]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  |  |  164|    132|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 132]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 132]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  |  |  165|    132|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 132]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 132]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  |  |  166|    132|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 132]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 132]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  12.8k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 132]
  |  |  |  Branch (199:26): [True: 0, False: 132]
  |  |  ------------------
  ------------------
  568|    132|        if (empty)
  ------------------
  |  Branch (568:13): [True: 132, False: 0]
  ------------------
  569|    132|	    return(0);
  570|      0|	return(1);
  571|    132|    }
  572|  99.2k|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|   198k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|   198k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  99.2k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 56.5k, False: 42.6k]
  |  |  |  |  |  |  |  Branch (152:41): [True: 56.5k, False: 18]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  99.2k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 1.76k, False: 40.9k]
  |  |  |  |  |  |  |  Branch (153:41): [True: 1.50k, False: 260]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|  41.1k|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 16.5k, False: 24.6k]
  |  |  |  |  |  |  |  Branch (151:40): [True: 16.1k, False: 332]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 603, False: 24.3k]
  |  |  |  |  ------------------
  |  |  |  |  186|  99.2k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 11.3k, False: 13.0k]
  |  |  |  |  |  Branch (186:27): [True: 242, False: 12.8k]
  |  |  |  |  |  Branch (186:46): [True: 18, False: 12.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|   112k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 12.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|   112k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 12.8k]
  |  |  |  |  ------------------
  |  |  |  |  164|  12.8k|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 12.8k]
  |  |  |  |  ------------------
  |  |  |  |  165|  12.8k|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 12.8k]
  |  |  |  |  ------------------
  |  |  |  |  166|  12.8k|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 12.8k]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 12.8k]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  99.2k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 72, False: 12.7k]
  |  |  |  Branch (199:26): [True: 0, False: 12.7k]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 86.4k, False: 0]
  ------------------
  573|  86.4k|        NEXT(cur);
  ------------------
  |  |  131|  99.2k|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 86.4k]
  |  |  ------------------
  ------------------
  574|  12.7k|    *str = cur;
  575|  12.7k|    return (0);
  576|  12.8k|}
uri.c:xmlParse3986PathAbsolute:
  632|     12|{
  633|     12|    const char *cur;
  634|     12|    int ret;
  635|       |
  636|     12|    cur = *str;
  637|       |
  638|     12|    if (*cur != '/')
  ------------------
  |  Branch (638:9): [True: 0, False: 12]
  ------------------
  639|      0|        return(1);
  640|     12|    cur++;
  641|     12|    ret = xmlParse3986Segment(&cur, 0, 0);
  642|     12|    if (ret == 0) {
  ------------------
  |  Branch (642:9): [True: 12, False: 0]
  ------------------
  643|     24|	while (*cur == '/') {
  ------------------
  |  Branch (643:9): [True: 12, False: 12]
  ------------------
  644|     12|	    cur++;
  645|     12|	    ret = xmlParse3986Segment(&cur, 0, 1);
  646|     12|	    if (ret != 0) return(ret);
  ------------------
  |  Branch (646:10): [True: 0, False: 12]
  ------------------
  647|     12|	}
  648|     12|    }
  649|     12|    if (uri != NULL) {
  ------------------
  |  Branch (649:9): [True: 12, False: 0]
  ------------------
  650|     12|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (650:6): [True: 0, False: 12]
  ------------------
  651|     12|        if (cur != *str) {
  ------------------
  |  Branch (651:13): [True: 12, False: 0]
  ------------------
  652|     12|            if (uri->cleanup & 2)
  ------------------
  |  Branch (652:17): [True: 0, False: 12]
  ------------------
  653|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  654|     12|            else
  655|     12|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  656|     12|        } else {
  657|      0|            uri->path = NULL;
  658|      0|        }
  659|     12|    }
  660|     12|    *str = cur;
  661|     12|    return (0);
  662|     12|}
uri.c:xmlParse3986PathRootless:
  678|     48|{
  679|     48|    const char *cur;
  680|     48|    int ret;
  681|       |
  682|     48|    cur = *str;
  683|       |
  684|     48|    ret = xmlParse3986Segment(&cur, 0, 0);
  685|     48|    if (ret != 0) return(ret);
  ------------------
  |  Branch (685:9): [True: 0, False: 48]
  ------------------
  686|     48|    while (*cur == '/') {
  ------------------
  |  Branch (686:12): [True: 0, False: 48]
  ------------------
  687|      0|        cur++;
  688|      0|	ret = xmlParse3986Segment(&cur, 0, 1);
  689|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (689:6): [True: 0, False: 0]
  ------------------
  690|      0|    }
  691|     48|    if (uri != NULL) {
  ------------------
  |  Branch (691:9): [True: 48, False: 0]
  ------------------
  692|     48|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (692:6): [True: 0, False: 48]
  ------------------
  693|     48|        if (cur != *str) {
  ------------------
  |  Branch (693:13): [True: 48, False: 0]
  ------------------
  694|     48|            if (uri->cleanup & 2)
  ------------------
  |  Branch (694:17): [True: 0, False: 48]
  ------------------
  695|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  696|     48|            else
  697|     48|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  698|     48|        } else {
  699|      0|            uri->path = NULL;
  700|      0|        }
  701|     48|    }
  702|     48|    *str = cur;
  703|     48|    return (0);
  704|     48|}
uri.c:xmlParse3986Fragment:
  250|     15|{
  251|     15|    const char *cur;
  252|       |
  253|     15|    if (str == NULL)
  ------------------
  |  Branch (253:9): [True: 0, False: 15]
  ------------------
  254|      0|        return (-1);
  255|       |
  256|     15|    cur = *str;
  257|       |
  258|     51|    while ((ISA_PCHAR(cur)) || (*cur == '/') || (*cur == '?') ||
  ------------------
  |  |  198|     51|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|    102|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     51|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 24, False: 27]
  |  |  |  |  |  |  |  Branch (152:41): [True: 24, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     51|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 9, False: 18]
  |  |  |  |  |  |  |  Branch (153:41): [True: 9, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|     18|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 18]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 18]
  |  |  |  |  ------------------
  |  |  |  |  186|     51|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 3, False: 15]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 15]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     66|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     66|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 15]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 15]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  |  |  164|     15|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 15]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 15]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  |  |  165|     15|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 15]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 15]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  |  |  166|     15|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 15]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 15]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     51|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 15]
  |  |  |  Branch (199:26): [True: 0, False: 15]
  |  |  ------------------
  ------------------
  |  Branch (258:32): [True: 0, False: 15]
  |  Branch (258:49): [True: 0, False: 15]
  ------------------
  259|     51|           (*cur == '[') || (*cur == ']') ||
  ------------------
  |  Branch (259:12): [True: 0, False: 15]
  |  Branch (259:29): [True: 0, False: 15]
  ------------------
  260|     51|           ((uri != NULL) && (uri->cleanup & 1) && (IS_UNWISE(cur))))
  ------------------
  |  |  108|      0|      (((*(p) == '{')) || ((*(p) == '}')) || ((*(p) == '|')) ||         \
  |  |  ------------------
  |  |  |  Branch (108:8): [True: 0, False: 0]
  |  |  |  Branch (108:27): [True: 0, False: 0]
  |  |  |  Branch (108:46): [True: 0, False: 0]
  |  |  ------------------
  |  |  109|      0|       ((*(p) == '\\')) || ((*(p) == '^')) || ((*(p) == '[')) ||        \
  |  |  ------------------
  |  |  |  Branch (109:8): [True: 0, False: 0]
  |  |  |  Branch (109:28): [True: 0, False: 0]
  |  |  |  Branch (109:47): [True: 0, False: 0]
  |  |  ------------------
  |  |  110|      0|       ((*(p) == ']')) || ((*(p) == '`')))
  |  |  ------------------
  |  |  |  Branch (110:8): [True: 0, False: 0]
  |  |  |  Branch (110:27): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (260:13): [True: 15, False: 0]
  |  Branch (260:30): [True: 0, False: 15]
  ------------------
  261|     36|        NEXT(cur);
  ------------------
  |  |  131|     51|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 36]
  |  |  ------------------
  ------------------
  262|     15|    if (uri != NULL) {
  ------------------
  |  Branch (262:9): [True: 15, False: 0]
  ------------------
  263|     15|        if (uri->fragment != NULL)
  ------------------
  |  Branch (263:13): [True: 0, False: 15]
  ------------------
  264|      0|            xmlFree(uri->fragment);
  265|     15|	if (uri->cleanup & 2)
  ------------------
  |  Branch (265:6): [True: 0, False: 15]
  ------------------
  266|      0|	    uri->fragment = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  267|     15|	else
  268|     15|	    uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);
  269|     15|    }
  270|     15|    *str = cur;
  271|     15|    return (0);
  272|     15|}
uri.c:xmlParse3986RelativeRef:
  818|  11.3k|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|  11.3k|    int ret;
  820|       |
  821|  11.3k|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 12, False: 11.3k]
  |  Branch (821:26): [True: 0, False: 12]
  ------------------
  822|      0|        str += 2;
  823|      0|	ret = xmlParse3986Authority(uri, &str);
  824|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 0, False: 0]
  ------------------
  825|      0|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 0]
  ------------------
  827|  11.3k|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 12, False: 11.3k]
  ------------------
  828|     12|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|     12|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 12]
  ------------------
  830|  11.3k|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|  11.3k|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|  22.6k|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|  11.3k|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 11.1k, False: 155]
  |  |  |  |  |  |  |  Branch (152:41): [True: 11.1k, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|  11.3k|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 91, False: 64]
  |  |  |  |  |  |  |  Branch (153:41): [True: 91, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|     64|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 64, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 64, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|  11.3k|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|  11.3k|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|  11.3k|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|  11.3k|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  831|  11.3k|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|  11.3k|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 11.3k]
  ------------------
  833|  11.3k|    } else {
  834|       |	/* path-empty is effectively empty */
  835|      0|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 0, False: 0]
  ------------------
  836|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 0]
  ------------------
  837|      0|	    uri->path = NULL;
  838|      0|	}
  839|      0|    }
  840|       |
  841|  11.3k|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 0, False: 11.3k]
  ------------------
  842|      0|	str++;
  843|      0|	ret = xmlParse3986Query(uri, &str);
  844|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  ------------------
  845|      0|    }
  846|  11.3k|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 0, False: 11.3k]
  ------------------
  847|      0|	str++;
  848|      0|	ret = xmlParse3986Fragment(uri, &str);
  849|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 0]
  ------------------
  850|      0|    }
  851|  11.3k|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 0, False: 11.3k]
  ------------------
  852|      0|	xmlCleanURI(uri);
  853|      0|	return(1);
  854|      0|    }
  855|  11.3k|    return(0);
  856|  11.3k|}
uri.c:xmlParse3986PathNoScheme:
  720|  11.3k|{
  721|  11.3k|    const char *cur;
  722|  11.3k|    int ret;
  723|       |
  724|  11.3k|    cur = *str;
  725|       |
  726|  11.3k|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|  11.3k|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 11.3k]
  ------------------
  728|  11.4k|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 183, False: 11.3k]
  ------------------
  729|    183|        cur++;
  730|    183|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|    183|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 183]
  ------------------
  732|    183|    }
  733|  11.3k|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 11.3k, False: 0]
  ------------------
  734|  11.3k|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 11.3k]
  ------------------
  735|  11.3k|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 11.3k, False: 0]
  ------------------
  736|  11.3k|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 0, False: 11.3k]
  ------------------
  737|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|  11.3k|            else
  739|  11.3k|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|  11.3k|        } else {
  741|      0|            uri->path = NULL;
  742|      0|        }
  743|  11.3k|    }
  744|  11.3k|    *str = cur;
  745|  11.3k|    return (0);
  746|  11.3k|}

xmlNewDocElementContent:
  754|  13.6k|                        xmlElementContentType type) {
  755|  13.6k|    xmlElementContentPtr ret;
  756|  13.6k|    xmlDictPtr dict = NULL;
  757|       |
  758|  13.6k|    if (doc != NULL)
  ------------------
  |  Branch (758:9): [True: 13.6k, False: 0]
  ------------------
  759|  13.6k|        dict = doc->dict;
  760|       |
  761|  13.6k|    switch(type) {
  762|  6.70k|	case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (762:2): [True: 6.70k, False: 6.95k]
  ------------------
  763|  6.70k|	    if (name == NULL) {
  ------------------
  |  Branch (763:10): [True: 0, False: 6.70k]
  ------------------
  764|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  765|      0|			"xmlNewElementContent : name == NULL !\n",
  766|      0|			NULL);
  767|      0|	    }
  768|  6.70k|	    break;
  769|  1.02k|        case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (769:9): [True: 1.02k, False: 12.6k]
  ------------------
  770|  1.95k|	case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (770:2): [True: 924, False: 12.7k]
  ------------------
  771|  6.95k|	case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (771:2): [True: 5.00k, False: 8.65k]
  ------------------
  772|  6.95k|	    if (name != NULL) {
  ------------------
  |  Branch (772:10): [True: 0, False: 6.95k]
  ------------------
  773|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  774|      0|			"xmlNewElementContent : name != NULL !\n",
  775|      0|			NULL);
  776|      0|	    }
  777|  6.95k|	    break;
  778|      0|	default:
  ------------------
  |  Branch (778:2): [True: 0, False: 13.6k]
  ------------------
  779|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  780|      0|		    "Internal: ELEMENT content corrupted invalid type\n",
  781|      0|		    NULL);
  782|      0|	    return(NULL);
  783|  13.6k|    }
  784|  13.6k|    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));
  785|  13.6k|    if (ret == NULL) {
  ------------------
  |  Branch (785:9): [True: 0, False: 13.6k]
  ------------------
  786|      0|	xmlVErrMemory(NULL, "malloc failed");
  787|      0|	return(NULL);
  788|      0|    }
  789|  13.6k|    memset(ret, 0, sizeof(xmlElementContent));
  790|  13.6k|    ret->type = type;
  791|  13.6k|    ret->ocur = XML_ELEMENT_CONTENT_ONCE;
  792|  13.6k|    if (name != NULL) {
  ------------------
  |  Branch (792:9): [True: 6.70k, False: 6.95k]
  ------------------
  793|  6.70k|        int l;
  794|  6.70k|	const xmlChar *tmp;
  795|       |
  796|  6.70k|	tmp = xmlSplitQName3(name, &l);
  797|  6.70k|	if (tmp == NULL) {
  ------------------
  |  Branch (797:6): [True: 6.62k, False: 87]
  ------------------
  798|  6.62k|	    if (dict == NULL)
  ------------------
  |  Branch (798:10): [True: 0, False: 6.62k]
  ------------------
  799|      0|		ret->name = xmlStrdup(name);
  800|  6.62k|	    else
  801|  6.62k|	        ret->name = xmlDictLookup(dict, name, -1);
  802|  6.62k|	} else {
  803|     87|	    if (dict == NULL) {
  ------------------
  |  Branch (803:10): [True: 0, False: 87]
  ------------------
  804|      0|		ret->prefix = xmlStrndup(name, l);
  805|      0|		ret->name = xmlStrdup(tmp);
  806|     87|	    } else {
  807|     87|	        ret->prefix = xmlDictLookup(dict, name, l);
  808|     87|		ret->name = xmlDictLookup(dict, tmp, -1);
  809|     87|	    }
  810|     87|	}
  811|  6.70k|    }
  812|  13.6k|    return(ret);
  813|  13.6k|}
xmlFreeDocElementContent:
  934|  2.36k|xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {
  935|  2.36k|    xmlDictPtr dict = NULL;
  936|  2.36k|    size_t depth = 0;
  937|       |
  938|  2.36k|    if (cur == NULL)
  ------------------
  |  Branch (938:9): [True: 555, False: 1.80k]
  ------------------
  939|    555|        return;
  940|  1.80k|    if (doc != NULL)
  ------------------
  |  Branch (940:9): [True: 1.80k, False: 0]
  ------------------
  941|  1.80k|        dict = doc->dict;
  942|       |
  943|  13.6k|    while (1) {
  ------------------
  |  Branch (943:12): [Folded - Ignored]
  ------------------
  944|  13.6k|        xmlElementContentPtr parent;
  945|       |
  946|  19.5k|        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {
  ------------------
  |  Branch (946:16): [True: 5.93k, False: 13.6k]
  |  Branch (946:37): [True: 0, False: 13.6k]
  ------------------
  947|  5.93k|            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;
  ------------------
  |  Branch (947:19): [True: 5.93k, False: 0]
  ------------------
  948|  5.93k|            depth += 1;
  949|  5.93k|        }
  950|       |
  951|  13.6k|	switch (cur->type) {
  952|  1.02k|	    case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (952:6): [True: 1.02k, False: 12.6k]
  ------------------
  953|  7.73k|	    case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (953:6): [True: 6.70k, False: 6.95k]
  ------------------
  954|  8.65k|	    case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (954:6): [True: 924, False: 12.7k]
  ------------------
  955|  13.6k|	    case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (955:6): [True: 5.00k, False: 8.65k]
  ------------------
  956|  13.6k|		break;
  957|      0|	    default:
  ------------------
  |  Branch (957:6): [True: 0, False: 13.6k]
  ------------------
  958|      0|		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  959|      0|			"Internal: ELEMENT content corrupted invalid type\n",
  960|      0|			NULL);
  961|      0|		return;
  962|  13.6k|	}
  963|  13.6k|	if (dict) {
  ------------------
  |  Branch (963:6): [True: 13.6k, False: 0]
  ------------------
  964|  13.6k|	    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))
  ------------------
  |  Branch (964:10): [True: 6.70k, False: 6.95k]
  |  Branch (964:33): [True: 0, False: 6.70k]
  ------------------
  965|      0|	        xmlFree((xmlChar *) cur->name);
  966|  13.6k|	    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))
  ------------------
  |  Branch (966:10): [True: 87, False: 13.5k]
  |  Branch (966:35): [True: 0, False: 87]
  ------------------
  967|      0|	        xmlFree((xmlChar *) cur->prefix);
  968|  13.6k|	} else {
  969|      0|	    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (969:10): [True: 0, False: 0]
  ------------------
  970|      0|	    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);
  ------------------
  |  Branch (970:10): [True: 0, False: 0]
  ------------------
  971|      0|	}
  972|  13.6k|        parent = cur->parent;
  973|  13.6k|        if ((depth == 0) || (parent == NULL)) {
  ------------------
  |  Branch (973:13): [True: 1.80k, False: 11.8k]
  |  Branch (973:29): [True: 0, False: 11.8k]
  ------------------
  974|  1.80k|            xmlFree(cur);
  975|  1.80k|            break;
  976|  1.80k|        }
  977|  11.8k|        if (cur == parent->c1)
  ------------------
  |  Branch (977:13): [True: 5.93k, False: 5.92k]
  ------------------
  978|  5.93k|            parent->c1 = NULL;
  979|  5.92k|        else
  980|  5.92k|            parent->c2 = NULL;
  981|  11.8k|	xmlFree(cur);
  982|       |
  983|  11.8k|        if (parent->c2 != NULL) {
  ------------------
  |  Branch (983:13): [True: 5.92k, False: 5.93k]
  ------------------
  984|  5.92k|	    cur = parent->c2;
  985|  5.93k|        } else {
  986|  5.93k|            depth -= 1;
  987|  5.93k|            cur = parent;
  988|  5.93k|        }
  989|  11.8k|    }
  990|  1.80k|}
xmlAddElementDecl:
 1266|  2.33k|		  xmlElementContentPtr content) {
 1267|  2.33k|    xmlElementPtr ret;
 1268|  2.33k|    xmlElementTablePtr table;
 1269|  2.33k|    xmlAttributePtr oldAttributes = NULL;
 1270|  2.33k|    xmlChar *ns, *uqname;
 1271|       |
 1272|  2.33k|    if (dtd == NULL) {
  ------------------
  |  Branch (1272:9): [True: 0, False: 2.33k]
  ------------------
 1273|      0|	return(NULL);
 1274|      0|    }
 1275|  2.33k|    if (name == NULL) {
  ------------------
  |  Branch (1275:9): [True: 0, False: 2.33k]
  ------------------
 1276|      0|	return(NULL);
 1277|      0|    }
 1278|       |
 1279|  2.33k|    switch (type) {
 1280|    507|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (1280:9): [True: 507, False: 1.82k]
  ------------------
 1281|    507|	    if (content != NULL) {
  ------------------
  |  Branch (1281:10): [True: 0, False: 507]
  ------------------
 1282|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1283|      0|		        "xmlAddElementDecl: content != NULL for EMPTY\n",
 1284|      0|			NULL);
 1285|      0|		return(NULL);
 1286|      0|	    }
 1287|    507|	    break;
 1288|    507|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (1288:2): [True: 27, False: 2.30k]
  ------------------
 1289|     27|	    if (content != NULL) {
  ------------------
  |  Branch (1289:10): [True: 0, False: 27]
  ------------------
 1290|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1291|      0|		        "xmlAddElementDecl: content != NULL for ANY\n",
 1292|      0|			NULL);
 1293|      0|		return(NULL);
 1294|      0|	    }
 1295|     27|	    break;
 1296|  1.02k|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (1296:2): [True: 1.02k, False: 1.30k]
  ------------------
 1297|  1.02k|	    if (content == NULL) {
  ------------------
  |  Branch (1297:10): [True: 0, False: 1.02k]
  ------------------
 1298|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1299|      0|		        "xmlAddElementDecl: content == NULL for MIXED\n",
 1300|      0|			NULL);
 1301|      0|		return(NULL);
 1302|      0|	    }
 1303|  1.02k|	    break;
 1304|  1.02k|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (1304:2): [True: 774, False: 1.56k]
  ------------------
 1305|    774|	    if (content == NULL) {
  ------------------
  |  Branch (1305:10): [True: 0, False: 774]
  ------------------
 1306|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1307|      0|		        "xmlAddElementDecl: content == NULL for ELEMENT\n",
 1308|      0|			NULL);
 1309|      0|		return(NULL);
 1310|      0|	    }
 1311|    774|	    break;
 1312|    774|	default:
  ------------------
  |  Branch (1312:2): [True: 0, False: 2.33k]
  ------------------
 1313|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1314|      0|		    "Internal: ELEMENT decl corrupted invalid type\n",
 1315|      0|		    NULL);
 1316|      0|	    return(NULL);
 1317|  2.33k|    }
 1318|       |
 1319|       |    /*
 1320|       |     * check if name is a QName
 1321|       |     */
 1322|  2.33k|    uqname = xmlSplitQName2(name, &ns);
 1323|  2.33k|    if (uqname != NULL)
  ------------------
  |  Branch (1323:9): [True: 81, False: 2.25k]
  ------------------
 1324|     81|	name = uqname;
 1325|       |
 1326|       |    /*
 1327|       |     * Create the Element table if needed.
 1328|       |     */
 1329|  2.33k|    table = (xmlElementTablePtr) dtd->elements;
 1330|  2.33k|    if (table == NULL) {
  ------------------
  |  Branch (1330:9): [True: 339, False: 1.99k]
  ------------------
 1331|    339|	xmlDictPtr dict = NULL;
 1332|       |
 1333|    339|	if (dtd->doc != NULL)
  ------------------
  |  Branch (1333:6): [True: 339, False: 0]
  ------------------
 1334|    339|	    dict = dtd->doc->dict;
 1335|    339|        table = xmlHashCreateDict(0, dict);
 1336|    339|	dtd->elements = (void *) table;
 1337|    339|    }
 1338|  2.33k|    if (table == NULL) {
  ------------------
  |  Branch (1338:9): [True: 0, False: 2.33k]
  ------------------
 1339|      0|	xmlVErrMemory(ctxt,
 1340|      0|            "xmlAddElementDecl: Table creation failed!\n");
 1341|      0|	if (uqname != NULL)
  ------------------
  |  Branch (1341:6): [True: 0, False: 0]
  ------------------
 1342|      0|	    xmlFree(uqname);
 1343|      0|	if (ns != NULL)
  ------------------
  |  Branch (1343:6): [True: 0, False: 0]
  ------------------
 1344|      0|	    xmlFree(ns);
 1345|      0|        return(NULL);
 1346|      0|    }
 1347|       |
 1348|       |    /*
 1349|       |     * lookup old attributes inserted on an undefined element in the
 1350|       |     * internal subset.
 1351|       |     */
 1352|  2.33k|    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {
  ------------------
  |  Branch (1352:9): [True: 2.33k, False: 0]
  |  Branch (1352:31): [True: 2.33k, False: 0]
  ------------------
 1353|  2.33k|	ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);
 1354|  2.33k|	if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (1354:6): [True: 15, False: 2.31k]
  |  Branch (1354:23): [True: 9, False: 6]
  ------------------
 1355|      9|	    oldAttributes = ret->attributes;
 1356|      9|	    ret->attributes = NULL;
 1357|      9|	    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);
 1358|      9|	    xmlFreeElement(ret);
 1359|      9|	}
 1360|  2.33k|    }
 1361|       |
 1362|       |    /*
 1363|       |     * The element may already be present if one of its attribute
 1364|       |     * was registered first
 1365|       |     */
 1366|  2.33k|    ret = xmlHashLookup2(table, name, ns);
 1367|  2.33k|    if (ret != NULL) {
  ------------------
  |  Branch (1367:9): [True: 3, False: 2.33k]
  ------------------
 1368|      3|	if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {
  ------------------
  |  Branch (1368:6): [True: 3, False: 0]
  ------------------
 1369|      3|#ifdef LIBXML_VALID_ENABLED
 1370|       |	    /*
 1371|       |	     * The element is already defined in this DTD.
 1372|       |	     */
 1373|      3|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1374|      3|	                    "Redefinition of element %s\n",
 1375|      3|			    name, NULL, NULL);
 1376|      3|#endif /* LIBXML_VALID_ENABLED */
 1377|      3|	    if (uqname != NULL)
  ------------------
  |  Branch (1377:10): [True: 0, False: 3]
  ------------------
 1378|      0|		xmlFree(uqname);
 1379|      3|            if (ns != NULL)
  ------------------
  |  Branch (1379:17): [True: 0, False: 3]
  ------------------
 1380|      0|	        xmlFree(ns);
 1381|      3|	    return(NULL);
 1382|      3|	}
 1383|      0|	if (ns != NULL) {
  ------------------
  |  Branch (1383:6): [True: 0, False: 0]
  ------------------
 1384|      0|	    xmlFree(ns);
 1385|      0|	    ns = NULL;
 1386|      0|	}
 1387|  2.33k|    } else {
 1388|  2.33k|	ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 1389|  2.33k|	if (ret == NULL) {
  ------------------
  |  Branch (1389:6): [True: 0, False: 2.33k]
  ------------------
 1390|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1391|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1391:10): [True: 0, False: 0]
  ------------------
 1392|      0|		xmlFree(uqname);
 1393|      0|            if (ns != NULL)
  ------------------
  |  Branch (1393:17): [True: 0, False: 0]
  ------------------
 1394|      0|	        xmlFree(ns);
 1395|      0|	    return(NULL);
 1396|      0|	}
 1397|  2.33k|	memset(ret, 0, sizeof(xmlElement));
 1398|  2.33k|	ret->type = XML_ELEMENT_DECL;
 1399|       |
 1400|       |	/*
 1401|       |	 * fill the structure.
 1402|       |	 */
 1403|  2.33k|	ret->name = xmlStrdup(name);
 1404|  2.33k|	if (ret->name == NULL) {
  ------------------
  |  Branch (1404:6): [True: 0, False: 2.33k]
  ------------------
 1405|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1406|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1406:10): [True: 0, False: 0]
  ------------------
 1407|      0|		xmlFree(uqname);
 1408|      0|            if (ns != NULL)
  ------------------
  |  Branch (1408:17): [True: 0, False: 0]
  ------------------
 1409|      0|	        xmlFree(ns);
 1410|      0|	    xmlFree(ret);
 1411|      0|	    return(NULL);
 1412|      0|	}
 1413|  2.33k|	ret->prefix = ns;
 1414|       |
 1415|       |	/*
 1416|       |	 * Validity Check:
 1417|       |	 * Insertion must not fail
 1418|       |	 */
 1419|  2.33k|	if (xmlHashAddEntry2(table, name, ns, ret)) {
  ------------------
  |  Branch (1419:6): [True: 0, False: 2.33k]
  ------------------
 1420|      0|#ifdef LIBXML_VALID_ENABLED
 1421|       |	    /*
 1422|       |	     * The element is already defined in this DTD.
 1423|       |	     */
 1424|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1425|      0|	                    "Redefinition of element %s\n",
 1426|      0|			    name, NULL, NULL);
 1427|      0|#endif /* LIBXML_VALID_ENABLED */
 1428|      0|	    xmlFreeElement(ret);
 1429|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1429:10): [True: 0, False: 0]
  ------------------
 1430|      0|		xmlFree(uqname);
 1431|      0|	    return(NULL);
 1432|      0|	}
 1433|       |	/*
 1434|       |	 * For new element, may have attributes from earlier
 1435|       |	 * definition in internal subset
 1436|       |	 */
 1437|  2.33k|	ret->attributes = oldAttributes;
 1438|  2.33k|    }
 1439|       |
 1440|       |    /*
 1441|       |     * Finish to fill the structure.
 1442|       |     */
 1443|  2.33k|    ret->etype = type;
 1444|       |    /*
 1445|       |     * Avoid a stupid copy when called by the parser
 1446|       |     * and flag it by setting a special parent value
 1447|       |     * so the parser doesn't unallocate it.
 1448|       |     */
 1449|  2.33k|    if ((ctxt != NULL) && (ctxt->flags & XML_VCTXT_USE_PCTXT)) {
  ------------------
  |  |   18|  2.33k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (1449:9): [True: 2.33k, False: 0]
  |  Branch (1449:27): [True: 2.33k, False: 0]
  ------------------
 1450|  2.33k|	ret->content = content;
 1451|  2.33k|	if (content != NULL)
  ------------------
  |  Branch (1451:6): [True: 1.79k, False: 534]
  ------------------
 1452|  1.79k|	    content->parent = (xmlElementContentPtr) 1;
 1453|  2.33k|    } else {
 1454|      0|	ret->content = xmlCopyDocElementContent(dtd->doc, content);
 1455|      0|    }
 1456|       |
 1457|       |    /*
 1458|       |     * Link it to the DTD
 1459|       |     */
 1460|  2.33k|    ret->parent = dtd;
 1461|  2.33k|    ret->doc = dtd->doc;
 1462|  2.33k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (1462:9): [True: 294, False: 2.03k]
  ------------------
 1463|    294|	dtd->children = dtd->last = (xmlNodePtr) ret;
 1464|  2.03k|    } else {
 1465|  2.03k|        dtd->last->next = (xmlNodePtr) ret;
 1466|  2.03k|	ret->prev = dtd->last;
 1467|  2.03k|	dtd->last = (xmlNodePtr) ret;
 1468|  2.03k|    }
 1469|  2.33k|    if (uqname != NULL)
  ------------------
  |  Branch (1469:9): [True: 81, False: 2.25k]
  ------------------
 1470|     81|	xmlFree(uqname);
 1471|  2.33k|    return(ret);
 1472|  2.33k|}
xmlFreeElementTable:
 1486|    354|xmlFreeElementTable(xmlElementTablePtr table) {
 1487|    354|    xmlHashFree(table, xmlFreeElementTableEntry);
 1488|    354|}
xmlDumpElementDecl:
 1550|    389|xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {
 1551|    389|    if ((buf == NULL) || (elem == NULL))
  ------------------
  |  Branch (1551:9): [True: 0, False: 389]
  |  Branch (1551:26): [True: 0, False: 389]
  ------------------
 1552|      0|        return;
 1553|    389|    switch (elem->etype) {
 1554|    124|	case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (1554:2): [True: 124, False: 265]
  ------------------
 1555|    124|	    xmlBufferWriteChar(buf, "<!ELEMENT ");
 1556|    124|	    if (elem->prefix != NULL) {
  ------------------
  |  Branch (1556:10): [True: 14, False: 110]
  ------------------
 1557|     14|		xmlBufferWriteCHAR(buf, elem->prefix);
 1558|     14|		xmlBufferWriteChar(buf, ":");
 1559|     14|	    }
 1560|    124|	    xmlBufferWriteCHAR(buf, elem->name);
 1561|    124|	    xmlBufferWriteChar(buf, " EMPTY>\n");
 1562|    124|	    break;
 1563|      2|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (1563:2): [True: 2, False: 387]
  ------------------
 1564|      2|	    xmlBufferWriteChar(buf, "<!ELEMENT ");
 1565|      2|	    if (elem->prefix != NULL) {
  ------------------
  |  Branch (1565:10): [True: 0, False: 2]
  ------------------
 1566|      0|		xmlBufferWriteCHAR(buf, elem->prefix);
 1567|      0|		xmlBufferWriteChar(buf, ":");
 1568|      0|	    }
 1569|      2|	    xmlBufferWriteCHAR(buf, elem->name);
 1570|      2|	    xmlBufferWriteChar(buf, " ANY>\n");
 1571|      2|	    break;
 1572|    159|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (1572:2): [True: 159, False: 230]
  ------------------
 1573|    159|	    xmlBufferWriteChar(buf, "<!ELEMENT ");
 1574|    159|	    if (elem->prefix != NULL) {
  ------------------
  |  Branch (1574:10): [True: 2, False: 157]
  ------------------
 1575|      2|		xmlBufferWriteCHAR(buf, elem->prefix);
 1576|      2|		xmlBufferWriteChar(buf, ":");
 1577|      2|	    }
 1578|    159|	    xmlBufferWriteCHAR(buf, elem->name);
 1579|    159|	    xmlBufferWriteChar(buf, " ");
 1580|    159|	    xmlDumpElementContent(buf, elem->content);
 1581|    159|	    xmlBufferWriteChar(buf, ">\n");
 1582|    159|	    break;
 1583|    104|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (1583:2): [True: 104, False: 285]
  ------------------
 1584|    104|	    xmlBufferWriteChar(buf, "<!ELEMENT ");
 1585|    104|	    if (elem->prefix != NULL) {
  ------------------
  |  Branch (1585:10): [True: 9, False: 95]
  ------------------
 1586|      9|		xmlBufferWriteCHAR(buf, elem->prefix);
 1587|      9|		xmlBufferWriteChar(buf, ":");
 1588|      9|	    }
 1589|    104|	    xmlBufferWriteCHAR(buf, elem->name);
 1590|    104|	    xmlBufferWriteChar(buf, " ");
 1591|    104|	    xmlDumpElementContent(buf, elem->content);
 1592|    104|	    xmlBufferWriteChar(buf, ">\n");
 1593|    104|	    break;
 1594|      0|	default:
  ------------------
  |  Branch (1594:2): [True: 0, False: 389]
  ------------------
 1595|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 1596|      0|		    "Internal: ELEMENT struct corrupted invalid type\n",
 1597|      0|		    NULL);
 1598|    389|    }
 1599|    389|}
xmlCreateEnumeration:
 1640|  2.05k|xmlCreateEnumeration(const xmlChar *name) {
 1641|  2.05k|    xmlEnumerationPtr ret;
 1642|       |
 1643|  2.05k|    ret = (xmlEnumerationPtr) xmlMalloc(sizeof(xmlEnumeration));
 1644|  2.05k|    if (ret == NULL) {
  ------------------
  |  Branch (1644:9): [True: 0, False: 2.05k]
  ------------------
 1645|      0|	xmlVErrMemory(NULL, "malloc failed");
 1646|      0|        return(NULL);
 1647|      0|    }
 1648|  2.05k|    memset(ret, 0, sizeof(xmlEnumeration));
 1649|       |
 1650|  2.05k|    if (name != NULL)
  ------------------
  |  Branch (1650:9): [True: 2.05k, False: 0]
  ------------------
 1651|  2.05k|        ret->name = xmlStrdup(name);
 1652|  2.05k|    return(ret);
 1653|  2.05k|}
xmlFreeEnumeration:
 1662|  2.05k|xmlFreeEnumeration(xmlEnumerationPtr cur) {
 1663|  2.05k|    if (cur == NULL) return;
  ------------------
  |  Branch (1663:9): [True: 0, False: 2.05k]
  ------------------
 1664|       |
 1665|  2.05k|    if (cur->next != NULL) xmlFreeEnumeration(cur->next);
  ------------------
  |  Branch (1665:9): [True: 786, False: 1.26k]
  ------------------
 1666|       |
 1667|  2.05k|    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (1667:9): [True: 2.05k, False: 0]
  ------------------
 1668|  2.05k|    xmlFree(cur);
 1669|  2.05k|}
xmlAddAttributeDecl:
 1816|  5.83k|		    const xmlChar *defaultValue, xmlEnumerationPtr tree) {
 1817|  5.83k|    xmlAttributePtr ret;
 1818|  5.83k|    xmlAttributeTablePtr table;
 1819|  5.83k|    xmlElementPtr elemDef;
 1820|  5.83k|    xmlDictPtr dict = NULL;
 1821|       |
 1822|  5.83k|    if (dtd == NULL) {
  ------------------
  |  Branch (1822:9): [True: 0, False: 5.83k]
  ------------------
 1823|      0|	xmlFreeEnumeration(tree);
 1824|      0|	return(NULL);
 1825|      0|    }
 1826|  5.83k|    if (name == NULL) {
  ------------------
  |  Branch (1826:9): [True: 0, False: 5.83k]
  ------------------
 1827|      0|	xmlFreeEnumeration(tree);
 1828|      0|	return(NULL);
 1829|      0|    }
 1830|  5.83k|    if (elem == NULL) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 5.83k]
  ------------------
 1831|      0|	xmlFreeEnumeration(tree);
 1832|      0|	return(NULL);
 1833|      0|    }
 1834|  5.83k|    if (dtd->doc != NULL)
  ------------------
  |  Branch (1834:9): [True: 5.83k, False: 0]
  ------------------
 1835|  5.83k|	dict = dtd->doc->dict;
 1836|       |
 1837|  5.83k|#ifdef LIBXML_VALID_ENABLED
 1838|       |    /*
 1839|       |     * Check the type and possibly the default value.
 1840|       |     */
 1841|  5.83k|    switch (type) {
 1842|  2.25k|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (1842:9): [True: 2.25k, False: 3.58k]
  ------------------
 1843|  2.25k|	    break;
 1844|  1.29k|        case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (1844:9): [True: 1.29k, False: 4.54k]
  ------------------
 1845|  1.29k|	    break;
 1846|     66|        case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (1846:9): [True: 66, False: 5.76k]
  ------------------
 1847|     66|	    break;
 1848|     12|        case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (1848:9): [True: 12, False: 5.82k]
  ------------------
 1849|     12|	    break;
 1850|      9|        case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (1850:9): [True: 9, False: 5.82k]
  ------------------
 1851|      9|	    break;
 1852|      0|        case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (1852:9): [True: 0, False: 5.83k]
  ------------------
 1853|      0|	    break;
 1854|    789|        case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (1854:9): [True: 789, False: 5.04k]
  ------------------
 1855|    789|	    break;
 1856|    147|        case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (1856:9): [True: 147, False: 5.68k]
  ------------------
 1857|    147|	    break;
 1858|  1.26k|        case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (1858:9): [True: 1.26k, False: 4.56k]
  ------------------
 1859|  1.26k|	    break;
 1860|      0|        case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (1860:9): [True: 0, False: 5.83k]
  ------------------
 1861|      0|	    break;
 1862|      0|	default:
  ------------------
  |  Branch (1862:2): [True: 0, False: 5.83k]
  ------------------
 1863|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1864|      0|		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
 1865|      0|		    NULL);
 1866|      0|	    xmlFreeEnumeration(tree);
 1867|      0|	    return(NULL);
 1868|  5.83k|    }
 1869|  5.83k|    if ((defaultValue != NULL) &&
  ------------------
  |  Branch (1869:9): [True: 1.23k, False: 4.60k]
  ------------------
 1870|  5.83k|        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {
  ------------------
  |  Branch (1870:9): [True: 9, False: 1.22k]
  ------------------
 1871|      9|	xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,
 1872|      9|	                "Attribute %s of %s: invalid default value\n",
 1873|      9|	                elem, name, defaultValue);
 1874|      9|	defaultValue = NULL;
 1875|      9|	if (ctxt != NULL)
  ------------------
  |  Branch (1875:6): [True: 9, False: 0]
  ------------------
 1876|      9|	    ctxt->valid = 0;
 1877|      9|    }
 1878|  5.83k|#endif /* LIBXML_VALID_ENABLED */
 1879|       |
 1880|       |    /*
 1881|       |     * Check first that an attribute defined in the external subset wasn't
 1882|       |     * already defined in the internal subset
 1883|       |     */
 1884|  5.83k|    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&
  ------------------
  |  Branch (1884:9): [True: 5.83k, False: 0]
  |  Branch (1884:31): [True: 3.14k, False: 2.69k]
  ------------------
 1885|  5.83k|	(dtd->doc->intSubset != NULL) &&
  ------------------
  |  Branch (1885:2): [True: 3.14k, False: 0]
  ------------------
 1886|  5.83k|	(dtd->doc->intSubset->attributes != NULL)) {
  ------------------
  |  Branch (1886:2): [True: 1.49k, False: 1.64k]
  ------------------
 1887|  1.49k|        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);
 1888|  1.49k|	if (ret != NULL) {
  ------------------
  |  Branch (1888:6): [True: 0, False: 1.49k]
  ------------------
 1889|      0|	    xmlFreeEnumeration(tree);
 1890|      0|	    return(NULL);
 1891|      0|	}
 1892|  1.49k|    }
 1893|       |
 1894|       |    /*
 1895|       |     * Create the Attribute table if needed.
 1896|       |     */
 1897|  5.83k|    table = (xmlAttributeTablePtr) dtd->attributes;
 1898|  5.83k|    if (table == NULL) {
  ------------------
  |  Branch (1898:9): [True: 126, False: 5.70k]
  ------------------
 1899|    126|        table = xmlHashCreateDict(0, dict);
 1900|    126|	dtd->attributes = (void *) table;
 1901|    126|    }
 1902|  5.83k|    if (table == NULL) {
  ------------------
  |  Branch (1902:9): [True: 0, False: 5.83k]
  ------------------
 1903|      0|	xmlVErrMemory(ctxt,
 1904|      0|            "xmlAddAttributeDecl: Table creation failed!\n");
 1905|      0|	xmlFreeEnumeration(tree);
 1906|      0|        return(NULL);
 1907|      0|    }
 1908|       |
 1909|       |
 1910|  5.83k|    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
 1911|  5.83k|    if (ret == NULL) {
  ------------------
  |  Branch (1911:9): [True: 0, False: 5.83k]
  ------------------
 1912|      0|	xmlVErrMemory(ctxt, "malloc failed");
 1913|      0|	xmlFreeEnumeration(tree);
 1914|      0|	return(NULL);
 1915|      0|    }
 1916|  5.83k|    memset(ret, 0, sizeof(xmlAttribute));
 1917|  5.83k|    ret->type = XML_ATTRIBUTE_DECL;
 1918|       |
 1919|       |    /*
 1920|       |     * fill the structure.
 1921|       |     */
 1922|  5.83k|    ret->atype = type;
 1923|       |    /*
 1924|       |     * doc must be set before possible error causes call
 1925|       |     * to xmlFreeAttribute (because it's used to check on
 1926|       |     * dict use)
 1927|       |     */
 1928|  5.83k|    ret->doc = dtd->doc;
 1929|  5.83k|    if (dict) {
  ------------------
  |  Branch (1929:9): [True: 5.83k, False: 0]
  ------------------
 1930|  5.83k|	ret->name = xmlDictLookup(dict, name, -1);
 1931|  5.83k|	ret->prefix = xmlDictLookup(dict, ns, -1);
 1932|  5.83k|	ret->elem = xmlDictLookup(dict, elem, -1);
 1933|  5.83k|    } else {
 1934|      0|	ret->name = xmlStrdup(name);
 1935|      0|	ret->prefix = xmlStrdup(ns);
 1936|      0|	ret->elem = xmlStrdup(elem);
 1937|      0|    }
 1938|  5.83k|    ret->def = def;
 1939|  5.83k|    ret->tree = tree;
 1940|  5.83k|    if (defaultValue != NULL) {
  ------------------
  |  Branch (1940:9): [True: 1.22k, False: 4.61k]
  ------------------
 1941|  1.22k|        if (dict)
  ------------------
  |  Branch (1941:13): [True: 1.22k, False: 0]
  ------------------
 1942|  1.22k|	    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);
 1943|      0|	else
 1944|      0|	    ret->defaultValue = xmlStrdup(defaultValue);
 1945|  1.22k|    }
 1946|       |
 1947|       |    /*
 1948|       |     * Validity Check:
 1949|       |     * Search the DTD for previous declarations of the ATTLIST
 1950|       |     */
 1951|  5.83k|    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {
  ------------------
  |  Branch (1951:9): [True: 3, False: 5.83k]
  ------------------
 1952|      3|#ifdef LIBXML_VALID_ENABLED
 1953|       |	/*
 1954|       |	 * The attribute is already defined in this DTD.
 1955|       |	 */
 1956|      3|	xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,
 1957|      3|		 "Attribute %s of element %s: already defined\n",
 1958|      3|		 name, elem, NULL);
 1959|      3|#endif /* LIBXML_VALID_ENABLED */
 1960|      3|	xmlFreeAttribute(ret);
 1961|      3|	return(NULL);
 1962|      3|    }
 1963|       |
 1964|       |    /*
 1965|       |     * Validity Check:
 1966|       |     * Multiple ID per element
 1967|       |     */
 1968|  5.83k|    elemDef = xmlGetDtdElementDesc2(ctxt, dtd, elem, 1);
 1969|  5.83k|    if (elemDef != NULL) {
  ------------------
  |  Branch (1969:9): [True: 5.83k, False: 0]
  ------------------
 1970|       |
 1971|  5.83k|#ifdef LIBXML_VALID_ENABLED
 1972|  5.83k|        if ((type == XML_ATTRIBUTE_ID) &&
  ------------------
  |  Branch (1972:13): [True: 1.29k, False: 4.53k]
  ------------------
 1973|  5.83k|	    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {
  ------------------
  |  Branch (1973:6): [True: 9, False: 1.28k]
  ------------------
 1974|      9|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,
 1975|      9|	   "Element %s has too may ID attributes defined : %s\n",
 1976|      9|		   elem, name, NULL);
 1977|      9|	    if (ctxt != NULL)
  ------------------
  |  Branch (1977:10): [True: 9, False: 0]
  ------------------
 1978|      9|		ctxt->valid = 0;
 1979|      9|	}
 1980|  5.83k|#endif /* LIBXML_VALID_ENABLED */
 1981|       |
 1982|       |	/*
 1983|       |	 * Insert namespace default def first they need to be
 1984|       |	 * processed first.
 1985|       |	 */
 1986|  5.83k|	if ((xmlStrEqual(ret->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|  5.83k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1986:6): [True: 6, False: 5.82k]
  ------------------
 1987|  5.83k|	    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1987:8): [True: 234, False: 5.59k]
  ------------------
 1988|  5.82k|	     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns"))))) {
  ------------------
  |  |   35|    234|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1988:7): [True: 42, False: 192]
  ------------------
 1989|     48|	    ret->nexth = elemDef->attributes;
 1990|     48|	    elemDef->attributes = ret;
 1991|  5.78k|	} else {
 1992|  5.78k|	    xmlAttributePtr tmp = elemDef->attributes;
 1993|       |
 1994|  5.78k|	    while ((tmp != NULL) &&
  ------------------
  |  Branch (1994:13): [True: 4.35k, False: 1.42k]
  ------------------
 1995|  5.78k|		   ((xmlStrEqual(tmp->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|  4.35k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1995:7): [True: 0, False: 4.35k]
  ------------------
 1996|  4.35k|		    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1996:9): [True: 144, False: 4.21k]
  ------------------
 1997|  4.35k|		     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns")))))) {
  ------------------
  |  |   35|    144|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1997:8): [True: 0, False: 144]
  ------------------
 1998|      0|		if (tmp->nexth == NULL)
  ------------------
  |  Branch (1998:7): [True: 0, False: 0]
  ------------------
 1999|      0|		    break;
 2000|      0|		tmp = tmp->nexth;
 2001|      0|	    }
 2002|  5.78k|	    if (tmp != NULL) {
  ------------------
  |  Branch (2002:10): [True: 4.35k, False: 1.42k]
  ------------------
 2003|  4.35k|		ret->nexth = tmp->nexth;
 2004|  4.35k|	        tmp->nexth = ret;
 2005|  4.35k|	    } else {
 2006|  1.42k|		ret->nexth = elemDef->attributes;
 2007|  1.42k|		elemDef->attributes = ret;
 2008|  1.42k|	    }
 2009|  5.78k|	}
 2010|  5.83k|    }
 2011|       |
 2012|       |    /*
 2013|       |     * Link it to the DTD
 2014|       |     */
 2015|  5.83k|    ret->parent = dtd;
 2016|  5.83k|    if (dtd->last == NULL) {
  ------------------
  |  Branch (2016:9): [True: 12, False: 5.82k]
  ------------------
 2017|     12|	dtd->children = dtd->last = (xmlNodePtr) ret;
 2018|  5.82k|    } else {
 2019|  5.82k|        dtd->last->next = (xmlNodePtr) ret;
 2020|  5.82k|	ret->prev = dtd->last;
 2021|  5.82k|	dtd->last = (xmlNodePtr) ret;
 2022|  5.82k|    }
 2023|  5.83k|    return(ret);
 2024|  5.83k|}
xmlFreeAttributeTable:
 2038|    126|xmlFreeAttributeTable(xmlAttributeTablePtr table) {
 2039|    126|    xmlHashFree(table, xmlFreeAttributeTableEntry);
 2040|    126|}
xmlDumpAttributeDecl:
 2101|    595|xmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {
 2102|    595|    if ((buf == NULL) || (attr == NULL))
  ------------------
  |  Branch (2102:9): [True: 0, False: 595]
  |  Branch (2102:26): [True: 0, False: 595]
  ------------------
 2103|      0|        return;
 2104|    595|    xmlBufferWriteChar(buf, "<!ATTLIST ");
 2105|    595|    xmlBufferWriteCHAR(buf, attr->elem);
 2106|    595|    xmlBufferWriteChar(buf, " ");
 2107|    595|    if (attr->prefix != NULL) {
  ------------------
  |  Branch (2107:9): [True: 35, False: 560]
  ------------------
 2108|     35|	xmlBufferWriteCHAR(buf, attr->prefix);
 2109|     35|	xmlBufferWriteChar(buf, ":");
 2110|     35|    }
 2111|    595|    xmlBufferWriteCHAR(buf, attr->name);
 2112|    595|    switch (attr->atype) {
 2113|    248|	case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (2113:2): [True: 248, False: 347]
  ------------------
 2114|    248|	    xmlBufferWriteChar(buf, " CDATA");
 2115|    248|	    break;
 2116|    133|	case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (2116:2): [True: 133, False: 462]
  ------------------
 2117|    133|	    xmlBufferWriteChar(buf, " ID");
 2118|    133|	    break;
 2119|      6|	case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (2119:2): [True: 6, False: 589]
  ------------------
 2120|      6|	    xmlBufferWriteChar(buf, " IDREF");
 2121|      6|	    break;
 2122|      2|	case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (2122:2): [True: 2, False: 593]
  ------------------
 2123|      2|	    xmlBufferWriteChar(buf, " IDREFS");
 2124|      2|	    break;
 2125|      3|	case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (2125:2): [True: 3, False: 592]
  ------------------
 2126|      3|	    xmlBufferWriteChar(buf, " ENTITY");
 2127|      3|	    break;
 2128|      0|	case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (2128:2): [True: 0, False: 595]
  ------------------
 2129|      0|	    xmlBufferWriteChar(buf, " ENTITIES");
 2130|      0|	    break;
 2131|     71|	case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (2131:2): [True: 71, False: 524]
  ------------------
 2132|     71|	    xmlBufferWriteChar(buf, " NMTOKEN");
 2133|     71|	    break;
 2134|     47|	case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (2134:2): [True: 47, False: 548]
  ------------------
 2135|     47|	    xmlBufferWriteChar(buf, " NMTOKENS");
 2136|     47|	    break;
 2137|     85|	case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (2137:2): [True: 85, False: 510]
  ------------------
 2138|     85|	    xmlBufferWriteChar(buf, " (");
 2139|     85|	    xmlDumpEnumeration(buf, attr->tree);
 2140|     85|	    break;
 2141|      0|	case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (2141:2): [True: 0, False: 595]
  ------------------
 2142|      0|	    xmlBufferWriteChar(buf, " NOTATION (");
 2143|      0|	    xmlDumpEnumeration(buf, attr->tree);
 2144|      0|	    break;
 2145|      0|	default:
  ------------------
  |  Branch (2145:2): [True: 0, False: 595]
  ------------------
 2146|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2147|      0|		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
 2148|      0|		    NULL);
 2149|    595|    }
 2150|    595|    switch (attr->def) {
 2151|     26|	case XML_ATTRIBUTE_NONE:
  ------------------
  |  Branch (2151:2): [True: 26, False: 569]
  ------------------
 2152|     26|	    break;
 2153|     49|	case XML_ATTRIBUTE_REQUIRED:
  ------------------
  |  Branch (2153:2): [True: 49, False: 546]
  ------------------
 2154|     49|	    xmlBufferWriteChar(buf, " #REQUIRED");
 2155|     49|	    break;
 2156|    507|	case XML_ATTRIBUTE_IMPLIED:
  ------------------
  |  Branch (2156:2): [True: 507, False: 88]
  ------------------
 2157|    507|	    xmlBufferWriteChar(buf, " #IMPLIED");
 2158|    507|	    break;
 2159|     13|	case XML_ATTRIBUTE_FIXED:
  ------------------
  |  Branch (2159:2): [True: 13, False: 582]
  ------------------
 2160|     13|	    xmlBufferWriteChar(buf, " #FIXED");
 2161|     13|	    break;
 2162|      0|	default:
  ------------------
  |  Branch (2162:2): [True: 0, False: 595]
  ------------------
 2163|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2164|      0|		    "Internal: ATTRIBUTE struct corrupted invalid def\n",
 2165|      0|		    NULL);
 2166|    595|    }
 2167|    595|    if (attr->defaultValue != NULL) {
  ------------------
  |  Branch (2167:9): [True: 36, False: 559]
  ------------------
 2168|     36|	xmlBufferWriteChar(buf, " ");
 2169|     36|	xmlBufferWriteQuotedString(buf, attr->defaultValue);
 2170|     36|    }
 2171|    595|    xmlBufferWriteChar(buf, ">\n");
 2172|    595|}
xmlAddID:
 2518|    999|         xmlAttrPtr attr) {
 2519|    999|    xmlIDPtr ret;
 2520|    999|    xmlIDTablePtr table;
 2521|       |
 2522|    999|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 999]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|    999|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 999]
  |  Branch (2525:28): [True: 0, False: 999]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|    999|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 999]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|    999|    table = (xmlIDTablePtr) doc->ids;
 2536|    999|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 45, False: 954]
  ------------------
 2537|     45|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|     45|    }
 2539|    999|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 999]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|    999|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|    999|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 999]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|    999|    ret->value = xmlStrdup(value);
 2555|    999|    ret->doc = doc;
 2556|    999|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 329, False: 670]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|    329|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 329, False: 0]
  ------------------
 2561|    329|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|    329|	ret->attr = NULL;
 2565|    670|    } else {
 2566|    670|	ret->attr = attr;
 2567|    670|	ret->name = NULL;
 2568|    670|    }
 2569|    999|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|    999|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 12, False: 987]
  ------------------
 2572|     12|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|     12|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 6, False: 6]
  ------------------
 2577|      6|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      6|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      6|	}
 2580|     12|#endif /* LIBXML_VALID_ENABLED */
 2581|     12|	xmlFreeID(ret);
 2582|     12|	return(NULL);
 2583|     12|    }
 2584|    987|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 987, False: 0]
  ------------------
 2585|    987|	attr->atype = XML_ATTRIBUTE_ID;
 2586|    987|    return(ret);
 2587|    999|}
xmlFreeIDTable:
 2601|     45|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|     45|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|     45|}
xmlIsID:
 2619|  64.0k|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|  64.0k|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 64.0k]
  |  Branch (2620:27): [True: 0, False: 64.0k]
  ------------------
 2621|  64.0k|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 582, False: 63.4k]
  |  Branch (2621:31): [True: 582, False: 0]
  ------------------
 2622|  64.0k|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 12, False: 570]
  ------------------
 2623|  64.0k|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 0, False: 12]
  ------------------
 2624|      0|	return(1);
 2625|  64.0k|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 64.0k]
  ------------------
 2626|  64.0k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 58.1k, False: 5.92k]
  |  Branch (2626:37): [True: 58.1k, False: 0]
  ------------------
 2627|  64.0k|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 58.1k, False: 0]
  ------------------
 2628|  58.1k|	return(0);
 2629|  58.1k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 0, False: 5.92k]
  ------------------
 2630|      0|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 0, False: 0]
  ------------------
 2631|      0|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 0, False: 0]
  ------------------
 2632|      0|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 0]
  |  Branch (2632:25): [True: 0, False: 0]
  ------------------
 2633|      0|	    return(1);
 2634|      0|	return(0);
 2635|  5.92k|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 5.92k]
  ------------------
 2636|      0|	return(0);
 2637|  5.92k|    } else {
 2638|  5.92k|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|  5.92k|	xmlChar felem[50], fattr[50];
 2641|  5.92k|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|  5.92k|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 216, False: 5.70k]
  |  Branch (2643:38): [True: 213, False: 3]
  ------------------
 2644|    213|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|  5.92k|	    (xmlChar *)elem->name;
 2646|       |
 2647|  5.92k|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 225, False: 5.69k]
  |  Branch (2647:38): [True: 225, False: 0]
  ------------------
 2648|    225|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|  5.92k|	    (xmlChar *)attr->name;
 2650|       |
 2651|  5.92k|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 5.92k, False: 0]
  |  Branch (2651:30): [True: 5.92k, False: 0]
  ------------------
 2652|  5.92k|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|  5.92k|		                         fullattrname);
 2654|  5.92k|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 5.55k, False: 363]
  |  Branch (2654:32): [True: 3.95k, False: 1.60k]
  ------------------
 2655|  3.95k|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|  3.95k|					     fullattrname);
 2657|  5.92k|	}
 2658|       |
 2659|  5.92k|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 5.69k, False: 225]
  |  Branch (2659:33): [True: 0, False: 5.69k]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|  5.92k|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 5.70k, False: 213]
  |  Branch (2661:33): [True: 0, False: 5.70k]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|  5.92k|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 4.31k, False: 1.60k]
  |  Branch (2664:35): [True: 978, False: 3.33k]
  ------------------
 2665|    978|	    return(1);
 2666|  5.92k|    }
 2667|  4.94k|    return(0);
 2668|  64.0k|}
xmlRemoveID:
 2680|    660|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|    660|    xmlIDTablePtr table;
 2682|    660|    xmlIDPtr id;
 2683|    660|    xmlChar *ID;
 2684|       |
 2685|    660|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 660]
  ------------------
 2686|    660|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 660]
  ------------------
 2687|       |
 2688|    660|    table = (xmlIDTablePtr) doc->ids;
 2689|    660|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 660, False: 0]
  ------------------
 2690|    660|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlAddRef:
 2849|  1.98k|    xmlAttrPtr attr) {
 2850|  1.98k|    xmlRefPtr ret;
 2851|  1.98k|    xmlRefTablePtr table;
 2852|  1.98k|    xmlListPtr ref_list;
 2853|       |
 2854|  1.98k|    if (doc == NULL) {
  ------------------
  |  Branch (2854:9): [True: 0, False: 1.98k]
  ------------------
 2855|      0|        return(NULL);
 2856|      0|    }
 2857|  1.98k|    if (value == NULL) {
  ------------------
  |  Branch (2857:9): [True: 0, False: 1.98k]
  ------------------
 2858|      0|        return(NULL);
 2859|      0|    }
 2860|  1.98k|    if (attr == NULL) {
  ------------------
  |  Branch (2860:9): [True: 0, False: 1.98k]
  ------------------
 2861|      0|        return(NULL);
 2862|      0|    }
 2863|       |
 2864|       |    /*
 2865|       |     * Create the Ref table if needed.
 2866|       |     */
 2867|  1.98k|    table = (xmlRefTablePtr) doc->refs;
 2868|  1.98k|    if (table == NULL) {
  ------------------
  |  Branch (2868:9): [True: 15, False: 1.97k]
  ------------------
 2869|     15|        doc->refs = table = xmlHashCreateDict(0, doc->dict);
 2870|     15|    }
 2871|  1.98k|    if (table == NULL) {
  ------------------
  |  Branch (2871:9): [True: 0, False: 1.98k]
  ------------------
 2872|      0|	xmlVErrMemory(ctxt,
 2873|      0|            "xmlAddRef: Table creation failed!\n");
 2874|      0|        return(NULL);
 2875|      0|    }
 2876|       |
 2877|  1.98k|    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));
 2878|  1.98k|    if (ret == NULL) {
  ------------------
  |  Branch (2878:9): [True: 0, False: 1.98k]
  ------------------
 2879|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2880|      0|        return(NULL);
 2881|      0|    }
 2882|       |
 2883|       |    /*
 2884|       |     * fill the structure.
 2885|       |     */
 2886|  1.98k|    ret->value = xmlStrdup(value);
 2887|  1.98k|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2887:9): [True: 663, False: 1.32k]
  ------------------
 2888|       |	/*
 2889|       |	 * Operating in streaming mode, attr is gonna disappear
 2890|       |	 */
 2891|    663|	ret->name = xmlStrdup(attr->name);
 2892|    663|	ret->attr = NULL;
 2893|  1.32k|    } else {
 2894|  1.32k|	ret->name = NULL;
 2895|  1.32k|	ret->attr = attr;
 2896|  1.32k|    }
 2897|  1.98k|    ret->lineno = xmlGetLineNo(attr->parent);
 2898|       |
 2899|       |    /* To add a reference :-
 2900|       |     * References are maintained as a list of references,
 2901|       |     * Lookup the entry, if no entry create new nodelist
 2902|       |     * Add the owning node to the NodeList
 2903|       |     * Return the ref
 2904|       |     */
 2905|       |
 2906|  1.98k|    if (NULL == (ref_list = xmlHashLookup(table, value))) {
  ------------------
  |  Branch (2906:9): [True: 657, False: 1.33k]
  ------------------
 2907|    657|        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {
  ------------------
  |  Branch (2907:13): [True: 0, False: 657]
  ------------------
 2908|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2909|      0|		    "xmlAddRef: Reference list creation failed!\n",
 2910|      0|		    NULL);
 2911|      0|	    goto failed;
 2912|      0|        }
 2913|    657|        if (xmlHashAddEntry(table, value, ref_list) < 0) {
  ------------------
  |  Branch (2913:13): [True: 0, False: 657]
  ------------------
 2914|      0|            xmlListDelete(ref_list);
 2915|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2916|      0|		    "xmlAddRef: Reference list insertion failed!\n",
 2917|      0|		    NULL);
 2918|      0|	    goto failed;
 2919|      0|        }
 2920|    657|    }
 2921|  1.98k|    if (xmlListAppend(ref_list, ret) != 0) {
  ------------------
  |  Branch (2921:9): [True: 0, False: 1.98k]
  ------------------
 2922|      0|	xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 2923|      0|		    "xmlAddRef: Reference list insertion failed!\n",
 2924|      0|		    NULL);
 2925|      0|        goto failed;
 2926|      0|    }
 2927|  1.98k|    return(ret);
 2928|      0|failed:
 2929|      0|    if (ret != NULL) {
  ------------------
  |  Branch (2929:9): [True: 0, False: 0]
  ------------------
 2930|      0|        if (ret->value != NULL)
  ------------------
  |  Branch (2930:13): [True: 0, False: 0]
  ------------------
 2931|      0|	    xmlFree((char *)ret->value);
 2932|      0|        if (ret->name != NULL)
  ------------------
  |  Branch (2932:13): [True: 0, False: 0]
  ------------------
 2933|      0|	    xmlFree((char *)ret->name);
 2934|      0|        xmlFree(ret);
 2935|      0|    }
 2936|      0|    return(NULL);
 2937|  1.98k|}
xmlFreeRefTable:
 2948|     15|xmlFreeRefTable(xmlRefTablePtr table) {
 2949|     15|    xmlHashFree(table, xmlFreeRefTableEntry);
 2950|     15|}
xmlIsRef:
 2967|  63.0k|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|  63.0k|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 63.0k]
  ------------------
 2969|      0|        return(0);
 2970|  63.0k|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 63.0k]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|  63.0k|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 58.1k, False: 4.94k]
  |  Branch (2975:37): [True: 58.1k, False: 0]
  ------------------
 2976|  58.1k|        return(0);
 2977|  58.1k|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 0, False: 4.94k]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|      0|        return(0);
 2980|  4.94k|    } else {
 2981|  4.94k|        xmlAttributePtr attrDecl;
 2982|       |
 2983|  4.94k|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 4.94k]
  ------------------
 2984|  4.94k|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|  4.94k|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 4.81k, False: 132]
  |  Branch (2985:35): [True: 3.00k, False: 1.80k]
  ------------------
 2986|  3.00k|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|  3.00k|		                         elem->name, attr->name);
 2988|       |
 2989|  4.94k|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 3.13k, False: 1.80k]
  ------------------
 2990|  4.94k|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 1.98k, False: 1.14k]
  ------------------
 2991|  3.13k|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 1.14k]
  ------------------
 2992|  1.98k|	return(1);
 2993|  4.94k|    }
 2994|  2.95k|    return(0);
 2995|  63.0k|}
xmlGetDtdAttrDesc:
 3230|  17.8k|xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {
 3231|  17.8k|    xmlAttributeTablePtr table;
 3232|  17.8k|    xmlAttributePtr cur;
 3233|  17.8k|    xmlChar *uqname = NULL, *prefix = NULL;
 3234|       |
 3235|  17.8k|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3235:9): [True: 0, False: 17.8k]
  ------------------
 3236|  17.8k|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3236:9): [True: 9.93k, False: 7.88k]
  ------------------
 3237|       |
 3238|  7.88k|    table = (xmlAttributeTablePtr) dtd->attributes;
 3239|  7.88k|    if (table == NULL)
  ------------------
  |  Branch (3239:9): [True: 0, False: 7.88k]
  ------------------
 3240|      0|	return(NULL);
 3241|       |
 3242|  7.88k|    uqname = xmlSplitQName2(name, &prefix);
 3243|       |
 3244|  7.88k|    if (uqname != NULL) {
  ------------------
  |  Branch (3244:9): [True: 219, False: 7.66k]
  ------------------
 3245|    219|	cur = xmlHashLookup3(table, uqname, prefix, elem);
 3246|    219|	if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3246:6): [True: 219, False: 0]
  ------------------
 3247|    219|	if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3247:6): [True: 219, False: 0]
  ------------------
 3248|    219|    } else
 3249|  7.66k|	cur = xmlHashLookup3(table, name, NULL, elem);
 3250|  7.88k|    return(cur);
 3251|  7.88k|}
valid.c:xmlErrValidNode:
  137|     27|{
  138|     27|    xmlStructuredErrorFunc schannel = NULL;
  139|     27|    xmlGenericErrorFunc channel = NULL;
  140|     27|    xmlParserCtxtPtr pctxt = NULL;
  141|     27|    void *data = NULL;
  142|       |
  143|     27|    if (ctxt != NULL) {
  ------------------
  |  Branch (143:9): [True: 27, False: 0]
  ------------------
  144|     27|        channel = ctxt->error;
  145|     27|        data = ctxt->userData;
  146|       |	/* Look up flag to detect if it is part of a parsing
  147|       |	   context */
  148|     27|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|     27|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (148:6): [True: 27, False: 0]
  ------------------
  149|     27|	    pctxt = ctxt->userData;
  150|     27|	}
  151|     27|    }
  152|     27|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  153|     27|                    XML_ERR_ERROR, NULL, 0,
  154|     27|                    (const char *) str1,
  155|     27|                    (const char *) str2,
  156|     27|                    (const char *) str3, 0, 0, msg, str1, str2, str3);
  157|     27|}
valid.c:xmlFreeElement:
 1234|  2.35k|xmlFreeElement(xmlElementPtr elem) {
 1235|  2.35k|    if (elem == NULL) return;
  ------------------
  |  Branch (1235:9): [True: 0, False: 2.35k]
  ------------------
 1236|  2.35k|    xmlUnlinkNode((xmlNodePtr) elem);
 1237|  2.35k|    xmlFreeDocElementContent(elem->doc, elem->content);
 1238|  2.35k|    if (elem->name != NULL)
  ------------------
  |  Branch (1238:9): [True: 2.35k, False: 0]
  ------------------
 1239|  2.35k|	xmlFree((xmlChar *) elem->name);
 1240|  2.35k|    if (elem->prefix != NULL)
  ------------------
  |  Branch (1240:9): [True: 81, False: 2.27k]
  ------------------
 1241|     81|	xmlFree((xmlChar *) elem->prefix);
 1242|  2.35k|#ifdef LIBXML_REGEXP_ENABLED
 1243|  2.35k|    if (elem->contModel != NULL)
  ------------------
  |  Branch (1243:9): [True: 0, False: 2.35k]
  ------------------
 1244|      0|	xmlRegFreeRegexp(elem->contModel);
 1245|  2.35k|#endif
 1246|  2.35k|    xmlFree(elem);
 1247|  2.35k|}
valid.c:xmlFreeElementTableEntry:
 1475|  2.34k|xmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {
 1476|  2.34k|    xmlFreeElement((xmlElementPtr) elem);
 1477|  2.34k|}
valid.c:xmlDumpElementContent:
 1037|    263|xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content) {
 1038|    263|    xmlElementContentPtr cur;
 1039|       |
 1040|    263|    if (content == NULL) return;
  ------------------
  |  Branch (1040:9): [True: 0, False: 263]
  ------------------
 1041|       |
 1042|    263|    xmlBufferWriteChar(buf, "(");
 1043|    263|    cur = content;
 1044|       |
 1045|  1.53k|    do {
 1046|  1.53k|        if (cur == NULL) return;
  ------------------
  |  Branch (1046:13): [True: 0, False: 1.53k]
  ------------------
 1047|       |
 1048|  1.53k|        switch (cur->type) {
 1049|    159|            case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (1049:13): [True: 159, False: 1.37k]
  ------------------
 1050|    159|                xmlBufferWriteChar(buf, "#PCDATA");
 1051|    159|                break;
 1052|    739|            case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (1052:13): [True: 739, False: 794]
  ------------------
 1053|    739|                if (cur->prefix != NULL) {
  ------------------
  |  Branch (1053:21): [True: 28, False: 711]
  ------------------
 1054|     28|                    xmlBufferWriteCHAR(buf, cur->prefix);
 1055|     28|                    xmlBufferWriteChar(buf, ":");
 1056|     28|                }
 1057|    739|                xmlBufferWriteCHAR(buf, cur->name);
 1058|    739|                break;
 1059|     93|            case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (1059:13): [True: 93, False: 1.44k]
  ------------------
 1060|    635|            case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (1060:13): [True: 542, False: 991]
  ------------------
 1061|    635|                if ((cur != content) &&
  ------------------
  |  Branch (1061:21): [True: 529, False: 106]
  ------------------
 1062|    635|                    (cur->parent != NULL) &&
  ------------------
  |  Branch (1062:21): [True: 529, False: 0]
  ------------------
 1063|    635|                    ((cur->type != cur->parent->type) ||
  ------------------
  |  Branch (1063:22): [True: 15, False: 514]
  ------------------
 1064|    529|                     (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))
  ------------------
  |  Branch (1064:22): [True: 4, False: 510]
  ------------------
 1065|     19|                    xmlBufferWriteChar(buf, "(");
 1066|    635|                cur = cur->c1;
 1067|    635|                continue;
 1068|      0|            default:
  ------------------
  |  Branch (1068:13): [True: 0, False: 1.53k]
  ------------------
 1069|      0|                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
 1070|      0|                        "Internal: ELEMENT cur corrupted invalid type\n",
 1071|      0|                        NULL);
 1072|  1.53k|        }
 1073|       |
 1074|  1.53k|        while (cur != content) {
  ------------------
  |  Branch (1074:16): [True: 1.27k, False: 263]
  ------------------
 1075|  1.27k|            xmlElementContentPtr parent = cur->parent;
 1076|       |
 1077|  1.27k|            if (parent == NULL) return;
  ------------------
  |  Branch (1077:17): [True: 0, False: 1.27k]
  ------------------
 1078|       |
 1079|  1.27k|            if (((cur->type == XML_ELEMENT_CONTENT_OR) ||
  ------------------
  |  Branch (1079:18): [True: 473, False: 797]
  ------------------
 1080|  1.27k|                 (cur->type == XML_ELEMENT_CONTENT_SEQ)) &&
  ------------------
  |  Branch (1080:18): [True: 56, False: 741]
  ------------------
 1081|  1.27k|                ((cur->type != parent->type) ||
  ------------------
  |  Branch (1081:18): [True: 15, False: 514]
  ------------------
 1082|    529|                 (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))
  ------------------
  |  Branch (1082:18): [True: 4, False: 510]
  ------------------
 1083|     19|                xmlBufferWriteChar(buf, ")");
 1084|  1.27k|            xmlDumpElementOccur(buf, cur);
 1085|       |
 1086|  1.27k|            if (cur == parent->c1) {
  ------------------
  |  Branch (1086:17): [True: 635, False: 635]
  ------------------
 1087|    635|                if (parent->type == XML_ELEMENT_CONTENT_SEQ)
  ------------------
  |  Branch (1087:21): [True: 93, False: 542]
  ------------------
 1088|     93|                    xmlBufferWriteChar(buf, " , ");
 1089|    542|                else if (parent->type == XML_ELEMENT_CONTENT_OR)
  ------------------
  |  Branch (1089:26): [True: 542, False: 0]
  ------------------
 1090|    542|                    xmlBufferWriteChar(buf, " | ");
 1091|       |
 1092|    635|                cur = parent->c2;
 1093|    635|                break;
 1094|    635|            }
 1095|       |
 1096|    635|            cur = parent;
 1097|    635|        }
 1098|  1.53k|    } while (cur != content);
  ------------------
  |  Branch (1098:14): [True: 1.27k, False: 263]
  ------------------
 1099|       |
 1100|    263|    xmlBufferWriteChar(buf, ")");
 1101|    263|    xmlDumpElementOccur(buf, content);
 1102|    263|}
valid.c:xmlDumpElementOccur:
 1013|  1.53k|xmlDumpElementOccur(xmlBufferPtr buf, xmlElementContentPtr cur) {
 1014|  1.53k|    switch (cur->ocur) {
  ------------------
  |  Branch (1014:13): [True: 0, False: 1.53k]
  ------------------
 1015|  1.33k|        case XML_ELEMENT_CONTENT_ONCE:
  ------------------
  |  Branch (1015:9): [True: 1.33k, False: 199]
  ------------------
 1016|  1.33k|            break;
 1017|     55|        case XML_ELEMENT_CONTENT_OPT:
  ------------------
  |  Branch (1017:9): [True: 55, False: 1.47k]
  ------------------
 1018|     55|            xmlBufferWriteChar(buf, "?");
 1019|     55|            break;
 1020|    109|        case XML_ELEMENT_CONTENT_MULT:
  ------------------
  |  Branch (1020:9): [True: 109, False: 1.42k]
  ------------------
 1021|    109|            xmlBufferWriteChar(buf, "*");
 1022|    109|            break;
 1023|     35|        case XML_ELEMENT_CONTENT_PLUS:
  ------------------
  |  Branch (1023:9): [True: 35, False: 1.49k]
  ------------------
 1024|     35|            xmlBufferWriteChar(buf, "+");
 1025|     35|            break;
 1026|  1.53k|    }
 1027|  1.53k|}
valid.c:xmlErrValidWarning:
  215|      3|{
  216|      3|    xmlStructuredErrorFunc schannel = NULL;
  217|      3|    xmlGenericErrorFunc channel = NULL;
  218|      3|    xmlParserCtxtPtr pctxt = NULL;
  219|      3|    void *data = NULL;
  220|       |
  221|      3|    if (ctxt != NULL) {
  ------------------
  |  Branch (221:9): [True: 3, False: 0]
  ------------------
  222|      3|        channel = ctxt->warning;
  223|      3|        data = ctxt->userData;
  224|       |	/* Look up flag to detect if it is part of a parsing
  225|       |	   context */
  226|      3|	if (ctxt->flags & XML_VCTXT_USE_PCTXT) {
  ------------------
  |  |   18|      3|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (226:6): [True: 3, False: 0]
  ------------------
  227|      3|	    pctxt = ctxt->userData;
  228|      3|	}
  229|      3|    }
  230|      3|    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,
  231|      3|                    XML_ERR_WARNING, NULL, 0,
  232|      3|                    (const char *) str1,
  233|      3|                    (const char *) str2,
  234|      3|                    (const char *) str3, 0, 0, msg, str1, str2, str3);
  235|      3|}
valid.c:xmlFreeAttribute:
 1759|  5.83k|xmlFreeAttribute(xmlAttributePtr attr) {
 1760|  5.83k|    xmlDictPtr dict;
 1761|       |
 1762|  5.83k|    if (attr == NULL) return;
  ------------------
  |  Branch (1762:9): [True: 0, False: 5.83k]
  ------------------
 1763|  5.83k|    if (attr->doc != NULL)
  ------------------
  |  Branch (1763:9): [True: 5.83k, False: 0]
  ------------------
 1764|  5.83k|	dict = attr->doc->dict;
 1765|      0|    else
 1766|      0|	dict = NULL;
 1767|  5.83k|    xmlUnlinkNode((xmlNodePtr) attr);
 1768|  5.83k|    if (attr->tree != NULL)
  ------------------
  |  Branch (1768:9): [True: 1.26k, False: 4.56k]
  ------------------
 1769|  1.26k|        xmlFreeEnumeration(attr->tree);
 1770|  5.83k|    if (dict) {
  ------------------
  |  Branch (1770:9): [True: 5.83k, False: 0]
  ------------------
 1771|  5.83k|        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))
  ------------------
  |  Branch (1771:13): [True: 5.83k, False: 0]
  |  Branch (1771:37): [True: 0, False: 5.83k]
  ------------------
 1772|      0|	    xmlFree((xmlChar *) attr->elem);
 1773|  5.83k|        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))
  ------------------
  |  Branch (1773:13): [True: 5.83k, False: 0]
  |  Branch (1773:37): [True: 0, False: 5.83k]
  ------------------
 1774|      0|	    xmlFree((xmlChar *) attr->name);
 1775|  5.83k|        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))
  ------------------
  |  Branch (1775:13): [True: 234, False: 5.60k]
  |  Branch (1775:39): [True: 0, False: 234]
  ------------------
 1776|      0|	    xmlFree((xmlChar *) attr->prefix);
 1777|  5.83k|        if ((attr->defaultValue != NULL) &&
  ------------------
  |  Branch (1777:13): [True: 1.22k, False: 4.61k]
  ------------------
 1778|  5.83k|	    (!xmlDictOwns(dict, attr->defaultValue)))
  ------------------
  |  Branch (1778:6): [True: 0, False: 1.22k]
  ------------------
 1779|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1780|  5.83k|    } else {
 1781|      0|	if (attr->elem != NULL)
  ------------------
  |  Branch (1781:6): [True: 0, False: 0]
  ------------------
 1782|      0|	    xmlFree((xmlChar *) attr->elem);
 1783|      0|	if (attr->name != NULL)
  ------------------
  |  Branch (1783:6): [True: 0, False: 0]
  ------------------
 1784|      0|	    xmlFree((xmlChar *) attr->name);
 1785|      0|	if (attr->defaultValue != NULL)
  ------------------
  |  Branch (1785:6): [True: 0, False: 0]
  ------------------
 1786|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1787|      0|	if (attr->prefix != NULL)
  ------------------
  |  Branch (1787:6): [True: 0, False: 0]
  ------------------
 1788|      0|	    xmlFree((xmlChar *) attr->prefix);
 1789|      0|    }
 1790|  5.83k|    xmlFree(attr);
 1791|  5.83k|}
valid.c:xmlScanIDAttributeDecl:
 1732|  1.29k|xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {
 1733|  1.29k|    xmlAttributePtr cur;
 1734|  1.29k|    int ret = 0;
 1735|       |
 1736|  1.29k|    if (elem == NULL) return(0);
  ------------------
  |  Branch (1736:9): [True: 0, False: 1.29k]
  ------------------
 1737|  1.29k|    cur = elem->attributes;
 1738|  1.32k|    while (cur != NULL) {
  ------------------
  |  Branch (1738:12): [True: 30, False: 1.29k]
  ------------------
 1739|     30|        if (cur->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (1739:13): [True: 9, False: 21]
  ------------------
 1740|      9|	    ret ++;
 1741|      9|	    if ((ret > 1) && (err))
  ------------------
  |  Branch (1741:10): [True: 0, False: 9]
  |  Branch (1741:23): [True: 0, False: 0]
  ------------------
 1742|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,
 1743|      0|	       "Element %s has too many ID attributes defined : %s\n",
 1744|      0|		       elem->name, cur->name, NULL);
 1745|      9|	}
 1746|     30|	cur = cur->nexth;
 1747|     30|    }
 1748|  1.29k|    return(ret);
 1749|  1.29k|}
valid.c:xmlFreeAttributeTableEntry:
 2027|  5.83k|xmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {
 2028|  5.83k|    xmlFreeAttribute((xmlAttributePtr) attr);
 2029|  5.83k|}
valid.c:xmlDumpEnumeration:
 1705|    250|xmlDumpEnumeration(xmlBufferPtr buf, xmlEnumerationPtr cur) {
 1706|    250|    if ((buf == NULL) || (cur == NULL))
  ------------------
  |  Branch (1706:9): [True: 0, False: 250]
  |  Branch (1706:26): [True: 0, False: 250]
  ------------------
 1707|      0|        return;
 1708|       |
 1709|    250|    xmlBufferWriteCHAR(buf, cur->name);
 1710|    250|    if (cur->next == NULL)
  ------------------
  |  Branch (1710:9): [True: 85, False: 165]
  ------------------
 1711|     85|	xmlBufferWriteChar(buf, ")");
 1712|    165|    else {
 1713|    165|	xmlBufferWriteChar(buf, " | ");
 1714|    165|	xmlDumpEnumeration(buf, cur->next);
 1715|    165|    }
 1716|    250|}
valid.c:xmlIsStreaming:
 2471|  2.98k|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|  2.98k|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|  2.98k|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 6, False: 2.98k]
  ------------------
 2475|      6|        return(0);
 2476|  2.98k|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|  2.98k|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 0, False: 2.98k]
  ------------------
 2477|      0|        return(0);
 2478|  2.98k|    pctxt = ctxt->userData;
 2479|  2.98k|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|  2.98k|}
valid.c:xmlFreeID:
 2489|    999|xmlFreeID(xmlIDPtr id) {
 2490|    999|    xmlDictPtr dict = NULL;
 2491|       |
 2492|    999|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 999]
  ------------------
 2493|       |
 2494|    999|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 999, False: 0]
  ------------------
 2495|    999|        dict = id->doc->dict;
 2496|       |
 2497|    999|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 999, False: 0]
  ------------------
 2498|    999|	DICT_FREE(id->value)
  ------------------
  |  | 2437|    999|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 999, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 999]
  |  |  ------------------
  |  | 2438|    999|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 999, False: 0]
  |  |  ------------------
  |  | 2439|    999|	    xmlFree((char *)(str));
  ------------------
 2499|    999|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 329, False: 670]
  ------------------
 2500|    329|	DICT_FREE(id->name)
  ------------------
  |  | 2437|    329|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 329, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 329]
  |  |  ------------------
  |  | 2438|    329|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 329]
  |  |  ------------------
  |  | 2439|    329|	    xmlFree((char *)(str));
  ------------------
 2501|    999|    xmlFree(id);
 2502|    999|}
valid.c:xmlFreeIDTableEntry:
 2590|    987|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|    987|    xmlFreeID((xmlIDPtr) id);
 2592|    987|}
valid.c:xmlFreeRef:
 2776|  1.98k|xmlFreeRef(xmlLinkPtr lk) {
 2777|  1.98k|    xmlRefPtr ref = (xmlRefPtr)xmlLinkGetData(lk);
 2778|  1.98k|    if (ref == NULL) return;
  ------------------
  |  Branch (2778:9): [True: 0, False: 1.98k]
  ------------------
 2779|  1.98k|    if (ref->value != NULL)
  ------------------
  |  Branch (2779:9): [True: 1.98k, False: 0]
  ------------------
 2780|  1.98k|        xmlFree((xmlChar *)ref->value);
 2781|  1.98k|    if (ref->name != NULL)
  ------------------
  |  Branch (2781:9): [True: 663, False: 1.32k]
  ------------------
 2782|    663|        xmlFree((xmlChar *)ref->name);
 2783|  1.98k|    xmlFree(ref);
 2784|  1.98k|}
valid.c:xmlDummyCompare:
 2830|  1.33k|{
 2831|  1.33k|    return (0);
 2832|  1.33k|}
valid.c:xmlFreeRefTableEntry:
 2793|    657|xmlFreeRefTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {
 2794|    657|    xmlListPtr list_ref = (xmlListPtr) payload;
 2795|    657|    if (list_ref == NULL) return;
  ------------------
  |  Branch (2795:9): [True: 0, False: 657]
  ------------------
 2796|    657|    xmlListDelete(list_ref);
 2797|    657|}
valid.c:xmlGetDtdElementDesc2:
 3133|  5.83k|                      int create) {
 3134|  5.83k|    xmlElementTablePtr table;
 3135|  5.83k|    xmlElementPtr cur;
 3136|  5.83k|    xmlChar *uqname = NULL, *prefix = NULL;
 3137|       |
 3138|  5.83k|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3138:9): [True: 0, False: 5.83k]
  ------------------
 3139|  5.83k|    if (dtd->elements == NULL) {
  ------------------
  |  Branch (3139:9): [True: 15, False: 5.81k]
  ------------------
 3140|     15|	xmlDictPtr dict = NULL;
 3141|       |
 3142|     15|	if (dtd->doc != NULL)
  ------------------
  |  Branch (3142:6): [True: 15, False: 0]
  ------------------
 3143|     15|	    dict = dtd->doc->dict;
 3144|       |
 3145|     15|	if (!create)
  ------------------
  |  Branch (3145:6): [True: 0, False: 15]
  ------------------
 3146|      0|	    return(NULL);
 3147|       |	/*
 3148|       |	 * Create the Element table if needed.
 3149|       |	 */
 3150|     15|	table = (xmlElementTablePtr) dtd->elements;
 3151|     15|	if (table == NULL) {
  ------------------
  |  Branch (3151:6): [True: 15, False: 0]
  ------------------
 3152|     15|	    table = xmlHashCreateDict(0, dict);
 3153|     15|	    dtd->elements = (void *) table;
 3154|     15|	}
 3155|     15|	if (table == NULL) {
  ------------------
  |  Branch (3155:6): [True: 0, False: 15]
  ------------------
 3156|      0|	    xmlVErrMemory(ctxt, "element table allocation failed");
 3157|      0|	    return(NULL);
 3158|      0|	}
 3159|     15|    }
 3160|  5.83k|    table = (xmlElementTablePtr) dtd->elements;
 3161|       |
 3162|  5.83k|    uqname = xmlSplitQName2(name, &prefix);
 3163|  5.83k|    if (uqname != NULL)
  ------------------
  |  Branch (3163:9): [True: 84, False: 5.74k]
  ------------------
 3164|     84|        name = uqname;
 3165|  5.83k|    cur = xmlHashLookup2(table, name, prefix);
 3166|  5.83k|    if ((cur == NULL) && (create)) {
  ------------------
  |  Branch (3166:9): [True: 21, False: 5.81k]
  |  Branch (3166:26): [True: 21, False: 0]
  ------------------
 3167|     21|	cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 3168|     21|	if (cur == NULL) {
  ------------------
  |  Branch (3168:6): [True: 0, False: 21]
  ------------------
 3169|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 3170|      0|	    goto error;
 3171|      0|	}
 3172|     21|	memset(cur, 0, sizeof(xmlElement));
 3173|     21|	cur->type = XML_ELEMENT_DECL;
 3174|       |
 3175|       |	/*
 3176|       |	 * fill the structure.
 3177|       |	 */
 3178|     21|	cur->name = xmlStrdup(name);
 3179|     21|	cur->prefix = xmlStrdup(prefix);
 3180|     21|	cur->etype = XML_ELEMENT_TYPE_UNDEFINED;
 3181|       |
 3182|     21|	if (xmlHashAddEntry2(table, name, prefix, cur) < 0) {
  ------------------
  |  Branch (3182:6): [True: 0, False: 21]
  ------------------
 3183|      0|	    xmlVErrMemory(ctxt, "adding entry failed");
 3184|      0|            xmlFreeElement(cur);
 3185|      0|            cur = NULL;
 3186|      0|        }
 3187|     21|    }
 3188|  5.83k|error:
 3189|  5.83k|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3189:9): [True: 84, False: 5.74k]
  ------------------
 3190|  5.83k|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3190:9): [True: 84, False: 5.74k]
  ------------------
 3191|  5.83k|    return(cur);
 3192|  5.83k|}
valid.c:xmlValidateNameValueInternal:
 3452|      6|xmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3453|      6|    const xmlChar *cur;
 3454|      6|    int val, len;
 3455|       |
 3456|      6|    if (value == NULL) return(0);
  ------------------
  |  Branch (3456:9): [True: 0, False: 6]
  ------------------
 3457|      6|    cur = value;
 3458|      6|    val = xmlStringCurrentChar(NULL, cur, &len);
 3459|      6|    cur += len;
 3460|      6|    if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3460:9): [True: 3, False: 3]
  ------------------
 3461|      3|	return(0);
 3462|       |
 3463|      3|    val = xmlStringCurrentChar(NULL, cur, &len);
 3464|      3|    cur += len;
 3465|     15|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3465:12): [True: 12, False: 3]
  ------------------
 3466|     12|	val = xmlStringCurrentChar(NULL, cur, &len);
 3467|     12|	cur += len;
 3468|     12|    }
 3469|       |
 3470|      3|    if (val != 0) return(0);
  ------------------
  |  Branch (3470:9): [True: 0, False: 3]
  ------------------
 3471|       |
 3472|      3|    return(1);
 3473|      3|}
valid.c:xmlIsDocNameStartChar:
 3374|     18|xmlIsDocNameStartChar(xmlDocPtr doc, int c) {
 3375|     18|    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {
  ------------------
  |  Branch (3375:9): [True: 0, False: 18]
  |  Branch (3375:26): [True: 18, False: 0]
  ------------------
 3376|       |        /*
 3377|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3378|       |	 * Update 5 of XML-1.0
 3379|       |	 */
 3380|     18|	if (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3380:7): [True: 12, False: 6]
  |  Branch (3380:21): [True: 12, False: 0]
  ------------------
 3381|     18|	    ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3381:7): [True: 0, False: 6]
  |  Branch (3381:21): [True: 0, False: 0]
  ------------------
 3382|     18|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3382:6): [True: 0, False: 6]
  |  Branch (3382:20): [True: 0, False: 6]
  ------------------
 3383|     18|	    ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3383:7): [True: 0, False: 6]
  |  Branch (3383:22): [True: 0, False: 0]
  ------------------
 3384|     18|	    ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3384:7): [True: 0, False: 6]
  |  Branch (3384:22): [True: 0, False: 0]
  ------------------
 3385|     18|	    ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3385:7): [True: 0, False: 6]
  |  Branch (3385:22): [True: 0, False: 0]
  ------------------
 3386|     18|	    ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3386:7): [True: 0, False: 6]
  |  Branch (3386:23): [True: 0, False: 0]
  ------------------
 3387|     18|	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3387:7): [True: 0, False: 6]
  |  Branch (3387:23): [True: 0, False: 0]
  ------------------
 3388|     18|	    ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3388:7): [True: 0, False: 6]
  |  Branch (3388:24): [True: 0, False: 0]
  ------------------
 3389|     18|	    ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3389:7): [True: 0, False: 6]
  |  Branch (3389:24): [True: 0, False: 0]
  ------------------
 3390|     18|	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3390:7): [True: 0, False: 6]
  |  Branch (3390:24): [True: 0, False: 0]
  ------------------
 3391|     18|	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3391:7): [True: 0, False: 6]
  |  Branch (3391:24): [True: 0, False: 0]
  ------------------
 3392|     18|	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3392:7): [True: 0, False: 6]
  |  Branch (3392:24): [True: 0, False: 0]
  ------------------
 3393|     18|	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3393:7): [True: 0, False: 6]
  |  Branch (3393:24): [True: 0, False: 0]
  ------------------
 3394|     18|	    ((c >= 0x10000) && (c <= 0xEFFFF)))
  ------------------
  |  Branch (3394:7): [True: 0, False: 6]
  |  Branch (3394:25): [True: 0, False: 0]
  ------------------
 3395|     12|	    return(1);
 3396|     18|    } else {
 3397|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3397:29): [True: 0, False: 0]
  |  Branch (3397:43): [True: 0, False: 0]
  ------------------
 3398|      0|	    return(1);
 3399|      0|    }
 3400|      6|    return(0);
 3401|     18|}
valid.c:xmlIsDocNameChar:
 3404|  3.24k|xmlIsDocNameChar(xmlDocPtr doc, int c) {
 3405|  3.24k|    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {
  ------------------
  |  Branch (3405:9): [True: 0, False: 3.24k]
  |  Branch (3405:26): [True: 3.24k, False: 0]
  ------------------
 3406|       |        /*
 3407|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3408|       |	 * Update 5 of XML-1.0
 3409|       |	 */
 3410|  3.24k|	if (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3410:7): [True: 321, False: 2.91k]
  |  Branch (3410:21): [True: 321, False: 0]
  ------------------
 3411|  3.24k|	    ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3411:7): [True: 9, False: 2.91k]
  |  Branch (3411:21): [True: 0, False: 9]
  ------------------
 3412|  3.24k|	    ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3412:7): [True: 1.89k, False: 1.02k]
  |  Branch (3412:21): [True: 1.88k, False: 15]
  ------------------
 3413|  3.24k|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3413:6): [True: 9, False: 1.02k]
  |  Branch (3413:20): [True: 6, False: 1.02k]
  ------------------
 3414|  3.24k|	    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3414:6): [True: 0, False: 1.02k]
  |  Branch (3414:20): [True: 0, False: 1.02k]
  |  Branch (3414:34): [True: 0, False: 1.02k]
  ------------------
 3415|  3.24k|	    ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3415:7): [True: 0, False: 1.02k]
  |  Branch (3415:22): [True: 0, False: 0]
  ------------------
 3416|  3.24k|	    ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3416:7): [True: 0, False: 1.02k]
  |  Branch (3416:22): [True: 0, False: 0]
  ------------------
 3417|  3.24k|	    ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3417:7): [True: 0, False: 1.02k]
  |  Branch (3417:22): [True: 0, False: 0]
  ------------------
 3418|  3.24k|	    ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3418:7): [True: 0, False: 1.02k]
  |  Branch (3418:23): [True: 0, False: 0]
  ------------------
 3419|  3.24k|	    ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3419:7): [True: 0, False: 1.02k]
  |  Branch (3419:23): [True: 0, False: 0]
  ------------------
 3420|  3.24k|	    ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3420:7): [True: 0, False: 1.02k]
  |  Branch (3420:23): [True: 0, False: 0]
  ------------------
 3421|  3.24k|	    ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3421:7): [True: 0, False: 1.02k]
  |  Branch (3421:24): [True: 0, False: 0]
  ------------------
 3422|  3.24k|	    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3422:7): [True: 0, False: 1.02k]
  |  Branch (3422:24): [True: 0, False: 0]
  ------------------
 3423|  3.24k|	    ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3423:7): [True: 0, False: 1.02k]
  |  Branch (3423:24): [True: 0, False: 0]
  ------------------
 3424|  3.24k|	    ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3424:7): [True: 0, False: 1.02k]
  |  Branch (3424:24): [True: 0, False: 0]
  ------------------
 3425|  3.24k|	    ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3425:7): [True: 0, False: 1.02k]
  |  Branch (3425:24): [True: 0, False: 0]
  ------------------
 3426|  3.24k|	    ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3426:7): [True: 0, False: 1.02k]
  |  Branch (3426:24): [True: 0, False: 0]
  ------------------
 3427|  3.24k|	    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3427:7): [True: 0, False: 1.02k]
  |  Branch (3427:24): [True: 0, False: 0]
  ------------------
 3428|  3.24k|	    ((c >= 0x10000) && (c <= 0xEFFFF)))
  ------------------
  |  Branch (3428:7): [True: 0, False: 1.02k]
  |  Branch (3428:25): [True: 0, False: 0]
  ------------------
 3429|  2.22k|	     return(1);
 3430|  3.24k|    } else {
 3431|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3431:31): [True: 0, False: 0]
  ------------------
 3432|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3432:13): [True: 0, False: 0]
  |  Branch (3432:27): [True: 0, False: 0]
  ------------------
 3433|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3433:6): [True: 0, False: 0]
  |  Branch (3433:20): [True: 0, False: 0]
  ------------------
 3434|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3434:6): [True: 0, False: 0]
  ------------------
 3435|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3435:6): [True: 0, False: 0]
  ------------------
 3436|      0|	    return(1);
 3437|      0|    }
 3438|  1.02k|    return(0);
 3439|  3.24k|}
valid.c:xmlValidateNamesValueInternal:
 3500|      6|xmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3501|      6|    const xmlChar *cur;
 3502|      6|    int val, len;
 3503|       |
 3504|      6|    if (value == NULL) return(0);
  ------------------
  |  Branch (3504:9): [True: 0, False: 6]
  ------------------
 3505|      6|    cur = value;
 3506|      6|    val = xmlStringCurrentChar(NULL, cur, &len);
 3507|      6|    cur += len;
 3508|       |
 3509|      6|    if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3509:9): [True: 0, False: 6]
  ------------------
 3510|      0|	return(0);
 3511|       |
 3512|      6|    val = xmlStringCurrentChar(NULL, cur, &len);
 3513|      6|    cur += len;
 3514|     30|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3514:12): [True: 24, False: 6]
  ------------------
 3515|     24|	val = xmlStringCurrentChar(NULL, cur, &len);
 3516|     24|	cur += len;
 3517|     24|    }
 3518|       |
 3519|       |    /* Should not test IS_BLANK(val) here -- see erratum E20*/
 3520|      9|    while (val == 0x20) {
  ------------------
  |  Branch (3520:12): [True: 6, False: 3]
  ------------------
 3521|     12|	while (val == 0x20) {
  ------------------
  |  Branch (3521:9): [True: 6, False: 6]
  ------------------
 3522|      6|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3523|      6|	    cur += len;
 3524|      6|	}
 3525|       |
 3526|      6|	if (!xmlIsDocNameStartChar(doc, val))
  ------------------
  |  Branch (3526:6): [True: 3, False: 3]
  ------------------
 3527|      3|	    return(0);
 3528|       |
 3529|      3|	val = xmlStringCurrentChar(NULL, cur, &len);
 3530|      3|	cur += len;
 3531|       |
 3532|     18|	while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3532:9): [True: 15, False: 3]
  ------------------
 3533|     15|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3534|     15|	    cur += len;
 3535|     15|	}
 3536|      3|    }
 3537|       |
 3538|      3|    if (val != 0) return(0);
  ------------------
  |  Branch (3538:9): [True: 0, False: 3]
  ------------------
 3539|       |
 3540|      3|    return(1);
 3541|      3|}
valid.c:xmlValidateNmtokenValueInternal:
 3570|     48|xmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3571|     48|    const xmlChar *cur;
 3572|     48|    int val, len;
 3573|       |
 3574|     48|    if (value == NULL) return(0);
  ------------------
  |  Branch (3574:9): [True: 0, False: 48]
  ------------------
 3575|     48|    cur = value;
 3576|     48|    val = xmlStringCurrentChar(NULL, cur, &len);
 3577|     48|    cur += len;
 3578|       |
 3579|     48|    if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3579:9): [True: 3, False: 45]
  ------------------
 3580|      3|	return(0);
 3581|       |
 3582|     45|    val = xmlStringCurrentChar(NULL, cur, &len);
 3583|     45|    cur += len;
 3584|     60|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3584:12): [True: 15, False: 45]
  ------------------
 3585|     15|	val = xmlStringCurrentChar(NULL, cur, &len);
 3586|     15|	cur += len;
 3587|     15|    }
 3588|       |
 3589|     45|    if (val != 0) return(0);
  ------------------
  |  Branch (3589:9): [True: 0, False: 45]
  ------------------
 3590|       |
 3591|     45|    return(1);
 3592|     45|}
valid.c:xmlValidateNmtokensValueInternal:
 3623|    951|xmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {
 3624|    951|    const xmlChar *cur;
 3625|    951|    int val, len;
 3626|       |
 3627|    951|    if (value == NULL) return(0);
  ------------------
  |  Branch (3627:9): [True: 0, False: 951]
  ------------------
 3628|    951|    cur = value;
 3629|    951|    val = xmlStringCurrentChar(NULL, cur, &len);
 3630|    951|    cur += len;
 3631|       |
 3632|    951|    while (IS_BLANK(val)) {
 3633|      0|	val = xmlStringCurrentChar(NULL, cur, &len);
 3634|      0|	cur += len;
 3635|      0|    }
 3636|       |
 3637|    951|    if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3637:9): [True: 0, False: 951]
  ------------------
 3638|      0|	return(0);
 3639|       |
 3640|  2.07k|    while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3640:12): [True: 1.11k, False: 951]
  ------------------
 3641|  1.11k|	val = xmlStringCurrentChar(NULL, cur, &len);
 3642|  1.11k|	cur += len;
 3643|  1.11k|    }
 3644|       |
 3645|       |    /* Should not test IS_BLANK(val) here -- see erratum E20*/
 3646|    960|    while (val == 0x20) {
  ------------------
  |  Branch (3646:12): [True: 9, False: 951]
  ------------------
 3647|     18|	while (val == 0x20) {
  ------------------
  |  Branch (3647:9): [True: 9, False: 9]
  ------------------
 3648|      9|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3649|      9|	    cur += len;
 3650|      9|	}
 3651|      9|	if (val == 0) return(1);
  ------------------
  |  Branch (3651:6): [True: 0, False: 9]
  ------------------
 3652|       |
 3653|      9|	if (!xmlIsDocNameChar(doc, val))
  ------------------
  |  Branch (3653:6): [True: 0, False: 9]
  ------------------
 3654|      0|	    return(0);
 3655|       |
 3656|      9|	val = xmlStringCurrentChar(NULL, cur, &len);
 3657|      9|	cur += len;
 3658|       |
 3659|     39|	while (xmlIsDocNameChar(doc, val)) {
  ------------------
  |  Branch (3659:9): [True: 30, False: 9]
  ------------------
 3660|     30|	    val = xmlStringCurrentChar(NULL, cur, &len);
 3661|     30|	    cur += len;
 3662|     30|	}
 3663|      9|    }
 3664|       |
 3665|    951|    if (val != 0) return(0);
  ------------------
  |  Branch (3665:9): [True: 0, False: 951]
  ------------------
 3666|       |
 3667|    951|    return(1);
 3668|    951|}
valid.c:xmlValidateAttributeValueInternal:
 3722|  1.23k|                                  const xmlChar *value) {
 3723|  1.23k|    switch (type) {
  ------------------
  |  Branch (3723:13): [True: 0, False: 1.23k]
  ------------------
 3724|      0|	case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (3724:2): [True: 0, False: 1.23k]
  ------------------
 3725|      6|	case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (3725:2): [True: 6, False: 1.22k]
  ------------------
 3726|      6|	    return(xmlValidateNamesValueInternal(doc, value));
 3727|      0|	case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (3727:2): [True: 0, False: 1.23k]
  ------------------
 3728|      6|	case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (3728:2): [True: 6, False: 1.22k]
  ------------------
 3729|      6|	case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (3729:2): [True: 0, False: 1.23k]
  ------------------
 3730|      6|	case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (3730:2): [True: 0, False: 1.23k]
  ------------------
 3731|      6|	    return(xmlValidateNameValueInternal(doc, value));
 3732|      9|	case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (3732:2): [True: 9, False: 1.22k]
  ------------------
 3733|    951|	case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (3733:2): [True: 942, False: 291]
  ------------------
 3734|    951|	    return(xmlValidateNmtokensValueInternal(doc, value));
 3735|     48|	case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (3735:2): [True: 48, False: 1.18k]
  ------------------
 3736|     48|	    return(xmlValidateNmtokenValueInternal(doc, value));
 3737|    222|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (3737:9): [True: 222, False: 1.01k]
  ------------------
 3738|    222|	    break;
 3739|  1.23k|    }
 3740|    222|    return(1);
 3741|  1.23k|}

xmlCheckFilename:
  679|  10.1k|{
  680|  10.1k|#ifdef HAVE_STAT
  681|       |#if defined(_WIN32)
  682|       |    struct _stat stat_buffer;
  683|       |#else
  684|  10.1k|    struct stat stat_buffer;
  685|  10.1k|#endif
  686|  10.1k|#endif
  687|  10.1k|    if (path == NULL)
  ------------------
  |  Branch (687:9): [True: 0, False: 10.1k]
  ------------------
  688|      0|	return(0);
  689|       |
  690|  10.1k|#ifdef HAVE_STAT
  691|       |#if defined(_WIN32)
  692|       |    /*
  693|       |     * On Windows stat and wstat do not work with long pathname,
  694|       |     * which start with '\\?\'
  695|       |     */
  696|       |    if ((path[0] == '\\') && (path[1] == '\\') && (path[2] == '?') &&
  697|       |	(path[3] == '\\') )
  698|       |	    return 1;
  699|       |
  700|       |    if (xmlWrapStatUtf8(path, &stat_buffer) == -1)
  701|       |        return 0;
  702|       |#else
  703|  10.1k|    if (stat(path, &stat_buffer) == -1)
  ------------------
  |  Branch (703:9): [True: 10.1k, False: 0]
  ------------------
  704|  10.1k|        return 0;
  705|      0|#endif
  706|      0|#ifdef S_ISDIR
  707|      0|    if (S_ISDIR(stat_buffer.st_mode))
  708|      0|        return 2;
  709|      0|#endif
  710|      0|#endif /* HAVE_STAT */
  711|      0|    return 1;
  712|      0|}
xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|  11.5k|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|  11.5k|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|  11.5k|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|  11.5k|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 0, False: 11.5k]
  ------------------
 2251|      0|	return(NULL);
 2252|      0|    }
 2253|  11.5k|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|  11.5k|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|  11.5k|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|  11.5k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|  11.5k|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 0, False: 11.5k]
  ------------------
 2256|      0|        xmlFree(ret);
 2257|      0|	return(NULL);
 2258|      0|    }
 2259|  11.5k|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|  11.5k|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|  11.5k|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 11.5k]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|  11.5k|    else
 2264|  11.5k|        ret->raw = NULL;
 2265|  11.5k|    ret->readcallback = NULL;
 2266|  11.5k|    ret->closecallback = NULL;
 2267|  11.5k|    ret->context = NULL;
 2268|  11.5k|    ret->compressed = -1;
 2269|  11.5k|    ret->rawconsumed = 0;
 2270|       |
 2271|  11.5k|    return(ret);
 2272|  11.5k|}
xmlAllocOutputBuffer:
 2284|    262|xmlAllocOutputBuffer(xmlCharEncodingHandlerPtr encoder) {
 2285|    262|    xmlOutputBufferPtr ret;
 2286|       |
 2287|    262|    ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));
 2288|    262|    if (ret == NULL) {
  ------------------
  |  Branch (2288:9): [True: 0, False: 262]
  ------------------
 2289|      0|	return(NULL);
 2290|      0|    }
 2291|    262|    memset(ret, 0, sizeof(xmlOutputBuffer));
 2292|    262|    ret->buffer = xmlBufCreate();
 2293|    262|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2293:9): [True: 0, False: 262]
  ------------------
 2294|      0|        xmlFree(ret);
 2295|      0|	return(NULL);
 2296|      0|    }
 2297|    262|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2298|       |
 2299|    262|    ret->encoder = encoder;
 2300|    262|    if (encoder != NULL) {
  ------------------
  |  Branch (2300:9): [True: 30, False: 232]
  ------------------
 2301|     30|        ret->conv = xmlBufCreateSize(4000);
 2302|     30|	if (ret->conv == NULL) {
  ------------------
  |  Branch (2302:6): [True: 0, False: 30]
  ------------------
 2303|      0|            xmlBufFree(ret->buffer);
 2304|      0|	    xmlFree(ret);
 2305|      0|	    return(NULL);
 2306|      0|	}
 2307|       |
 2308|       |	/*
 2309|       |	 * This call is designed to initiate the encoder state
 2310|       |	 */
 2311|     30|	xmlCharEncOutput(ret, 1);
 2312|     30|    } else
 2313|    232|        ret->conv = NULL;
 2314|    262|    ret->writecallback = NULL;
 2315|    262|    ret->closecallback = NULL;
 2316|    262|    ret->context = NULL;
 2317|    262|    ret->written = 0;
 2318|       |
 2319|    262|    return(ret);
 2320|    262|}
xmlFreeParserInputBuffer:
 2383|  11.5k|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|  11.5k|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 11.5k]
  ------------------
 2385|       |
 2386|  11.5k|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 54, False: 11.5k]
  ------------------
 2387|     54|        xmlBufFree(in->raw);
 2388|     54|	in->raw = NULL;
 2389|     54|    }
 2390|  11.5k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 54, False: 11.5k]
  ------------------
 2391|     54|        xmlCharEncCloseFunc(in->encoder);
 2392|     54|    }
 2393|  11.5k|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 10.9k, False: 646]
  ------------------
 2394|  10.9k|	in->closecallback(in->context);
 2395|  10.9k|    }
 2396|  11.5k|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 11.5k, False: 0]
  ------------------
 2397|  11.5k|        xmlBufFree(in->buffer);
 2398|  11.5k|	in->buffer = NULL;
 2399|  11.5k|    }
 2400|       |
 2401|  11.5k|    xmlFree(in);
 2402|  11.5k|}
xmlOutputBufferClose:
 2416|    262|{
 2417|    262|    int written;
 2418|    262|    int err_rc = 0;
 2419|       |
 2420|    262|    if (out == NULL)
  ------------------
  |  Branch (2420:9): [True: 0, False: 262]
  ------------------
 2421|      0|        return (-1);
 2422|    262|    if (out->writecallback != NULL)
  ------------------
  |  Branch (2422:9): [True: 0, False: 262]
  ------------------
 2423|      0|        xmlOutputBufferFlush(out);
 2424|    262|    if (out->closecallback != NULL) {
  ------------------
  |  Branch (2424:9): [True: 0, False: 262]
  ------------------
 2425|      0|        err_rc = out->closecallback(out->context);
 2426|      0|    }
 2427|    262|    written = out->written;
 2428|    262|    if (out->conv) {
  ------------------
  |  Branch (2428:9): [True: 30, False: 232]
  ------------------
 2429|     30|        xmlBufFree(out->conv);
 2430|     30|        out->conv = NULL;
 2431|     30|    }
 2432|    262|    if (out->encoder != NULL) {
  ------------------
  |  Branch (2432:9): [True: 30, False: 232]
  ------------------
 2433|     30|        xmlCharEncCloseFunc(out->encoder);
 2434|     30|    }
 2435|    262|    if (out->buffer != NULL) {
  ------------------
  |  Branch (2435:9): [True: 262, False: 0]
  ------------------
 2436|    262|        xmlBufFree(out->buffer);
 2437|    262|        out->buffer = NULL;
 2438|    262|    }
 2439|       |
 2440|    262|    if (out->error)
  ------------------
  |  Branch (2440:9): [True: 0, False: 262]
  ------------------
 2441|      0|        err_rc = -1;
 2442|    262|    xmlFree(out);
 2443|    262|    return ((err_rc == 0) ? written : err_rc);
  ------------------
  |  Branch (2443:13): [True: 262, False: 0]
  ------------------
 2444|    262|}
xmlParserInputBufferCreateMem:
 2870|  10.6k|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|  10.6k|    xmlParserInputBufferPtr ret;
 2872|  10.6k|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|  10.6k|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 10.6k]
  ------------------
 2875|  10.6k|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 10.6k]
  ------------------
 2876|       |
 2877|  10.6k|    ret = xmlAllocParserInputBuffer(enc);
 2878|  10.6k|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 0, False: 10.6k]
  ------------------
 2879|      0|        return(NULL);
 2880|       |
 2881|  10.6k|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|  10.6k|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 10.6k]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|  10.6k|    ctxt->mem = mem;
 2887|  10.6k|    ctxt->size = size;
 2888|       |
 2889|  10.6k|    ret->context = ctxt;
 2890|  10.6k|    ret->readcallback = xmlMemRead;
 2891|  10.6k|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|  10.6k|    return(ret);
 2894|  10.6k|}
xmlParserInputBufferCreateString:
 2947|    324|xmlParserInputBufferCreateString(const xmlChar *str) {
 2948|    324|    xmlParserInputBufferPtr ret;
 2949|    324|    xmlStringIOCtxt *ctxt;
 2950|       |
 2951|    324|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (2951:9): [True: 0, False: 324]
  ------------------
 2952|       |
 2953|    324|    ret = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);
 2954|    324|    if (ret == NULL)
  ------------------
  |  Branch (2954:9): [True: 0, False: 324]
  ------------------
 2955|      0|        return(NULL);
 2956|       |
 2957|    324|    ctxt = xmlMalloc(sizeof(*ctxt));
 2958|    324|    if (ctxt == NULL) {
  ------------------
  |  Branch (2958:9): [True: 0, False: 324]
  ------------------
 2959|      0|        xmlFreeParserInputBuffer(ret);
 2960|      0|        return(NULL);
 2961|      0|    }
 2962|    324|    ctxt->str = str;
 2963|       |
 2964|    324|    ret->context = ctxt;
 2965|    324|    ret->readcallback = xmlStringRead;
 2966|    324|    ret->closecallback = xmlStringClose;
 2967|       |
 2968|    324|    return(ret);
 2969|    324|}
xmlParserInputBufferPush:
 3116|  12.2k|	                 int len, const char *buf) {
 3117|  12.2k|    int nbchars = 0;
 3118|  12.2k|    int ret;
 3119|       |
 3120|  12.2k|    if (len < 0) return(0);
  ------------------
  |  Branch (3120:9): [True: 0, False: 12.2k]
  ------------------
 3121|  12.2k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3121:9): [True: 0, False: 12.2k]
  |  Branch (3121:25): [True: 0, False: 12.2k]
  ------------------
 3122|  12.2k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3122:9): [True: 1.92k, False: 10.3k]
  ------------------
 3123|       |        /*
 3124|       |	 * Store the data in the incoming raw buffer
 3125|       |	 */
 3126|  1.92k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3126:13): [True: 0, False: 1.92k]
  ------------------
 3127|      0|	    in->raw = xmlBufCreate();
 3128|      0|            if (in->raw == NULL) {
  ------------------
  |  Branch (3128:17): [True: 0, False: 0]
  ------------------
 3129|      0|                in->error = XML_ERR_NO_MEMORY;
 3130|      0|                return(-1);
 3131|      0|            }
 3132|      0|	}
 3133|  1.92k|	ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);
 3134|  1.92k|	if (ret != 0) {
  ------------------
  |  Branch (3134:6): [True: 0, False: 1.92k]
  ------------------
 3135|      0|            in->error = XML_ERR_NO_MEMORY;
 3136|      0|	    return(-1);
 3137|      0|        }
 3138|       |
 3139|       |	/*
 3140|       |	 * convert as much as possible to the parser reading buffer.
 3141|       |	 */
 3142|  1.92k|	nbchars = xmlCharEncInput(in);
 3143|  1.92k|	if (nbchars < 0)
  ------------------
  |  Branch (3143:6): [True: 0, False: 1.92k]
  ------------------
 3144|      0|	    return(-1);
 3145|  10.3k|    } else {
 3146|  10.3k|	nbchars = len;
 3147|  10.3k|        ret = xmlBufAdd(in->buffer, (xmlChar *) buf, nbchars);
 3148|  10.3k|	if (ret != 0) {
  ------------------
  |  Branch (3148:6): [True: 0, False: 10.3k]
  ------------------
 3149|      0|            in->error = XML_ERR_NO_MEMORY;
 3150|      0|	    return(-1);
 3151|      0|        }
 3152|  10.3k|    }
 3153|  12.2k|    return(nbchars);
 3154|  12.2k|}
xmlParserInputBufferGrow:
 3185|  1.47M|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  1.47M|    xmlBufPtr buf;
 3187|  1.47M|    int res = 0;
 3188|       |
 3189|  1.47M|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 1.47M]
  |  Branch (3189:25): [True: 0, False: 1.47M]
  ------------------
 3190|  1.47M|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  1.47M|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 1.47M, False: 945]
  |  Branch (3190:28): [True: 1.47M, False: 323]
  ------------------
 3191|  1.47M|        len = MINLEN;
  ------------------
  |  |   73|  1.47M|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  1.47M|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 1.47M, False: 1.29k]
  ------------------
 3194|  1.47M|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 1.47M]
  ------------------
 3195|      0|            return(0);
 3196|  1.47M|        buf = in->buffer;
 3197|  1.47M|    } else {
 3198|  1.29k|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 0, False: 1.29k]
  ------------------
 3199|      0|	    in->raw = xmlBufCreate();
 3200|      0|	}
 3201|  1.29k|        buf = in->raw;
 3202|  1.29k|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  1.47M|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 1.47M, False: 0]
  ------------------
 3208|  1.47M|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 1.47M]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  1.47M|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  1.47M|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 1.46M, False: 11.8k]
  ------------------
 3215|  1.46M|	    in->readcallback = endOfInput;
 3216|  1.47M|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 1.47M]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  1.47M|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 1.47M]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  1.47M|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  1.47M|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 1.47M, False: 0]
  ------------------
 3231|  1.47M|#ifdef LIBXML_LZMA_ENABLED
 3232|  1.47M|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 1.47M]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  1.47M|#endif
 3235|  1.47M|    }
 3236|       |
 3237|  1.47M|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 1.29k, False: 1.47M]
  ------------------
 3238|  1.29k|	res = xmlCharEncInput(in);
 3239|  1.29k|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 1.29k]
  ------------------
 3240|      0|	    return(-1);
 3241|  1.29k|    }
 3242|  1.47M|    return(res);
 3243|  1.47M|}
xmlParserInputBufferRead:
 3258|  1.26k|xmlParserInputBufferRead(xmlParserInputBufferPtr in, int len) {
 3259|  1.26k|    return(xmlParserInputBufferGrow(in, len));
 3260|  1.26k|}
xmlOutputBufferWrite:
 3278|   144k|xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {
 3279|   144k|    int nbchars = 0; /* number of chars to output to I/O */
 3280|   144k|    int ret;         /* return from function call */
 3281|   144k|    int written = 0; /* number of char written to I/O so far */
 3282|   144k|    int chunk;       /* number of byte current processed from buf */
 3283|       |
 3284|   144k|    if ((out == NULL) || (out->error)) return(-1);
  ------------------
  |  Branch (3284:9): [True: 0, False: 144k]
  |  Branch (3284:26): [True: 0, False: 144k]
  ------------------
 3285|   144k|    if (len < 0) return(0);
  ------------------
  |  Branch (3285:9): [True: 0, False: 144k]
  ------------------
 3286|   144k|    if (out->error) return(-1);
  ------------------
  |  Branch (3286:9): [True: 0, False: 144k]
  ------------------
 3287|       |
 3288|   144k|    do {
 3289|   144k|	chunk = len;
 3290|   144k|	if (chunk > 4 * MINLEN)
  ------------------
  |  |   73|   144k|#define MINLEN 4000
  ------------------
  |  Branch (3290:6): [True: 0, False: 144k]
  ------------------
 3291|      0|	    chunk = 4 * MINLEN;
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
 3292|       |
 3293|       |	/*
 3294|       |	 * first handle encoding stuff.
 3295|       |	 */
 3296|   144k|	if (out->encoder != NULL) {
  ------------------
  |  Branch (3296:6): [True: 125k, False: 19.2k]
  ------------------
 3297|       |	    /*
 3298|       |	     * Store the data in the incoming raw buffer
 3299|       |	     */
 3300|   125k|	    if (out->conv == NULL) {
  ------------------
  |  Branch (3300:10): [True: 0, False: 125k]
  ------------------
 3301|      0|		out->conv = xmlBufCreate();
 3302|      0|	    }
 3303|   125k|	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
 3304|   125k|	    if (ret != 0)
  ------------------
  |  Branch (3304:10): [True: 0, False: 125k]
  ------------------
 3305|      0|	        return(-1);
 3306|       |
 3307|   125k|	    if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))
  ------------------
  |  |   73|   125k|#define MINLEN 4000
  ------------------
  |  Branch (3307:10): [True: 125k, False: 95]
  |  Branch (3307:47): [True: 125k, False: 0]
  ------------------
 3308|   125k|		goto done;
 3309|       |
 3310|       |	    /*
 3311|       |	     * convert as much as possible to the parser reading buffer.
 3312|       |	     */
 3313|     95|	    ret = xmlCharEncOutput(out, 0);
 3314|     95|	    if ((ret < 0) && (ret != -3)) {
  ------------------
  |  Branch (3314:10): [True: 0, False: 95]
  |  Branch (3314:23): [True: 0, False: 0]
  ------------------
 3315|      0|		xmlIOErr(XML_IO_ENCODER, NULL);
 3316|      0|		out->error = XML_IO_ENCODER;
 3317|      0|		return(-1);
 3318|      0|	    }
 3319|     95|            if (out->writecallback)
  ------------------
  |  Branch (3319:17): [True: 0, False: 95]
  ------------------
 3320|      0|	        nbchars = xmlBufUse(out->conv);
 3321|     95|            else
 3322|     95|                nbchars = ret >= 0 ? ret : 0;
  ------------------
  |  Branch (3322:27): [True: 95, False: 0]
  ------------------
 3323|  19.2k|	} else {
 3324|  19.2k|	    ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);
 3325|  19.2k|	    if (ret != 0)
  ------------------
  |  Branch (3325:10): [True: 0, False: 19.2k]
  ------------------
 3326|      0|	        return(-1);
 3327|  19.2k|            if (out->writecallback)
  ------------------
  |  Branch (3327:17): [True: 0, False: 19.2k]
  ------------------
 3328|      0|	        nbchars = xmlBufUse(out->buffer);
 3329|  19.2k|            else
 3330|  19.2k|                nbchars = chunk;
 3331|  19.2k|	}
 3332|  19.3k|	buf += chunk;
 3333|  19.3k|	len -= chunk;
 3334|       |
 3335|  19.3k|	if (out->writecallback) {
  ------------------
  |  Branch (3335:6): [True: 0, False: 19.3k]
  ------------------
 3336|      0|            if ((nbchars < MINLEN) && (len <= 0))
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
  |  Branch (3336:17): [True: 0, False: 0]
  |  Branch (3336:39): [True: 0, False: 0]
  ------------------
 3337|      0|                goto done;
 3338|       |
 3339|       |	    /*
 3340|       |	     * second write the stuff to the I/O channel
 3341|       |	     */
 3342|      0|	    if (out->encoder != NULL) {
  ------------------
  |  Branch (3342:10): [True: 0, False: 0]
  ------------------
 3343|      0|		ret = out->writecallback(out->context,
 3344|      0|                           (const char *)xmlBufContent(out->conv), nbchars);
 3345|      0|		if (ret >= 0)
  ------------------
  |  Branch (3345:7): [True: 0, False: 0]
  ------------------
 3346|      0|		    xmlBufShrink(out->conv, ret);
 3347|      0|	    } else {
 3348|      0|		ret = out->writecallback(out->context,
 3349|      0|                           (const char *)xmlBufContent(out->buffer), nbchars);
 3350|      0|		if (ret >= 0)
  ------------------
  |  Branch (3350:7): [True: 0, False: 0]
  ------------------
 3351|      0|		    xmlBufShrink(out->buffer, ret);
 3352|      0|	    }
 3353|      0|	    if (ret < 0) {
  ------------------
  |  Branch (3353:10): [True: 0, False: 0]
  ------------------
 3354|      0|		xmlIOErr(XML_IO_WRITE, NULL);
 3355|      0|		out->error = XML_IO_WRITE;
 3356|      0|		return(ret);
 3357|      0|	    }
 3358|      0|            if (out->written > INT_MAX - ret)
  ------------------
  |  Branch (3358:17): [True: 0, False: 0]
  ------------------
 3359|      0|                out->written = INT_MAX;
 3360|      0|            else
 3361|      0|                out->written += ret;
 3362|      0|	}
 3363|  19.3k|	written += nbchars;
 3364|  19.3k|    } while (len > 0);
  ------------------
  |  Branch (3364:14): [True: 0, False: 19.3k]
  ------------------
 3365|       |
 3366|   144k|done:
 3367|   144k|    return(written);
 3368|   144k|}
xmlOutputBufferWriteEscape:
 3447|  17.2k|                           xmlCharEncodingOutputFunc escaping) {
 3448|  17.2k|    int nbchars = 0; /* number of chars to output to I/O */
 3449|  17.2k|    int ret;         /* return from function call */
 3450|  17.2k|    int written = 0; /* number of char written to I/O so far */
 3451|  17.2k|    int oldwritten=0;/* loop guard */
 3452|  17.2k|    int chunk;       /* number of byte currently processed from str */
 3453|  17.2k|    int len;         /* number of bytes in str */
 3454|  17.2k|    int cons;        /* byte from str consumed */
 3455|       |
 3456|  17.2k|    if ((out == NULL) || (out->error) || (str == NULL) ||
  ------------------
  |  Branch (3456:9): [True: 0, False: 17.2k]
  |  Branch (3456:26): [True: 0, False: 17.2k]
  |  Branch (3456:42): [True: 0, False: 17.2k]
  ------------------
 3457|  17.2k|        (out->buffer == NULL))
  ------------------
  |  Branch (3457:9): [True: 0, False: 17.2k]
  ------------------
 3458|      0|        return(-1);
 3459|  17.2k|    len = strlen((const char *)str);
 3460|  17.2k|    if (len < 0) return(0);
  ------------------
  |  Branch (3460:9): [True: 0, False: 17.2k]
  ------------------
 3461|  17.2k|    if (out->error) return(-1);
  ------------------
  |  Branch (3461:9): [True: 0, False: 17.2k]
  ------------------
 3462|  17.2k|    if (escaping == NULL) escaping = xmlEscapeContent;
  ------------------
  |  Branch (3462:9): [True: 14.3k, False: 2.83k]
  ------------------
 3463|       |
 3464|  17.2k|    do {
 3465|  17.2k|        oldwritten = written;
 3466|       |
 3467|       |        /*
 3468|       |	 * how many bytes to consume and how many bytes to store.
 3469|       |	 */
 3470|  17.2k|	cons = len;
 3471|  17.2k|	chunk = xmlBufAvail(out->buffer);
 3472|       |
 3473|       |        /*
 3474|       |	 * make sure we have enough room to save first, if this is
 3475|       |	 * not the case force a flush, but make sure we stay in the loop
 3476|       |	 */
 3477|  17.2k|	if (chunk < 40) {
  ------------------
  |  Branch (3477:6): [True: 0, False: 17.2k]
  ------------------
 3478|      0|	    if (xmlBufGrow(out->buffer, 100) < 0)
  ------------------
  |  Branch (3478:10): [True: 0, False: 0]
  ------------------
 3479|      0|	        return(-1);
 3480|      0|            oldwritten = -1;
 3481|      0|	    continue;
 3482|      0|	}
 3483|       |
 3484|       |	/*
 3485|       |	 * first handle encoding stuff.
 3486|       |	 */
 3487|  17.2k|	if (out->encoder != NULL) {
  ------------------
  |  Branch (3487:6): [True: 14.3k, False: 2.84k]
  ------------------
 3488|       |	    /*
 3489|       |	     * Store the data in the incoming raw buffer
 3490|       |	     */
 3491|  14.3k|	    if (out->conv == NULL) {
  ------------------
  |  Branch (3491:10): [True: 0, False: 14.3k]
  ------------------
 3492|      0|		out->conv = xmlBufCreate();
 3493|      0|	    }
 3494|  14.3k|	    ret = escaping(xmlBufEnd(out->buffer) ,
 3495|  14.3k|	                   &chunk, str, &cons);
 3496|  14.3k|	    if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */
  ------------------
  |  Branch (3496:10): [True: 0, False: 14.3k]
  |  Branch (3496:23): [True: 0, False: 14.3k]
  ------------------
 3497|      0|	        return(-1);
 3498|  14.3k|            xmlBufAddLen(out->buffer, chunk);
 3499|       |
 3500|  14.3k|	    if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))
  ------------------
  |  |   73|  14.3k|#define MINLEN 4000
  ------------------
  |  Branch (3500:10): [True: 14.3k, False: 44]
  |  Branch (3500:47): [True: 14.3k, False: 0]
  ------------------
 3501|  14.3k|		goto done;
 3502|       |
 3503|       |	    /*
 3504|       |	     * convert as much as possible to the output buffer.
 3505|       |	     */
 3506|     44|	    ret = xmlCharEncOutput(out, 0);
 3507|     44|	    if ((ret < 0) && (ret != -3)) {
  ------------------
  |  Branch (3507:10): [True: 0, False: 44]
  |  Branch (3507:23): [True: 0, False: 0]
  ------------------
 3508|      0|		xmlIOErr(XML_IO_ENCODER, NULL);
 3509|      0|		out->error = XML_IO_ENCODER;
 3510|      0|		return(-1);
 3511|      0|	    }
 3512|     44|            if (out->writecallback)
  ------------------
  |  Branch (3512:17): [True: 0, False: 44]
  ------------------
 3513|      0|	        nbchars = xmlBufUse(out->conv);
 3514|     44|            else
 3515|     44|                nbchars = ret >= 0 ? ret : 0;
  ------------------
  |  Branch (3515:27): [True: 44, False: 0]
  ------------------
 3516|  2.84k|	} else {
 3517|  2.84k|	    ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);
 3518|  2.84k|	    if ((ret < 0) || (chunk == 0)) /* chunk==0 => nothing done */
  ------------------
  |  Branch (3518:10): [True: 0, False: 2.84k]
  |  Branch (3518:23): [True: 0, False: 2.84k]
  ------------------
 3519|      0|	        return(-1);
 3520|  2.84k|            xmlBufAddLen(out->buffer, chunk);
 3521|  2.84k|            if (out->writecallback)
  ------------------
  |  Branch (3521:17): [True: 0, False: 2.84k]
  ------------------
 3522|      0|	        nbchars = xmlBufUse(out->buffer);
 3523|  2.84k|            else
 3524|  2.84k|                nbchars = chunk;
 3525|  2.84k|	}
 3526|  2.89k|	str += cons;
 3527|  2.89k|	len -= cons;
 3528|       |
 3529|  2.89k|	if (out->writecallback) {
  ------------------
  |  Branch (3529:6): [True: 0, False: 2.89k]
  ------------------
 3530|      0|            if ((nbchars < MINLEN) && (len <= 0))
  ------------------
  |  |   73|      0|#define MINLEN 4000
  ------------------
  |  Branch (3530:17): [True: 0, False: 0]
  |  Branch (3530:39): [True: 0, False: 0]
  ------------------
 3531|      0|                goto done;
 3532|       |
 3533|       |	    /*
 3534|       |	     * second write the stuff to the I/O channel
 3535|       |	     */
 3536|      0|	    if (out->encoder != NULL) {
  ------------------
  |  Branch (3536:10): [True: 0, False: 0]
  ------------------
 3537|      0|		ret = out->writecallback(out->context,
 3538|      0|                           (const char *)xmlBufContent(out->conv), nbchars);
 3539|      0|		if (ret >= 0)
  ------------------
  |  Branch (3539:7): [True: 0, False: 0]
  ------------------
 3540|      0|		    xmlBufShrink(out->conv, ret);
 3541|      0|	    } else {
 3542|      0|		ret = out->writecallback(out->context,
 3543|      0|                           (const char *)xmlBufContent(out->buffer), nbchars);
 3544|      0|		if (ret >= 0)
  ------------------
  |  Branch (3544:7): [True: 0, False: 0]
  ------------------
 3545|      0|		    xmlBufShrink(out->buffer, ret);
 3546|      0|	    }
 3547|      0|	    if (ret < 0) {
  ------------------
  |  Branch (3547:10): [True: 0, False: 0]
  ------------------
 3548|      0|		xmlIOErr(XML_IO_WRITE, NULL);
 3549|      0|		out->error = XML_IO_WRITE;
 3550|      0|		return(ret);
 3551|      0|	    }
 3552|      0|            if (out->written > INT_MAX - ret)
  ------------------
  |  Branch (3552:17): [True: 0, False: 0]
  ------------------
 3553|      0|                out->written = INT_MAX;
 3554|      0|            else
 3555|      0|                out->written += ret;
 3556|  2.89k|	} else if (xmlBufAvail(out->buffer) < MINLEN) {
  ------------------
  |  |   73|  2.89k|#define MINLEN 4000
  ------------------
  |  Branch (3556:13): [True: 160, False: 2.73k]
  ------------------
 3557|    160|	    xmlBufGrow(out->buffer, MINLEN);
  ------------------
  |  |   73|    160|#define MINLEN 4000
  ------------------
 3558|    160|	}
 3559|  2.89k|	written += nbchars;
 3560|  2.89k|    } while ((len > 0) && (oldwritten != written));
  ------------------
  |  Branch (3560:14): [True: 19, False: 2.87k]
  |  Branch (3560:27): [True: 19, False: 0]
  ------------------
 3561|       |
 3562|  17.2k|done:
 3563|  17.2k|    return(written);
 3564|  17.2k|}
xmlOutputBufferWriteString:
 3580|  41.0k|xmlOutputBufferWriteString(xmlOutputBufferPtr out, const char *str) {
 3581|  41.0k|    int len;
 3582|       |
 3583|  41.0k|    if ((out == NULL) || (out->error)) return(-1);
  ------------------
  |  Branch (3583:9): [True: 0, False: 41.0k]
  |  Branch (3583:26): [True: 0, False: 41.0k]
  ------------------
 3584|  41.0k|    if (str == NULL)
  ------------------
  |  Branch (3584:9): [True: 0, False: 41.0k]
  ------------------
 3585|      0|        return(-1);
 3586|  41.0k|    len = strlen(str);
 3587|       |
 3588|  41.0k|    if (len > 0)
  ------------------
  |  Branch (3588:9): [True: 41.0k, False: 0]
  ------------------
 3589|  41.0k|	return(xmlOutputBufferWrite(out, len, str));
 3590|      0|    return(len);
 3591|  41.0k|}
xmlOutputBufferFlush:
 3602|    262|xmlOutputBufferFlush(xmlOutputBufferPtr out) {
 3603|    262|    int nbchars = 0, ret = 0;
 3604|       |
 3605|    262|    if ((out == NULL) || (out->error)) return(-1);
  ------------------
  |  Branch (3605:9): [True: 0, False: 262]
  |  Branch (3605:26): [True: 0, False: 262]
  ------------------
 3606|       |    /*
 3607|       |     * first handle encoding stuff.
 3608|       |     */
 3609|    262|    if ((out->conv != NULL) && (out->encoder != NULL)) {
  ------------------
  |  Branch (3609:9): [True: 30, False: 232]
  |  Branch (3609:32): [True: 30, False: 0]
  ------------------
 3610|       |	/*
 3611|       |	 * convert as much as possible to the parser output buffer.
 3612|       |	 */
 3613|     60|	do {
 3614|     60|	    nbchars = xmlCharEncOutput(out, 0);
 3615|     60|	    if (nbchars < 0) {
  ------------------
  |  Branch (3615:10): [True: 0, False: 60]
  ------------------
 3616|      0|		xmlIOErr(XML_IO_ENCODER, NULL);
 3617|      0|		out->error = XML_IO_ENCODER;
 3618|      0|		return(-1);
 3619|      0|	    }
 3620|     60|	} while (nbchars);
  ------------------
  |  Branch (3620:11): [True: 30, False: 30]
  ------------------
 3621|     30|    }
 3622|       |
 3623|       |    /*
 3624|       |     * second flush the stuff to the I/O channel
 3625|       |     */
 3626|    262|    if ((out->conv != NULL) && (out->encoder != NULL) &&
  ------------------
  |  Branch (3626:9): [True: 30, False: 232]
  |  Branch (3626:32): [True: 30, False: 0]
  ------------------
 3627|    262|	(out->writecallback != NULL)) {
  ------------------
  |  Branch (3627:2): [True: 0, False: 30]
  ------------------
 3628|      0|	ret = out->writecallback(out->context,
 3629|      0|                                 (const char *)xmlBufContent(out->conv),
 3630|      0|                                 xmlBufUse(out->conv));
 3631|      0|	if (ret >= 0)
  ------------------
  |  Branch (3631:6): [True: 0, False: 0]
  ------------------
 3632|      0|	    xmlBufShrink(out->conv, ret);
 3633|    262|    } else if (out->writecallback != NULL) {
  ------------------
  |  Branch (3633:16): [True: 0, False: 262]
  ------------------
 3634|      0|	ret = out->writecallback(out->context,
 3635|      0|                                 (const char *)xmlBufContent(out->buffer),
 3636|      0|                                 xmlBufUse(out->buffer));
 3637|      0|	if (ret >= 0)
  ------------------
  |  Branch (3637:6): [True: 0, False: 0]
  ------------------
 3638|      0|	    xmlBufShrink(out->buffer, ret);
 3639|      0|    }
 3640|    262|    if (ret < 0) {
  ------------------
  |  Branch (3640:9): [True: 0, False: 262]
  ------------------
 3641|      0|	xmlIOErr(XML_IO_FLUSH, NULL);
 3642|      0|	out->error = XML_IO_FLUSH;
 3643|      0|	return(ret);
 3644|      0|    }
 3645|    262|    if (out->written > INT_MAX - ret)
  ------------------
  |  Branch (3645:9): [True: 0, False: 262]
  ------------------
 3646|      0|        out->written = INT_MAX;
 3647|    262|    else
 3648|    262|        out->written += ret;
 3649|       |
 3650|    262|    return(ret);
 3651|    262|}
xmlParserGetDirectory:
 3663|    350|xmlParserGetDirectory(const char *filename) {
 3664|    350|    char *ret = NULL;
 3665|    350|    char dir[1024];
 3666|    350|    char *cur;
 3667|       |
 3668|    350|    if (xmlInputCallbackInitialized == 0)
  ------------------
  |  Branch (3668:9): [True: 0, False: 350]
  ------------------
 3669|      0|	xmlRegisterDefaultInputCallbacks();
 3670|       |
 3671|    350|    if (filename == NULL) return(NULL);
  ------------------
  |  Branch (3671:9): [True: 0, False: 350]
  ------------------
 3672|       |
 3673|       |#if defined(_WIN32)
 3674|       |#   define IS_XMLPGD_SEP(ch) ((ch=='/')||(ch=='\\'))
 3675|       |#else
 3676|    350|#   define IS_XMLPGD_SEP(ch) (ch=='/')
 3677|    350|#endif
 3678|       |
 3679|    350|    strncpy(dir, filename, 1023);
 3680|    350|    dir[1023] = 0;
 3681|    350|    cur = &dir[strlen(dir)];
 3682|  3.74k|    while (cur > dir) {
  ------------------
  |  Branch (3682:12): [True: 3.40k, False: 341]
  ------------------
 3683|  3.40k|         if (IS_XMLPGD_SEP(*cur)) break;
  ------------------
  |  | 3676|  3.40k|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 9, False: 3.39k]
  |  |  ------------------
  ------------------
 3684|  3.39k|	 cur --;
 3685|  3.39k|    }
 3686|    350|    if (IS_XMLPGD_SEP(*cur)) {
  ------------------
  |  | 3676|    350|#   define IS_XMLPGD_SEP(ch) (ch=='/')
  |  |  ------------------
  |  |  |  Branch (3676:30): [True: 9, False: 341]
  |  |  ------------------
  ------------------
 3687|      9|        if (cur == dir) dir[1] = 0;
  ------------------
  |  Branch (3687:13): [True: 0, False: 9]
  ------------------
 3688|      9|	else *cur = 0;
 3689|      9|	ret = xmlMemStrdup(dir);
 3690|    341|    } else {
 3691|    341|        if (getcwd(dir, 1024) != NULL) {
  ------------------
  |  Branch (3691:13): [True: 341, False: 0]
  ------------------
 3692|    341|	    dir[1023] = 0;
 3693|    341|	    ret = xmlMemStrdup(dir);
 3694|    341|	}
 3695|    341|    }
 3696|    350|    return(ret);
 3697|    350|#undef IS_XMLPGD_SEP
 3698|    350|}
xmlSetExternalEntityLoader:
 3937|      2|xmlSetExternalEntityLoader(xmlExternalEntityLoader f) {
 3938|      2|    xmlCurrentExternalEntityLoader = f;
 3939|      2|}
xmlLoadExternalEntity:
 3966|  10.1k|                      xmlParserCtxtPtr ctxt) {
 3967|  10.1k|    if ((URL != NULL) && (xmlNoNetExists(URL) == 0)) {
  ------------------
  |  Branch (3967:9): [True: 10.1k, False: 0]
  |  Branch (3967:26): [True: 10.1k, False: 0]
  ------------------
 3968|  10.1k|	char *canonicFilename;
 3969|  10.1k|	xmlParserInputPtr ret;
 3970|       |
 3971|  10.1k|	canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);
 3972|  10.1k|	if (canonicFilename == NULL) {
  ------------------
  |  Branch (3972:6): [True: 0, False: 10.1k]
  ------------------
 3973|      0|            xmlErrMemory(ctxt, "building canonical path\n");
 3974|      0|	    return(NULL);
 3975|      0|	}
 3976|       |
 3977|  10.1k|	ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);
 3978|  10.1k|	xmlFree(canonicFilename);
 3979|  10.1k|	return(ret);
 3980|  10.1k|    }
 3981|      0|    return(xmlCurrentExternalEntityLoader(URL, ID, ctxt));
 3982|  10.1k|}
xmlIO.c:xmlMemRead:
 2839|  22.1k|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|  22.1k|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|  22.1k|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 21.2k, False: 954]
  ------------------
 2843|  21.2k|        size = ctxt->size;
 2844|       |
 2845|  22.1k|    memcpy(buf, ctxt->mem, size);
 2846|  22.1k|    ctxt->mem += size;
 2847|  22.1k|    ctxt->size -= size;
 2848|       |
 2849|  22.1k|    return size;
 2850|  22.1k|}
xmlIO.c:xmlMemClose:
 2853|  10.6k|xmlMemClose(void *vctxt) {
 2854|  10.6k|    xmlFree(vctxt);
 2855|  10.6k|    return(0);
 2856|  10.6k|}
xmlIO.c:xmlStringRead:
 2917|    642|xmlStringRead(void *vctxt, char *buf, int size) {
 2918|    642|    xmlStringIOCtxt *ctxt = vctxt;
 2919|    642|    const xmlChar *zero;
 2920|    642|    size_t len;
 2921|       |
 2922|    642|    zero = memchr(ctxt->str, 0, size);
 2923|    642|    len = zero ? zero - ctxt->str : size;
  ------------------
  |  Branch (2923:11): [True: 642, False: 0]
  ------------------
 2924|       |
 2925|    642|    memcpy(buf, ctxt->str, len);
 2926|    642|    ctxt->str += len;
 2927|       |
 2928|    642|    return(len);
 2929|    642|}
xmlIO.c:xmlStringClose:
 2932|    324|xmlStringClose(void *vctxt) {
 2933|    324|    xmlFree(vctxt);
 2934|    324|    return(0);
 2935|    324|}
xmlIO.c:endOfInput:
 3165|  1.45M|	    int len ATTRIBUTE_UNUSED) {
 3166|  1.45M|    return(0);
 3167|  1.45M|}
xmlIO.c:xmlEscapeContent:
 3385|  14.3k|                 const xmlChar* in, int *inlen) {
 3386|  14.3k|    unsigned char* outstart = out;
 3387|  14.3k|    const unsigned char* base = in;
 3388|  14.3k|    unsigned char* outend = out + *outlen;
 3389|  14.3k|    const unsigned char* inend;
 3390|       |
 3391|  14.3k|    inend = in + (*inlen);
 3392|       |
 3393|   210k|    while ((in < inend) && (out < outend)) {
  ------------------
  |  Branch (3393:12): [True: 196k, False: 14.3k]
  |  Branch (3393:28): [True: 196k, False: 9]
  ------------------
 3394|   196k|	if (*in == '<') {
  ------------------
  |  Branch (3394:6): [True: 102, False: 195k]
  ------------------
 3395|    102|	    if (outend - out < 4) break;
  ------------------
  |  Branch (3395:10): [True: 0, False: 102]
  ------------------
 3396|    102|	    *out++ = '&';
 3397|    102|	    *out++ = 'l';
 3398|    102|	    *out++ = 't';
 3399|    102|	    *out++ = ';';
 3400|   195k|	} else if (*in == '>') {
  ------------------
  |  Branch (3400:13): [True: 95, False: 195k]
  ------------------
 3401|     95|	    if (outend - out < 4) break;
  ------------------
  |  Branch (3401:10): [True: 0, False: 95]
  ------------------
 3402|     95|	    *out++ = '&';
 3403|     95|	    *out++ = 'g';
 3404|     95|	    *out++ = 't';
 3405|     95|	    *out++ = ';';
 3406|   195k|	} else if (*in == '&') {
  ------------------
  |  Branch (3406:13): [True: 44, False: 195k]
  ------------------
 3407|     44|	    if (outend - out < 5) break;
  ------------------
  |  Branch (3407:10): [True: 0, False: 44]
  ------------------
 3408|     44|	    *out++ = '&';
 3409|     44|	    *out++ = 'a';
 3410|     44|	    *out++ = 'm';
 3411|     44|	    *out++ = 'p';
 3412|     44|	    *out++ = ';';
 3413|   195k|	} else if (*in == '\r') {
  ------------------
  |  Branch (3413:13): [True: 0, False: 195k]
  ------------------
 3414|      0|	    if (outend - out < 5) break;
  ------------------
  |  Branch (3414:10): [True: 0, False: 0]
  ------------------
 3415|      0|	    *out++ = '&';
 3416|      0|	    *out++ = '#';
 3417|      0|	    *out++ = '1';
 3418|      0|	    *out++ = '3';
 3419|      0|	    *out++ = ';';
 3420|   195k|	} else {
 3421|   195k|	    *out++ = *in;
 3422|   195k|	}
 3423|   196k|	++in;
 3424|   196k|    }
 3425|  14.3k|    *outlen = out - outstart;
 3426|  14.3k|    *inlen = in - base;
 3427|  14.3k|    return(0);
 3428|  14.3k|}
xmlIO.c:xmlNoNetExists:
 3781|  10.1k|static int xmlNoNetExists(const char *URL) {
 3782|  10.1k|    const char *path;
 3783|       |
 3784|  10.1k|    if (URL == NULL)
  ------------------
  |  Branch (3784:9): [True: 0, False: 10.1k]
  ------------------
 3785|      0|	return(0);
 3786|       |
 3787|  10.1k|    if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|  10.1k|#define BAD_CAST (xmlChar *)
  ------------------
                  if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file://localhost/", 17))
  ------------------
  |  |   35|  10.1k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3787:9): [True: 0, False: 10.1k]
  ------------------
 3788|       |#if defined (_WIN32)
 3789|       |	path = &URL[17];
 3790|       |#else
 3791|      0|	path = &URL[16];
 3792|  10.1k|#endif
 3793|  10.1k|    else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|  10.1k|#define BAD_CAST (xmlChar *)
  ------------------
                  else if (!xmlStrncasecmp(BAD_CAST URL, BAD_CAST "file:///", 8)) {
  ------------------
  |  |   35|  10.1k|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (3793:14): [True: 0, False: 10.1k]
  ------------------
 3794|       |#if defined (_WIN32)
 3795|       |	path = &URL[8];
 3796|       |#else
 3797|      0|	path = &URL[7];
 3798|      0|#endif
 3799|      0|    } else
 3800|  10.1k|	path = URL;
 3801|       |
 3802|  10.1k|    return xmlCheckFilename(path);
 3803|  10.1k|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlTextReaderRead:
 1160|  39.6k|xmlTextReaderRead(xmlTextReaderPtr reader) {
 1161|  39.6k|    int val, olddepth = 0;
 1162|  39.6k|    xmlTextReaderState oldstate = XML_TEXTREADER_START;
 1163|  39.6k|    xmlNodePtr oldnode = NULL;
 1164|       |
 1165|       |
 1166|  39.6k|    if (reader == NULL)
  ------------------
  |  Branch (1166:9): [True: 0, False: 39.6k]
  ------------------
 1167|      0|	return(-1);
 1168|  39.6k|    reader->curnode = NULL;
 1169|  39.6k|    if (reader->doc != NULL)
  ------------------
  |  Branch (1169:9): [True: 0, False: 39.6k]
  ------------------
 1170|      0|        return(xmlTextReaderReadTree(reader));
 1171|  39.6k|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1171:9): [True: 0, False: 39.6k]
  ------------------
 1172|      0|	return(-1);
 1173|       |
 1174|  39.6k|    if (reader->mode == XML_TEXTREADER_MODE_INITIAL) {
  ------------------
  |  Branch (1174:9): [True: 323, False: 39.3k]
  ------------------
 1175|    323|	reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;
 1176|       |	/*
 1177|       |	 * Initial state
 1178|       |	 */
 1179|    552|	do {
 1180|    552|	    val = xmlTextReaderPushData(reader);
 1181|    552|		if (val < 0){
  ------------------
  |  Branch (1181:7): [True: 55, False: 497]
  ------------------
 1182|     55|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1183|     55|			reader->state = XML_TEXTREADER_ERROR;
 1184|     55|		return(-1);
 1185|     55|		}
 1186|    552|	} while ((reader->ctxt->node == NULL) &&
  ------------------
  |  Branch (1186:11): [True: 437, False: 60]
  ------------------
 1187|    497|		 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&
  ------------------
  |  Branch (1187:5): [True: 229, False: 208]
  ------------------
 1188|    437|		  (reader->state != XML_TEXTREADER_DONE)));
  ------------------
  |  Branch (1188:5): [True: 229, False: 0]
  ------------------
 1189|    268|	if (reader->ctxt->node == NULL) {
  ------------------
  |  Branch (1189:6): [True: 208, False: 60]
  ------------------
 1190|    208|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1190:10): [True: 208, False: 0]
  ------------------
 1191|    208|		reader->node = reader->ctxt->myDoc->children;
 1192|    208|	    }
 1193|    208|	    if (reader->node == NULL){
  ------------------
  |  Branch (1193:10): [True: 0, False: 208]
  ------------------
 1194|      0|			reader->mode = XML_TEXTREADER_MODE_ERROR;
 1195|      0|			reader->state = XML_TEXTREADER_ERROR;
 1196|      0|		return(-1);
 1197|      0|		}
 1198|    208|	    reader->state = XML_TEXTREADER_ELEMENT;
 1199|    208|	} else {
 1200|     60|	    if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (1200:10): [True: 60, False: 0]
  ------------------
 1201|     60|		reader->node = reader->ctxt->myDoc->children;
 1202|     60|	    }
 1203|     60|	    if (reader->node == NULL)
  ------------------
  |  Branch (1203:10): [True: 0, False: 60]
  ------------------
 1204|      0|		reader->node = reader->ctxt->nodeTab[0];
 1205|     60|	    reader->state = XML_TEXTREADER_ELEMENT;
 1206|     60|	}
 1207|    268|	reader->depth = 0;
 1208|    268|	reader->ctxt->parseMode = XML_PARSE_READER;
 1209|    268|	goto node_found;
 1210|    268|    }
 1211|  39.3k|    oldstate = reader->state;
 1212|  39.3k|    olddepth = reader->ctxt->nodeNr;
 1213|  39.3k|    oldnode = reader->node;
 1214|       |
 1215|  39.3k|get_next_node:
 1216|  39.3k|    if (reader->node == NULL) {
  ------------------
  |  Branch (1216:9): [True: 3.17k, False: 36.1k]
  ------------------
 1217|  3.17k|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1217:6): [True: 2.62k, False: 550]
  ------------------
 1218|  2.62k|	    return(0);
 1219|    550|	else
 1220|    550|	    return(-1);
 1221|  3.17k|    }
 1222|       |
 1223|       |    /*
 1224|       |     * If we are not backtracking on ancestors or examined nodes,
 1225|       |     * that the parser didn't finished or that we aren't at the end
 1226|       |     * of stream, continue processing.
 1227|       |     */
 1228|  36.8k|    while ((reader->node != NULL) && (reader->node->next == NULL) &&
  ------------------
  |  Branch (1228:12): [True: 36.8k, False: 0]
  |  Branch (1228:38): [True: 6.33k, False: 30.5k]
  ------------------
 1229|  36.8k|	   (reader->ctxt->nodeNr == olddepth) &&
  ------------------
  |  Branch (1229:5): [True: 6.29k, False: 38]
  ------------------
 1230|  36.8k|           ((oldstate == XML_TEXTREADER_BACKTRACK) ||
  ------------------
  |  Branch (1230:13): [True: 559, False: 5.73k]
  ------------------
 1231|  6.29k|            (reader->node->children == NULL) ||
  ------------------
  |  Branch (1231:13): [True: 4.27k, False: 1.46k]
  ------------------
 1232|  6.29k|	    (reader->node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (1232:6): [True: 0, False: 1.46k]
  ------------------
 1233|  6.29k|	    ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1233:7): [True: 1.46k, False: 0]
  ------------------
 1234|  1.46k|	     (reader->node->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (1234:7): [True: 1.26k, False: 203]
  ------------------
 1235|  1.46k|	     (reader->node->children->next == NULL)) ||
  ------------------
  |  Branch (1235:7): [True: 538, False: 723]
  ------------------
 1236|  6.29k|	    (reader->node->type == XML_DTD_NODE) ||
  ------------------
  |  Branch (1236:6): [True: 0, False: 926]
  ------------------
 1237|  6.29k|	    (reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1237:6): [True: 7, False: 919]
  ------------------
 1238|  6.29k|	    (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&
  ------------------
  |  Branch (1238:6): [True: 0, False: 919]
  ------------------
 1239|  36.8k|	   ((reader->ctxt->node == NULL) ||
  ------------------
  |  Branch (1239:6): [True: 945, False: 4.43k]
  ------------------
 1240|  5.37k|	    (reader->ctxt->node == reader->node) ||
  ------------------
  |  Branch (1240:6): [True: 397, False: 4.03k]
  ------------------
 1241|  5.37k|	    (reader->ctxt->node == reader->node->parent)) &&
  ------------------
  |  Branch (1241:6): [True: 296, False: 3.73k]
  ------------------
 1242|  36.8k|	   (reader->ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (1242:5): [True: 731, False: 907]
  ------------------
 1243|    731|	val = xmlTextReaderPushData(reader);
 1244|    731|	if (val < 0){
  ------------------
  |  Branch (1244:6): [True: 25, False: 706]
  ------------------
 1245|     25|		reader->mode = XML_TEXTREADER_MODE_ERROR;
 1246|     25|		reader->state = XML_TEXTREADER_ERROR;
 1247|     25|	    return(-1);
 1248|     25|	}
 1249|    706|	if (reader->node == NULL)
  ------------------
  |  Branch (1249:6): [True: 0, False: 706]
  ------------------
 1250|      0|	    goto node_end;
 1251|    706|    }
 1252|  36.1k|    if (oldstate != XML_TEXTREADER_BACKTRACK) {
  ------------------
  |  Branch (1252:9): [True: 31.9k, False: 4.14k]
  ------------------
 1253|  31.9k|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1253:6): [True: 4.26k, False: 27.7k]
  ------------------
 1254|  31.9k|	    (reader->node->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1254:6): [True: 4.26k, False: 0]
  ------------------
 1255|  31.9k|	    (reader->node->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (1255:6): [True: 4.26k, False: 0]
  ------------------
 1256|  31.9k|	    (reader->node->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1256:6): [True: 4.15k, False: 114]
  ------------------
 1257|  4.15k|	    reader->node = reader->node->children;
 1258|  4.15k|	    reader->depth++;
 1259|  4.15k|	    reader->state = XML_TEXTREADER_ELEMENT;
 1260|  4.15k|	    goto node_found;
 1261|  4.15k|	}
 1262|  31.9k|    }
 1263|  31.9k|    if (reader->node->next != NULL) {
  ------------------
  |  Branch (1263:9): [True: 27.5k, False: 4.42k]
  ------------------
 1264|  27.5k|	if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1264:6): [True: 23.9k, False: 3.62k]
  ------------------
 1265|  27.5k|            (reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1265:13): [True: 10.0k, False: 13.9k]
  ------------------
 1266|  27.5k|	    (reader->node->children == NULL) &&
  ------------------
  |  Branch (1266:6): [True: 10.0k, False: 0]
  ------------------
 1267|  27.5k|	    ((reader->node->extra & NODE_IS_EMPTY) == 0)
  ------------------
  |  |  186|  10.0k|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1267:6): [True: 13, False: 9.99k]
  ------------------
 1268|  27.5k|#ifdef LIBXML_XINCLUDE_ENABLED
 1269|  27.5k|	    && (reader->in_xinclude <= 0)
  ------------------
  |  Branch (1269:9): [True: 13, False: 0]
  ------------------
 1270|  27.5k|#endif
 1271|  27.5k|	    ) {
 1272|     13|	    reader->state = XML_TEXTREADER_END;
 1273|     13|	    goto node_found;
 1274|     13|	}
 1275|  27.5k|#ifdef LIBXML_REGEXP_ENABLED
 1276|  27.5k|	if ((reader->validate) &&
  ------------------
  |  Branch (1276:6): [True: 0, False: 27.5k]
  ------------------
 1277|  27.5k|	    (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1277:6): [True: 0, False: 0]
  ------------------
 1278|      0|	    xmlTextReaderValidatePop(reader);
 1279|  27.5k|#endif /* LIBXML_REGEXP_ENABLED */
 1280|  27.5k|        if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1280:13): [True: 0, False: 27.5k]
  ------------------
 1281|  27.5k|	    (reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1281:6): [True: 0, False: 0]
  ------------------
 1282|      0|	    reader->preserves--;
 1283|  27.5k|	reader->node = reader->node->next;
 1284|  27.5k|	reader->state = XML_TEXTREADER_ELEMENT;
 1285|       |
 1286|       |	/*
 1287|       |	 * Cleanup of the old node
 1288|       |	 */
 1289|  27.5k|	if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1289:6): [True: 27.5k, False: 0]
  ------------------
 1290|  27.5k|#ifdef LIBXML_XINCLUDE_ENABLED
 1291|  27.5k|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1291:6): [True: 27.5k, False: 0]
  ------------------
 1292|  27.5k|#endif
 1293|  27.5k|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1293:6): [True: 27.5k, False: 0]
  ------------------
 1294|  27.5k|	    (reader->node->prev != NULL) &&
  ------------------
  |  Branch (1294:6): [True: 27.5k, False: 0]
  ------------------
 1295|  27.5k|            (reader->node->prev->type != XML_DTD_NODE)) {
  ------------------
  |  Branch (1295:13): [True: 27.3k, False: 166]
  ------------------
 1296|  27.3k|	    xmlNodePtr tmp = reader->node->prev;
 1297|  27.3k|	    if ((tmp->extra & NODE_IS_PRESERVED) == 0) {
  ------------------
  |  |  187|  27.3k|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1297:10): [True: 27.3k, False: 0]
  ------------------
 1298|  27.3k|                if (oldnode == tmp)
  ------------------
  |  Branch (1298:21): [True: 27.3k, False: 0]
  ------------------
 1299|  27.3k|                    oldnode = NULL;
 1300|  27.3k|		xmlUnlinkNode(tmp);
 1301|  27.3k|		xmlTextReaderFreeNode(reader, tmp);
 1302|  27.3k|	    }
 1303|  27.3k|	}
 1304|       |
 1305|  27.5k|	goto node_found;
 1306|  27.5k|    }
 1307|  4.42k|    if ((oldstate == XML_TEXTREADER_ELEMENT) &&
  ------------------
  |  Branch (1307:9): [True: 3.87k, False: 551]
  ------------------
 1308|  4.42k|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1308:2): [True: 90, False: 3.78k]
  ------------------
 1309|  4.42k|	(reader->node->children == NULL) &&
  ------------------
  |  Branch (1309:2): [True: 90, False: 0]
  ------------------
 1310|  4.42k|	((reader->node->extra & NODE_IS_EMPTY) == 0)) {;
  ------------------
  |  |  186|     90|#define NODE_IS_EMPTY		0x1
  ------------------
  |  Branch (1310:2): [True: 14, False: 76]
  ------------------
 1311|     14|	reader->state = XML_TEXTREADER_END;
 1312|     14|	goto node_found;
 1313|     14|    }
 1314|  4.41k|#ifdef LIBXML_REGEXP_ENABLED
 1315|  4.41k|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (1315:9): [True: 0, False: 4.41k]
  |  Branch (1315:62): [True: 0, False: 0]
  ------------------
 1316|      0|	xmlTextReaderValidatePop(reader);
 1317|  4.41k|#endif /* LIBXML_REGEXP_ENABLED */
 1318|  4.41k|    if ((reader->preserves > 0) &&
  ------------------
  |  Branch (1318:9): [True: 0, False: 4.41k]
  ------------------
 1319|  4.41k|	(reader->node->extra & NODE_IS_SPRESERVED))
  ------------------
  |  |  188|      0|#define NODE_IS_SPRESERVED	0x4
  ------------------
  |  Branch (1319:2): [True: 0, False: 0]
  ------------------
 1320|      0|	reader->preserves--;
 1321|  4.41k|    reader->node = reader->node->parent;
 1322|  4.41k|    if ((reader->node == NULL) ||
  ------------------
  |  Branch (1322:9): [True: 0, False: 4.41k]
  ------------------
 1323|  4.41k|	(reader->node->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1323:2): [True: 269, False: 4.14k]
  ------------------
 1324|  4.41k|	(reader->node->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (1324:2): [True: 0, False: 4.14k]
  ------------------
 1325|    269|	if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (1325:6): [True: 7, False: 262]
  ------------------
 1326|      7|	    val = xmlParseChunk(reader->ctxt, "", 0, 1);
 1327|      7|	    reader->state = XML_TEXTREADER_DONE;
 1328|      7|	    if (val != 0)
  ------------------
  |  Branch (1328:10): [True: 7, False: 0]
  ------------------
 1329|      7|	        return(-1);
 1330|      7|	}
 1331|    262|	reader->node = NULL;
 1332|    262|	reader->depth = -1;
 1333|       |
 1334|       |	/*
 1335|       |	 * Cleanup of the old node
 1336|       |	 */
 1337|    262|	if ((oldnode != NULL) && (reader->preserves == 0) &&
  ------------------
  |  Branch (1337:6): [True: 262, False: 0]
  |  Branch (1337:27): [True: 262, False: 0]
  ------------------
 1338|    262|#ifdef LIBXML_XINCLUDE_ENABLED
 1339|    262|	    (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1339:6): [True: 262, False: 0]
  ------------------
 1340|    262|#endif
 1341|    262|	    (reader->entNr == 0) &&
  ------------------
  |  Branch (1341:6): [True: 262, False: 0]
  ------------------
 1342|    262|	    (oldnode->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (1342:6): [True: 262, False: 0]
  ------------------
 1343|    262|	    ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|    262|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1343:6): [True: 262, False: 0]
  ------------------
 1344|    262|	    xmlUnlinkNode(oldnode);
 1345|    262|	    xmlTextReaderFreeNode(reader, oldnode);
 1346|    262|	}
 1347|       |
 1348|    262|	goto node_end;
 1349|    269|    }
 1350|  4.14k|    if ((reader->preserves == 0) &&
  ------------------
  |  Branch (1350:9): [True: 4.14k, False: 0]
  ------------------
 1351|  4.14k|#ifdef LIBXML_XINCLUDE_ENABLED
 1352|  4.14k|        (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1352:9): [True: 4.14k, False: 0]
  ------------------
 1353|  4.14k|#endif
 1354|  4.14k|	(reader->entNr == 0) &&
  ------------------
  |  Branch (1354:2): [True: 4.14k, False: 0]
  ------------------
 1355|  4.14k|        (reader->node->last != NULL) &&
  ------------------
  |  Branch (1355:9): [True: 4.14k, False: 0]
  ------------------
 1356|  4.14k|        ((reader->node->last->extra & NODE_IS_PRESERVED) == 0)) {
  ------------------
  |  |  187|  4.14k|#define NODE_IS_PRESERVED	0x2
  ------------------
  |  Branch (1356:9): [True: 4.14k, False: 0]
  ------------------
 1357|  4.14k|	xmlNodePtr tmp = reader->node->last;
 1358|  4.14k|	xmlUnlinkNode(tmp);
 1359|  4.14k|	xmlTextReaderFreeNode(reader, tmp);
 1360|  4.14k|    }
 1361|  4.14k|    reader->depth--;
 1362|  4.14k|    reader->state = XML_TEXTREADER_BACKTRACK;
 1363|       |
 1364|  36.1k|node_found:
 1365|       |    /*
 1366|       |     * If we are in the middle of a piece of CDATA make sure it's finished
 1367|       |     */
 1368|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1368:9): [True: 36.1k, False: 0]
  ------------------
 1369|  36.1k|        (reader->node->next == NULL) &&
  ------------------
  |  Branch (1369:9): [True: 6.86k, False: 29.2k]
  ------------------
 1370|  36.1k|        ((reader->node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1370:10): [True: 4.42k, False: 2.43k]
  ------------------
 1371|  6.86k|	 (reader->node->type == XML_CDATA_SECTION_NODE))) {
  ------------------
  |  Branch (1371:3): [True: 27, False: 2.41k]
  ------------------
 1372|  4.45k|            if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1372:17): [True: 1, False: 4.45k]
  ------------------
 1373|      1|	        return -1;
 1374|  4.45k|    }
 1375|       |
 1376|  36.1k|#ifdef LIBXML_XINCLUDE_ENABLED
 1377|       |    /*
 1378|       |     * Handle XInclude if asked for
 1379|       |     */
 1380|  36.1k|    if ((reader->xinclude) && (reader->in_xinclude == 0) &&
  ------------------
  |  Branch (1380:9): [True: 0, False: 36.1k]
  |  Branch (1380:31): [True: 0, False: 0]
  ------------------
 1381|  36.1k|        (reader->node != NULL) &&
  ------------------
  |  Branch (1381:9): [True: 0, False: 0]
  ------------------
 1382|  36.1k|	(reader->node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1382:2): [True: 0, False: 0]
  ------------------
 1383|  36.1k|	(reader->node->ns != NULL) &&
  ------------------
  |  Branch (1383:2): [True: 0, False: 0]
  ------------------
 1384|  36.1k|	((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||
  ------------------
  |  |   30|      0|#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
  ------------------
  |  Branch (1384:3): [True: 0, False: 0]
  ------------------
 1385|      0|	 (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {
  ------------------
  |  |   36|      0|#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
  ------------------
  |  Branch (1385:3): [True: 0, False: 0]
  ------------------
 1386|      0|	if (reader->xincctxt == NULL) {
  ------------------
  |  Branch (1386:6): [True: 0, False: 0]
  ------------------
 1387|      0|	    reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);
 1388|      0|	    xmlXIncludeSetFlags(reader->xincctxt,
 1389|      0|	                        reader->parserFlags & (~XML_PARSE_NOXINCNODE));
 1390|      0|            xmlXIncludeSetStreamingMode(reader->xincctxt, 1);
 1391|      0|	}
 1392|       |	/*
 1393|       |	 * expand that node and process it
 1394|       |	 */
 1395|      0|	if (xmlTextReaderExpand(reader) == NULL)
  ------------------
  |  Branch (1395:6): [True: 0, False: 0]
  ------------------
 1396|      0|	    return -1;
 1397|      0|	xmlXIncludeProcessNode(reader->xincctxt, reader->node);
 1398|      0|    }
 1399|  36.1k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_START)) {
  ------------------
  |  Branch (1399:9): [True: 36.1k, False: 0]
  |  Branch (1399:35): [True: 0, False: 36.1k]
  ------------------
 1400|      0|        reader->in_xinclude++;
 1401|      0|	goto get_next_node;
 1402|      0|    }
 1403|  36.1k|    if ((reader->node != NULL) && (reader->node->type == XML_XINCLUDE_END)) {
  ------------------
  |  Branch (1403:9): [True: 36.1k, False: 0]
  |  Branch (1403:35): [True: 0, False: 36.1k]
  ------------------
 1404|      0|        reader->in_xinclude--;
 1405|      0|	goto get_next_node;
 1406|      0|    }
 1407|  36.1k|#endif
 1408|       |    /*
 1409|       |     * Handle entities enter and exit when in entity replacement mode
 1410|       |     */
 1411|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1411:9): [True: 36.1k, False: 0]
  ------------------
 1412|  36.1k|	(reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1412:2): [True: 1, False: 36.1k]
  ------------------
 1413|  36.1k|	(reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {
  ------------------
  |  Branch (1413:2): [True: 1, False: 0]
  |  Branch (1413:28): [True: 1, False: 0]
  ------------------
 1414|      1|	if ((reader->node->children != NULL) &&
  ------------------
  |  Branch (1414:6): [True: 0, False: 1]
  ------------------
 1415|      1|	    (reader->node->children->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1415:6): [True: 0, False: 0]
  ------------------
 1416|      1|	    (reader->node->children->children != NULL)) {
  ------------------
  |  Branch (1416:6): [True: 0, False: 0]
  ------------------
 1417|      0|	    if (xmlTextReaderEntPush(reader, reader->node) < 0)
  ------------------
  |  Branch (1417:10): [True: 0, False: 0]
  ------------------
 1418|      0|                goto get_next_node;
 1419|      0|	    reader->node = reader->node->children->children;
 1420|      0|	}
 1421|      1|#ifdef LIBXML_REGEXP_ENABLED
 1422|  36.1k|    } else if ((reader->node != NULL) &&
  ------------------
  |  Branch (1422:16): [True: 36.1k, False: 0]
  ------------------
 1423|  36.1k|	       (reader->node->type == XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (1423:9): [True: 0, False: 36.1k]
  ------------------
 1424|  36.1k|	       (reader->ctxt != NULL) && (reader->validate)) {
  ------------------
  |  Branch (1424:9): [True: 0, False: 0]
  |  Branch (1424:35): [True: 0, False: 0]
  ------------------
 1425|      0|	xmlTextReaderValidateEntity(reader);
 1426|      0|#endif /* LIBXML_REGEXP_ENABLED */
 1427|      0|    }
 1428|  36.1k|    if ((reader->node != NULL) &&
  ------------------
  |  Branch (1428:9): [True: 36.1k, False: 0]
  ------------------
 1429|  36.1k|	(reader->node->type == XML_ENTITY_DECL) &&
  ------------------
  |  Branch (1429:2): [True: 0, False: 36.1k]
  ------------------
 1430|  36.1k|	(reader->ent != NULL) && (reader->ent->children == reader->node)) {
  ------------------
  |  Branch (1430:2): [True: 0, False: 0]
  |  Branch (1430:27): [True: 0, False: 0]
  ------------------
 1431|      0|	reader->node = xmlTextReaderEntPop(reader);
 1432|      0|	reader->depth++;
 1433|      0|        goto get_next_node;
 1434|      0|    }
 1435|  36.1k|#ifdef LIBXML_REGEXP_ENABLED
 1436|  36.1k|    if ((reader->validate != XML_TEXTREADER_NOT_VALIDATE) && (reader->node != NULL)) {
  ------------------
  |  Branch (1436:9): [True: 0, False: 36.1k]
  |  Branch (1436:62): [True: 0, False: 0]
  ------------------
 1437|      0|	xmlNodePtr node = reader->node;
 1438|       |
 1439|      0|	if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1439:6): [True: 0, False: 0]
  ------------------
 1440|      0|            ((reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1440:14): [True: 0, False: 0]
  ------------------
 1441|      0|	     (reader->state != XML_TEXTREADER_BACKTRACK))) {
  ------------------
  |  Branch (1441:7): [True: 0, False: 0]
  ------------------
 1442|      0|	    xmlTextReaderValidatePush(reader);
 1443|      0|	} else if ((node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1443:13): [True: 0, False: 0]
  ------------------
 1444|      0|		   (node->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (1444:6): [True: 0, False: 0]
  ------------------
 1445|      0|            xmlTextReaderValidateCData(reader, node->content,
 1446|      0|	                               xmlStrlen(node->content));
 1447|      0|	}
 1448|      0|    }
 1449|  36.1k|#endif /* LIBXML_REGEXP_ENABLED */
 1450|  36.1k|#ifdef LIBXML_PATTERN_ENABLED
 1451|  36.1k|    if ((reader->patternNr > 0) && (reader->state != XML_TEXTREADER_END) &&
  ------------------
  |  Branch (1451:9): [True: 0, False: 36.1k]
  |  Branch (1451:36): [True: 0, False: 0]
  ------------------
 1452|  36.1k|        (reader->state != XML_TEXTREADER_BACKTRACK)) {
  ------------------
  |  Branch (1452:9): [True: 0, False: 0]
  ------------------
 1453|      0|        int i;
 1454|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (1454:13): [True: 0, False: 0]
  ------------------
 1455|      0|	     if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {
  ------------------
  |  Branch (1455:11): [True: 0, False: 0]
  ------------------
 1456|      0|	         xmlTextReaderPreserve(reader);
 1457|      0|		 break;
 1458|      0|             }
 1459|      0|	}
 1460|      0|    }
 1461|  36.1k|#endif /* LIBXML_PATTERN_ENABLED */
 1462|  36.1k|#ifdef LIBXML_SCHEMAS_ENABLED
 1463|  36.1k|    if ((reader->validate == XML_TEXTREADER_VALIDATE_XSD) &&
  ------------------
  |  Branch (1463:9): [True: 0, False: 36.1k]
  ------------------
 1464|  36.1k|        (reader->xsdValidErrors == 0) &&
  ------------------
  |  Branch (1464:9): [True: 0, False: 0]
  ------------------
 1465|  36.1k|	(reader->xsdValidCtxt != NULL)) {
  ------------------
  |  Branch (1465:2): [True: 0, False: 0]
  ------------------
 1466|      0|	reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);
 1467|      0|    }
 1468|  36.1k|#endif /* LIBXML_PATTERN_ENABLED */
 1469|  36.1k|    return(1);
 1470|    262|node_end:
 1471|    262|    reader->state = XML_TEXTREADER_DONE;
 1472|    262|    return(0);
 1473|  36.1k|}
xmlTextReaderExpand:
 1501|  4.45k|xmlTextReaderExpand(xmlTextReaderPtr reader) {
 1502|  4.45k|    if ((reader == NULL) || (reader->node == NULL))
  ------------------
  |  Branch (1502:9): [True: 0, False: 4.45k]
  |  Branch (1502:29): [True: 0, False: 4.45k]
  ------------------
 1503|      0|        return(NULL);
 1504|  4.45k|    if (reader->doc != NULL)
  ------------------
  |  Branch (1504:9): [True: 0, False: 4.45k]
  ------------------
 1505|      0|        return(reader->node);
 1506|  4.45k|    if (reader->ctxt == NULL)
  ------------------
  |  Branch (1506:9): [True: 0, False: 4.45k]
  ------------------
 1507|      0|        return(NULL);
 1508|  4.45k|    if (xmlTextReaderDoExpand(reader) < 0)
  ------------------
  |  Branch (1508:9): [True: 1, False: 4.45k]
  ------------------
 1509|      1|        return(NULL);
 1510|  4.45k|    return(reader->node);
 1511|  4.45k|}
xmlNewTextReader:
 1935|    323|xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {
 1936|    323|    xmlTextReaderPtr ret;
 1937|       |
 1938|    323|    if (input == NULL)
  ------------------
  |  Branch (1938:9): [True: 0, False: 323]
  ------------------
 1939|      0|	return(NULL);
 1940|    323|    ret = xmlMalloc(sizeof(xmlTextReader));
 1941|    323|    if (ret == NULL) {
  ------------------
  |  Branch (1941:9): [True: 0, False: 323]
  ------------------
 1942|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1943|      0|		"xmlNewTextReader : malloc failed\n");
 1944|      0|	return(NULL);
 1945|      0|    }
 1946|    323|    memset(ret, 0, sizeof(xmlTextReader));
 1947|    323|    ret->doc = NULL;
 1948|    323|    ret->entTab = NULL;
 1949|    323|    ret->entMax = 0;
 1950|    323|    ret->entNr = 0;
 1951|    323|    ret->input = input;
 1952|    323|    ret->buffer = xmlBufCreateSize(100);
 1953|    323|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (1953:9): [True: 0, False: 323]
  ------------------
 1954|      0|        xmlFree(ret);
 1955|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1956|      0|		"xmlNewTextReader : malloc failed\n");
 1957|      0|	return(NULL);
 1958|      0|    }
 1959|       |    /* no operation on a reader should require a huge buffer */
 1960|    323|    xmlBufSetAllocationScheme(ret->buffer,
 1961|    323|			      XML_BUFFER_ALLOC_DOUBLEIT);
 1962|    323|    ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1963|    323|    if (ret->sax == NULL) {
  ------------------
  |  Branch (1963:9): [True: 0, False: 323]
  ------------------
 1964|      0|	xmlBufFree(ret->buffer);
 1965|      0|	xmlFree(ret);
 1966|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1967|      0|		"xmlNewTextReader : malloc failed\n");
 1968|      0|	return(NULL);
 1969|      0|    }
 1970|    323|    xmlSAXVersion(ret->sax, 2);
 1971|    323|    ret->startElement = ret->sax->startElement;
 1972|    323|    ret->sax->startElement = xmlTextReaderStartElement;
 1973|    323|    ret->endElement = ret->sax->endElement;
 1974|    323|    ret->sax->endElement = xmlTextReaderEndElement;
 1975|    323|#ifdef LIBXML_SAX1_ENABLED
 1976|    323|    if (ret->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    323|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1976:9): [True: 323, False: 0]
  ------------------
 1977|    323|#endif /* LIBXML_SAX1_ENABLED */
 1978|    323|	ret->startElementNs = ret->sax->startElementNs;
 1979|    323|	ret->sax->startElementNs = xmlTextReaderStartElementNs;
 1980|    323|	ret->endElementNs = ret->sax->endElementNs;
 1981|    323|	ret->sax->endElementNs = xmlTextReaderEndElementNs;
 1982|    323|#ifdef LIBXML_SAX1_ENABLED
 1983|    323|    } else {
 1984|      0|	ret->startElementNs = NULL;
 1985|      0|	ret->endElementNs = NULL;
 1986|      0|    }
 1987|    323|#endif /* LIBXML_SAX1_ENABLED */
 1988|    323|    ret->characters = ret->sax->characters;
 1989|    323|    ret->sax->characters = xmlTextReaderCharacters;
 1990|    323|    ret->sax->ignorableWhitespace = xmlTextReaderCharacters;
 1991|    323|    ret->cdataBlock = ret->sax->cdataBlock;
 1992|    323|    ret->sax->cdataBlock = xmlTextReaderCDataBlock;
 1993|       |
 1994|    323|    ret->mode = XML_TEXTREADER_MODE_INITIAL;
 1995|    323|    ret->node = NULL;
 1996|    323|    ret->curnode = NULL;
 1997|    323|    if (xmlBufUse(ret->input->buffer) < 4) {
  ------------------
  |  Branch (1997:9): [True: 323, False: 0]
  ------------------
 1998|    323|	xmlParserInputBufferRead(input, 4);
 1999|    323|    }
 2000|    323|    if (xmlBufUse(ret->input->buffer) >= 4) {
  ------------------
  |  Branch (2000:9): [True: 310, False: 13]
  ------------------
 2001|    310|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,
 2002|    310|			     (const char *) xmlBufContent(ret->input->buffer),
 2003|    310|                                            4, URI);
 2004|    310|	ret->base = 0;
 2005|    310|	ret->cur = 4;
 2006|    310|    } else {
 2007|     13|	ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);
 2008|     13|	ret->base = 0;
 2009|     13|	ret->cur = 0;
 2010|     13|    }
 2011|       |
 2012|    323|    if (ret->ctxt == NULL) {
  ------------------
  |  Branch (2012:9): [True: 0, False: 323]
  ------------------
 2013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2014|      0|		"xmlNewTextReader : malloc failed\n");
 2015|      0|	xmlBufFree(ret->buffer);
 2016|      0|	xmlFree(ret->sax);
 2017|      0|	xmlFree(ret);
 2018|      0|	return(NULL);
 2019|      0|    }
 2020|    323|    ret->ctxt->parseMode = XML_PARSE_READER;
 2021|    323|    ret->ctxt->_private = ret;
 2022|    323|    ret->ctxt->linenumbers = 1;
 2023|    323|    ret->ctxt->dictNames = 1;
 2024|    323|    ret->allocs = XML_TEXTREADER_CTXT;
  ------------------
  |  |   99|    323|#define XML_TEXTREADER_CTXT	2
  ------------------
 2025|       |    /*
 2026|       |     * use the parser dictionary to allocate all elements and attributes names
 2027|       |     */
 2028|    323|    ret->ctxt->docdict = 1;
 2029|    323|    ret->dict = ret->ctxt->dict;
 2030|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 2031|    323|    ret->xinclude = 0;
 2032|    323|#endif
 2033|    323|#ifdef LIBXML_PATTERN_ENABLED
 2034|    323|    ret->patternMax = 0;
 2035|    323|    ret->patternTab = NULL;
 2036|    323|#endif
 2037|    323|    return(ret);
 2038|    323|}
xmlFreeTextReader:
 2079|    323|xmlFreeTextReader(xmlTextReaderPtr reader) {
 2080|    323|    if (reader == NULL)
  ------------------
  |  Branch (2080:9): [True: 0, False: 323]
  ------------------
 2081|      0|	return;
 2082|    323|#ifdef LIBXML_SCHEMAS_ENABLED
 2083|    323|    if (reader->rngSchemas != NULL) {
  ------------------
  |  Branch (2083:9): [True: 0, False: 323]
  ------------------
 2084|      0|	xmlRelaxNGFree(reader->rngSchemas);
 2085|      0|	reader->rngSchemas = NULL;
 2086|      0|    }
 2087|    323|    if (reader->rngValidCtxt != NULL) {
  ------------------
  |  Branch (2087:9): [True: 0, False: 323]
  ------------------
 2088|      0|	if (! reader->rngPreserveCtxt)
  ------------------
  |  Branch (2088:6): [True: 0, False: 0]
  ------------------
 2089|      0|	    xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);
 2090|      0|	reader->rngValidCtxt = NULL;
 2091|      0|    }
 2092|    323|    if (reader->xsdPlug != NULL) {
  ------------------
  |  Branch (2092:9): [True: 0, False: 323]
  ------------------
 2093|      0|	xmlSchemaSAXUnplug(reader->xsdPlug);
 2094|      0|	reader->xsdPlug = NULL;
 2095|      0|    }
 2096|    323|    if (reader->xsdValidCtxt != NULL) {
  ------------------
  |  Branch (2096:9): [True: 0, False: 323]
  ------------------
 2097|      0|	if (! reader->xsdPreserveCtxt)
  ------------------
  |  Branch (2097:6): [True: 0, False: 0]
  ------------------
 2098|      0|	    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);
 2099|      0|	reader->xsdValidCtxt = NULL;
 2100|      0|    }
 2101|    323|    if (reader->xsdSchemas != NULL) {
  ------------------
  |  Branch (2101:9): [True: 0, False: 323]
  ------------------
 2102|      0|	xmlSchemaFree(reader->xsdSchemas);
 2103|      0|	reader->xsdSchemas = NULL;
 2104|      0|    }
 2105|    323|#endif
 2106|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 2107|    323|    if (reader->xincctxt != NULL)
  ------------------
  |  Branch (2107:9): [True: 0, False: 323]
  ------------------
 2108|      0|	xmlXIncludeFreeContext(reader->xincctxt);
 2109|    323|#endif
 2110|    323|#ifdef LIBXML_PATTERN_ENABLED
 2111|    323|    if (reader->patternTab != NULL) {
  ------------------
  |  Branch (2111:9): [True: 0, False: 323]
  ------------------
 2112|      0|        int i;
 2113|      0|	for (i = 0;i < reader->patternNr;i++) {
  ------------------
  |  Branch (2113:13): [True: 0, False: 0]
  ------------------
 2114|      0|	    if (reader->patternTab[i] != NULL)
  ------------------
  |  Branch (2114:10): [True: 0, False: 0]
  ------------------
 2115|      0|	        xmlFreePattern(reader->patternTab[i]);
 2116|      0|	}
 2117|      0|	xmlFree(reader->patternTab);
 2118|      0|    }
 2119|    323|#endif
 2120|    323|    if (reader->mode != XML_TEXTREADER_MODE_CLOSED)
  ------------------
  |  Branch (2120:9): [True: 323, False: 0]
  ------------------
 2121|    323|        xmlTextReaderClose(reader);
 2122|    323|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2122:9): [True: 323, False: 0]
  ------------------
 2123|    323|        if (reader->dict == reader->ctxt->dict)
  ------------------
  |  Branch (2123:13): [True: 323, False: 0]
  ------------------
 2124|    323|	    reader->dict = NULL;
 2125|    323|	if (reader->allocs & XML_TEXTREADER_CTXT)
  ------------------
  |  |   99|    323|#define XML_TEXTREADER_CTXT	2
  ------------------
  |  Branch (2125:6): [True: 323, False: 0]
  ------------------
 2126|    323|	    xmlFreeParserCtxt(reader->ctxt);
 2127|    323|    }
 2128|    323|    if (reader->sax != NULL)
  ------------------
  |  Branch (2128:9): [True: 323, False: 0]
  ------------------
 2129|    323|	xmlFree(reader->sax);
 2130|    323|    if (reader->buffer != NULL)
  ------------------
  |  Branch (2130:9): [True: 323, False: 0]
  ------------------
 2131|    323|        xmlBufFree(reader->buffer);
 2132|    323|    if (reader->entTab != NULL)
  ------------------
  |  Branch (2132:9): [True: 0, False: 323]
  ------------------
 2133|      0|	xmlFree(reader->entTab);
 2134|    323|    if (reader->dict != NULL)
  ------------------
  |  Branch (2134:9): [True: 0, False: 323]
  ------------------
 2135|      0|        xmlDictFree(reader->dict);
 2136|    323|    xmlFree(reader);
 2137|    323|}
xmlTextReaderClose:
 2154|    323|xmlTextReaderClose(xmlTextReaderPtr reader) {
 2155|    323|    if (reader == NULL)
  ------------------
  |  Branch (2155:9): [True: 0, False: 323]
  ------------------
 2156|      0|	return(-1);
 2157|    323|    reader->node = NULL;
 2158|    323|    reader->curnode = NULL;
 2159|    323|    reader->mode = XML_TEXTREADER_MODE_CLOSED;
 2160|    323|    if (reader->faketext != NULL) {
  ------------------
  |  Branch (2160:9): [True: 66, False: 257]
  ------------------
 2161|     66|        xmlFreeNode(reader->faketext);
 2162|     66|        reader->faketext = NULL;
 2163|     66|    }
 2164|    323|    if (reader->ctxt != NULL) {
  ------------------
  |  Branch (2164:9): [True: 323, False: 0]
  ------------------
 2165|    323|#ifdef LIBXML_VALID_ENABLED
 2166|    323|	if ((reader->ctxt->vctxt.vstateTab != NULL) &&
  ------------------
  |  Branch (2166:6): [True: 0, False: 323]
  ------------------
 2167|    323|	    (reader->ctxt->vctxt.vstateMax > 0)){
  ------------------
  |  Branch (2167:6): [True: 0, False: 0]
  ------------------
 2168|      0|#ifdef LIBXML_REGEXP_ENABLED
 2169|      0|            while (reader->ctxt->vctxt.vstateNr > 0)
  ------------------
  |  Branch (2169:20): [True: 0, False: 0]
  ------------------
 2170|      0|                xmlValidatePopElement(&reader->ctxt->vctxt, NULL, NULL, NULL);
 2171|      0|#endif /* LIBXML_REGEXP_ENABLED */
 2172|      0|	    xmlFree(reader->ctxt->vctxt.vstateTab);
 2173|      0|	    reader->ctxt->vctxt.vstateTab = NULL;
 2174|      0|	    reader->ctxt->vctxt.vstateMax = 0;
 2175|      0|	}
 2176|    323|#endif /* LIBXML_VALID_ENABLED */
 2177|    323|	xmlStopParser(reader->ctxt);
 2178|    323|	if (reader->ctxt->myDoc != NULL) {
  ------------------
  |  Branch (2178:6): [True: 322, False: 1]
  ------------------
 2179|    322|	    if (reader->preserve == 0)
  ------------------
  |  Branch (2179:10): [True: 322, False: 0]
  ------------------
 2180|    322|		xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);
 2181|    322|	    reader->ctxt->myDoc = NULL;
 2182|    322|	}
 2183|    323|    }
 2184|    323|    if ((reader->input != NULL)  && (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (2184:9): [True: 323, False: 0]
  |  Branch (2184:37): [True: 323, False: 0]
  ------------------
 2185|    323|	xmlFreeParserInputBuffer(reader->input);
 2186|    323|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
 2187|    323|    }
 2188|    323|    return(0);
 2189|    323|}
xmlTextReaderMoveToAttributeNo:
 2448|  21.4k|xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader, int no) {
 2449|  21.4k|    int i;
 2450|  21.4k|    xmlAttrPtr cur;
 2451|  21.4k|    xmlNsPtr ns;
 2452|       |
 2453|  21.4k|    if (reader == NULL)
  ------------------
  |  Branch (2453:9): [True: 0, False: 21.4k]
  ------------------
 2454|      0|	return(-1);
 2455|  21.4k|    if (reader->node == NULL)
  ------------------
  |  Branch (2455:9): [True: 0, False: 21.4k]
  ------------------
 2456|      0|	return(-1);
 2457|       |    /* TODO: handle the xmlDecl */
 2458|  21.4k|    if (reader->node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2458:9): [True: 0, False: 21.4k]
  ------------------
 2459|      0|	return(-1);
 2460|       |
 2461|  21.4k|    reader->curnode = NULL;
 2462|       |
 2463|  21.4k|    ns = reader->node->nsDef;
 2464|  21.5k|    for (i = 0;(i < no) && (ns != NULL);i++) {
  ------------------
  |  Branch (2464:16): [True: 9.87k, False: 11.6k]
  |  Branch (2464:28): [True: 78, False: 9.80k]
  ------------------
 2465|     78|	ns = ns->next;
 2466|     78|    }
 2467|  21.4k|    if (ns != NULL) {
  ------------------
  |  Branch (2467:9): [True: 105, False: 21.3k]
  ------------------
 2468|    105|	reader->curnode = (xmlNodePtr) ns;
 2469|    105|	return(1);
 2470|    105|    }
 2471|       |
 2472|  21.3k|    cur = reader->node->properties;
 2473|  21.3k|    if (cur == NULL)
  ------------------
  |  Branch (2473:9): [True: 0, False: 21.3k]
  ------------------
 2474|      0|	return(0);
 2475|  41.8k|    for (;i < no;i++) {
  ------------------
  |  Branch (2475:11): [True: 20.4k, False: 21.3k]
  ------------------
 2476|  20.4k|	cur = cur->next;
 2477|  20.4k|	if (cur == NULL)
  ------------------
  |  Branch (2477:6): [True: 0, False: 20.4k]
  ------------------
 2478|      0|	    return(0);
 2479|  20.4k|    }
 2480|       |    /* TODO walk the DTD if present */
 2481|       |
 2482|  21.3k|    reader->curnode = (xmlNodePtr) cur;
 2483|  21.3k|    return(1);
 2484|  21.3k|}
xmlTextReaderReadAttributeValue:
 2753|  42.9k|xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader) {
 2754|  42.9k|    if (reader == NULL)
  ------------------
  |  Branch (2754:9): [True: 0, False: 42.9k]
  ------------------
 2755|      0|	return(-1);
 2756|  42.9k|    if (reader->node == NULL)
  ------------------
  |  Branch (2756:9): [True: 0, False: 42.9k]
  ------------------
 2757|      0|	return(-1);
 2758|  42.9k|    if (reader->curnode == NULL)
  ------------------
  |  Branch (2758:9): [True: 0, False: 42.9k]
  ------------------
 2759|      0|	return(0);
 2760|  42.9k|    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (2760:9): [True: 21.3k, False: 21.5k]
  ------------------
 2761|  21.3k|	if (reader->curnode->children == NULL)
  ------------------
  |  Branch (2761:6): [True: 0, False: 21.3k]
  ------------------
 2762|      0|	    return(0);
 2763|  21.3k|	reader->curnode = reader->curnode->children;
 2764|  21.5k|    } else if (reader->curnode->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (2764:16): [True: 105, False: 21.4k]
  ------------------
 2765|    105|	xmlNsPtr ns = (xmlNsPtr) reader->curnode;
 2766|       |
 2767|    105|	if (reader->faketext == NULL) {
  ------------------
  |  Branch (2767:6): [True: 66, False: 39]
  ------------------
 2768|     66|	    reader->faketext = xmlNewDocText(reader->node->doc,
 2769|     66|		                             ns->href);
 2770|     66|	} else {
 2771|     39|            if ((reader->faketext->content != NULL) &&
  ------------------
  |  Branch (2771:17): [True: 36, False: 3]
  ------------------
 2772|     39|	        (reader->faketext->content !=
  ------------------
  |  Branch (2772:10): [True: 36, False: 0]
  ------------------
 2773|     36|		 (xmlChar *) &(reader->faketext->properties)))
 2774|     36|		xmlFree(reader->faketext->content);
 2775|     39|	    reader->faketext->content = xmlStrdup(ns->href);
 2776|     39|	}
 2777|    105|	reader->curnode = reader->faketext;
 2778|  21.4k|    } else {
 2779|  21.4k|	if (reader->curnode->next == NULL)
  ------------------
  |  Branch (2779:6): [True: 21.4k, False: 0]
  ------------------
 2780|  21.4k|	    return(0);
 2781|      0|	reader->curnode = reader->curnode->next;
 2782|      0|    }
 2783|  21.4k|    return(1);
 2784|  42.9k|}
xmlTextReaderAttributeCount:
 2828|  14.2k|xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {
 2829|  14.2k|    int ret;
 2830|  14.2k|    xmlAttrPtr attr;
 2831|  14.2k|    xmlNsPtr ns;
 2832|  14.2k|    xmlNodePtr node;
 2833|       |
 2834|  14.2k|    if (reader == NULL)
  ------------------
  |  Branch (2834:9): [True: 0, False: 14.2k]
  ------------------
 2835|      0|	return(-1);
 2836|  14.2k|    if (reader->node == NULL)
  ------------------
  |  Branch (2836:9): [True: 0, False: 14.2k]
  ------------------
 2837|      0|	return(0);
 2838|       |
 2839|  14.2k|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2839:9): [True: 0, False: 14.2k]
  ------------------
 2840|      0|	node = reader->curnode;
 2841|  14.2k|    else
 2842|  14.2k|	node = reader->node;
 2843|       |
 2844|  14.2k|    if (node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (2844:9): [True: 0, False: 14.2k]
  ------------------
 2845|      0|	return(0);
 2846|  14.2k|    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2846:9): [True: 0, False: 14.2k]
  ------------------
 2847|  14.2k|	(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2847:2): [True: 0, False: 14.2k]
  ------------------
 2848|      0|	return(0);
 2849|  14.2k|    ret = 0;
 2850|  14.2k|    attr = node->properties;
 2851|  35.5k|    while (attr != NULL) {
  ------------------
  |  Branch (2851:12): [True: 21.3k, False: 14.2k]
  ------------------
 2852|  21.3k|	ret++;
 2853|  21.3k|	attr = attr->next;
 2854|  21.3k|    }
 2855|  14.2k|    ns = node->nsDef;
 2856|  14.3k|    while (ns != NULL) {
  ------------------
  |  Branch (2856:12): [True: 105, False: 14.2k]
  ------------------
 2857|    105|	ret++;
 2858|    105|	ns = ns->next;
 2859|    105|    }
 2860|  14.2k|    return(ret);
 2861|  14.2k|}
xmlTextReaderNodeType:
 2874|  36.0k|xmlTextReaderNodeType(xmlTextReaderPtr reader) {
 2875|  36.0k|    xmlNodePtr node;
 2876|       |
 2877|  36.0k|    if (reader == NULL)
  ------------------
  |  Branch (2877:9): [True: 0, False: 36.0k]
  ------------------
 2878|      0|	return(-1);
 2879|  36.0k|    if (reader->node == NULL)
  ------------------
  |  Branch (2879:9): [True: 0, False: 36.0k]
  ------------------
 2880|      0|	return(XML_READER_TYPE_NONE);
 2881|  36.0k|    if (reader->curnode != NULL)
  ------------------
  |  Branch (2881:9): [True: 0, False: 36.0k]
  ------------------
 2882|      0|	node = reader->curnode;
 2883|  36.0k|    else
 2884|  36.0k|	node = reader->node;
 2885|  36.0k|    switch (node->type) {
  ------------------
  |  Branch (2885:13): [True: 0, False: 36.0k]
  ------------------
 2886|  18.3k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (2886:9): [True: 18.3k, False: 17.6k]
  ------------------
 2887|  18.3k|	    if ((reader->state == XML_TEXTREADER_END) ||
  ------------------
  |  Branch (2887:10): [True: 22, False: 18.3k]
  ------------------
 2888|  18.3k|		(reader->state == XML_TEXTREADER_BACKTRACK))
  ------------------
  |  Branch (2888:3): [True: 4.13k, False: 14.2k]
  ------------------
 2889|  4.16k|		return(XML_READER_TYPE_END_ELEMENT);
 2890|  14.2k|	    return(XML_READER_TYPE_ELEMENT);
 2891|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (2891:9): [True: 0, False: 36.0k]
  ------------------
 2892|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (2892:9): [True: 0, False: 36.0k]
  ------------------
 2893|      0|	    return(XML_READER_TYPE_ATTRIBUTE);
 2894|  17.3k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (2894:9): [True: 17.3k, False: 18.7k]
  ------------------
 2895|  17.3k|	    if (xmlIsBlankNode(reader->node)) {
  ------------------
  |  Branch (2895:10): [True: 13.7k, False: 3.59k]
  ------------------
 2896|  13.7k|		if (xmlNodeGetSpacePreserve(reader->node))
  ------------------
  |  Branch (2896:7): [True: 13.7k, False: 0]
  ------------------
 2897|  13.7k|		    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);
 2898|      0|		else
 2899|      0|		    return(XML_READER_TYPE_WHITESPACE);
 2900|  13.7k|	    } else {
 2901|  3.59k|		return(XML_READER_TYPE_TEXT);
 2902|  3.59k|	    }
 2903|     33|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (2903:9): [True: 33, False: 36.0k]
  ------------------
 2904|     33|	    return(XML_READER_TYPE_CDATA);
 2905|      1|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (2905:9): [True: 1, False: 36.0k]
  ------------------
 2906|      1|	    return(XML_READER_TYPE_ENTITY_REFERENCE);
 2907|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (2907:9): [True: 0, False: 36.0k]
  ------------------
 2908|      0|	    return(XML_READER_TYPE_ENTITY);
 2909|     18|        case XML_PI_NODE:
  ------------------
  |  Branch (2909:9): [True: 18, False: 36.0k]
  ------------------
 2910|     18|	    return(XML_READER_TYPE_PROCESSING_INSTRUCTION);
 2911|    149|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (2911:9): [True: 149, False: 35.9k]
  ------------------
 2912|    149|	    return(XML_READER_TYPE_COMMENT);
 2913|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (2913:9): [True: 0, False: 36.0k]
  ------------------
 2914|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (2914:9): [True: 0, False: 36.0k]
  ------------------
 2915|      0|	    return(XML_READER_TYPE_DOCUMENT);
 2916|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (2916:9): [True: 0, False: 36.0k]
  ------------------
 2917|      0|	    return(XML_READER_TYPE_DOCUMENT_FRAGMENT);
 2918|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (2918:9): [True: 0, False: 36.0k]
  ------------------
 2919|      0|	    return(XML_READER_TYPE_NOTATION);
 2920|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (2920:9): [True: 0, False: 36.0k]
  ------------------
 2921|    165|        case XML_DTD_NODE:
  ------------------
  |  Branch (2921:9): [True: 165, False: 35.9k]
  ------------------
 2922|    165|	    return(XML_READER_TYPE_DOCUMENT_TYPE);
 2923|       |
 2924|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (2924:9): [True: 0, False: 36.0k]
  ------------------
 2925|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (2925:9): [True: 0, False: 36.0k]
  ------------------
 2926|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (2926:9): [True: 0, False: 36.0k]
  ------------------
 2927|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (2927:9): [True: 0, False: 36.0k]
  ------------------
 2928|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (2928:9): [True: 0, False: 36.0k]
  ------------------
 2929|      0|	    return(XML_READER_TYPE_NONE);
 2930|  36.0k|    }
 2931|      0|    return(-1);
 2932|  36.0k|}
xmlTextReaderSetup:
 4983|    323|{
 4984|    323|    if (reader == NULL) {
  ------------------
  |  Branch (4984:9): [True: 0, False: 323]
  ------------------
 4985|      0|        if (input != NULL)
  ------------------
  |  Branch (4985:13): [True: 0, False: 0]
  ------------------
 4986|      0|	    xmlFreeParserInputBuffer(input);
 4987|      0|        return (-1);
 4988|      0|    }
 4989|       |
 4990|       |    /*
 4991|       |     * we force the generation of compact text nodes on the reader
 4992|       |     * since usr applications should never modify the tree
 4993|       |     */
 4994|    323|    options |= XML_PARSE_COMPACT;
 4995|       |
 4996|    323|    reader->doc = NULL;
 4997|    323|    reader->entNr = 0;
 4998|    323|    reader->parserFlags = options;
 4999|    323|    reader->validate = XML_TEXTREADER_NOT_VALIDATE;
 5000|    323|    if ((input != NULL) && (reader->input != NULL) &&
  ------------------
  |  Branch (5000:9): [True: 0, False: 323]
  |  Branch (5000:28): [True: 0, False: 0]
  ------------------
 5001|    323|        (reader->allocs & XML_TEXTREADER_INPUT)) {
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
  |  Branch (5001:9): [True: 0, False: 0]
  ------------------
 5002|      0|	xmlFreeParserInputBuffer(reader->input);
 5003|      0|	reader->input = NULL;
 5004|      0|	reader->allocs -= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5005|      0|    }
 5006|    323|    if (input != NULL) {
  ------------------
  |  Branch (5006:9): [True: 0, False: 323]
  ------------------
 5007|      0|	reader->input = input;
 5008|      0|	reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|      0|#define XML_TEXTREADER_INPUT	1
  ------------------
 5009|      0|    }
 5010|    323|    if (reader->buffer == NULL)
  ------------------
  |  Branch (5010:9): [True: 0, False: 323]
  ------------------
 5011|      0|        reader->buffer = xmlBufCreateSize(100);
 5012|    323|    if (reader->buffer == NULL) {
  ------------------
  |  Branch (5012:9): [True: 0, False: 323]
  ------------------
 5013|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5014|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5015|      0|        return (-1);
 5016|      0|    }
 5017|       |    /* no operation on a reader should require a huge buffer */
 5018|    323|    xmlBufSetAllocationScheme(reader->buffer,
 5019|    323|			      XML_BUFFER_ALLOC_DOUBLEIT);
 5020|    323|    if (reader->sax == NULL)
  ------------------
  |  Branch (5020:9): [True: 0, False: 323]
  ------------------
 5021|      0|	reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 5022|    323|    if (reader->sax == NULL) {
  ------------------
  |  Branch (5022:9): [True: 0, False: 323]
  ------------------
 5023|      0|        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5024|      0|                        "xmlTextReaderSetup : malloc failed\n");
 5025|      0|        return (-1);
 5026|      0|    }
 5027|    323|    xmlSAXVersion(reader->sax, 2);
 5028|    323|    reader->startElement = reader->sax->startElement;
 5029|    323|    reader->sax->startElement = xmlTextReaderStartElement;
 5030|    323|    reader->endElement = reader->sax->endElement;
 5031|    323|    reader->sax->endElement = xmlTextReaderEndElement;
 5032|    323|#ifdef LIBXML_SAX1_ENABLED
 5033|    323|    if (reader->sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|    323|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (5033:9): [True: 323, False: 0]
  ------------------
 5034|    323|#endif /* LIBXML_SAX1_ENABLED */
 5035|    323|        reader->startElementNs = reader->sax->startElementNs;
 5036|    323|        reader->sax->startElementNs = xmlTextReaderStartElementNs;
 5037|    323|        reader->endElementNs = reader->sax->endElementNs;
 5038|    323|        reader->sax->endElementNs = xmlTextReaderEndElementNs;
 5039|    323|#ifdef LIBXML_SAX1_ENABLED
 5040|    323|    } else {
 5041|      0|        reader->startElementNs = NULL;
 5042|      0|        reader->endElementNs = NULL;
 5043|      0|    }
 5044|    323|#endif /* LIBXML_SAX1_ENABLED */
 5045|    323|    reader->characters = reader->sax->characters;
 5046|    323|    reader->sax->characters = xmlTextReaderCharacters;
 5047|    323|    reader->sax->ignorableWhitespace = xmlTextReaderCharacters;
 5048|    323|    reader->cdataBlock = reader->sax->cdataBlock;
 5049|    323|    reader->sax->cdataBlock = xmlTextReaderCDataBlock;
 5050|       |
 5051|    323|    reader->mode = XML_TEXTREADER_MODE_INITIAL;
 5052|    323|    reader->node = NULL;
 5053|    323|    reader->curnode = NULL;
 5054|    323|    if (input != NULL) {
  ------------------
  |  Branch (5054:9): [True: 0, False: 323]
  ------------------
 5055|      0|        if (xmlBufUse(reader->input->buffer) < 4) {
  ------------------
  |  Branch (5055:13): [True: 0, False: 0]
  ------------------
 5056|      0|            xmlParserInputBufferRead(input, 4);
 5057|      0|        }
 5058|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5058:13): [True: 0, False: 0]
  ------------------
 5059|      0|            if (xmlBufUse(reader->input->buffer) >= 4) {
  ------------------
  |  Branch (5059:17): [True: 0, False: 0]
  ------------------
 5060|      0|                reader->ctxt = xmlCreatePushParserCtxt(reader->sax, NULL,
 5061|      0|		       (const char *) xmlBufContent(reader->input->buffer),
 5062|      0|                                      4, URL);
 5063|      0|                reader->base = 0;
 5064|      0|                reader->cur = 4;
 5065|      0|            } else {
 5066|      0|                reader->ctxt =
 5067|      0|                    xmlCreatePushParserCtxt(reader->sax, NULL, NULL, 0, URL);
 5068|      0|                reader->base = 0;
 5069|      0|                reader->cur = 0;
 5070|      0|            }
 5071|      0|        } else {
 5072|      0|	    xmlParserInputPtr inputStream;
 5073|      0|	    xmlParserInputBufferPtr buf;
 5074|      0|	    xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;
 5075|       |
 5076|      0|	    xmlCtxtReset(reader->ctxt);
 5077|      0|	    buf = xmlAllocParserInputBuffer(enc);
 5078|      0|	    if (buf == NULL) return(-1);
  ------------------
  |  Branch (5078:10): [True: 0, False: 0]
  ------------------
 5079|      0|	    inputStream = xmlNewInputStream(reader->ctxt);
 5080|      0|	    if (inputStream == NULL) {
  ------------------
  |  Branch (5080:10): [True: 0, False: 0]
  ------------------
 5081|      0|		xmlFreeParserInputBuffer(buf);
 5082|      0|		return(-1);
 5083|      0|	    }
 5084|       |
 5085|      0|	    if (URL == NULL)
  ------------------
  |  Branch (5085:10): [True: 0, False: 0]
  ------------------
 5086|      0|		inputStream->filename = NULL;
 5087|      0|	    else
 5088|      0|		inputStream->filename = (char *)
 5089|      0|		    xmlCanonicPath((const xmlChar *) URL);
 5090|      0|	    inputStream->buf = buf;
 5091|      0|            xmlBufResetInput(buf->buffer, inputStream);
 5092|       |
 5093|      0|	    inputPush(reader->ctxt, inputStream);
 5094|      0|	    reader->cur = 0;
 5095|      0|	}
 5096|      0|        if (reader->ctxt == NULL) {
  ------------------
  |  Branch (5096:13): [True: 0, False: 0]
  ------------------
 5097|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 5098|      0|                            "xmlTextReaderSetup : malloc failed\n");
 5099|      0|            return (-1);
 5100|      0|        }
 5101|      0|    }
 5102|    323|    if (reader->dict != NULL) {
  ------------------
  |  Branch (5102:9): [True: 323, False: 0]
  ------------------
 5103|    323|        if (reader->ctxt->dict != NULL) {
  ------------------
  |  Branch (5103:13): [True: 323, False: 0]
  ------------------
 5104|    323|	    if (reader->dict != reader->ctxt->dict) {
  ------------------
  |  Branch (5104:10): [True: 0, False: 323]
  ------------------
 5105|      0|		xmlDictFree(reader->dict);
 5106|      0|		reader->dict = reader->ctxt->dict;
 5107|      0|	    }
 5108|    323|	} else {
 5109|      0|	    reader->ctxt->dict = reader->dict;
 5110|      0|	}
 5111|    323|    } else {
 5112|      0|	if (reader->ctxt->dict == NULL)
  ------------------
  |  Branch (5112:6): [True: 0, False: 0]
  ------------------
 5113|      0|	    reader->ctxt->dict = xmlDictCreate();
 5114|      0|        reader->dict = reader->ctxt->dict;
 5115|      0|    }
 5116|    323|    reader->ctxt->_private = reader;
 5117|    323|    reader->ctxt->linenumbers = 1;
 5118|    323|    reader->ctxt->dictNames = 1;
 5119|       |    /*
 5120|       |     * use the parser dictionary to allocate all elements and attributes names
 5121|       |     */
 5122|    323|    reader->ctxt->docdict = 1;
 5123|    323|    reader->ctxt->parseMode = XML_PARSE_READER;
 5124|       |
 5125|    323|#ifdef LIBXML_XINCLUDE_ENABLED
 5126|    323|    if (reader->xincctxt != NULL) {
  ------------------
  |  Branch (5126:9): [True: 0, False: 323]
  ------------------
 5127|      0|	xmlXIncludeFreeContext(reader->xincctxt);
 5128|      0|	reader->xincctxt = NULL;
 5129|      0|    }
 5130|    323|    if (options & XML_PARSE_XINCLUDE) {
  ------------------
  |  Branch (5130:9): [True: 0, False: 323]
  ------------------
 5131|      0|        reader->xinclude = 1;
 5132|      0|	reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);
  ------------------
  |  |   42|      0|#define XINCLUDE_NODE (const xmlChar *) "include"
  ------------------
 5133|      0|	options -= XML_PARSE_XINCLUDE;
 5134|      0|    } else
 5135|    323|        reader->xinclude = 0;
 5136|    323|    reader->in_xinclude = 0;
 5137|    323|#endif
 5138|    323|#ifdef LIBXML_PATTERN_ENABLED
 5139|    323|    if (reader->patternTab == NULL) {
  ------------------
  |  Branch (5139:9): [True: 323, False: 0]
  ------------------
 5140|    323|        reader->patternNr = 0;
 5141|    323|	reader->patternMax = 0;
 5142|    323|    }
 5143|    323|    while (reader->patternNr > 0) {
  ------------------
  |  Branch (5143:12): [True: 0, False: 323]
  ------------------
 5144|      0|        reader->patternNr--;
 5145|      0|	if (reader->patternTab[reader->patternNr] != NULL) {
  ------------------
  |  Branch (5145:6): [True: 0, False: 0]
  ------------------
 5146|      0|	    xmlFreePattern(reader->patternTab[reader->patternNr]);
 5147|      0|            reader->patternTab[reader->patternNr] = NULL;
 5148|      0|	}
 5149|      0|    }
 5150|    323|#endif
 5151|       |
 5152|    323|    if (options & XML_PARSE_DTDVALID)
  ------------------
  |  Branch (5152:9): [True: 0, False: 323]
  ------------------
 5153|      0|        reader->validate = XML_TEXTREADER_VALIDATE_DTD;
 5154|       |
 5155|    323|    xmlCtxtUseOptions(reader->ctxt, options);
 5156|    323|    if (encoding != NULL) {
  ------------------
  |  Branch (5156:9): [True: 0, False: 323]
  ------------------
 5157|      0|        xmlCharEncodingHandlerPtr hdlr;
 5158|       |
 5159|      0|        hdlr = xmlFindCharEncodingHandler(encoding);
 5160|      0|        if (hdlr != NULL)
  ------------------
  |  Branch (5160:13): [True: 0, False: 0]
  ------------------
 5161|      0|            xmlSwitchToEncoding(reader->ctxt, hdlr);
 5162|      0|    }
 5163|    323|    if ((URL != NULL) && (reader->ctxt->input != NULL) &&
  ------------------
  |  Branch (5163:9): [True: 0, False: 323]
  |  Branch (5163:26): [True: 0, False: 0]
  ------------------
 5164|    323|        (reader->ctxt->input->filename == NULL))
  ------------------
  |  Branch (5164:9): [True: 0, False: 0]
  ------------------
 5165|      0|        reader->ctxt->input->filename = (char *)
 5166|      0|            xmlStrdup((const xmlChar *) URL);
 5167|       |
 5168|    323|    reader->doc = NULL;
 5169|       |
 5170|    323|    return (0);
 5171|    323|}
xmlReaderForMemory:
 5309|    323|{
 5310|    323|    xmlTextReaderPtr reader;
 5311|    323|    xmlParserInputBufferPtr buf;
 5312|       |
 5313|    323|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
 5314|    323|    if (buf == NULL) {
  ------------------
  |  Branch (5314:9): [True: 0, False: 323]
  ------------------
 5315|      0|        return (NULL);
 5316|      0|    }
 5317|    323|    reader = xmlNewTextReader(buf, URL);
 5318|    323|    if (reader == NULL) {
  ------------------
  |  Branch (5318:9): [True: 0, False: 323]
  ------------------
 5319|      0|        xmlFreeParserInputBuffer(buf);
 5320|      0|        return (NULL);
 5321|      0|    }
 5322|    323|    reader->allocs |= XML_TEXTREADER_INPUT;
  ------------------
  |  |   98|    323|#define XML_TEXTREADER_INPUT	1
  ------------------
 5323|    323|    xmlTextReaderSetup(reader, NULL, URL, encoding, options);
 5324|    323|    return (reader);
 5325|    323|}
xmlreader.c:xmlTextReaderPushData:
  711|  1.98k|xmlTextReaderPushData(xmlTextReaderPtr reader) {
  712|  1.98k|    xmlBufPtr inbuf;
  713|  1.98k|    int val, s;
  714|  1.98k|    xmlTextReaderState oldstate;
  715|       |
  716|  1.98k|    if ((reader->input == NULL) || (reader->input->buffer == NULL))
  ------------------
  |  Branch (716:9): [True: 0, False: 1.98k]
  |  Branch (716:36): [True: 0, False: 1.98k]
  ------------------
  717|      0|	return(-1);
  718|       |
  719|  1.98k|    oldstate = reader->state;
  720|  1.98k|    reader->state = XML_TEXTREADER_NONE;
  721|  1.98k|    inbuf = reader->input->buffer;
  722|       |
  723|  4.18k|    while (reader->state == XML_TEXTREADER_NONE) {
  ------------------
  |  Branch (723:12): [True: 2.82k, False: 1.35k]
  ------------------
  724|  2.82k|	if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|  2.82k|#define CHUNK_SIZE 512
  ------------------
  |  Branch (724:6): [True: 939, False: 1.88k]
  ------------------
  725|       |	    /*
  726|       |	     * Refill the buffer unless we are at the end of the stream
  727|       |	     */
  728|    939|	    if (reader->mode != XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (728:10): [True: 939, False: 0]
  ------------------
  729|    939|		val = xmlParserInputBufferRead(reader->input, 4096);
  730|    939|		if (val == 0) {
  ------------------
  |  Branch (730:7): [True: 381, False: 558]
  ------------------
  731|    381|		    if (xmlBufUse(inbuf) == reader->cur) {
  ------------------
  |  Branch (731:11): [True: 299, False: 82]
  ------------------
  732|    299|			reader->mode = XML_TEXTREADER_MODE_EOF;
  733|    299|                        break;
  734|    299|		    }
  735|    558|		} else if (val < 0) {
  ------------------
  |  Branch (735:14): [True: 0, False: 558]
  ------------------
  736|      0|                    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                  xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  737|      0|                                    "xmlParserInputBufferRead failed\n");
  738|      0|		    reader->mode = XML_TEXTREADER_MODE_EOF;
  739|      0|		    reader->state = oldstate;
  740|      0|		    return(val);
  741|      0|		}
  742|       |
  743|    939|	    } else
  744|      0|		break;
  745|    939|	}
  746|       |	/*
  747|       |	 * parse by block of CHUNK_SIZE bytes, various tests show that
  748|       |	 * it's the best tradeoff at least on a 1.2GH Duron
  749|       |	 */
  750|  2.52k|	if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {
  ------------------
  |  |   90|  2.52k|#define CHUNK_SIZE 512
  ------------------
  |  Branch (750:6): [True: 2.20k, False: 317]
  ------------------
  751|  2.20k|	    val = xmlParseChunk(reader->ctxt,
  752|  2.20k|                 (const char *) xmlBufContent(inbuf) + reader->cur,
  753|  2.20k|                                CHUNK_SIZE, 0);
  ------------------
  |  |   90|  2.20k|#define CHUNK_SIZE 512
  ------------------
  754|  2.20k|	    reader->cur += CHUNK_SIZE;
  ------------------
  |  |   90|  2.20k|#define CHUNK_SIZE 512
  ------------------
  755|  2.20k|	    if (val != 0)
  ------------------
  |  Branch (755:10): [True: 13, False: 2.19k]
  ------------------
  756|     13|		reader->ctxt->wellFormed = 0;
  757|  2.20k|	    if (reader->ctxt->wellFormed == 0)
  ------------------
  |  Branch (757:10): [True: 13, False: 2.19k]
  ------------------
  758|     13|		break;
  759|  2.20k|	} else {
  760|    317|	    s = xmlBufUse(inbuf) - reader->cur;
  761|    317|	    val = xmlParseChunk(reader->ctxt,
  762|    317|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  763|    317|			        s, 0);
  764|    317|	    reader->cur += s;
  765|    317|	    if (val != 0)
  ------------------
  |  Branch (765:10): [True: 31, False: 286]
  ------------------
  766|     31|		reader->ctxt->wellFormed = 0;
  767|    317|	    break;
  768|    317|	}
  769|  2.52k|    }
  770|  1.98k|    reader->state = oldstate;
  771|       |
  772|       |    /*
  773|       |     * Discard the consumed input when needed and possible
  774|       |     */
  775|  1.98k|    if (reader->mode == XML_TEXTREADER_MODE_INTERACTIVE) {
  ------------------
  |  Branch (775:9): [True: 1.67k, False: 309]
  ------------------
  776|  1.67k|        if (reader->input->readcallback != NULL) {
  ------------------
  |  Branch (776:13): [True: 1.67k, False: 0]
  ------------------
  777|  1.67k|	    if ((reader->cur >= 4096) &&
  ------------------
  |  Branch (777:10): [True: 212, False: 1.46k]
  ------------------
  778|  1.67k|		(xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {
  ------------------
  |  |   90|    212|#define CHUNK_SIZE 512
  ------------------
  |  Branch (778:3): [True: 180, False: 32]
  ------------------
  779|    180|		val = xmlBufShrink(inbuf, reader->cur);
  780|    180|		if (val >= 0) {
  ------------------
  |  Branch (780:7): [True: 180, False: 0]
  ------------------
  781|    180|		    reader->cur -= val;
  782|    180|		}
  783|    180|	    }
  784|  1.67k|	}
  785|  1.67k|    }
  786|       |
  787|       |    /*
  788|       |     * At the end of the stream signal that the work is done to the Push
  789|       |     * parser.
  790|       |     */
  791|    309|    else if (reader->mode == XML_TEXTREADER_MODE_EOF) {
  ------------------
  |  Branch (791:14): [True: 299, False: 10]
  ------------------
  792|    299|	if (reader->state != XML_TEXTREADER_DONE) {
  ------------------
  |  Branch (792:6): [True: 299, False: 0]
  ------------------
  793|    299|	    s = xmlBufUse(inbuf) - reader->cur;
  794|    299|	    val = xmlParseChunk(reader->ctxt,
  795|    299|		 (const char *) xmlBufContent(inbuf) + reader->cur,
  796|    299|			        s, 1);
  797|    299|	    reader->cur = xmlBufUse(inbuf);
  798|    299|	    reader->state  = XML_TEXTREADER_DONE;
  799|    299|	    if (val != 0) {
  ------------------
  |  Branch (799:10): [True: 37, False: 262]
  ------------------
  800|     37|	        if (reader->ctxt->wellFormed)
  ------------------
  |  Branch (800:14): [True: 0, False: 37]
  ------------------
  801|      0|		    reader->ctxt->wellFormed = 0;
  802|     37|		else
  803|     37|		    return(-1);
  804|     37|	    }
  805|    299|	}
  806|    299|    }
  807|  1.95k|    if (reader->ctxt->wellFormed == 0) {
  ------------------
  |  Branch (807:9): [True: 44, False: 1.90k]
  ------------------
  808|     44|	reader->mode = XML_TEXTREADER_MODE_EOF;
  809|     44|        return(-1);
  810|     44|    }
  811|       |
  812|  1.90k|    return(0);
  813|  1.95k|}
xmlreader.c:xmlTextReaderFreeNode:
  377|  31.7k|xmlTextReaderFreeNode(xmlTextReaderPtr reader, xmlNodePtr cur) {
  378|  31.7k|    xmlDictPtr dict;
  379|       |
  380|  31.7k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (380:9): [True: 31.7k, False: 0]
  |  Branch (380:29): [True: 31.7k, False: 0]
  ------------------
  381|  31.7k|	dict = reader->ctxt->dict;
  382|      0|    else
  383|      0|        dict = NULL;
  384|  31.7k|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (384:9): [True: 0, False: 31.7k]
  ------------------
  385|      0|	xmlFreeDtd((xmlDtdPtr) cur);
  386|      0|	return;
  387|      0|    }
  388|  31.7k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (388:9): [True: 0, False: 31.7k]
  ------------------
  389|      0|	xmlFreeNs((xmlNsPtr) cur);
  390|      0|        return;
  391|      0|    }
  392|  31.7k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (392:9): [True: 0, False: 31.7k]
  ------------------
  393|      0|	xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);
  394|      0|	return;
  395|      0|    }
  396|       |
  397|  31.7k|    if ((cur->children != NULL) &&
  ------------------
  |  Branch (397:9): [True: 0, False: 31.7k]
  ------------------
  398|  31.7k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (398:2): [True: 0, False: 0]
  ------------------
  399|      0|	if (cur->children->parent == cur)
  ------------------
  |  Branch (399:6): [True: 0, False: 0]
  ------------------
  400|      0|	    xmlTextReaderFreeNodeList(reader, cur->children);
  401|      0|	cur->children = NULL;
  402|      0|    }
  403|       |
  404|  31.7k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (404:9): [True: 0, False: 31.7k]
  |  Branch (404:37): [True: 0, False: 0]
  ------------------
  405|      0|	xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  406|       |
  407|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (407:10): [True: 14.2k, False: 17.5k]
  ------------------
  408|  31.7k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (408:3): [True: 0, False: 17.5k]
  ------------------
  409|  31.7k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (409:3): [True: 0, False: 17.5k]
  ------------------
  410|  31.7k|	(cur->properties != NULL))
  ------------------
  |  Branch (410:2): [True: 11.5k, False: 2.68k]
  ------------------
  411|  11.5k|	xmlTextReaderFreePropList(reader, cur->properties);
  412|  31.7k|    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (412:9): [True: 16.2k, False: 15.4k]
  ------------------
  413|  31.7k|        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (413:9): [True: 2.03k, False: 14.2k]
  ------------------
  414|  31.7k|	(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (414:2): [True: 2.03k, False: 0]
  ------------------
  415|  31.7k|	(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (415:2): [True: 2.03k, False: 0]
  ------------------
  416|  31.7k|	(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (416:2): [True: 2.03k, False: 1]
  ------------------
  417|  2.03k|	DICT_FREE(cur->content);
  ------------------
  |  |  214|  2.03k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 2.03k, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 2.03k]
  |  |  ------------------
  |  |  215|  2.03k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 2.03k, False: 0]
  |  |  ------------------
  |  |  216|  2.03k|	    xmlFree((char *)(str));
  ------------------
  418|  2.03k|    }
  419|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (419:10): [True: 14.2k, False: 17.5k]
  ------------------
  420|  31.7k|	 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (420:3): [True: 0, False: 17.5k]
  ------------------
  421|  31.7k|	 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (421:3): [True: 0, False: 17.5k]
  ------------------
  422|  31.7k|	(cur->nsDef != NULL))
  ------------------
  |  Branch (422:2): [True: 78, False: 14.1k]
  ------------------
  423|     78|	xmlFreeNsList(cur->nsDef);
  424|       |
  425|       |    /*
  426|       |     * we don't free names here they are interned now
  427|       |     */
  428|  31.7k|    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (428:9): [True: 14.4k, False: 17.3k]
  ------------------
  429|  31.7k|        (cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (429:9): [True: 14.2k, False: 149]
  ------------------
  430|  14.2k|	DICT_FREE(cur->name);
  ------------------
  |  |  214|  14.2k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 14.2k, False: 33]
  |  |  |  Branch (214:16): [True: 0, False: 14.2k]
  |  |  ------------------
  |  |  215|  14.2k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 1, False: 14.2k]
  |  |  ------------------
  |  |  216|  14.2k|	    xmlFree((char *)(str));
  ------------------
  431|       |
  432|  31.7k|    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (432:10): [True: 14.2k, False: 17.5k]
  ------------------
  433|  31.7k|	 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (433:3): [True: 17.3k, False: 201]
  ------------------
  434|  31.7k|	(reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (434:2): [True: 31.5k, False: 0]
  |  Branch (434:22): [True: 31.5k, False: 0]
  ------------------
  435|  31.7k|	(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  31.5k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (435:2): [True: 1.43k, False: 30.1k]
  ------------------
  436|  1.43k|	cur->next = reader->ctxt->freeElems;
  437|  1.43k|	reader->ctxt->freeElems = cur;
  438|  1.43k|	reader->ctxt->freeElemsNr++;
  439|  30.3k|    } else {
  440|  30.3k|	xmlFree(cur);
  441|  30.3k|    }
  442|  31.7k|}
xmlreader.c:xmlTextReaderFreeProp:
  229|  21.3k|xmlTextReaderFreeProp(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  230|  21.3k|    xmlDictPtr dict;
  231|       |
  232|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (232:9): [True: 21.3k, False: 0]
  |  Branch (232:29): [True: 21.3k, False: 0]
  ------------------
  233|  21.3k|	dict = reader->ctxt->dict;
  234|      0|    else
  235|      0|        dict = NULL;
  236|  21.3k|    if (cur == NULL) return;
  ------------------
  |  Branch (236:9): [True: 0, False: 21.3k]
  ------------------
  237|       |
  238|  21.3k|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (238:9): [True: 0, False: 21.3k]
  |  Branch (238:37): [True: 0, False: 0]
  ------------------
  239|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  240|       |
  241|  21.3k|    if (cur->children != NULL)
  ------------------
  |  Branch (241:9): [True: 21.3k, False: 0]
  ------------------
  242|  21.3k|        xmlTextReaderFreeNodeList(reader, cur->children);
  243|       |
  244|  21.3k|    DICT_FREE(cur->name);
  ------------------
  |  |  214|  21.3k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 21.3k, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 21.3k]
  |  |  ------------------
  |  |  215|  21.3k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 0, False: 21.3k]
  |  |  ------------------
  |  |  216|  21.3k|	    xmlFree((char *)(str));
  ------------------
  245|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (245:9): [True: 21.3k, False: 0]
  |  Branch (245:29): [True: 21.3k, False: 0]
  ------------------
  246|  21.3k|        (reader->ctxt->freeAttrsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  21.3k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (246:9): [True: 1.30k, False: 20.0k]
  ------------------
  247|  1.30k|        cur->next = reader->ctxt->freeAttrs;
  248|  1.30k|	reader->ctxt->freeAttrs = cur;
  249|  1.30k|	reader->ctxt->freeAttrsNr++;
  250|  20.0k|    } else {
  251|  20.0k|	xmlFree(cur);
  252|  20.0k|    }
  253|  21.3k|}
xmlreader.c:xmlTextReaderFreeNodeList:
  282|  21.3k|xmlTextReaderFreeNodeList(xmlTextReaderPtr reader, xmlNodePtr cur) {
  283|  21.3k|    xmlNodePtr next;
  284|  21.3k|    xmlNodePtr parent;
  285|  21.3k|    xmlDictPtr dict;
  286|  21.3k|    size_t depth = 0;
  287|       |
  288|  21.3k|    if ((reader != NULL) && (reader->ctxt != NULL))
  ------------------
  |  Branch (288:9): [True: 21.3k, False: 0]
  |  Branch (288:29): [True: 21.3k, False: 0]
  ------------------
  289|  21.3k|	dict = reader->ctxt->dict;
  290|      0|    else
  291|      0|        dict = NULL;
  292|  21.3k|    if (cur == NULL) return;
  ------------------
  |  Branch (292:9): [True: 0, False: 21.3k]
  ------------------
  293|  21.3k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (293:9): [True: 0, False: 21.3k]
  ------------------
  294|      0|	xmlFreeNsList((xmlNsPtr) cur);
  295|      0|	return;
  296|      0|    }
  297|  21.3k|    if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (297:9): [True: 0, False: 21.3k]
  ------------------
  298|  21.3k|	(cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (298:2): [True: 0, False: 21.3k]
  ------------------
  299|      0|	xmlFreeDoc((xmlDocPtr) cur);
  300|      0|	return;
  301|      0|    }
  302|  21.4k|    while (1) {
  ------------------
  |  Branch (302:12): [Folded - Ignored]
  ------------------
  303|  21.4k|        while ((cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (303:16): [True: 21.4k, False: 0]
  ------------------
  304|  21.4k|               (cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (304:16): [True: 21.4k, False: 0]
  ------------------
  305|  21.4k|               (cur->children != NULL) &&
  ------------------
  |  Branch (305:16): [True: 6, False: 21.4k]
  ------------------
  306|  21.4k|               (cur->children->parent == cur)) {
  ------------------
  |  Branch (306:16): [True: 6, False: 0]
  ------------------
  307|      6|            cur = cur->children;
  308|      6|            depth += 1;
  309|      6|        }
  310|       |
  311|  21.4k|        next = cur->next;
  312|  21.4k|        parent = cur->parent;
  313|       |
  314|       |	/* unroll to speed up freeing the document */
  315|  21.4k|	if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (315:6): [True: 21.4k, False: 0]
  ------------------
  316|       |
  317|  21.4k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (317:10): [True: 0, False: 21.4k]
  |  Branch (317:38): [True: 0, False: 0]
  ------------------
  318|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  319|       |
  320|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (320:11): [True: 117, False: 21.3k]
  ------------------
  321|  21.4k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (321:4): [True: 0, False: 21.3k]
  ------------------
  322|  21.4k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (322:4): [True: 0, False: 21.3k]
  ------------------
  323|  21.4k|		(cur->properties != NULL))
  ------------------
  |  Branch (323:3): [True: 1, False: 116]
  ------------------
  324|      1|		xmlTextReaderFreePropList(reader, cur->properties);
  325|  21.4k|	    if ((cur->content != (xmlChar *) &(cur->properties)) &&
  ------------------
  |  Branch (325:10): [True: 1.02k, False: 20.4k]
  ------------------
  326|  21.4k|	        (cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (326:10): [True: 908, False: 117]
  ------------------
  327|  21.4k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (327:3): [True: 908, False: 0]
  ------------------
  328|  21.4k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (328:3): [True: 908, False: 0]
  ------------------
  329|  21.4k|		(cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (329:3): [True: 908, False: 0]
  ------------------
  330|    908|		DICT_FREE(cur->content);
  ------------------
  |  |  214|    908|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 907, False: 1]
  |  |  |  Branch (214:16): [True: 0, False: 907]
  |  |  ------------------
  |  |  215|    907|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 907, False: 0]
  |  |  ------------------
  |  |  216|    908|	    xmlFree((char *)(str));
  ------------------
  331|    908|	    }
  332|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (332:11): [True: 117, False: 21.3k]
  ------------------
  333|  21.4k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (333:11): [True: 0, False: 21.3k]
  ------------------
  334|  21.4k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (334:4): [True: 0, False: 21.3k]
  ------------------
  335|  21.4k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (335:3): [True: 3, False: 114]
  ------------------
  336|      3|		xmlFreeNsList(cur->nsDef);
  337|       |
  338|       |	    /*
  339|       |	     * we don't free element names here they are interned now
  340|       |	     */
  341|  21.4k|	    if ((cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (341:10): [True: 122, False: 21.3k]
  ------------------
  342|  21.4k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (342:3): [True: 120, False: 2]
  ------------------
  343|    120|		DICT_FREE(cur->name);
  ------------------
  |  |  214|    120|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (214:6): [True: 120, False: 0]
  |  |  |  Branch (214:16): [True: 0, False: 120]
  |  |  ------------------
  |  |  215|    120|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (215:6): [True: 0, False: 120]
  |  |  ------------------
  |  |  216|    120|	    xmlFree((char *)(str));
  ------------------
  344|  21.4k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (344:11): [True: 117, False: 21.3k]
  ------------------
  345|  21.4k|		 (cur->type == XML_TEXT_NODE)) &&
  ------------------
  |  Branch (345:4): [True: 21.3k, False: 5]
  ------------------
  346|  21.4k|	        (reader != NULL) && (reader->ctxt != NULL) &&
  ------------------
  |  Branch (346:10): [True: 21.4k, False: 0]
  |  Branch (346:30): [True: 21.4k, False: 0]
  ------------------
  347|  21.4k|		(reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {
  ------------------
  |  |   52|  21.4k|#define MAX_FREE_NODES 1
  ------------------
  |  Branch (347:3): [True: 198, False: 21.2k]
  ------------------
  348|    198|	        cur->next = reader->ctxt->freeElems;
  349|    198|		reader->ctxt->freeElems = cur;
  350|    198|		reader->ctxt->freeElemsNr++;
  351|  21.2k|	    } else {
  352|  21.2k|		xmlFree(cur);
  353|  21.2k|	    }
  354|  21.4k|	}
  355|       |
  356|  21.4k|        if (next != NULL) {
  ------------------
  |  Branch (356:13): [True: 104, False: 21.3k]
  ------------------
  357|    104|	    cur = next;
  358|  21.3k|        } else {
  359|  21.3k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (359:17): [True: 21.3k, False: 6]
  |  Branch (359:33): [True: 0, False: 6]
  ------------------
  360|  21.3k|                break;
  361|      6|            depth -= 1;
  362|      6|            cur = parent;
  363|      6|            cur->children = NULL;
  364|      6|        }
  365|  21.4k|    }
  366|  21.3k|}
xmlreader.c:xmlTextReaderFreePropList:
  263|  11.5k|xmlTextReaderFreePropList(xmlTextReaderPtr reader, xmlAttrPtr cur) {
  264|  11.5k|    xmlAttrPtr next;
  265|       |
  266|  32.9k|    while (cur != NULL) {
  ------------------
  |  Branch (266:12): [True: 21.3k, False: 11.5k]
  ------------------
  267|  21.3k|        next = cur->next;
  268|  21.3k|        xmlTextReaderFreeProp(reader, cur);
  269|  21.3k|	cur = next;
  270|  21.3k|    }
  271|  11.5k|}
xmlreader.c:xmlTextReaderDoExpand:
 1078|  4.45k|xmlTextReaderDoExpand(xmlTextReaderPtr reader) {
 1079|  4.45k|    int val;
 1080|       |
 1081|  4.45k|    if ((reader == NULL) || (reader->node == NULL) || (reader->ctxt == NULL))
  ------------------
  |  Branch (1081:9): [True: 0, False: 4.45k]
  |  Branch (1081:29): [True: 0, False: 4.45k]
  |  Branch (1081:55): [True: 0, False: 4.45k]
  ------------------
 1082|      0|        return(-1);
 1083|  5.15k|    do {
 1084|  5.15k|	if (reader->ctxt->instate == XML_PARSER_EOF) return(1);
  ------------------
  |  Branch (1084:6): [True: 460, False: 4.69k]
  ------------------
 1085|       |
 1086|  4.69k|        if (xmlTextReaderGetSuccessor(reader->node) != NULL)
  ------------------
  |  Branch (1086:13): [True: 3.96k, False: 733]
  ------------------
 1087|  3.96k|	    return(1);
 1088|    733|	if (reader->ctxt->nodeNr < reader->depth)
  ------------------
  |  Branch (1088:6): [True: 29, False: 704]
  ------------------
 1089|     29|	    return(1);
 1090|    704|	if (reader->mode == XML_TEXTREADER_MODE_EOF)
  ------------------
  |  Branch (1090:6): [True: 0, False: 704]
  ------------------
 1091|      0|	    return(1);
 1092|    704|	val = xmlTextReaderPushData(reader);
 1093|    704|	if (val < 0){
  ------------------
  |  Branch (1093:6): [True: 1, False: 703]
  ------------------
 1094|      1|	    reader->mode = XML_TEXTREADER_MODE_ERROR;
 1095|      1|	    return(-1);
 1096|      1|	}
 1097|    704|    } while(reader->mode != XML_TEXTREADER_MODE_EOF);
  ------------------
  |  Branch (1097:13): [True: 703, False: 0]
  ------------------
 1098|      0|    return(1);
 1099|  4.45k|}
xmlreader.c:xmlTextReaderGetSuccessor:
 1055|  4.69k|xmlTextReaderGetSuccessor(xmlNodePtr cur) {
 1056|  4.69k|    if (cur == NULL) return(NULL) ; /* ERROR */
  ------------------
  |  Branch (1056:9): [True: 0, False: 4.69k]
  ------------------
 1057|  4.69k|    if (cur->next != NULL) return(cur->next) ;
  ------------------
  |  Branch (1057:9): [True: 677, False: 4.02k]
  ------------------
 1058|  8.49k|    do {
 1059|  8.49k|        cur = cur->parent;
 1060|  8.49k|        if (cur == NULL) break;
  ------------------
  |  Branch (1060:13): [True: 733, False: 7.76k]
  ------------------
 1061|  7.76k|        if (cur->next != NULL) return(cur->next);
  ------------------
  |  Branch (1061:13): [True: 3.28k, False: 4.47k]
  ------------------
 1062|  7.76k|    } while (cur != NULL);
  ------------------
  |  Branch (1062:14): [True: 4.47k, False: 0]
  ------------------
 1063|    733|    return(cur);
 1064|  4.02k|}
xmlreader.c:xmlTextReaderStartElementNs:
  622|  14.3k|{
  623|  14.3k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  624|  14.3k|    xmlTextReaderPtr reader = ctxt->_private;
  625|       |
  626|  14.3k|    if ((reader != NULL) && (reader->startElementNs != NULL)) {
  ------------------
  |  Branch (626:9): [True: 14.3k, False: 0]
  |  Branch (626:29): [True: 14.3k, False: 0]
  ------------------
  627|  14.3k|	reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,
  628|  14.3k|	                       namespaces, nb_attributes, nb_defaulted,
  629|  14.3k|			       attributes);
  630|  14.3k|	if ((ctxt->node != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (630:6): [True: 14.3k, False: 0]
  |  Branch (630:30): [True: 14.3k, False: 0]
  ------------------
  631|  14.3k|	    (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '/') &&
  ------------------
  |  Branch (631:6): [True: 14.3k, False: 0]
  |  Branch (631:36): [True: 10.1k, False: 4.15k]
  ------------------
  632|  14.3k|	    (ctxt->input->cur[1] == '>'))
  ------------------
  |  Branch (632:6): [True: 10.1k, False: 0]
  ------------------
  633|  10.1k|	    ctxt->node->extra = NODE_IS_EMPTY;
  ------------------
  |  |  186|  10.1k|#define NODE_IS_EMPTY		0x1
  ------------------
  634|  14.3k|    }
  635|  14.3k|    if (reader != NULL)
  ------------------
  |  Branch (635:9): [True: 14.3k, False: 0]
  ------------------
  636|  14.3k|	reader->state = XML_TEXTREADER_ELEMENT;
  637|  14.3k|}
xmlreader.c:xmlTextReaderEndElementNs:
  653|  14.3k|{
  654|  14.3k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  655|  14.3k|    xmlTextReaderPtr reader = ctxt->_private;
  656|       |
  657|  14.3k|    if ((reader != NULL) && (reader->endElementNs != NULL)) {
  ------------------
  |  Branch (657:9): [True: 14.3k, False: 0]
  |  Branch (657:29): [True: 14.3k, False: 0]
  ------------------
  658|  14.3k|	reader->endElementNs(ctx, localname, prefix, URI);
  659|  14.3k|    }
  660|  14.3k|}
xmlreader.c:xmlTextReaderCharacters:
  673|  18.4k|{
  674|  18.4k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  675|  18.4k|    xmlTextReaderPtr reader = ctxt->_private;
  676|       |
  677|  18.4k|    if ((reader != NULL) && (reader->characters != NULL)) {
  ------------------
  |  Branch (677:9): [True: 18.4k, False: 0]
  |  Branch (677:29): [True: 18.4k, False: 0]
  ------------------
  678|  18.4k|	reader->characters(ctx, ch, len);
  679|  18.4k|    }
  680|  18.4k|}
xmlreader.c:xmlTextReaderCDataBlock:
  692|     56|{
  693|     56|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  694|     56|    xmlTextReaderPtr reader = ctxt->_private;
  695|       |
  696|     56|    if ((reader != NULL) && (reader->cdataBlock != NULL)) {
  ------------------
  |  Branch (696:9): [True: 56, False: 0]
  |  Branch (696:29): [True: 56, False: 0]
  ------------------
  697|     56|	reader->cdataBlock(ctx, ch, len);
  698|     56|    }
  699|     56|}
xmlreader.c:xmlTextReaderFreeDoc:
  452|    322|xmlTextReaderFreeDoc(xmlTextReaderPtr reader, xmlDocPtr cur) {
  453|    322|    xmlDtdPtr extSubset, intSubset;
  454|       |
  455|    322|    if (cur == NULL) return;
  ------------------
  |  Branch (455:9): [True: 0, False: 322]
  ------------------
  456|       |
  457|    322|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (457:9): [True: 0, False: 322]
  |  Branch (457:37): [True: 0, False: 0]
  ------------------
  458|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  459|       |
  460|       |    /*
  461|       |     * Do this before freeing the children list to avoid ID lookups
  462|       |     */
  463|    322|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (463:9): [True: 15, False: 307]
  ------------------
  464|    322|    cur->ids = NULL;
  465|    322|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (465:9): [True: 5, False: 317]
  ------------------
  466|    322|    cur->refs = NULL;
  467|    322|    extSubset = cur->extSubset;
  468|    322|    intSubset = cur->intSubset;
  469|    322|    if (intSubset == extSubset)
  ------------------
  |  Branch (469:9): [True: 132, False: 190]
  ------------------
  470|    132|	extSubset = NULL;
  471|    322|    if (extSubset != NULL) {
  ------------------
  |  Branch (471:9): [True: 21, False: 301]
  ------------------
  472|     21|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
  473|     21|	cur->extSubset = NULL;
  474|     21|	xmlFreeDtd(extSubset);
  475|     21|    }
  476|    322|    if (intSubset != NULL) {
  ------------------
  |  Branch (476:9): [True: 190, False: 132]
  ------------------
  477|    190|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
  478|    190|	cur->intSubset = NULL;
  479|    190|	xmlFreeDtd(intSubset);
  480|    190|    }
  481|       |
  482|    322|    if (cur->children != NULL) xmlTextReaderFreeNodeList(reader, cur->children);
  ------------------
  |  Branch (482:9): [True: 24, False: 298]
  ------------------
  483|       |
  484|    322|    if (cur->version != NULL) xmlFree((char *) cur->version);
  ------------------
  |  Branch (484:9): [True: 322, False: 0]
  ------------------
  485|    322|    if (cur->name != NULL) xmlFree((char *) cur->name);
  ------------------
  |  Branch (485:9): [True: 0, False: 322]
  ------------------
  486|    322|    if (cur->encoding != NULL) xmlFree((char *) cur->encoding);
  ------------------
  |  Branch (486:9): [True: 32, False: 290]
  ------------------
  487|    322|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (487:9): [True: 12, False: 310]
  ------------------
  488|    322|    if (cur->URL != NULL) xmlFree((char *) cur->URL);
  ------------------
  |  Branch (488:9): [True: 0, False: 322]
  ------------------
  489|    322|    if (cur->dict != NULL) xmlDictFree(cur->dict);
  ------------------
  |  Branch (489:9): [True: 322, False: 0]
  ------------------
  490|       |
  491|    322|    xmlFree(cur);
  492|    322|}

xmlBufAttrSerializeTxtContent:
 1970|  21.1k|{
 1971|  21.1k|    xmlChar *base, *cur;
 1972|       |
 1973|  21.1k|    if (string == NULL)
  ------------------
  |  Branch (1973:9): [True: 0, False: 21.1k]
  ------------------
 1974|      0|        return;
 1975|  21.1k|    base = cur = (xmlChar *) string;
 1976|   768k|    while (*cur != 0) {
  ------------------
  |  Branch (1976:12): [True: 746k, False: 21.1k]
  ------------------
 1977|   746k|        if (*cur == '\n') {
  ------------------
  |  Branch (1977:13): [True: 10, False: 746k]
  ------------------
 1978|     10|            if (base != cur)
  ------------------
  |  Branch (1978:17): [True: 3, False: 7]
  ------------------
 1979|      3|                xmlBufAdd(buf, base, cur - base);
 1980|     10|            xmlBufAdd(buf, BAD_CAST "&#10;", 5);
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 1981|     10|            cur++;
 1982|     10|            base = cur;
 1983|   746k|        } else if (*cur == '\r') {
  ------------------
  |  Branch (1983:20): [True: 9, False: 746k]
  ------------------
 1984|      9|            if (base != cur)
  ------------------
  |  Branch (1984:17): [True: 4, False: 5]
  ------------------
 1985|      4|                xmlBufAdd(buf, base, cur - base);
 1986|      9|            xmlBufAdd(buf, BAD_CAST "&#13;", 5);
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
 1987|      9|            cur++;
 1988|      9|            base = cur;
 1989|   746k|        } else if (*cur == '\t') {
  ------------------
  |  Branch (1989:20): [True: 3, False: 746k]
  ------------------
 1990|      3|            if (base != cur)
  ------------------
  |  Branch (1990:17): [True: 1, False: 2]
  ------------------
 1991|      1|                xmlBufAdd(buf, base, cur - base);
 1992|      3|            xmlBufAdd(buf, BAD_CAST "&#9;", 4);
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
 1993|      3|            cur++;
 1994|      3|            base = cur;
 1995|   746k|        } else if (*cur == '"') {
  ------------------
  |  Branch (1995:20): [True: 0, False: 746k]
  ------------------
 1996|      0|            if (base != cur)
  ------------------
  |  Branch (1996:17): [True: 0, False: 0]
  ------------------
 1997|      0|                xmlBufAdd(buf, base, cur - base);
 1998|      0|            xmlBufAdd(buf, BAD_CAST "&quot;", 6);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1999|      0|            cur++;
 2000|      0|            base = cur;
 2001|   746k|        } else if (*cur == '<') {
  ------------------
  |  Branch (2001:20): [True: 10, False: 746k]
  ------------------
 2002|     10|            if (base != cur)
  ------------------
  |  Branch (2002:17): [True: 7, False: 3]
  ------------------
 2003|      7|                xmlBufAdd(buf, base, cur - base);
 2004|     10|            xmlBufAdd(buf, BAD_CAST "&lt;", 4);
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
 2005|     10|            cur++;
 2006|     10|            base = cur;
 2007|   746k|        } else if (*cur == '>') {
  ------------------
  |  Branch (2007:20): [True: 13, False: 746k]
  ------------------
 2008|     13|            if (base != cur)
  ------------------
  |  Branch (2008:17): [True: 11, False: 2]
  ------------------
 2009|     11|                xmlBufAdd(buf, base, cur - base);
 2010|     13|            xmlBufAdd(buf, BAD_CAST "&gt;", 4);
  ------------------
  |  |   35|     13|#define BAD_CAST (xmlChar *)
  ------------------
 2011|     13|            cur++;
 2012|     13|            base = cur;
 2013|   746k|        } else if (*cur == '&') {
  ------------------
  |  Branch (2013:20): [True: 14, False: 746k]
  ------------------
 2014|     14|            if (base != cur)
  ------------------
  |  Branch (2014:17): [True: 10, False: 4]
  ------------------
 2015|     10|                xmlBufAdd(buf, base, cur - base);
 2016|     14|            xmlBufAdd(buf, BAD_CAST "&amp;", 5);
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
 2017|     14|            cur++;
 2018|     14|            base = cur;
 2019|   746k|        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
  ------------------
  |  Branch (2019:20): [True: 59, False: 746k]
  |  Branch (2019:38): [True: 58, False: 1]
  ------------------
 2020|   746k|	           ((doc == NULL) || (doc->encoding == NULL))) {
  ------------------
  |  Branch (2020:14): [True: 0, False: 58]
  |  Branch (2020:31): [True: 49, False: 9]
  ------------------
 2021|       |            /*
 2022|       |             * We assume we have UTF-8 content.
 2023|       |             */
 2024|     49|            unsigned char tmp[12];
 2025|     49|            int val = 0, l = 1;
 2026|       |
 2027|     49|            if (base != cur)
  ------------------
  |  Branch (2027:17): [True: 2, False: 47]
  ------------------
 2028|      2|                xmlBufAdd(buf, base, cur - base);
 2029|     49|            if (*cur < 0xC0) {
  ------------------
  |  Branch (2029:17): [True: 0, False: 49]
  ------------------
 2030|      0|                xmlSaveErr(XML_SAVE_NOT_UTF8, (xmlNodePtr) attr, NULL);
 2031|      0|		xmlSerializeHexCharRef(tmp, *cur);
 2032|      0|                xmlBufAdd(buf, (xmlChar *) tmp, -1);
 2033|      0|                cur++;
 2034|      0|                base = cur;
 2035|      0|                continue;
 2036|     49|            } else if (*cur < 0xE0) {
  ------------------
  |  Branch (2036:24): [True: 49, False: 0]
  ------------------
 2037|     49|                val = (cur[0]) & 0x1F;
 2038|     49|                val <<= 6;
 2039|     49|                val |= (cur[1]) & 0x3F;
 2040|     49|                l = 2;
 2041|     49|            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
  ------------------
  |  Branch (2041:24): [True: 0, False: 0]
  |  Branch (2041:41): [True: 0, False: 0]
  ------------------
 2042|      0|                val = (cur[0]) & 0x0F;
 2043|      0|                val <<= 6;
 2044|      0|                val |= (cur[1]) & 0x3F;
 2045|      0|                val <<= 6;
 2046|      0|                val |= (cur[2]) & 0x3F;
 2047|      0|                l = 3;
 2048|      0|            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
  ------------------
  |  Branch (2048:24): [True: 0, False: 0]
  |  Branch (2048:41): [True: 0, False: 0]
  |  Branch (2048:59): [True: 0, False: 0]
  ------------------
 2049|      0|                val = (cur[0]) & 0x07;
 2050|      0|                val <<= 6;
 2051|      0|                val |= (cur[1]) & 0x3F;
 2052|      0|                val <<= 6;
 2053|      0|                val |= (cur[2]) & 0x3F;
 2054|      0|                val <<= 6;
 2055|      0|                val |= (cur[3]) & 0x3F;
 2056|      0|                l = 4;
 2057|      0|            }
 2058|     49|            if ((l == 1) || (!IS_CHAR(val))) {
  ------------------
  |  |  125|     49|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     49|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 49, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     49|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     49|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 49, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 49]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     49|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 49]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     49|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 49, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     49|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (2058:17): [True: 0, False: 49]
  |  Branch (2058:29): [True: 0, False: 49]
  ------------------
 2059|      0|                xmlSaveErr(XML_SAVE_CHAR_INVALID, (xmlNodePtr) attr, NULL);
 2060|      0|		xmlSerializeHexCharRef(tmp, *cur);
 2061|      0|                xmlBufAdd(buf, (xmlChar *) tmp, -1);
 2062|      0|                cur++;
 2063|      0|                base = cur;
 2064|      0|                continue;
 2065|      0|            }
 2066|       |            /*
 2067|       |             * We could do multiple things here. Just save
 2068|       |             * as a char ref
 2069|       |             */
 2070|     49|	    xmlSerializeHexCharRef(tmp, val);
 2071|     49|            xmlBufAdd(buf, (xmlChar *) tmp, -1);
 2072|     49|            cur += l;
 2073|     49|            base = cur;
 2074|   746k|        } else {
 2075|   746k|            cur++;
 2076|   746k|        }
 2077|   746k|    }
 2078|  21.1k|    if (base != cur)
  ------------------
  |  Branch (2078:9): [True: 21.1k, False: 20]
  ------------------
 2079|  21.1k|        xmlBufAdd(buf, base, cur - base);
 2080|  21.1k|}
xmlDocDumpFormatMemoryEnc:
 2309|    323|		int format) {
 2310|    323|    xmlSaveCtxt ctxt;
 2311|    323|    int                         dummy = 0;
 2312|    323|    xmlOutputBufferPtr          out_buff = NULL;
 2313|    323|    xmlCharEncodingHandlerPtr   conv_hdlr = NULL;
 2314|       |
 2315|    323|    if (doc_txt_len == NULL) {
  ------------------
  |  Branch (2315:9): [True: 0, False: 323]
  ------------------
 2316|      0|        doc_txt_len = &dummy;   /*  Continue, caller just won't get length */
 2317|      0|    }
 2318|       |
 2319|    323|    if (doc_txt_ptr == NULL) {
  ------------------
  |  Branch (2319:9): [True: 0, False: 323]
  ------------------
 2320|      0|        *doc_txt_len = 0;
 2321|      0|        return;
 2322|      0|    }
 2323|       |
 2324|    323|    *doc_txt_ptr = NULL;
 2325|    323|    *doc_txt_len = 0;
 2326|       |
 2327|    323|    if (out_doc == NULL) {
  ------------------
  |  Branch (2327:9): [True: 61, False: 262]
  ------------------
 2328|       |        /*  No document, no output  */
 2329|     61|        return;
 2330|     61|    }
 2331|       |
 2332|       |    /*
 2333|       |     *  Validate the encoding value, if provided.
 2334|       |     *  This logic is copied from xmlSaveFileEnc.
 2335|       |     */
 2336|       |
 2337|    262|    if (txt_encoding == NULL)
  ------------------
  |  Branch (2337:9): [True: 262, False: 0]
  ------------------
 2338|    262|	txt_encoding = (const char *) out_doc->encoding;
 2339|    262|    if (txt_encoding != NULL) {
  ------------------
  |  Branch (2339:9): [True: 30, False: 232]
  ------------------
 2340|     30|	conv_hdlr = xmlFindCharEncodingHandler(txt_encoding);
 2341|     30|	if ( conv_hdlr == NULL ) {
  ------------------
  |  Branch (2341:7): [True: 0, False: 30]
  ------------------
 2342|      0|	    xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,
 2343|      0|		       txt_encoding);
 2344|      0|	    return;
 2345|      0|	}
 2346|     30|    }
 2347|       |
 2348|    262|    if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {
  ------------------
  |  Branch (2348:9): [True: 0, False: 262]
  ------------------
 2349|      0|        xmlSaveErrMemory("creating buffer");
 2350|      0|        xmlCharEncCloseFunc(conv_hdlr);
 2351|      0|        return;
 2352|      0|    }
 2353|       |
 2354|    262|    memset(&ctxt, 0, sizeof(ctxt));
 2355|    262|    ctxt.buf = out_buff;
 2356|    262|    ctxt.level = 0;
 2357|    262|    ctxt.format = format ? 1 : 0;
  ------------------
  |  Branch (2357:19): [True: 0, False: 262]
  ------------------
 2358|    262|    ctxt.encoding = (const xmlChar *) txt_encoding;
 2359|    262|    xmlSaveCtxtInit(&ctxt);
 2360|    262|    ctxt.options |= XML_SAVE_AS_XML;
 2361|    262|    xmlDocContentDumpOutput(&ctxt, out_doc);
 2362|    262|    xmlOutputBufferFlush(out_buff);
 2363|    262|    if (out_buff->conv != NULL) {
  ------------------
  |  Branch (2363:9): [True: 30, False: 232]
  ------------------
 2364|     30|	*doc_txt_len = xmlBufUse(out_buff->conv);
 2365|     30|	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);
 2366|    232|    } else {
 2367|    232|	*doc_txt_len = xmlBufUse(out_buff->buffer);
 2368|    232|	*doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);
 2369|    232|    }
 2370|    262|    (void)xmlOutputBufferClose(out_buff);
 2371|       |
 2372|    262|    if ((*doc_txt_ptr == NULL) && (*doc_txt_len > 0)) {
  ------------------
  |  Branch (2372:9): [True: 0, False: 262]
  |  Branch (2372:35): [True: 0, False: 0]
  ------------------
 2373|      0|        *doc_txt_len = 0;
 2374|      0|        xmlSaveErrMemory("creating output");
 2375|      0|    }
 2376|       |
 2377|    262|    return;
 2378|    262|}
xmlDocDumpMemory:
 2392|    323|xmlDocDumpMemory(xmlDocPtr cur, xmlChar**mem, int *size) {
 2393|    323|    xmlDocDumpFormatMemoryEnc(cur, mem, size, NULL, 0);
 2394|    323|}
xmlsave.c:xmlNsDumpOutput:
  591|    101|xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur, xmlSaveCtxtPtr ctxt) {
  592|    101|    if ((cur == NULL) || (buf == NULL)) return;
  ------------------
  |  Branch (592:9): [True: 0, False: 101]
  |  Branch (592:26): [True: 0, False: 101]
  ------------------
  593|    101|    if ((cur->type == XML_LOCAL_NAMESPACE) && (cur->href != NULL)) {
  ------------------
  |  |  370|    101|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  |  Branch (593:9): [True: 101, False: 0]
  |  Branch (593:47): [True: 97, False: 4]
  ------------------
  594|     97|	if (xmlStrEqual(cur->prefix, BAD_CAST "xml"))
  ------------------
  |  |   35|     97|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (594:6): [True: 0, False: 97]
  ------------------
  595|      0|	    return;
  596|       |
  597|     97|	if (ctxt != NULL && ctxt->format == 2)
  ------------------
  |  Branch (597:6): [True: 97, False: 0]
  |  Branch (597:22): [True: 0, False: 97]
  ------------------
  598|      0|	    xmlOutputBufferWriteWSNonSig(ctxt, 2);
  599|     97|	else
  600|     97|	    xmlOutputBufferWrite(buf, 1, " ");
  601|       |
  602|       |        /* Within the context of an element attributes */
  603|     97|	if (cur->prefix != NULL) {
  ------------------
  |  Branch (603:6): [True: 70, False: 27]
  ------------------
  604|     70|	    xmlOutputBufferWrite(buf, 6, "xmlns:");
  605|     70|	    xmlOutputBufferWriteString(buf, (const char *)cur->prefix);
  606|     70|	} else
  607|     27|	    xmlOutputBufferWrite(buf, 5, "xmlns");
  608|     97|	xmlOutputBufferWrite(buf, 1, "=");
  609|     97|	xmlBufWriteQuotedString(buf->buffer, cur->href);
  610|     97|    }
  611|    101|}
xmlsave.c:xmlDocContentDumpOutput:
 1077|    262|xmlDocContentDumpOutput(xmlSaveCtxtPtr ctxt, xmlDocPtr cur) {
 1078|    262|#ifdef LIBXML_HTML_ENABLED
 1079|    262|    xmlDtdPtr dtd;
 1080|    262|    int is_xhtml = 0;
 1081|    262|#endif
 1082|    262|    const xmlChar *oldenc = cur->encoding;
 1083|    262|    const xmlChar *oldctxtenc = ctxt->encoding;
 1084|    262|    const xmlChar *encoding = ctxt->encoding;
 1085|    262|    xmlCharEncodingOutputFunc oldescape = ctxt->escape;
 1086|    262|    xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;
 1087|    262|    xmlOutputBufferPtr buf = ctxt->buf;
 1088|    262|    xmlCharEncoding enc;
 1089|    262|    int switched_encoding = 0;
 1090|       |
 1091|    262|    xmlInitParser();
 1092|       |
 1093|    262|    if ((cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (1093:9): [True: 262, False: 0]
  ------------------
 1094|    262|        (cur->type != XML_DOCUMENT_NODE))
  ------------------
  |  Branch (1094:9): [True: 0, False: 262]
  ------------------
 1095|      0|	 return(-1);
 1096|       |
 1097|    262|    if (ctxt->encoding != NULL) {
  ------------------
  |  Branch (1097:9): [True: 30, False: 232]
  ------------------
 1098|     30|        cur->encoding = BAD_CAST ctxt->encoding;
  ------------------
  |  |   35|     30|#define BAD_CAST (xmlChar *)
  ------------------
 1099|    232|    } else if (cur->encoding != NULL) {
  ------------------
  |  Branch (1099:16): [True: 0, False: 232]
  ------------------
 1100|      0|	encoding = cur->encoding;
 1101|      0|    }
 1102|       |
 1103|    262|    if (((cur->type == XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (1103:10): [True: 0, False: 262]
  ------------------
 1104|    262|         ((ctxt->options & XML_SAVE_AS_XML) == 0) &&
  ------------------
  |  Branch (1104:10): [True: 0, False: 0]
  ------------------
 1105|    262|         ((ctxt->options & XML_SAVE_XHTML) == 0)) ||
  ------------------
  |  Branch (1105:10): [True: 0, False: 0]
  ------------------
 1106|    262|        (ctxt->options & XML_SAVE_AS_HTML)) {
  ------------------
  |  Branch (1106:9): [True: 0, False: 262]
  ------------------
 1107|      0|#ifdef LIBXML_HTML_ENABLED
 1108|      0|        if (encoding != NULL)
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|	    htmlSetMetaEncoding(cur, (const xmlChar *) encoding);
 1110|      0|        if (encoding == NULL)
  ------------------
  |  Branch (1110:13): [True: 0, False: 0]
  ------------------
 1111|      0|	    encoding = htmlGetMetaEncoding(cur);
 1112|      0|        if (encoding == NULL)
  ------------------
  |  Branch (1112:13): [True: 0, False: 0]
  ------------------
 1113|      0|	    encoding = BAD_CAST "HTML";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1114|      0|	if ((encoding != NULL) && (oldctxtenc == NULL) &&
  ------------------
  |  Branch (1114:6): [True: 0, False: 0]
  |  Branch (1114:28): [True: 0, False: 0]
  ------------------
 1115|      0|	    (buf->encoder == NULL) && (buf->conv == NULL)) {
  ------------------
  |  Branch (1115:6): [True: 0, False: 0]
  |  Branch (1115:32): [True: 0, False: 0]
  ------------------
 1116|      0|	    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {
  ------------------
  |  Branch (1116:10): [True: 0, False: 0]
  ------------------
 1117|      0|		cur->encoding = oldenc;
 1118|      0|		return(-1);
 1119|      0|	    }
 1120|      0|	}
 1121|      0|        if (ctxt->options & XML_SAVE_FORMAT)
  ------------------
  |  Branch (1121:13): [True: 0, False: 0]
  ------------------
 1122|      0|	    htmlDocContentDumpFormatOutput(buf, cur,
 1123|      0|	                                   (const char *)encoding, 1);
 1124|      0|	else
 1125|      0|	    htmlDocContentDumpFormatOutput(buf, cur,
 1126|      0|	                                   (const char *)encoding, 0);
 1127|      0|	if (ctxt->encoding != NULL)
  ------------------
  |  Branch (1127:6): [True: 0, False: 0]
  ------------------
 1128|      0|	    cur->encoding = oldenc;
 1129|      0|	return(0);
 1130|       |#else
 1131|       |        return(-1);
 1132|       |#endif
 1133|    262|    } else if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (1133:16): [True: 262, False: 0]
  ------------------
 1134|    262|               (ctxt->options & XML_SAVE_AS_XML) ||
  ------------------
  |  Branch (1134:16): [True: 0, False: 0]
  ------------------
 1135|    262|               (ctxt->options & XML_SAVE_XHTML)) {
  ------------------
  |  Branch (1135:16): [True: 0, False: 0]
  ------------------
 1136|    262|	enc = xmlParseCharEncoding((const char*) encoding);
 1137|    262|	if ((encoding != NULL) && (oldctxtenc == NULL) &&
  ------------------
  |  Branch (1137:6): [True: 30, False: 232]
  |  Branch (1137:28): [True: 0, False: 30]
  ------------------
 1138|    262|	    (buf->encoder == NULL) && (buf->conv == NULL) &&
  ------------------
  |  Branch (1138:6): [True: 0, False: 0]
  |  Branch (1138:32): [True: 0, False: 0]
  ------------------
 1139|    262|	    ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {
  ------------------
  |  Branch (1139:6): [True: 0, False: 0]
  ------------------
 1140|      0|	    if ((enc != XML_CHAR_ENCODING_UTF8) &&
  ------------------
  |  Branch (1140:10): [True: 0, False: 0]
  ------------------
 1141|      0|		(enc != XML_CHAR_ENCODING_NONE) &&
  ------------------
  |  Branch (1141:3): [True: 0, False: 0]
  ------------------
 1142|      0|		(enc != XML_CHAR_ENCODING_ASCII)) {
  ------------------
  |  Branch (1142:3): [True: 0, False: 0]
  ------------------
 1143|       |		/*
 1144|       |		 * we need to switch to this encoding but just for this
 1145|       |		 * document since we output the XMLDecl the conversion
 1146|       |		 * must be done to not generate not well formed documents.
 1147|       |		 */
 1148|      0|		if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {
  ------------------
  |  Branch (1148:7): [True: 0, False: 0]
  ------------------
 1149|      0|		    cur->encoding = oldenc;
 1150|      0|		    return(-1);
 1151|      0|		}
 1152|      0|		switched_encoding = 1;
 1153|      0|	    }
 1154|      0|	    if (ctxt->escape == xmlEscapeEntities)
  ------------------
  |  Branch (1154:10): [True: 0, False: 0]
  ------------------
 1155|      0|		ctxt->escape = NULL;
 1156|      0|	    if (ctxt->escapeAttr == xmlEscapeEntities)
  ------------------
  |  Branch (1156:10): [True: 0, False: 0]
  ------------------
 1157|      0|		ctxt->escapeAttr = NULL;
 1158|      0|	}
 1159|       |
 1160|       |
 1161|       |	/*
 1162|       |	 * Save the XML declaration
 1163|       |	 */
 1164|    262|	if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {
  ------------------
  |  Branch (1164:6): [True: 262, False: 0]
  ------------------
 1165|    262|	    xmlOutputBufferWrite(buf, 14, "<?xml version=");
 1166|    262|	    if (cur->version != NULL)
  ------------------
  |  Branch (1166:10): [True: 262, False: 0]
  ------------------
 1167|    262|		xmlBufWriteQuotedString(buf->buffer, cur->version);
 1168|      0|	    else
 1169|      0|		xmlOutputBufferWrite(buf, 5, "\"1.0\"");
 1170|    262|	    if (encoding != NULL) {
  ------------------
  |  Branch (1170:10): [True: 30, False: 232]
  ------------------
 1171|     30|		xmlOutputBufferWrite(buf, 10, " encoding=");
 1172|     30|		xmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);
 1173|     30|	    }
 1174|    262|	    switch (cur->standalone) {
  ------------------
  |  Branch (1174:14): [True: 213, False: 49]
  ------------------
 1175|     31|		case 0:
  ------------------
  |  Branch (1175:3): [True: 31, False: 231]
  ------------------
 1176|     31|		    xmlOutputBufferWrite(buf, 16, " standalone=\"no\"");
 1177|     31|		    break;
 1178|     18|		case 1:
  ------------------
  |  Branch (1178:3): [True: 18, False: 244]
  ------------------
 1179|     18|		    xmlOutputBufferWrite(buf, 17, " standalone=\"yes\"");
 1180|     18|		    break;
 1181|    262|	    }
 1182|    262|	    xmlOutputBufferWrite(buf, 3, "?>\n");
 1183|    262|	}
 1184|       |
 1185|    262|#ifdef LIBXML_HTML_ENABLED
 1186|    262|        if (ctxt->options & XML_SAVE_XHTML)
  ------------------
  |  Branch (1186:13): [True: 0, False: 262]
  ------------------
 1187|      0|            is_xhtml = 1;
 1188|    262|	if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {
  ------------------
  |  Branch (1188:6): [True: 262, False: 0]
  ------------------
 1189|    262|	    dtd = xmlGetIntSubset(cur);
 1190|    262|	    if (dtd != NULL) {
  ------------------
  |  Branch (1190:10): [True: 163, False: 99]
  ------------------
 1191|    163|		is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);
 1192|    163|		if (is_xhtml < 0) is_xhtml = 0;
  ------------------
  |  Branch (1192:7): [True: 102, False: 61]
  ------------------
 1193|    163|	    }
 1194|    262|	}
 1195|    262|#endif
 1196|    262|	if (cur->children != NULL) {
  ------------------
  |  Branch (1196:6): [True: 262, False: 0]
  ------------------
 1197|    262|	    xmlNodePtr child = cur->children;
 1198|       |
 1199|    721|	    while (child != NULL) {
  ------------------
  |  Branch (1199:13): [True: 459, False: 262]
  ------------------
 1200|    459|		ctxt->level = 0;
 1201|    459|#ifdef LIBXML_HTML_ENABLED
 1202|    459|		if (is_xhtml)
  ------------------
  |  Branch (1202:7): [True: 5, False: 454]
  ------------------
 1203|      5|		    xhtmlNodeDumpOutput(ctxt, child);
 1204|    454|		else
 1205|    454|#endif
 1206|    454|		    xmlNodeDumpOutputInternal(ctxt, child);
 1207|    459|                if ((child->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (1207:21): [True: 459, False: 0]
  ------------------
 1208|    459|                    (child->type != XML_XINCLUDE_END))
  ------------------
  |  Branch (1208:21): [True: 459, False: 0]
  ------------------
 1209|    459|                    xmlOutputBufferWrite(buf, 1, "\n");
 1210|    459|		child = child->next;
 1211|    459|	    }
 1212|    262|	}
 1213|    262|    }
 1214|       |
 1215|       |    /*
 1216|       |     * Restore the state of the saving context at the end of the document
 1217|       |     */
 1218|    262|    if ((switched_encoding) && (oldctxtenc == NULL)) {
  ------------------
  |  Branch (1218:9): [True: 0, False: 262]
  |  Branch (1218:32): [True: 0, False: 0]
  ------------------
 1219|      0|	xmlSaveClearEncoding(ctxt);
 1220|      0|	ctxt->escape = oldescape;
 1221|      0|	ctxt->escapeAttr = oldescapeAttr;
 1222|      0|    }
 1223|    262|    cur->encoding = oldenc;
 1224|    262|    return(0);
 1225|    262|}
xmlsave.c:xmlEscapeEntities:
  166|  2.84k|                 const xmlChar* in, int *inlen) {
  167|  2.84k|    unsigned char* outstart = out;
  168|  2.84k|    const unsigned char* base = in;
  169|  2.84k|    unsigned char* outend = out + *outlen;
  170|  2.84k|    const unsigned char* inend;
  171|  2.84k|    int val;
  172|       |
  173|  2.84k|    inend = in + (*inlen);
  174|       |
  175|   256k|    while ((in < inend) && (out < outend)) {
  ------------------
  |  Branch (175:12): [True: 253k, False: 2.83k]
  |  Branch (175:28): [True: 253k, False: 10]
  ------------------
  176|   253k|	if (*in == '<') {
  ------------------
  |  Branch (176:6): [True: 5, False: 253k]
  ------------------
  177|      5|	    if (outend - out < 4) break;
  ------------------
  |  Branch (177:10): [True: 0, False: 5]
  ------------------
  178|      5|	    *out++ = '&';
  179|      5|	    *out++ = 'l';
  180|      5|	    *out++ = 't';
  181|      5|	    *out++ = ';';
  182|      5|	    in++;
  183|      5|	    continue;
  184|   253k|	} else if (*in == '>') {
  ------------------
  |  Branch (184:13): [True: 6, False: 253k]
  ------------------
  185|      6|	    if (outend - out < 4) break;
  ------------------
  |  Branch (185:10): [True: 0, False: 6]
  ------------------
  186|      6|	    *out++ = '&';
  187|      6|	    *out++ = 'g';
  188|      6|	    *out++ = 't';
  189|      6|	    *out++ = ';';
  190|      6|	    in++;
  191|      6|	    continue;
  192|   253k|	} else if (*in == '&') {
  ------------------
  |  Branch (192:13): [True: 5, False: 253k]
  ------------------
  193|      5|	    if (outend - out < 5) break;
  ------------------
  |  Branch (193:10): [True: 0, False: 5]
  ------------------
  194|      5|	    *out++ = '&';
  195|      5|	    *out++ = 'a';
  196|      5|	    *out++ = 'm';
  197|      5|	    *out++ = 'p';
  198|      5|	    *out++ = ';';
  199|      5|	    in++;
  200|      5|	    continue;
  201|   253k|	} else if (((*in >= 0x20) && (*in < 0x80)) ||
  ------------------
  |  Branch (201:14): [True: 248k, False: 4.52k]
  |  Branch (201:31): [True: 248k, False: 14]
  ------------------
  202|   253k|	           (*in == '\n') || (*in == '\t')) {
  ------------------
  |  Branch (202:13): [True: 4.50k, False: 34]
  |  Branch (202:30): [True: 20, False: 14]
  ------------------
  203|       |	    /*
  204|       |	     * default case, just copy !
  205|       |	     */
  206|   253k|	    *out++ = *in++;
  207|   253k|	    continue;
  208|   253k|	} else if (*in >= 0x80) {
  ------------------
  |  Branch (208:13): [True: 14, False: 0]
  ------------------
  209|       |	    /*
  210|       |	     * We assume we have UTF-8 input.
  211|       |	     */
  212|     14|	    if (outend - out < 11) break;
  ------------------
  |  Branch (212:10): [True: 0, False: 14]
  ------------------
  213|       |
  214|     14|	    if (*in < 0xC0) {
  ------------------
  |  Branch (214:10): [True: 0, False: 14]
  ------------------
  215|      0|		xmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);
  216|      0|		in++;
  217|      0|		goto error;
  218|     14|	    } else if (*in < 0xE0) {
  ------------------
  |  Branch (218:17): [True: 14, False: 0]
  ------------------
  219|     14|		if (inend - in < 2) break;
  ------------------
  |  Branch (219:7): [True: 0, False: 14]
  ------------------
  220|     14|		val = (in[0]) & 0x1F;
  221|     14|		val <<= 6;
  222|     14|		val |= (in[1]) & 0x3F;
  223|     14|		in += 2;
  224|     14|	    } else if (*in < 0xF0) {
  ------------------
  |  Branch (224:17): [True: 0, False: 0]
  ------------------
  225|      0|		if (inend - in < 3) break;
  ------------------
  |  Branch (225:7): [True: 0, False: 0]
  ------------------
  226|      0|		val = (in[0]) & 0x0F;
  227|      0|		val <<= 6;
  228|      0|		val |= (in[1]) & 0x3F;
  229|      0|		val <<= 6;
  230|      0|		val |= (in[2]) & 0x3F;
  231|      0|		in += 3;
  232|      0|	    } else if (*in < 0xF8) {
  ------------------
  |  Branch (232:17): [True: 0, False: 0]
  ------------------
  233|      0|		if (inend - in < 4) break;
  ------------------
  |  Branch (233:7): [True: 0, False: 0]
  ------------------
  234|      0|		val = (in[0]) & 0x07;
  235|      0|		val <<= 6;
  236|      0|		val |= (in[1]) & 0x3F;
  237|      0|		val <<= 6;
  238|      0|		val |= (in[2]) & 0x3F;
  239|      0|		val <<= 6;
  240|      0|		val |= (in[3]) & 0x3F;
  241|      0|		in += 4;
  242|      0|	    } else {
  243|      0|		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);
  244|      0|		in++;
  245|      0|		goto error;
  246|      0|	    }
  247|     14|	    if (!IS_CHAR(val)) {
  ------------------
  |  |  125|     14|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     14|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 14, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     14|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     14|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 14, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 14]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     14|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 14]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     14|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 14, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     14|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (247:10): [True: 0, False: 14]
  ------------------
  248|      0|		xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);
  249|      0|		in++;
  250|      0|		goto error;
  251|      0|	    }
  252|       |
  253|       |	    /*
  254|       |	     * We could do multiple things here. Just save as a char ref
  255|       |	     */
  256|     14|	    out = xmlSerializeHexCharRef(out, val);
  257|     14|	} else if (IS_BYTE_CHAR(*in)) {
  ------------------
  |  |  113|      0|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  258|      0|	    if (outend - out < 6) break;
  ------------------
  |  Branch (258:10): [True: 0, False: 0]
  ------------------
  259|      0|	    out = xmlSerializeHexCharRef(out, *in++);
  260|      0|	} else {
  261|      0|	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  262|      0|		"xmlEscapeEntities : char out of range\n");
  263|      0|	    in++;
  264|      0|	    goto error;
  265|      0|	}
  266|   253k|    }
  267|  2.84k|    *outlen = out - outstart;
  268|  2.84k|    *inlen = in - base;
  269|  2.84k|    return(0);
  270|      0|error:
  271|      0|    *outlen = out - outstart;
  272|      0|    *inlen = in - base;
  273|      0|    return(-1);
  274|  2.84k|}
xmlsave.c:xhtmlNodeDumpOutput:
 1392|      5|xhtmlNodeDumpOutput(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
 1393|      5|    int format = ctxt->format, addmeta;
 1394|      5|    xmlNodePtr tmp, root, unformattedNode = NULL;
 1395|      5|    xmlChar *start, *end;
 1396|      5|    xmlOutputBufferPtr buf = ctxt->buf;
 1397|       |
 1398|      5|    if (cur == NULL) return;
  ------------------
  |  Branch (1398:9): [True: 0, False: 5]
  ------------------
 1399|       |
 1400|      5|    root = cur;
 1401|     67|    while (1) {
  ------------------
  |  Branch (1401:12): [Folded - Ignored]
  ------------------
 1402|     67|        switch (cur->type) {
 1403|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (1403:9): [True: 0, False: 67]
  ------------------
 1404|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (1404:9): [True: 0, False: 67]
  ------------------
 1405|      0|            xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
 1406|      0|	    break;
 1407|       |
 1408|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (1408:9): [True: 0, False: 67]
  ------------------
 1409|      0|	    xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
 1410|      0|	    break;
 1411|       |
 1412|      2|        case XML_DTD_NODE:
  ------------------
  |  Branch (1412:9): [True: 2, False: 65]
  ------------------
 1413|      2|            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
 1414|      2|	    break;
 1415|       |
 1416|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (1416:9): [True: 0, False: 67]
  ------------------
 1417|      0|            if (cur->children) {
  ------------------
  |  Branch (1417:17): [True: 0, False: 0]
  ------------------
 1418|      0|                cur = cur->children;
 1419|      0|                continue;
 1420|      0|            }
 1421|      0|            break;
 1422|       |
 1423|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (1423:9): [True: 0, False: 67]
  ------------------
 1424|      0|            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
 1425|      0|	    break;
 1426|       |
 1427|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (1427:9): [True: 0, False: 67]
  ------------------
 1428|      0|            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
 1429|      0|	    break;
 1430|       |
 1431|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (1431:9): [True: 0, False: 67]
  ------------------
 1432|      0|            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
 1433|      0|	    break;
 1434|       |
 1435|     19|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (1435:9): [True: 19, False: 48]
  ------------------
 1436|     19|            addmeta = 0;
 1437|       |
 1438|     19|	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1438:10): [True: 17, False: 2]
  |  Branch (1438:27): [True: 0, False: 17]
  |  Branch (1438:50): [True: 0, False: 0]
  ------------------
 1439|      0|		xmlOutputBufferWrite(buf, ctxt->indent_size *
 1440|      0|				     (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (1440:11): [True: 0, False: 0]
  ------------------
 1441|      0|				      ctxt->indent_nr : ctxt->level),
 1442|      0|				     ctxt->indent);
 1443|       |
 1444|     19|            xmlOutputBufferWrite(buf, 1, "<");
 1445|     19|            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (1445:17): [True: 0, False: 19]
  |  Branch (1445:38): [True: 0, False: 0]
  ------------------
 1446|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
 1447|      0|                xmlOutputBufferWrite(buf, 1, ":");
 1448|      0|            }
 1449|       |
 1450|     19|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1451|     19|            if (cur->nsDef)
  ------------------
  |  Branch (1451:17): [True: 0, False: 19]
  ------------------
 1452|      0|                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
 1453|     19|            if ((xmlStrEqual(cur->name, BAD_CAST "html") &&
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1453:18): [True: 2, False: 17]
  ------------------
 1454|     19|                (cur->ns == NULL) && (cur->nsDef == NULL))) {
  ------------------
  |  Branch (1454:17): [True: 2, False: 0]
  |  Branch (1454:38): [True: 2, False: 0]
  ------------------
 1455|       |                /*
 1456|       |                 * 3.1.1. Strictly Conforming Documents A.3.1.1 3/
 1457|       |                 */
 1458|      2|                xmlOutputBufferWriteString(buf,
 1459|      2|                        " xmlns=\"http://www.w3.org/1999/xhtml\"");
 1460|      2|            }
 1461|     19|            if (cur->properties != NULL)
  ------------------
  |  Branch (1461:17): [True: 8, False: 11]
  ------------------
 1462|      8|                xhtmlAttrListDumpOutput(ctxt, cur->properties);
 1463|       |
 1464|     19|            if ((cur->parent != NULL) &&
  ------------------
  |  Branch (1464:17): [True: 19, False: 0]
  ------------------
 1465|     19|                (cur->parent->parent == (xmlNodePtr) cur->doc) &&
  ------------------
  |  Branch (1465:17): [True: 10, False: 9]
  ------------------
 1466|     19|                xmlStrEqual(cur->name, BAD_CAST"head") &&
  ------------------
  |  |   35|     10|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1466:17): [True: 1, False: 9]
  ------------------
 1467|     19|                xmlStrEqual(cur->parent->name, BAD_CAST"html")) {
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1467:17): [True: 1, False: 0]
  ------------------
 1468|       |
 1469|      1|                tmp = cur->children;
 1470|      4|                while (tmp != NULL) {
  ------------------
  |  Branch (1470:24): [True: 3, False: 1]
  ------------------
 1471|      3|                    if (xmlStrEqual(tmp->name, BAD_CAST"meta")) {
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1471:25): [True: 0, False: 3]
  ------------------
 1472|      0|                        xmlChar *httpequiv;
 1473|       |
 1474|      0|                        httpequiv = xmlGetProp(tmp, BAD_CAST"http-equiv");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1475|      0|                        if (httpequiv != NULL) {
  ------------------
  |  Branch (1475:29): [True: 0, False: 0]
  ------------------
 1476|      0|                            if (xmlStrcasecmp(httpequiv,
  ------------------
  |  Branch (1476:33): [True: 0, False: 0]
  ------------------
 1477|      0|                                        BAD_CAST"Content-Type") == 0) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1478|      0|                                xmlFree(httpequiv);
 1479|      0|                                break;
 1480|      0|                            }
 1481|      0|                            xmlFree(httpequiv);
 1482|      0|                        }
 1483|      0|                    }
 1484|      3|                    tmp = tmp->next;
 1485|      3|                }
 1486|      1|                if (tmp == NULL)
  ------------------
  |  Branch (1486:21): [True: 1, False: 0]
  ------------------
 1487|      1|                    addmeta = 1;
 1488|      1|            }
 1489|       |
 1490|     19|            if (cur->children == NULL) {
  ------------------
  |  Branch (1490:17): [True: 2, False: 17]
  ------------------
 1491|      2|                if (((cur->ns == NULL) || (cur->ns->prefix == NULL)) &&
  ------------------
  |  Branch (1491:22): [True: 2, False: 0]
  |  Branch (1491:43): [True: 0, False: 0]
  ------------------
 1492|      2|                    ((xhtmlIsEmpty(cur) == 1) && (addmeta == 0))) {
  ------------------
  |  Branch (1492:22): [True: 1, False: 1]
  |  Branch (1492:50): [True: 1, False: 0]
  ------------------
 1493|       |                    /*
 1494|       |                     * C.2. Empty Elements
 1495|       |                     */
 1496|      1|                    xmlOutputBufferWrite(buf, 3, " />");
 1497|      1|                } else {
 1498|      1|                    if (addmeta == 1) {
  ------------------
  |  Branch (1498:25): [True: 0, False: 1]
  ------------------
 1499|      0|                        xmlOutputBufferWrite(buf, 1, ">");
 1500|      0|                        if (ctxt->format == 1) {
  ------------------
  |  Branch (1500:29): [True: 0, False: 0]
  ------------------
 1501|      0|                            xmlOutputBufferWrite(buf, 1, "\n");
 1502|      0|                            if (xmlIndentTreeOutput)
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1503|      0|                                xmlOutputBufferWrite(buf, ctxt->indent_size *
 1504|      0|                                    (ctxt->level + 1 > ctxt->indent_nr ?
  ------------------
  |  Branch (1504:38): [True: 0, False: 0]
  ------------------
 1505|      0|                                    ctxt->indent_nr : ctxt->level + 1),
 1506|      0|                                    ctxt->indent);
 1507|      0|                        }
 1508|      0|                        xmlOutputBufferWriteString(buf,
 1509|      0|                                "<meta http-equiv=\"Content-Type\" "
 1510|      0|                                "content=\"text/html; charset=");
 1511|      0|                        if (ctxt->encoding) {
  ------------------
  |  Branch (1511:29): [True: 0, False: 0]
  ------------------
 1512|      0|                            xmlOutputBufferWriteString(buf,
 1513|      0|                                    (const char *)ctxt->encoding);
 1514|      0|                        } else {
 1515|      0|                            xmlOutputBufferWrite(buf, 5, "UTF-8");
 1516|      0|                        }
 1517|      0|                        xmlOutputBufferWrite(buf, 4, "\" />");
 1518|      0|                        if (ctxt->format == 1)
  ------------------
  |  Branch (1518:29): [True: 0, False: 0]
  ------------------
 1519|      0|                            xmlOutputBufferWrite(buf, 1, "\n");
 1520|      1|                    } else {
 1521|      1|                        xmlOutputBufferWrite(buf, 1, ">");
 1522|      1|                    }
 1523|       |                    /*
 1524|       |                     * C.3. Element Minimization and Empty Element Content
 1525|       |                     */
 1526|      1|                    xmlOutputBufferWrite(buf, 2, "</");
 1527|      1|                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (1527:25): [True: 0, False: 1]
  |  Branch (1527:46): [True: 0, False: 0]
  ------------------
 1528|      0|                        xmlOutputBufferWriteString(buf,
 1529|      0|                                (const char *)cur->ns->prefix);
 1530|      0|                        xmlOutputBufferWrite(buf, 1, ":");
 1531|      0|                    }
 1532|      1|                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1533|      1|                    xmlOutputBufferWrite(buf, 1, ">");
 1534|      1|                }
 1535|     17|            } else {
 1536|     17|                xmlOutputBufferWrite(buf, 1, ">");
 1537|     17|                if (addmeta == 1) {
  ------------------
  |  Branch (1537:21): [True: 1, False: 16]
  ------------------
 1538|      1|                    if (ctxt->format == 1) {
  ------------------
  |  Branch (1538:25): [True: 0, False: 1]
  ------------------
 1539|      0|                        xmlOutputBufferWrite(buf, 1, "\n");
 1540|      0|                        if (xmlIndentTreeOutput)
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1541|      0|                            xmlOutputBufferWrite(buf, ctxt->indent_size *
 1542|      0|                                (ctxt->level + 1 > ctxt->indent_nr ?
  ------------------
  |  Branch (1542:34): [True: 0, False: 0]
  ------------------
 1543|      0|                                ctxt->indent_nr : ctxt->level + 1),
 1544|      0|                                ctxt->indent);
 1545|      0|                    }
 1546|      1|                    xmlOutputBufferWriteString(buf,
 1547|      1|                            "<meta http-equiv=\"Content-Type\" "
 1548|      1|                            "content=\"text/html; charset=");
 1549|      1|                    if (ctxt->encoding) {
  ------------------
  |  Branch (1549:25): [True: 1, False: 0]
  ------------------
 1550|      1|                        xmlOutputBufferWriteString(buf,
 1551|      1|                                (const char *)ctxt->encoding);
 1552|      1|                    } else {
 1553|      0|                        xmlOutputBufferWrite(buf, 5, "UTF-8");
 1554|      0|                    }
 1555|      1|                    xmlOutputBufferWrite(buf, 4, "\" />");
 1556|      1|                }
 1557|       |
 1558|     17|                if (ctxt->format == 1) {
  ------------------
  |  Branch (1558:21): [True: 0, False: 17]
  ------------------
 1559|      0|                    tmp = cur->children;
 1560|      0|                    while (tmp != NULL) {
  ------------------
  |  Branch (1560:28): [True: 0, False: 0]
  ------------------
 1561|      0|                        if ((tmp->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (1561:29): [True: 0, False: 0]
  ------------------
 1562|      0|                            (tmp->type == XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (1562:29): [True: 0, False: 0]
  ------------------
 1563|      0|                            unformattedNode = cur;
 1564|      0|                            ctxt->format = 0;
 1565|      0|                            break;
 1566|      0|                        }
 1567|      0|                        tmp = tmp->next;
 1568|      0|                    }
 1569|      0|                }
 1570|       |
 1571|     17|                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");
  ------------------
  |  Branch (1571:21): [True: 0, False: 17]
  ------------------
 1572|     17|                if (ctxt->level >= 0) ctxt->level++;
  ------------------
  |  Branch (1572:21): [True: 17, False: 0]
  ------------------
 1573|     17|                cur = cur->children;
 1574|     17|                continue;
 1575|     17|            }
 1576|       |
 1577|      2|            break;
 1578|       |
 1579|     39|        case XML_TEXT_NODE:
  ------------------
  |  Branch (1579:9): [True: 39, False: 28]
  ------------------
 1580|     39|	    if (cur->content == NULL)
  ------------------
  |  Branch (1580:10): [True: 0, False: 39]
  ------------------
 1581|      0|                break;
 1582|     39|	    if ((cur->name == xmlStringText) ||
  ------------------
  |  Branch (1582:10): [True: 39, False: 0]
  ------------------
 1583|     39|		(cur->name != xmlStringTextNoenc)) {
  ------------------
  |  Branch (1583:3): [True: 0, False: 0]
  ------------------
 1584|     39|                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
 1585|     39|	    } else {
 1586|       |		/*
 1587|       |		 * Disable escaping, needed for XSLT
 1588|       |		 */
 1589|      0|		xmlOutputBufferWriteString(buf, (const char *) cur->content);
 1590|      0|	    }
 1591|     39|	    break;
 1592|       |
 1593|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (1593:9): [True: 0, False: 67]
  ------------------
 1594|      0|            if (cur->content != NULL) {
  ------------------
  |  Branch (1594:17): [True: 0, False: 0]
  ------------------
 1595|      0|                xmlOutputBufferWrite(buf, 2, "<?");
 1596|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1597|      0|                if (cur->content != NULL) {
  ------------------
  |  Branch (1597:21): [True: 0, False: 0]
  ------------------
 1598|      0|                    xmlOutputBufferWrite(buf, 1, " ");
 1599|      0|                    xmlOutputBufferWriteString(buf,
 1600|      0|                            (const char *)cur->content);
 1601|      0|                }
 1602|      0|                xmlOutputBufferWrite(buf, 2, "?>");
 1603|      0|            } else {
 1604|      0|                xmlOutputBufferWrite(buf, 2, "<?");
 1605|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1606|      0|                xmlOutputBufferWrite(buf, 2, "?>");
 1607|      0|            }
 1608|      0|            break;
 1609|       |
 1610|      7|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (1610:9): [True: 7, False: 60]
  ------------------
 1611|      7|            if (cur->content != NULL) {
  ------------------
  |  Branch (1611:17): [True: 7, False: 0]
  ------------------
 1612|      7|                xmlOutputBufferWrite(buf, 4, "<!--");
 1613|      7|                xmlOutputBufferWriteString(buf, (const char *)cur->content);
 1614|      7|                xmlOutputBufferWrite(buf, 3, "-->");
 1615|      7|            }
 1616|      7|            break;
 1617|       |
 1618|      0|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (1618:9): [True: 0, False: 67]
  ------------------
 1619|      0|            xmlOutputBufferWrite(buf, 1, "&");
 1620|      0|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1621|      0|            xmlOutputBufferWrite(buf, 1, ";");
 1622|      0|            break;
 1623|       |
 1624|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (1624:9): [True: 0, False: 67]
  ------------------
 1625|      0|            if (cur->content == NULL || *cur->content == '\0') {
  ------------------
  |  Branch (1625:17): [True: 0, False: 0]
  |  Branch (1625:41): [True: 0, False: 0]
  ------------------
 1626|      0|                xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
 1627|      0|            } else {
 1628|      0|                start = end = cur->content;
 1629|      0|                while (*end != '\0') {
  ------------------
  |  Branch (1629:24): [True: 0, False: 0]
  ------------------
 1630|      0|                    if (*end == ']' && *(end + 1) == ']' &&
  ------------------
  |  Branch (1630:25): [True: 0, False: 0]
  |  Branch (1630:40): [True: 0, False: 0]
  ------------------
 1631|      0|                        *(end + 2) == '>') {
  ------------------
  |  Branch (1631:25): [True: 0, False: 0]
  ------------------
 1632|      0|                        end = end + 2;
 1633|      0|                        xmlOutputBufferWrite(buf, 9, "<![CDATA[");
 1634|      0|                        xmlOutputBufferWrite(buf, end - start,
 1635|      0|                                (const char *)start);
 1636|      0|                        xmlOutputBufferWrite(buf, 3, "]]>");
 1637|      0|                        start = end;
 1638|      0|                    }
 1639|      0|                    end++;
 1640|      0|                }
 1641|      0|                if (start != end) {
  ------------------
  |  Branch (1641:21): [True: 0, False: 0]
  ------------------
 1642|      0|                    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
 1643|      0|                    xmlOutputBufferWriteString(buf, (const char *)start);
 1644|      0|                    xmlOutputBufferWrite(buf, 3, "]]>");
 1645|      0|                }
 1646|      0|            }
 1647|      0|            break;
 1648|       |
 1649|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (1649:9): [True: 0, False: 67]
  ------------------
 1650|      0|            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
 1651|      0|	    break;
 1652|       |
 1653|      0|        default:
  ------------------
  |  Branch (1653:9): [True: 0, False: 67]
  ------------------
 1654|      0|            break;
 1655|     67|        }
 1656|       |
 1657|     67|        while (1) {
  ------------------
  |  Branch (1657:16): [Folded - Ignored]
  ------------------
 1658|     67|            if (cur == root)
  ------------------
  |  Branch (1658:17): [True: 5, False: 62]
  ------------------
 1659|      5|                return;
 1660|     62|            if (ctxt->format == 1)
  ------------------
  |  Branch (1660:17): [True: 0, False: 62]
  ------------------
 1661|      0|                xmlOutputBufferWrite(buf, 1, "\n");
 1662|     62|            if (cur->next != NULL) {
  ------------------
  |  Branch (1662:17): [True: 45, False: 17]
  ------------------
 1663|     45|                cur = cur->next;
 1664|     45|                break;
 1665|     45|            }
 1666|       |
 1667|       |            /*
 1668|       |             * The parent should never be NULL here but we want to handle
 1669|       |             * corrupted documents gracefully.
 1670|       |             */
 1671|     17|            if (cur->parent == NULL)
  ------------------
  |  Branch (1671:17): [True: 0, False: 17]
  ------------------
 1672|      0|                return;
 1673|     17|            cur = cur->parent;
 1674|       |
 1675|     17|            if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (1675:17): [True: 17, False: 0]
  ------------------
 1676|     17|                if (ctxt->level > 0) ctxt->level--;
  ------------------
  |  Branch (1676:21): [True: 17, False: 0]
  ------------------
 1677|     17|                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
  ------------------
  |  |   55|     17|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|     17|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1677:21): [True: 17, False: 0]
  |  Branch (1677:46): [True: 0, False: 17]
  ------------------
 1678|      0|                    xmlOutputBufferWrite(buf, ctxt->indent_size *
 1679|      0|                                         (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (1679:43): [True: 0, False: 0]
  ------------------
 1680|      0|                                          ctxt->indent_nr : ctxt->level),
 1681|      0|                                         ctxt->indent);
 1682|       |
 1683|     17|                xmlOutputBufferWrite(buf, 2, "</");
 1684|     17|                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (1684:21): [True: 0, False: 17]
  |  Branch (1684:42): [True: 0, False: 0]
  ------------------
 1685|      0|                    xmlOutputBufferWriteString(buf,
 1686|      0|                            (const char *)cur->ns->prefix);
 1687|      0|                    xmlOutputBufferWrite(buf, 1, ":");
 1688|      0|                }
 1689|       |
 1690|     17|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1691|     17|                xmlOutputBufferWrite(buf, 1, ">");
 1692|       |
 1693|     17|                if (cur == unformattedNode) {
  ------------------
  |  Branch (1693:21): [True: 0, False: 17]
  ------------------
 1694|      0|                    ctxt->format = format;
 1695|      0|                    unformattedNode = NULL;
 1696|      0|                }
 1697|     17|            }
 1698|     17|        }
 1699|     50|    }
 1700|      5|}
xmlsave.c:xmlDtdDumpOutput:
  666|    163|xmlDtdDumpOutput(xmlSaveCtxtPtr ctxt, xmlDtdPtr dtd) {
  667|    163|    xmlOutputBufferPtr buf;
  668|    163|    xmlNodePtr cur;
  669|    163|    int format, level;
  670|       |
  671|    163|    if (dtd == NULL) return;
  ------------------
  |  Branch (671:9): [True: 0, False: 163]
  ------------------
  672|    163|    if ((ctxt == NULL) || (ctxt->buf == NULL))
  ------------------
  |  Branch (672:9): [True: 0, False: 163]
  |  Branch (672:27): [True: 0, False: 163]
  ------------------
  673|      0|        return;
  674|    163|    buf = ctxt->buf;
  675|    163|    xmlOutputBufferWrite(buf, 10, "<!DOCTYPE ");
  676|    163|    xmlOutputBufferWriteString(buf, (const char *)dtd->name);
  677|    163|    if (dtd->ExternalID != NULL) {
  ------------------
  |  Branch (677:9): [True: 40, False: 123]
  ------------------
  678|     40|	xmlOutputBufferWrite(buf, 8, " PUBLIC ");
  679|     40|	xmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);
  680|     40|	xmlOutputBufferWrite(buf, 1, " ");
  681|     40|	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);
  682|    123|    }  else if (dtd->SystemID != NULL) {
  ------------------
  |  Branch (682:17): [True: 21, False: 102]
  ------------------
  683|     21|	xmlOutputBufferWrite(buf, 8, " SYSTEM ");
  684|     21|	xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);
  685|     21|    }
  686|    163|    if ((dtd->entities == NULL) && (dtd->elements == NULL) &&
  ------------------
  |  Branch (686:9): [True: 128, False: 35]
  |  Branch (686:36): [True: 53, False: 75]
  ------------------
  687|    163|        (dtd->attributes == NULL) && (dtd->notations == NULL) &&
  ------------------
  |  Branch (687:9): [True: 53, False: 0]
  |  Branch (687:38): [True: 53, False: 0]
  ------------------
  688|    163|	(dtd->pentities == NULL)) {
  ------------------
  |  Branch (688:2): [True: 52, False: 1]
  ------------------
  689|     52|	xmlOutputBufferWrite(buf, 1, ">");
  690|     52|	return;
  691|     52|    }
  692|    111|    xmlOutputBufferWrite(buf, 3, " [\n");
  693|       |    /*
  694|       |     * Dump the notations first they are not in the DTD children list
  695|       |     * Do this only on a standalone DTD or on the internal subset though.
  696|       |     */
  697|    111|    if ((dtd->notations != NULL) && ((dtd->doc == NULL) ||
  ------------------
  |  Branch (697:9): [True: 0, False: 111]
  |  Branch (697:38): [True: 0, False: 0]
  ------------------
  698|      0|        (dtd->doc->intSubset == dtd))) {
  ------------------
  |  Branch (698:9): [True: 0, False: 0]
  ------------------
  699|      0|        xmlBufDumpNotationTable(buf->buffer,
  700|      0|                                (xmlNotationTablePtr) dtd->notations);
  701|      0|    }
  702|    111|    format = ctxt->format;
  703|    111|    level = ctxt->level;
  704|    111|    ctxt->format = 0;
  705|    111|    ctxt->level = -1;
  706|  1.54k|    for (cur = dtd->children; cur != NULL; cur = cur->next) {
  ------------------
  |  Branch (706:31): [True: 1.43k, False: 111]
  ------------------
  707|  1.43k|        xmlNodeDumpOutputInternal(ctxt, cur);
  708|  1.43k|    }
  709|    111|    ctxt->format = format;
  710|    111|    ctxt->level = level;
  711|    111|    xmlOutputBufferWrite(buf, 2, "]>");
  712|    111|}
xmlsave.c:xmlBufDumpElementDecl:
  449|    389|xmlBufDumpElementDecl(xmlBufPtr buf, xmlElementPtr elem) {
  450|    389|    xmlBufferPtr buffer;
  451|       |
  452|    389|    buffer = xmlBufferCreate();
  453|    389|    if (buffer == NULL) {
  ------------------
  |  Branch (453:9): [True: 0, False: 389]
  ------------------
  454|       |        /*
  455|       |         * TODO set the error in buf
  456|       |         */
  457|      0|        return;
  458|      0|    }
  459|    389|    xmlBufferSetAllocationScheme(buffer, XML_BUFFER_ALLOC_DOUBLEIT);
  460|    389|    xmlDumpElementDecl(buffer, elem);
  461|    389|    xmlBufMergeBuffer(buf, buffer);
  462|    389|}
xmlsave.c:xmlBufDumpAttributeDecl:
  473|    595|xmlBufDumpAttributeDecl(xmlBufPtr buf, xmlAttributePtr attr) {
  474|    595|    xmlBufferPtr buffer;
  475|       |
  476|    595|    buffer = xmlBufferCreate();
  477|    595|    if (buffer == NULL) {
  ------------------
  |  Branch (477:9): [True: 0, False: 595]
  ------------------
  478|       |        /*
  479|       |         * TODO set the error in buf
  480|       |         */
  481|      0|        return;
  482|      0|    }
  483|    595|    xmlBufferSetAllocationScheme(buffer, XML_BUFFER_ALLOC_DOUBLEIT);
  484|    595|    xmlDumpAttributeDecl(buffer, attr);
  485|    595|    xmlBufMergeBuffer(buf, buffer);
  486|    595|}
xmlsave.c:xmlBufDumpEntityDecl:
  496|    202|xmlBufDumpEntityDecl(xmlBufPtr buf, xmlEntityPtr ent) {
  497|    202|    xmlBufferPtr buffer;
  498|       |
  499|    202|    buffer = xmlBufferCreate();
  500|    202|    if (buffer == NULL) {
  ------------------
  |  Branch (500:9): [True: 0, False: 202]
  ------------------
  501|       |        /*
  502|       |         * TODO set the error in buf
  503|       |         */
  504|      0|        return;
  505|      0|    }
  506|    202|    xmlBufferSetAllocationScheme(buffer, XML_BUFFER_ALLOC_DOUBLEIT);
  507|    202|    xmlDumpEntityDecl(buffer, ent);
  508|    202|    xmlBufMergeBuffer(buf, buffer);
  509|    202|}
xmlsave.c:xmlNsListDumpOutputCtxt:
  635|     78|xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {
  636|    179|    while (cur != NULL) {
  ------------------
  |  Branch (636:12): [True: 101, False: 78]
  ------------------
  637|    101|        xmlNsDumpOutput(ctxt->buf, cur, ctxt);
  638|    101|	cur = cur->next;
  639|    101|    }
  640|     78|}
xmlsave.c:xhtmlAttrListDumpOutput:
 1308|      8|xhtmlAttrListDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
 1309|      8|    xmlAttrPtr xml_lang = NULL;
 1310|      8|    xmlAttrPtr lang = NULL;
 1311|      8|    xmlAttrPtr name = NULL;
 1312|      8|    xmlAttrPtr id = NULL;
 1313|      8|    xmlNodePtr parent;
 1314|      8|    xmlOutputBufferPtr buf;
 1315|       |
 1316|      8|    if (cur == NULL) return;
  ------------------
  |  Branch (1316:9): [True: 0, False: 8]
  ------------------
 1317|      8|    buf = ctxt->buf;
 1318|      8|    parent = cur->parent;
 1319|     18|    while (cur != NULL) {
  ------------------
  |  Branch (1319:12): [True: 10, False: 8]
  ------------------
 1320|     10|	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "id")))
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1320:6): [True: 8, False: 2]
  |  Branch (1320:27): [True: 0, False: 8]
  ------------------
 1321|      0|	    id = cur;
 1322|     10|	else
 1323|     10|	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "name")))
  ------------------
  |  |   35|      8|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1323:6): [True: 8, False: 2]
  |  Branch (1323:27): [True: 1, False: 7]
  ------------------
 1324|      1|	    name = cur;
 1325|      9|	else
 1326|      9|	if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")))
  ------------------
  |  |   35|      7|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1326:6): [True: 7, False: 2]
  |  Branch (1326:27): [True: 2, False: 5]
  ------------------
 1327|      2|	    lang = cur;
 1328|      7|	else
 1329|      7|	if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST "lang")) &&
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1329:6): [True: 2, False: 5]
  |  Branch (1329:27): [True: 2, False: 0]
  ------------------
 1330|      7|	    (xmlStrEqual(cur->ns->prefix, BAD_CAST "xml")))
  ------------------
  |  |   35|      2|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1330:6): [True: 2, False: 0]
  ------------------
 1331|      2|	    xml_lang = cur;
 1332|      5|	else if ((cur->ns == NULL) &&
  ------------------
  |  Branch (1332:11): [True: 5, False: 0]
  ------------------
 1333|      5|		 ((cur->children == NULL) ||
  ------------------
  |  Branch (1333:5): [True: 0, False: 5]
  ------------------
 1334|      5|		  (cur->children->content == NULL) ||
  ------------------
  |  Branch (1334:5): [True: 0, False: 5]
  ------------------
 1335|      5|		  (cur->children->content[0] == 0)) &&
  ------------------
  |  Branch (1335:5): [True: 1, False: 4]
  ------------------
 1336|      5|		 (htmlIsBooleanAttr(cur->name))) {
  ------------------
  |  Branch (1336:4): [True: 1, False: 0]
  ------------------
 1337|      1|	    if (cur->children != NULL)
  ------------------
  |  Branch (1337:10): [True: 1, False: 0]
  ------------------
 1338|      1|		xmlFreeNode(cur->children);
 1339|      1|	    cur->children = xmlNewDocText(cur->doc, cur->name);
 1340|      1|	    if (cur->children != NULL)
  ------------------
  |  Branch (1340:10): [True: 1, False: 0]
  ------------------
 1341|      1|		cur->children->parent = (xmlNodePtr) cur;
 1342|      1|	}
 1343|     10|        xmlAttrDumpOutput(ctxt, cur);
 1344|     10|	cur = cur->next;
 1345|     10|    }
 1346|       |    /*
 1347|       |     * C.8
 1348|       |     */
 1349|      8|    if ((name != NULL) && (id == NULL)) {
  ------------------
  |  Branch (1349:9): [True: 1, False: 7]
  |  Branch (1349:27): [True: 1, False: 0]
  ------------------
 1350|      1|	if ((parent != NULL) && (parent->name != NULL) &&
  ------------------
  |  Branch (1350:6): [True: 1, False: 0]
  |  Branch (1350:26): [True: 1, False: 0]
  ------------------
 1351|      1|	    ((xmlStrEqual(parent->name, BAD_CAST "a")) ||
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1351:7): [True: 0, False: 1]
  ------------------
 1352|      1|	     (xmlStrEqual(parent->name, BAD_CAST "p")) ||
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1352:7): [True: 1, False: 0]
  ------------------
 1353|      1|	     (xmlStrEqual(parent->name, BAD_CAST "div")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1353:7): [True: 0, False: 0]
  ------------------
 1354|      1|	     (xmlStrEqual(parent->name, BAD_CAST "img")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1354:7): [True: 0, False: 0]
  ------------------
 1355|      1|	     (xmlStrEqual(parent->name, BAD_CAST "map")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1355:7): [True: 0, False: 0]
  ------------------
 1356|      1|	     (xmlStrEqual(parent->name, BAD_CAST "applet")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1356:7): [True: 0, False: 0]
  ------------------
 1357|      1|	     (xmlStrEqual(parent->name, BAD_CAST "form")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1357:7): [True: 0, False: 0]
  ------------------
 1358|      1|	     (xmlStrEqual(parent->name, BAD_CAST "frame")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1358:7): [True: 0, False: 0]
  ------------------
 1359|      1|	     (xmlStrEqual(parent->name, BAD_CAST "iframe")))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1359:7): [True: 0, False: 0]
  ------------------
 1360|      1|	    xmlOutputBufferWrite(buf, 5, " id=\"");
 1361|      1|	    xmlAttrSerializeContent(buf, name);
 1362|      1|	    xmlOutputBufferWrite(buf, 1, "\"");
 1363|      1|	}
 1364|      1|    }
 1365|       |    /*
 1366|       |     * C.7.
 1367|       |     */
 1368|      8|    if ((lang != NULL) && (xml_lang == NULL)) {
  ------------------
  |  Branch (1368:9): [True: 2, False: 6]
  |  Branch (1368:27): [True: 1, False: 1]
  ------------------
 1369|      1|	xmlOutputBufferWrite(buf, 11, " xml:lang=\"");
 1370|      1|	xmlAttrSerializeContent(buf, lang);
 1371|      1|	xmlOutputBufferWrite(buf, 1, "\"");
 1372|      1|    } else
 1373|      7|    if ((xml_lang != NULL) && (lang == NULL)) {
  ------------------
  |  Branch (1373:9): [True: 2, False: 5]
  |  Branch (1373:31): [True: 1, False: 1]
  ------------------
 1374|      1|	xmlOutputBufferWrite(buf, 7, " lang=\"");
 1375|      1|	xmlAttrSerializeContent(buf, xml_lang);
 1376|      1|	xmlOutputBufferWrite(buf, 1, "\"");
 1377|      1|    }
 1378|      8|}
xmlsave.c:xmlAttrSerializeContent:
  393|  21.1k|{
  394|  21.1k|    xmlNodePtr children;
  395|       |
  396|  21.1k|    children = attr->children;
  397|  42.3k|    while (children != NULL) {
  ------------------
  |  Branch (397:12): [True: 21.1k, False: 21.1k]
  ------------------
  398|  21.1k|        switch (children->type) {
  399|  21.1k|            case XML_TEXT_NODE:
  ------------------
  |  Branch (399:13): [True: 21.1k, False: 0]
  ------------------
  400|  21.1k|	        xmlBufAttrSerializeTxtContent(buf->buffer, attr->doc,
  401|  21.1k|		                              attr, children->content);
  402|  21.1k|		break;
  403|      0|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (403:13): [True: 0, False: 21.1k]
  ------------------
  404|      0|                xmlBufAdd(buf->buffer, BAD_CAST "&", 1);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  405|      0|                xmlBufAdd(buf->buffer, children->name,
  406|      0|                             xmlStrlen(children->name));
  407|      0|                xmlBufAdd(buf->buffer, BAD_CAST ";", 1);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  408|      0|                break;
  409|      0|            default:
  ------------------
  |  Branch (409:13): [True: 0, False: 21.1k]
  ------------------
  410|       |                /* should not happen unless we have a badly built tree */
  411|      0|                break;
  412|  21.1k|        }
  413|  21.1k|        children = children->next;
  414|  21.1k|    }
  415|  21.1k|}
xmlsave.c:xhtmlIsEmpty:
 1243|      2|xhtmlIsEmpty(xmlNodePtr node) {
 1244|      2|    if (node == NULL)
  ------------------
  |  Branch (1244:9): [True: 0, False: 2]
  ------------------
 1245|      0|	return(-1);
 1246|      2|    if (node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (1246:9): [True: 0, False: 2]
  ------------------
 1247|      0|	return(0);
 1248|      2|    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))
  ------------------
  |  |   29|      0|#define XHTML_NS_NAME BAD_CAST "http://www.w3.org/1999/xhtml"
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (1248:9): [True: 0, False: 2]
  |  Branch (1248:31): [True: 0, False: 0]
  ------------------
 1249|      0|	return(0);
 1250|      2|    if (node->children != NULL)
  ------------------
  |  Branch (1250:9): [True: 0, False: 2]
  ------------------
 1251|      0|	return(0);
 1252|      2|    switch (node->name[0]) {
  ------------------
  |  Branch (1252:13): [True: 0, False: 2]
  ------------------
 1253|      0|	case 'a':
  ------------------
  |  Branch (1253:2): [True: 0, False: 2]
  ------------------
 1254|      0|	    if (xmlStrEqual(node->name, BAD_CAST "area"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1254:10): [True: 0, False: 0]
  ------------------
 1255|      0|		return(1);
 1256|      0|	    return(0);
 1257|      0|	case 'b':
  ------------------
  |  Branch (1257:2): [True: 0, False: 2]
  ------------------
 1258|      0|	    if (xmlStrEqual(node->name, BAD_CAST "br"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1258:10): [True: 0, False: 0]
  ------------------
 1259|      0|		return(1);
 1260|      0|	    if (xmlStrEqual(node->name, BAD_CAST "base"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1260:10): [True: 0, False: 0]
  ------------------
 1261|      0|		return(1);
 1262|      0|	    if (xmlStrEqual(node->name, BAD_CAST "basefont"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1262:10): [True: 0, False: 0]
  ------------------
 1263|      0|		return(1);
 1264|      0|	    return(0);
 1265|      0|	case 'c':
  ------------------
  |  Branch (1265:2): [True: 0, False: 2]
  ------------------
 1266|      0|	    if (xmlStrEqual(node->name, BAD_CAST "col"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1266:10): [True: 0, False: 0]
  ------------------
 1267|      0|		return(1);
 1268|      0|	    return(0);
 1269|      0|	case 'f':
  ------------------
  |  Branch (1269:2): [True: 0, False: 2]
  ------------------
 1270|      0|	    if (xmlStrEqual(node->name, BAD_CAST "frame"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1270:10): [True: 0, False: 0]
  ------------------
 1271|      0|		return(1);
 1272|      0|	    return(0);
 1273|      0|	case 'h':
  ------------------
  |  Branch (1273:2): [True: 0, False: 2]
  ------------------
 1274|      0|	    if (xmlStrEqual(node->name, BAD_CAST "hr"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1274:10): [True: 0, False: 0]
  ------------------
 1275|      0|		return(1);
 1276|      0|	    return(0);
 1277|      1|	case 'i':
  ------------------
  |  Branch (1277:2): [True: 1, False: 1]
  ------------------
 1278|      1|	    if (xmlStrEqual(node->name, BAD_CAST "img"))
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1278:10): [True: 1, False: 0]
  ------------------
 1279|      1|		return(1);
 1280|      0|	    if (xmlStrEqual(node->name, BAD_CAST "input"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1280:10): [True: 0, False: 0]
  ------------------
 1281|      0|		return(1);
 1282|      0|	    if (xmlStrEqual(node->name, BAD_CAST "isindex"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1282:10): [True: 0, False: 0]
  ------------------
 1283|      0|		return(1);
 1284|      0|	    return(0);
 1285|      0|	case 'l':
  ------------------
  |  Branch (1285:2): [True: 0, False: 2]
  ------------------
 1286|      0|	    if (xmlStrEqual(node->name, BAD_CAST "link"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1286:10): [True: 0, False: 0]
  ------------------
 1287|      0|		return(1);
 1288|      0|	    return(0);
 1289|      0|	case 'm':
  ------------------
  |  Branch (1289:2): [True: 0, False: 2]
  ------------------
 1290|      0|	    if (xmlStrEqual(node->name, BAD_CAST "meta"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1290:10): [True: 0, False: 0]
  ------------------
 1291|      0|		return(1);
 1292|      0|	    return(0);
 1293|      1|	case 'p':
  ------------------
  |  Branch (1293:2): [True: 1, False: 1]
  ------------------
 1294|      1|	    if (xmlStrEqual(node->name, BAD_CAST "param"))
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1294:10): [True: 0, False: 1]
  ------------------
 1295|      0|		return(1);
 1296|      1|	    return(0);
 1297|      2|    }
 1298|      0|    return(0);
 1299|      2|}
xmlsave.c:xmlAttrDumpOutput:
  722|  21.1k|xmlAttrDumpOutput(xmlSaveCtxtPtr ctxt, xmlAttrPtr cur) {
  723|  21.1k|    xmlOutputBufferPtr buf;
  724|       |
  725|  21.1k|    if (cur == NULL) return;
  ------------------
  |  Branch (725:9): [True: 0, False: 21.1k]
  ------------------
  726|  21.1k|    buf = ctxt->buf;
  727|  21.1k|    if (buf == NULL) return;
  ------------------
  |  Branch (727:9): [True: 0, False: 21.1k]
  ------------------
  728|  21.1k|    if (ctxt->format == 2)
  ------------------
  |  Branch (728:9): [True: 0, False: 21.1k]
  ------------------
  729|      0|        xmlOutputBufferWriteWSNonSig(ctxt, 2);
  730|  21.1k|    else
  731|  21.1k|        xmlOutputBufferWrite(buf, 1, " ");
  732|  21.1k|    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (732:9): [True: 98, False: 21.0k]
  |  Branch (732:30): [True: 98, False: 0]
  ------------------
  733|     98|        xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
  734|     98|	xmlOutputBufferWrite(buf, 1, ":");
  735|     98|    }
  736|  21.1k|    xmlOutputBufferWriteString(buf, (const char *)cur->name);
  737|  21.1k|    xmlOutputBufferWrite(buf, 2, "=\"");
  738|  21.1k|    xmlAttrSerializeContent(buf, cur);
  739|  21.1k|    xmlOutputBufferWrite(buf, 1, "\"");
  740|  21.1k|}
xmlsave.c:xmlNodeDumpOutputInternal:
  809|  1.88k|xmlNodeDumpOutputInternal(xmlSaveCtxtPtr ctxt, xmlNodePtr cur) {
  810|  1.88k|    int format = ctxt->format;
  811|  1.88k|    xmlNodePtr tmp, root, unformattedNode = NULL, parent;
  812|  1.88k|    xmlAttrPtr attr;
  813|  1.88k|    xmlChar *start, *end;
  814|  1.88k|    xmlOutputBufferPtr buf;
  815|       |
  816|  1.88k|    if (cur == NULL) return;
  ------------------
  |  Branch (816:9): [True: 0, False: 1.88k]
  ------------------
  817|  1.88k|    buf = ctxt->buf;
  818|       |
  819|  1.88k|    root = cur;
  820|  1.88k|    parent = cur->parent;
  821|  33.0k|    while (1) {
  ------------------
  |  Branch (821:12): [Folded - Ignored]
  ------------------
  822|  33.0k|        switch (cur->type) {
  823|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (823:9): [True: 0, False: 33.0k]
  ------------------
  824|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (824:9): [True: 0, False: 33.0k]
  ------------------
  825|      0|	    xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);
  826|      0|	    break;
  827|       |
  828|    161|        case XML_DTD_NODE:
  ------------------
  |  Branch (828:9): [True: 161, False: 32.9k]
  ------------------
  829|    161|            xmlDtdDumpOutput(ctxt, (xmlDtdPtr) cur);
  830|    161|            break;
  831|       |
  832|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (832:9): [True: 0, False: 33.0k]
  ------------------
  833|       |            /* Always validate cur->parent when descending. */
  834|      0|            if ((cur->parent == parent) && (cur->children != NULL)) {
  ------------------
  |  Branch (834:17): [True: 0, False: 0]
  |  Branch (834:44): [True: 0, False: 0]
  ------------------
  835|      0|                parent = cur;
  836|      0|                cur = cur->children;
  837|      0|                continue;
  838|      0|            }
  839|      0|	    break;
  840|       |
  841|    389|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (841:9): [True: 389, False: 32.6k]
  ------------------
  842|    389|            xmlBufDumpElementDecl(buf->buffer, (xmlElementPtr) cur);
  843|    389|            break;
  844|       |
  845|    595|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (845:9): [True: 595, False: 32.4k]
  ------------------
  846|    595|            xmlBufDumpAttributeDecl(buf->buffer, (xmlAttributePtr) cur);
  847|    595|            break;
  848|       |
  849|    202|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (849:9): [True: 202, False: 32.8k]
  ------------------
  850|    202|            xmlBufDumpEntityDecl(buf->buffer, (xmlEntityPtr) cur);
  851|    202|            break;
  852|       |
  853|  14.1k|        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (853:9): [True: 14.1k, False: 18.9k]
  ------------------
  854|  14.1k|	    if ((cur != root) && (ctxt->format == 1) &&
  ------------------
  |  Branch (854:10): [True: 13.8k, False: 260]
  |  Branch (854:27): [True: 0, False: 13.8k]
  ------------------
  855|  14.1k|                (xmlIndentTreeOutput))
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (855:17): [True: 0, False: 0]
  ------------------
  856|      0|		xmlOutputBufferWrite(buf, ctxt->indent_size *
  857|      0|				     (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (857:11): [True: 0, False: 0]
  ------------------
  858|      0|				      ctxt->indent_nr : ctxt->level),
  859|      0|				     ctxt->indent);
  860|       |
  861|       |            /*
  862|       |             * Some users like lxml are known to pass nodes with a corrupted
  863|       |             * tree structure. Fall back to a recursive call to handle this
  864|       |             * case.
  865|       |             */
  866|  14.1k|            if ((cur->parent != parent) && (cur->children != NULL)) {
  ------------------
  |  Branch (866:17): [True: 0, False: 14.1k]
  |  Branch (866:44): [True: 0, False: 0]
  ------------------
  867|      0|                xmlNodeDumpOutputInternal(ctxt, cur);
  868|      0|                break;
  869|      0|            }
  870|       |
  871|  14.1k|            xmlOutputBufferWrite(buf, 1, "<");
  872|  14.1k|            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (872:17): [True: 575, False: 13.5k]
  |  Branch (872:38): [True: 470, False: 105]
  ------------------
  873|    470|                xmlOutputBufferWriteString(buf, (const char *)cur->ns->prefix);
  874|    470|                xmlOutputBufferWrite(buf, 1, ":");
  875|    470|            }
  876|  14.1k|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
  877|  14.1k|            if (cur->nsDef)
  ------------------
  |  Branch (877:17): [True: 78, False: 14.0k]
  ------------------
  878|     78|                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);
  879|  35.2k|            for (attr = cur->properties; attr != NULL; attr = attr->next)
  ------------------
  |  Branch (879:42): [True: 21.1k, False: 14.1k]
  ------------------
  880|  21.1k|                xmlAttrDumpOutput(ctxt, attr);
  881|       |
  882|  14.1k|            if (cur->children == NULL) {
  ------------------
  |  Branch (882:17): [True: 10.0k, False: 4.06k]
  ------------------
  883|  10.0k|                if ((ctxt->options & XML_SAVE_NO_EMPTY) == 0) {
  ------------------
  |  Branch (883:21): [True: 10.0k, False: 0]
  ------------------
  884|  10.0k|                    if (ctxt->format == 2)
  ------------------
  |  Branch (884:25): [True: 0, False: 10.0k]
  ------------------
  885|      0|                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
  886|  10.0k|                    xmlOutputBufferWrite(buf, 2, "/>");
  887|  10.0k|                } else {
  888|      0|                    if (ctxt->format == 2)
  ------------------
  |  Branch (888:25): [True: 0, False: 0]
  ------------------
  889|      0|                        xmlOutputBufferWriteWSNonSig(ctxt, 1);
  890|      0|                    xmlOutputBufferWrite(buf, 3, "></");
  891|      0|                    if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (891:25): [True: 0, False: 0]
  |  Branch (891:46): [True: 0, False: 0]
  ------------------
  892|      0|                        xmlOutputBufferWriteString(buf,
  893|      0|                                (const char *)cur->ns->prefix);
  894|      0|                        xmlOutputBufferWrite(buf, 1, ":");
  895|      0|                    }
  896|      0|                    xmlOutputBufferWriteString(buf, (const char *)cur->name);
  897|      0|                    if (ctxt->format == 2)
  ------------------
  |  Branch (897:25): [True: 0, False: 0]
  ------------------
  898|      0|                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
  899|      0|                    xmlOutputBufferWrite(buf, 1, ">");
  900|      0|                }
  901|  10.0k|            } else {
  902|  4.06k|                if (ctxt->format == 1) {
  ------------------
  |  Branch (902:21): [True: 0, False: 4.06k]
  ------------------
  903|      0|                    tmp = cur->children;
  904|      0|                    while (tmp != NULL) {
  ------------------
  |  Branch (904:28): [True: 0, False: 0]
  ------------------
  905|      0|                        if ((tmp->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (905:29): [True: 0, False: 0]
  ------------------
  906|      0|                            (tmp->type == XML_CDATA_SECTION_NODE) ||
  ------------------
  |  Branch (906:29): [True: 0, False: 0]
  ------------------
  907|      0|                            (tmp->type == XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (907:29): [True: 0, False: 0]
  ------------------
  908|      0|                            ctxt->format = 0;
  909|      0|                            unformattedNode = cur;
  910|      0|                            break;
  911|      0|                        }
  912|      0|                        tmp = tmp->next;
  913|      0|                    }
  914|      0|                }
  915|  4.06k|                if (ctxt->format == 2)
  ------------------
  |  Branch (915:21): [True: 0, False: 4.06k]
  ------------------
  916|      0|                    xmlOutputBufferWriteWSNonSig(ctxt, 1);
  917|  4.06k|                xmlOutputBufferWrite(buf, 1, ">");
  918|  4.06k|                if (ctxt->format == 1) xmlOutputBufferWrite(buf, 1, "\n");
  ------------------
  |  Branch (918:21): [True: 0, False: 4.06k]
  ------------------
  919|  4.06k|                if (ctxt->level >= 0) ctxt->level++;
  ------------------
  |  Branch (919:21): [True: 4.06k, False: 0]
  ------------------
  920|  4.06k|                parent = cur;
  921|  4.06k|                cur = cur->children;
  922|  4.06k|                continue;
  923|  4.06k|            }
  924|       |
  925|  10.0k|            break;
  926|       |
  927|  17.1k|        case XML_TEXT_NODE:
  ------------------
  |  Branch (927:9): [True: 17.1k, False: 15.9k]
  ------------------
  928|  17.1k|	    if (cur->content == NULL)
  ------------------
  |  Branch (928:10): [True: 0, False: 17.1k]
  ------------------
  929|      0|                break;
  930|  17.1k|	    if (cur->name != xmlStringTextNoenc) {
  ------------------
  |  Branch (930:10): [True: 17.1k, False: 0]
  ------------------
  931|  17.1k|                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);
  932|  17.1k|	    } else {
  933|       |		/*
  934|       |		 * Disable escaping, needed for XSLT
  935|       |		 */
  936|      0|		xmlOutputBufferWriteString(buf, (const char *) cur->content);
  937|      0|	    }
  938|  17.1k|	    break;
  939|       |
  940|     17|        case XML_PI_NODE:
  ------------------
  |  Branch (940:9): [True: 17, False: 33.0k]
  ------------------
  941|     17|	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (941:10): [True: 8, False: 9]
  |  Branch (941:27): [True: 0, False: 8]
  |  Branch (941:50): [True: 0, False: 0]
  ------------------
  942|      0|		xmlOutputBufferWrite(buf, ctxt->indent_size *
  943|      0|				     (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (943:11): [True: 0, False: 0]
  ------------------
  944|      0|				      ctxt->indent_nr : ctxt->level),
  945|      0|				     ctxt->indent);
  946|       |
  947|     17|            if (cur->content != NULL) {
  ------------------
  |  Branch (947:17): [True: 17, False: 0]
  ------------------
  948|     17|                xmlOutputBufferWrite(buf, 2, "<?");
  949|     17|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
  950|     17|                if (cur->content != NULL) {
  ------------------
  |  Branch (950:21): [True: 17, False: 0]
  ------------------
  951|     17|                    if (ctxt->format == 2)
  ------------------
  |  Branch (951:25): [True: 0, False: 17]
  ------------------
  952|      0|                        xmlOutputBufferWriteWSNonSig(ctxt, 0);
  953|     17|                    else
  954|     17|                        xmlOutputBufferWrite(buf, 1, " ");
  955|     17|                    xmlOutputBufferWriteString(buf,
  956|     17|                            (const char *)cur->content);
  957|     17|                }
  958|     17|                xmlOutputBufferWrite(buf, 2, "?>");
  959|     17|            } else {
  960|      0|                xmlOutputBufferWrite(buf, 2, "<?");
  961|      0|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
  962|      0|                if (ctxt->format == 2)
  ------------------
  |  Branch (962:21): [True: 0, False: 0]
  ------------------
  963|      0|                    xmlOutputBufferWriteWSNonSig(ctxt, 0);
  964|      0|                xmlOutputBufferWrite(buf, 2, "?>");
  965|      0|            }
  966|     17|            break;
  967|       |
  968|    384|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (968:9): [True: 384, False: 32.6k]
  ------------------
  969|    384|	    if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))
  ------------------
  |  |   55|      0|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (969:10): [True: 116, False: 268]
  |  Branch (969:27): [True: 0, False: 116]
  |  Branch (969:50): [True: 0, False: 0]
  ------------------
  970|      0|		xmlOutputBufferWrite(buf, ctxt->indent_size *
  971|      0|				     (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (971:11): [True: 0, False: 0]
  ------------------
  972|      0|				      ctxt->indent_nr : ctxt->level),
  973|      0|				     ctxt->indent);
  974|       |
  975|    384|            if (cur->content != NULL) {
  ------------------
  |  Branch (975:17): [True: 384, False: 0]
  ------------------
  976|    384|                xmlOutputBufferWrite(buf, 4, "<!--");
  977|    384|                xmlOutputBufferWriteString(buf, (const char *)cur->content);
  978|    384|                xmlOutputBufferWrite(buf, 3, "-->");
  979|    384|            }
  980|    384|            break;
  981|       |
  982|      1|        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (982:9): [True: 1, False: 33.0k]
  ------------------
  983|      1|            xmlOutputBufferWrite(buf, 1, "&");
  984|      1|            xmlOutputBufferWriteString(buf, (const char *)cur->name);
  985|      1|            xmlOutputBufferWrite(buf, 1, ";");
  986|      1|            break;
  987|       |
  988|     33|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (988:9): [True: 33, False: 33.0k]
  ------------------
  989|     33|            if (cur->content == NULL || *cur->content == '\0') {
  ------------------
  |  Branch (989:17): [True: 0, False: 33]
  |  Branch (989:41): [True: 1, False: 32]
  ------------------
  990|      1|                xmlOutputBufferWrite(buf, 12, "<![CDATA[]]>");
  991|     32|            } else {
  992|     32|                start = end = cur->content;
  993|  13.1k|                while (*end != '\0') {
  ------------------
  |  Branch (993:24): [True: 13.1k, False: 32]
  ------------------
  994|  13.1k|                    if ((*end == ']') && (*(end + 1) == ']') &&
  ------------------
  |  Branch (994:25): [True: 3, False: 13.1k]
  |  Branch (994:42): [True: 0, False: 3]
  ------------------
  995|  13.1k|                        (*(end + 2) == '>')) {
  ------------------
  |  Branch (995:25): [True: 0, False: 0]
  ------------------
  996|      0|                        end = end + 2;
  997|      0|                        xmlOutputBufferWrite(buf, 9, "<![CDATA[");
  998|      0|                        xmlOutputBufferWrite(buf, end - start,
  999|      0|                                (const char *)start);
 1000|      0|                        xmlOutputBufferWrite(buf, 3, "]]>");
 1001|      0|                        start = end;
 1002|      0|                    }
 1003|  13.1k|                    end++;
 1004|  13.1k|                }
 1005|     32|                if (start != end) {
  ------------------
  |  Branch (1005:21): [True: 32, False: 0]
  ------------------
 1006|     32|                    xmlOutputBufferWrite(buf, 9, "<![CDATA[");
 1007|     32|                    xmlOutputBufferWriteString(buf, (const char *)start);
 1008|     32|                    xmlOutputBufferWrite(buf, 3, "]]>");
 1009|     32|                }
 1010|     32|            }
 1011|     33|            break;
 1012|       |
 1013|      0|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (1013:9): [True: 0, False: 33.0k]
  ------------------
 1014|      0|            xmlAttrDumpOutput(ctxt, (xmlAttrPtr) cur);
 1015|      0|            break;
 1016|       |
 1017|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (1017:9): [True: 0, False: 33.0k]
  ------------------
 1018|      0|            xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);
 1019|      0|            break;
 1020|       |
 1021|      0|        default:
  ------------------
  |  Branch (1021:9): [True: 0, False: 33.0k]
  ------------------
 1022|      0|            break;
 1023|  33.0k|        }
 1024|       |
 1025|  33.0k|        while (1) {
  ------------------
  |  Branch (1025:16): [Folded - Ignored]
  ------------------
 1026|  33.0k|            if (cur == root)
  ------------------
  |  Branch (1026:17): [True: 1.88k, False: 31.1k]
  ------------------
 1027|  1.88k|                return;
 1028|  31.1k|            if ((ctxt->format == 1) &&
  ------------------
  |  Branch (1028:17): [True: 0, False: 31.1k]
  ------------------
 1029|  31.1k|                (cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (1029:17): [True: 0, False: 0]
  ------------------
 1030|  31.1k|                (cur->type != XML_XINCLUDE_END))
  ------------------
  |  Branch (1030:17): [True: 0, False: 0]
  ------------------
 1031|      0|                xmlOutputBufferWrite(buf, 1, "\n");
 1032|  31.1k|            if (cur->next != NULL) {
  ------------------
  |  Branch (1032:17): [True: 27.1k, False: 4.06k]
  ------------------
 1033|  27.1k|                cur = cur->next;
 1034|  27.1k|                break;
 1035|  27.1k|            }
 1036|       |
 1037|  4.06k|            cur = parent;
 1038|       |            /* cur->parent was validated when descending. */
 1039|  4.06k|            parent = cur->parent;
 1040|       |
 1041|  4.06k|            if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (1041:17): [True: 4.06k, False: 0]
  ------------------
 1042|  4.06k|                if (ctxt->level > 0) ctxt->level--;
  ------------------
  |  Branch (1042:21): [True: 4.06k, False: 0]
  ------------------
 1043|  4.06k|                if ((xmlIndentTreeOutput) && (ctxt->format == 1))
  ------------------
  |  |   55|  4.06k|  #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)
  |  |  ------------------
  |  |  |  |  500|  4.06k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1043:21): [True: 4.06k, False: 0]
  |  Branch (1043:46): [True: 0, False: 4.06k]
  ------------------
 1044|      0|                    xmlOutputBufferWrite(buf, ctxt->indent_size *
 1045|      0|                                         (ctxt->level > ctxt->indent_nr ?
  ------------------
  |  Branch (1045:43): [True: 0, False: 0]
  ------------------
 1046|      0|                                          ctxt->indent_nr : ctxt->level),
 1047|      0|                                         ctxt->indent);
 1048|       |
 1049|  4.06k|                xmlOutputBufferWrite(buf, 2, "</");
 1050|  4.06k|                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {
  ------------------
  |  Branch (1050:21): [True: 449, False: 3.61k]
  |  Branch (1050:42): [True: 357, False: 92]
  ------------------
 1051|    357|                    xmlOutputBufferWriteString(buf,
 1052|    357|                            (const char *)cur->ns->prefix);
 1053|    357|                    xmlOutputBufferWrite(buf, 1, ":");
 1054|    357|                }
 1055|       |
 1056|  4.06k|                xmlOutputBufferWriteString(buf, (const char *)cur->name);
 1057|  4.06k|                if (ctxt->format == 2)
  ------------------
  |  Branch (1057:21): [True: 0, False: 4.06k]
  ------------------
 1058|      0|                    xmlOutputBufferWriteWSNonSig(ctxt, 0);
 1059|  4.06k|                xmlOutputBufferWrite(buf, 1, ">");
 1060|       |
 1061|  4.06k|                if (cur == unformattedNode) {
  ------------------
  |  Branch (1061:21): [True: 0, False: 4.06k]
  ------------------
 1062|      0|                    ctxt->format = format;
 1063|      0|                    unformattedNode = NULL;
 1064|      0|                }
 1065|  4.06k|            }
 1066|  4.06k|        }
 1067|  29.0k|    }
 1068|  1.88k|}
xmlsave.c:xmlSerializeHexCharRef:
  109|     63|xmlSerializeHexCharRef(unsigned char *out, int val) {
  110|     63|    unsigned char *ptr;
  111|       |
  112|     63|    *out++ = '&';
  113|     63|    *out++ = '#';
  114|     63|    *out++ = 'x';
  115|     63|    if (val < 0x10) ptr = out;
  ------------------
  |  Branch (115:9): [True: 0, False: 63]
  ------------------
  116|     63|    else if (val < 0x100) ptr = out + 1;
  ------------------
  |  Branch (116:14): [True: 63, False: 0]
  ------------------
  117|      0|    else if (val < 0x1000) ptr = out + 2;
  ------------------
  |  Branch (117:14): [True: 0, False: 0]
  ------------------
  118|      0|    else if (val < 0x10000) ptr = out + 3;
  ------------------
  |  Branch (118:14): [True: 0, False: 0]
  ------------------
  119|      0|    else if (val < 0x100000) ptr = out + 4;
  ------------------
  |  Branch (119:14): [True: 0, False: 0]
  ------------------
  120|      0|    else ptr = out + 5;
  121|     63|    out = ptr + 1;
  122|    189|    while (val > 0) {
  ------------------
  |  Branch (122:12): [True: 126, False: 63]
  ------------------
  123|    126|	switch (val & 0xF) {
  124|     50|	    case 0: *ptr-- = '0'; break;
  ------------------
  |  Branch (124:6): [True: 50, False: 76]
  ------------------
  125|      1|	    case 1: *ptr-- = '1'; break;
  ------------------
  |  Branch (125:6): [True: 1, False: 125]
  ------------------
  126|      0|	    case 2: *ptr-- = '2'; break;
  ------------------
  |  Branch (126:6): [True: 0, False: 126]
  ------------------
  127|      1|	    case 3: *ptr-- = '3'; break;
  ------------------
  |  Branch (127:6): [True: 1, False: 125]
  ------------------
  128|      3|	    case 4: *ptr-- = '4'; break;
  ------------------
  |  Branch (128:6): [True: 3, False: 123]
  ------------------
  129|      0|	    case 5: *ptr-- = '5'; break;
  ------------------
  |  Branch (129:6): [True: 0, False: 126]
  ------------------
  130|      2|	    case 6: *ptr-- = '6'; break;
  ------------------
  |  Branch (130:6): [True: 2, False: 124]
  ------------------
  131|      1|	    case 7: *ptr-- = '7'; break;
  ------------------
  |  Branch (131:6): [True: 1, False: 125]
  ------------------
  132|      0|	    case 8: *ptr-- = '8'; break;
  ------------------
  |  Branch (132:6): [True: 0, False: 126]
  ------------------
  133|      1|	    case 9: *ptr-- = '9'; break;
  ------------------
  |  Branch (133:6): [True: 1, False: 125]
  ------------------
  134|     51|	    case 0xA: *ptr-- = 'A'; break;
  ------------------
  |  Branch (134:6): [True: 51, False: 75]
  ------------------
  135|      0|	    case 0xB: *ptr-- = 'B'; break;
  ------------------
  |  Branch (135:6): [True: 0, False: 126]
  ------------------
  136|      4|	    case 0xC: *ptr-- = 'C'; break;
  ------------------
  |  Branch (136:6): [True: 4, False: 122]
  ------------------
  137|      0|	    case 0xD: *ptr-- = 'D'; break;
  ------------------
  |  Branch (137:6): [True: 0, False: 126]
  ------------------
  138|      6|	    case 0xE: *ptr-- = 'E'; break;
  ------------------
  |  Branch (138:6): [True: 6, False: 120]
  ------------------
  139|      6|	    case 0xF: *ptr-- = 'F'; break;
  ------------------
  |  Branch (139:6): [True: 6, False: 120]
  ------------------
  140|      0|	    default: *ptr-- = '0'; break;
  ------------------
  |  Branch (140:6): [True: 0, False: 126]
  ------------------
  141|    126|	}
  142|    126|	val >>= 4;
  143|    126|    }
  144|     63|    *out++ = ';';
  145|     63|    *out = 0;
  146|     63|    return(out);
  147|     63|}
xmlsave.c:xmlSaveCtxtInit:
  289|    262|{
  290|    262|    int i;
  291|    262|    int len;
  292|       |
  293|    262|    if (ctxt == NULL) return;
  ------------------
  |  Branch (293:9): [True: 0, False: 262]
  ------------------
  294|    262|    if ((ctxt->encoding == NULL) && (ctxt->escape == NULL))
  ------------------
  |  Branch (294:9): [True: 232, False: 30]
  |  Branch (294:37): [True: 232, False: 0]
  ------------------
  295|    232|        ctxt->escape = xmlEscapeEntities;
  296|    262|    len = xmlStrlen((xmlChar *)xmlTreeIndentString);
  ------------------
  |  |   56|    262|  #define xmlTreeIndentString XML_GLOBAL_MACRO(xmlTreeIndentString)
  |  |  ------------------
  |  |  |  |  500|    262|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  297|    262|    if ((xmlTreeIndentString == NULL) || (len == 0)) {
  ------------------
  |  |   56|    262|  #define xmlTreeIndentString XML_GLOBAL_MACRO(xmlTreeIndentString)
  |  |  ------------------
  |  |  |  |  500|    262|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (297:9): [True: 0, False: 262]
  |  Branch (297:42): [True: 0, False: 262]
  ------------------
  298|      0|        memset(&ctxt->indent[0], 0, MAX_INDENT + 1);
  ------------------
  |  |   18|      0|#define MAX_INDENT 60
  ------------------
  299|    262|    } else {
  300|    262|	ctxt->indent_size = len;
  301|    262|	ctxt->indent_nr = MAX_INDENT / ctxt->indent_size;
  ------------------
  |  |   18|    262|#define MAX_INDENT 60
  ------------------
  302|  8.12k|	for (i = 0;i < ctxt->indent_nr;i++)
  ------------------
  |  Branch (302:13): [True: 7.86k, False: 262]
  ------------------
  303|  7.86k|	    memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,
  ------------------
  |  |   56|  7.86k|  #define xmlTreeIndentString XML_GLOBAL_MACRO(xmlTreeIndentString)
  |  |  ------------------
  |  |  |  |  500|  7.86k|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  304|  7.86k|		   ctxt->indent_size);
  305|    262|        ctxt->indent[ctxt->indent_nr * ctxt->indent_size] = 0;
  306|    262|    }
  307|       |
  308|    262|    if (xmlSaveNoEmptyTags) {
  ------------------
  |  |   57|    262|  #define xmlSaveNoEmptyTags XML_GLOBAL_MACRO(xmlSaveNoEmptyTags)
  |  |  ------------------
  |  |  |  |  500|    262|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (500:34): [True: 0, False: 262]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  309|      0|	ctxt->options |= XML_SAVE_NO_EMPTY;
  310|      0|    }
  311|    262|}

xmlStrndup:
   45|   727k|xmlStrndup(const xmlChar *cur, int len) {
   46|   727k|    xmlChar *ret;
   47|       |
   48|   727k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 727k]
  |  Branch (48:26): [True: 0, False: 727k]
  ------------------
   49|   727k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|   727k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 0, False: 727k]
  ------------------
   51|      0|        return(NULL);
   52|      0|    }
   53|   727k|    memcpy(ret, cur, len);
   54|   727k|    ret[len] = 0;
   55|   727k|    return(ret);
   56|   727k|}
xmlStrdup:
   69|   520k|xmlStrdup(const xmlChar *cur) {
   70|   520k|    const xmlChar *p = cur;
   71|       |
   72|   520k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 4.97k, False: 515k]
  ------------------
   73|  4.78M|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 4.27M, False: 515k]
  ------------------
   74|   515k|    return(xmlStrndup(cur, p - cur));
   75|   520k|}
xmlCharStrndup:
   88|  10.8k|xmlCharStrndup(const char *cur, int len) {
   89|  10.8k|    int i;
   90|  10.8k|    xmlChar *ret;
   91|       |
   92|  10.8k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 10.8k]
  |  Branch (92:26): [True: 0, False: 10.8k]
  ------------------
   93|  10.8k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|  10.8k|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 0, False: 10.8k]
  ------------------
   95|      0|        return(NULL);
   96|      0|    }
   97|  74.5k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 63.6k, False: 10.8k]
  ------------------
   98|       |        /* Explicit sign change */
   99|  63.6k|        ret[i] = (xmlChar) cur[i];
  100|  63.6k|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 63.6k]
  ------------------
  101|  63.6k|    }
  102|  10.8k|    ret[len] = 0;
  103|  10.8k|    return(ret);
  104|  10.8k|}
xmlCharStrdup:
  116|  10.8k|xmlCharStrdup(const char *cur) {
  117|  10.8k|    const char *p = cur;
  118|       |
  119|  10.8k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 0, False: 10.8k]
  ------------------
  120|  74.5k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 63.6k, False: 10.8k]
  ------------------
  121|  10.8k|    return(xmlCharStrndup(cur, p - cur));
  122|  10.8k|}
xmlStrcmp:
  135|     30|xmlStrcmp(const xmlChar *str1, const xmlChar *str2) {
  136|     30|    if (str1 == str2) return(0);
  ------------------
  |  Branch (136:9): [True: 0, False: 30]
  ------------------
  137|     30|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (137:9): [True: 0, False: 30]
  ------------------
  138|     30|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (138:9): [True: 0, False: 30]
  ------------------
  139|     30|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  140|     30|    return(strcmp((const char *)str1, (const char *)str2));
  141|       |#else
  142|       |    do {
  143|       |        int tmp = *str1++ - *str2;
  144|       |        if (tmp != 0) return(tmp);
  145|       |    } while (*str2++ != 0);
  146|       |    return 0;
  147|       |#endif
  148|     30|}
xmlStrEqual:
  162|   256k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|   256k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 9.44k, False: 246k]
  ------------------
  164|   246k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 30, False: 246k]
  ------------------
  165|   246k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 0, False: 246k]
  ------------------
  166|   246k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|   246k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|   246k|}
xmlStrQEqual:
  188|  9.61k|xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {
  189|  9.61k|    if (pref == NULL) return(xmlStrEqual(name, str));
  ------------------
  |  Branch (189:9): [True: 9.44k, False: 165]
  ------------------
  190|    165|    if (name == NULL) return(0);
  ------------------
  |  Branch (190:9): [True: 0, False: 165]
  ------------------
  191|    165|    if (str == NULL) return(0);
  ------------------
  |  Branch (191:9): [True: 0, False: 165]
  ------------------
  192|       |
  193|    495|    do {
  194|    495|        if (*pref++ != *str) return(0);
  ------------------
  |  Branch (194:13): [True: 0, False: 495]
  ------------------
  195|    495|    } while ((*str++) && (*pref));
  ------------------
  |  Branch (195:14): [True: 495, False: 0]
  |  Branch (195:26): [True: 330, False: 165]
  ------------------
  196|    165|    if (*str++ != ':') return(0);
  ------------------
  |  Branch (196:9): [True: 0, False: 165]
  ------------------
  197|    924|    do {
  198|    924|        if (*name++ != *str) return(0);
  ------------------
  |  Branch (198:13): [True: 0, False: 924]
  ------------------
  199|    924|    } while (*str++);
  ------------------
  |  Branch (199:14): [True: 759, False: 165]
  ------------------
  200|    165|    return(1);
  201|    165|}
xmlStrncmp:
  215|      6|xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
  216|      6|    if (len <= 0) return(0);
  ------------------
  |  Branch (216:9): [True: 0, False: 6]
  ------------------
  217|      6|    if (str1 == str2) return(0);
  ------------------
  |  Branch (217:9): [True: 0, False: 6]
  ------------------
  218|      6|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (218:9): [True: 0, False: 6]
  ------------------
  219|      6|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (219:9): [True: 0, False: 6]
  ------------------
  220|      6|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  221|      6|    return(strncmp((const char *)str1, (const char *)str2, len));
  222|       |#else
  223|       |    do {
  224|       |        int tmp = *str1++ - *str2;
  225|       |        if (tmp != 0 || --len == 0) return(tmp);
  226|       |    } while (*str2++ != 0);
  227|       |    return 0;
  228|       |#endif
  229|      6|}
xmlStrcasecmp:
  277|    134|xmlStrcasecmp(const xmlChar *str1, const xmlChar *str2) {
  278|    134|    register int tmp;
  279|       |
  280|    134|    if (str1 == str2) return(0);
  ------------------
  |  Branch (280:9): [True: 60, False: 74]
  ------------------
  281|     74|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (281:9): [True: 0, False: 74]
  ------------------
  282|     74|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (282:9): [True: 0, False: 74]
  ------------------
  283|    145|    do {
  284|    145|        tmp = casemap[*str1++] - casemap[*str2];
  285|    145|        if (tmp != 0) return(tmp);
  ------------------
  |  Branch (285:13): [True: 55, False: 90]
  ------------------
  286|    145|    } while (*str2++ != 0);
  ------------------
  |  Branch (286:14): [True: 71, False: 19]
  ------------------
  287|     19|    return 0;
  288|     74|}
xmlStrncasecmp:
  302|  20.2k|xmlStrncasecmp(const xmlChar *str1, const xmlChar *str2, int len) {
  303|  20.2k|    register int tmp;
  304|       |
  305|  20.2k|    if (len <= 0) return(0);
  ------------------
  |  Branch (305:9): [True: 0, False: 20.2k]
  ------------------
  306|  20.2k|    if (str1 == str2) return(0);
  ------------------
  |  Branch (306:9): [True: 0, False: 20.2k]
  ------------------
  307|  20.2k|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (307:9): [True: 0, False: 20.2k]
  ------------------
  308|  20.2k|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (308:9): [True: 0, False: 20.2k]
  ------------------
  309|  20.2k|    do {
  310|  20.2k|        tmp = casemap[*str1++] - casemap[*str2];
  311|  20.2k|        if (tmp != 0 || --len == 0) return(tmp);
  ------------------
  |  Branch (311:13): [True: 20.2k, False: 0]
  |  Branch (311:25): [True: 0, False: 0]
  ------------------
  312|  20.2k|    } while (*str2++ != 0);
  ------------------
  |  Branch (312:14): [True: 0, False: 0]
  ------------------
  313|      0|    return 0;
  314|  20.2k|}
xmlStrchr:
  327|  2.78k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  2.78k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 2.78k]
  ------------------
  329|   324k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 321k, False: 2.78k]
  ------------------
  330|   321k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 3, False: 321k]
  ------------------
  331|   321k|        str++;
  332|   321k|    }
  333|  2.78k|    return(NULL);
  334|  2.78k|}
xmlStrlen:
  428|  33.5k|xmlStrlen(const xmlChar *str) {
  429|  33.5k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 33.5k, False: 0]
  ------------------
  430|  33.5k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 33.5k]
  ------------------
  431|  33.5k|}
xmlStrncat:
  448|  9.49k|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|  9.49k|    int size;
  450|  9.49k|    xmlChar *ret;
  451|       |
  452|  9.49k|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 9.49k]
  |  Branch (452:26): [True: 0, False: 9.49k]
  ------------------
  453|      0|        return(cur);
  454|  9.49k|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 9.49k]
  ------------------
  455|      0|	return(NULL);
  456|  9.49k|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 9.49k]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|  9.49k|    size = xmlStrlen(cur);
  460|  9.49k|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 9.49k]
  |  Branch (460:23): [True: 0, False: 9.49k]
  ------------------
  461|      0|        return(NULL);
  462|  9.49k|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|  9.49k|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 0, False: 9.49k]
  ------------------
  464|      0|        return(cur);
  465|      0|    }
  466|  9.49k|    memcpy(&ret[size], add, len);
  467|  9.49k|    ret[size + len] = 0;
  468|  9.49k|    return(ret);
  469|  9.49k|}
xmlStrncatNew:
  484|     21|xmlStrncatNew(const xmlChar *str1, const xmlChar *str2, int len) {
  485|     21|    int size;
  486|     21|    xmlChar *ret;
  487|       |
  488|     21|    if (len < 0) {
  ------------------
  |  Branch (488:9): [True: 0, False: 21]
  ------------------
  489|      0|        len = xmlStrlen(str2);
  490|      0|        if (len < 0)
  ------------------
  |  Branch (490:13): [True: 0, False: 0]
  ------------------
  491|      0|            return(NULL);
  492|      0|    }
  493|     21|    if ((str2 == NULL) || (len == 0))
  ------------------
  |  Branch (493:9): [True: 0, False: 21]
  |  Branch (493:27): [True: 0, False: 21]
  ------------------
  494|      0|        return(xmlStrdup(str1));
  495|     21|    if (str1 == NULL)
  ------------------
  |  Branch (495:9): [True: 0, False: 21]
  ------------------
  496|      0|        return(xmlStrndup(str2, len));
  497|       |
  498|     21|    size = xmlStrlen(str1);
  499|     21|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (499:9): [True: 0, False: 21]
  |  Branch (499:23): [True: 0, False: 21]
  ------------------
  500|      0|        return(NULL);
  501|     21|    ret = (xmlChar *) xmlMalloc((size_t) size + len + 1);
  502|     21|    if (ret == NULL) {
  ------------------
  |  Branch (502:9): [True: 0, False: 21]
  ------------------
  503|      0|        return(xmlStrndup(str1, size));
  504|      0|    }
  505|     21|    memcpy(ret, str1, size);
  506|     21|    memcpy(&ret[size], str2, len);
  507|     21|    ret[size + len] = 0;
  508|     21|    return(ret);
  509|     21|}
xmlStrcat:
  524|      6|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|      6|    const xmlChar *p = add;
  526|       |
  527|      6|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 6]
  ------------------
  528|      6|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 6, False: 0]
  ------------------
  529|      6|        return(xmlStrdup(add));
  530|       |
  531|      0|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 0, False: 0]
  ------------------
  532|      0|    return(xmlStrncat(cur, add, p - add));
  533|      6|}
xmlGetUTF8Char:
  708|  12.8M|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  12.8M|    unsigned int c;
  710|       |
  711|  12.8M|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 12.8M]
  ------------------
  712|      0|        goto error;
  713|  12.8M|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 12.8M]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  12.8M|    c = utf[0];
  717|  12.8M|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 12.8M, False: 162]
  ------------------
  718|  12.8M|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 12.8M]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  12.8M|        *len = 1;
  722|  12.8M|    } else {
  723|    162|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 0, False: 162]
  |  Branch (723:27): [True: 39, False: 123]
  ------------------
  724|     39|            goto error;
  725|    123|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 33, False: 90]
  ------------------
  726|     33|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 0, False: 33]
  ------------------
  727|      0|                goto error;
  728|       |            /* 2-byte code */
  729|     33|            *len = 2;
  730|     33|            c = (c & 0x1f) << 6;
  731|     33|            c |= utf[1] & 0x3f;
  732|     90|        } else {
  733|     90|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 90]
  |  Branch (733:31): [True: 0, False: 90]
  ------------------
  734|      0|                goto error;
  735|     90|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 90, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|     90|                *len = 3;
  738|     90|                c = (c & 0xf) << 12;
  739|     90|                c |= (utf[1] & 0x3f) << 6;
  740|     90|                c |= utf[2] & 0x3f;
  741|     90|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 90]
  |  Branch (741:37): [True: 0, False: 90]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|     90|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|     90|        }
  756|    123|    }
  757|  12.8M|    return(c);
  758|       |
  759|     39|error:
  760|     39|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 39, False: 0]
  ------------------
  761|     39|	*len = 0;
  762|     39|    return(-1);
  763|  12.8M|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}

