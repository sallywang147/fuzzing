xmlSAX2InternalSubset:
  326|     23|{
  327|     23|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  328|     23|    xmlDtdPtr dtd;
  329|     23|    if (ctx == NULL) return;
  ------------------
  |  Branch (329:9): [True: 0, False: 23]
  ------------------
  330|       |
  331|     23|    if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (331:9): [True: 0, False: 23]
  ------------------
  332|      0|	return;
  333|     23|    dtd = xmlGetIntSubset(ctxt->myDoc);
  334|     23|    if (dtd != NULL) {
  ------------------
  |  Branch (334:9): [True: 0, False: 23]
  ------------------
  335|      0|	if (ctxt->html)
  ------------------
  |  Branch (335:6): [True: 0, False: 0]
  ------------------
  336|      0|	    return;
  337|      0|	xmlUnlinkNode((xmlNodePtr) dtd);
  338|      0|	xmlFreeDtd(dtd);
  339|      0|	ctxt->myDoc->intSubset = NULL;
  340|      0|    }
  341|     23|    ctxt->myDoc->intSubset =
  342|     23|	xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);
  343|     23|    if (ctxt->myDoc->intSubset == NULL)
  ------------------
  |  Branch (343:9): [True: 0, False: 23]
  ------------------
  344|      0|        xmlSAX2ErrMemory(ctxt, "xmlSAX2InternalSubset");
  345|     23|}
xmlSAX2ExternalSubset:
  359|     22|{
  360|     22|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  361|     22|    if (ctx == NULL) return;
  ------------------
  |  Branch (361:9): [True: 0, False: 22]
  ------------------
  362|     22|    if (((ExternalID != NULL) || (SystemID != NULL)) &&
  ------------------
  |  Branch (362:10): [True: 0, False: 22]
  |  Branch (362:34): [True: 0, False: 22]
  ------------------
  363|     22|        (((ctxt->validate) || (ctxt->loadsubset != 0)) &&
  ------------------
  |  Branch (363:11): [True: 0, False: 0]
  |  Branch (363:31): [True: 0, False: 0]
  ------------------
  364|      0|	 (ctxt->wellFormed && ctxt->myDoc))) {
  ------------------
  |  Branch (364:4): [True: 0, False: 0]
  |  Branch (364:24): [True: 0, False: 0]
  ------------------
  365|       |	/*
  366|       |	 * Try to fetch and parse the external subset.
  367|       |	 */
  368|      0|	xmlParserInputPtr oldinput;
  369|      0|	int oldinputNr;
  370|      0|	int oldinputMax;
  371|      0|	xmlParserInputPtr *oldinputTab;
  372|      0|	xmlParserInputPtr input = NULL;
  373|      0|	const xmlChar *oldencoding;
  374|      0|	int oldprogressive;
  375|      0|        unsigned long consumed;
  376|      0|        size_t buffered;
  377|       |
  378|       |	/*
  379|       |	 * Ask the Entity resolver to load the damn thing
  380|       |	 */
  381|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))
  ------------------
  |  Branch (381:6): [True: 0, False: 0]
  |  Branch (381:29): [True: 0, False: 0]
  ------------------
  382|      0|	    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,
  383|      0|	                                        SystemID);
  384|      0|	if (input == NULL) {
  ------------------
  |  Branch (384:6): [True: 0, False: 0]
  ------------------
  385|      0|	    return;
  386|      0|	}
  387|       |
  388|      0|	xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);
  389|       |
  390|       |	/*
  391|       |	 * make sure we won't destroy the main document context
  392|       |	 */
  393|      0|	oldinput = ctxt->input;
  394|      0|	oldinputNr = ctxt->inputNr;
  395|      0|	oldinputMax = ctxt->inputMax;
  396|      0|	oldinputTab = ctxt->inputTab;
  397|      0|	oldencoding = ctxt->encoding;
  398|      0|        oldprogressive = ctxt->progressive;
  399|      0|	ctxt->encoding = NULL;
  400|      0|        ctxt->progressive = 0;
  401|       |
  402|      0|	ctxt->inputTab = (xmlParserInputPtr *)
  403|      0|	                 xmlMalloc(5 * sizeof(xmlParserInputPtr));
  404|      0|	if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (404:6): [True: 0, False: 0]
  ------------------
  405|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2ExternalSubset");
  406|      0|            xmlFreeInputStream(input);
  407|      0|	    ctxt->input = oldinput;
  408|      0|	    ctxt->inputNr = oldinputNr;
  409|      0|	    ctxt->inputMax = oldinputMax;
  410|      0|	    ctxt->inputTab = oldinputTab;
  411|      0|	    ctxt->encoding = oldencoding;
  412|      0|            ctxt->progressive = oldprogressive;
  413|      0|	    return;
  414|      0|	}
  415|      0|	ctxt->inputNr = 0;
  416|      0|	ctxt->inputMax = 5;
  417|      0|	ctxt->input = NULL;
  418|      0|	xmlPushInput(ctxt, input);
  419|       |
  420|      0|	if (input->filename == NULL)
  ------------------
  |  Branch (420:6): [True: 0, False: 0]
  ------------------
  421|      0|	    input->filename = (char *) xmlCanonicPath(SystemID);
  422|      0|	input->line = 1;
  423|      0|	input->col = 1;
  424|      0|	input->base = ctxt->input->cur;
  425|      0|	input->cur = ctxt->input->cur;
  426|      0|	input->free = NULL;
  427|       |
  428|       |	/*
  429|       |	 * let's parse that entity knowing it's an external subset.
  430|       |	 */
  431|      0|	xmlParseExternalSubset(ctxt, ExternalID, SystemID);
  432|       |
  433|       |        /*
  434|       |	 * Free up the external entities
  435|       |	 */
  436|       |
  437|      0|	while (ctxt->inputNr > 1)
  ------------------
  |  Branch (437:9): [True: 0, False: 0]
  ------------------
  438|      0|	    xmlPopInput(ctxt);
  439|       |
  440|      0|        consumed = ctxt->input->consumed;
  441|      0|        buffered = ctxt->input->cur - ctxt->input->base;
  442|      0|        if (buffered > ULONG_MAX - consumed)
  ------------------
  |  Branch (442:13): [True: 0, False: 0]
  ------------------
  443|      0|            consumed = ULONG_MAX;
  444|      0|        else
  445|      0|            consumed += buffered;
  446|      0|        if (consumed > ULONG_MAX - ctxt->sizeentities)
  ------------------
  |  Branch (446:13): [True: 0, False: 0]
  ------------------
  447|      0|            ctxt->sizeentities = ULONG_MAX;
  448|      0|        else
  449|      0|            ctxt->sizeentities += consumed;
  450|       |
  451|      0|	xmlFreeInputStream(ctxt->input);
  452|      0|        xmlFree(ctxt->inputTab);
  453|       |
  454|       |	/*
  455|       |	 * Restore the parsing context of the main entity
  456|       |	 */
  457|      0|	ctxt->input = oldinput;
  458|      0|	ctxt->inputNr = oldinputNr;
  459|      0|	ctxt->inputMax = oldinputMax;
  460|      0|	ctxt->inputTab = oldinputTab;
  461|      0|	if ((ctxt->encoding != NULL) &&
  ------------------
  |  Branch (461:6): [True: 0, False: 0]
  ------------------
  462|      0|	    ((ctxt->dict == NULL) ||
  ------------------
  |  Branch (462:7): [True: 0, False: 0]
  ------------------
  463|      0|	     (!xmlDictOwns(ctxt->dict, ctxt->encoding))))
  ------------------
  |  Branch (463:7): [True: 0, False: 0]
  ------------------
  464|      0|	    xmlFree((xmlChar *) ctxt->encoding);
  465|      0|	ctxt->encoding = oldencoding;
  466|      0|        ctxt->progressive = oldprogressive;
  467|       |	/* ctxt->wellFormed = oldwellFormed; */
  468|      0|    }
  469|     22|}
xmlSAX2GetEntity:
  519|      1|{
  520|      1|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  521|      1|    xmlEntityPtr ret = NULL;
  522|       |
  523|      1|    if (ctx == NULL) return(NULL);
  ------------------
  |  Branch (523:9): [True: 0, False: 1]
  ------------------
  524|       |
  525|      1|    if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (525:9): [True: 1, False: 0]
  ------------------
  526|      1|	ret = xmlGetPredefinedEntity(name);
  527|      1|	if (ret != NULL)
  ------------------
  |  Branch (527:6): [True: 0, False: 1]
  ------------------
  528|      0|	    return(ret);
  529|      1|    }
  530|      1|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->standalone == 1)) {
  ------------------
  |  Branch (530:9): [True: 1, False: 0]
  |  Branch (530:34): [True: 0, False: 1]
  ------------------
  531|      0|	if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (531:6): [True: 0, False: 0]
  ------------------
  532|      0|	    ctxt->myDoc->standalone = 0;
  533|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  534|      0|	    ctxt->myDoc->standalone = 1;
  535|      0|	} else {
  536|      0|	    ret = xmlGetDocEntity(ctxt->myDoc, name);
  537|      0|	    if (ret == NULL) {
  ------------------
  |  Branch (537:10): [True: 0, False: 0]
  ------------------
  538|      0|		ctxt->myDoc->standalone = 0;
  539|      0|		ret = xmlGetDocEntity(ctxt->myDoc, name);
  540|      0|		if (ret != NULL) {
  ------------------
  |  Branch (540:7): [True: 0, False: 0]
  ------------------
  541|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,
  542|      0|	 "Entity(%s) document marked standalone but requires external subset\n",
  543|      0|				   name, NULL);
  544|      0|		}
  545|      0|		ctxt->myDoc->standalone = 1;
  546|      0|	    }
  547|      0|	}
  548|      1|    } else {
  549|      1|	ret = xmlGetDocEntity(ctxt->myDoc, name);
  550|      1|    }
  551|      1|    return(ret);
  552|      1|}
xmlSAX2AttributeDecl:
  656|     88|{
  657|     88|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  658|     88|    xmlAttributePtr attr;
  659|     88|    xmlChar *name = NULL, *prefix = NULL;
  660|       |
  661|       |    /* Avoid unused variable warning if features are disabled. */
  662|     88|    (void) attr;
  663|       |
  664|     88|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (664:9): [True: 0, False: 88]
  |  Branch (664:27): [True: 0, False: 88]
  ------------------
  665|      0|        return;
  666|       |
  667|     88|    if ((xmlStrEqual(fullname, BAD_CAST "xml:id")) &&
  ------------------
  |  |   35|     88|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (667:9): [True: 0, False: 88]
  ------------------
  668|     88|        (type != XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (668:9): [True: 0, False: 0]
  ------------------
  669|       |	/*
  670|       |	 * Raise the error but keep the validity flag
  671|       |	 */
  672|      0|	int tmp = ctxt->valid;
  673|      0|	xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,
  674|      0|	      "xml:id : attribute type should be ID\n", NULL, NULL);
  675|      0|	ctxt->valid = tmp;
  676|      0|    }
  677|       |    /* TODO: optimize name/prefix allocation */
  678|     88|    name = xmlSplitQName(ctxt, fullname, &prefix);
  679|     88|    ctxt->vctxt.valid = 1;
  680|     88|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (680:9): [True: 88, False: 0]
  ------------------
  681|     88|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,
  682|     88|	       name, prefix, (xmlAttributeType) type,
  683|     88|	       (xmlAttributeDefault) def, defaultValue, tree);
  684|      0|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (684:14): [True: 0, False: 0]
  ------------------
  685|      0|	attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,
  686|      0|	   name, prefix, (xmlAttributeType) type,
  687|      0|	   (xmlAttributeDefault) def, defaultValue, tree);
  688|      0|    else {
  689|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  690|      0|	     "SAX.xmlSAX2AttributeDecl(%s) called while not in subset\n",
  691|      0|	               name, NULL);
  692|      0|	xmlFree(name);
  693|      0|	xmlFreeEnumeration(tree);
  694|      0|	return;
  695|      0|    }
  696|     88|#ifdef LIBXML_VALID_ENABLED
  697|     88|    if (ctxt->vctxt.valid == 0)
  ------------------
  |  Branch (697:9): [True: 0, False: 88]
  ------------------
  698|      0|	ctxt->valid = 0;
  699|     88|    if ((attr != NULL) && (ctxt->validate) && (ctxt->wellFormed) &&
  ------------------
  |  Branch (699:9): [True: 88, False: 0]
  |  Branch (699:27): [True: 0, False: 88]
  |  Branch (699:47): [True: 0, False: 0]
  ------------------
  700|     88|        (ctxt->myDoc->intSubset != NULL))
  ------------------
  |  Branch (700:9): [True: 0, False: 0]
  ------------------
  701|      0|	ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,
  702|      0|	                                        attr);
  703|     88|#endif /* LIBXML_VALID_ENABLED */
  704|     88|    if (prefix != NULL)
  ------------------
  |  Branch (704:9): [True: 0, False: 88]
  ------------------
  705|      0|	xmlFree(prefix);
  706|     88|    if (name != NULL)
  ------------------
  |  Branch (706:9): [True: 88, False: 0]
  ------------------
  707|     88|	xmlFree(name);
  708|     88|}
xmlSAX2ElementDecl:
  722|    132|{
  723|    132|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  724|    132|    xmlElementPtr elem = NULL;
  725|       |
  726|       |    /* Avoid unused variable warning if features are disabled. */
  727|    132|    (void) elem;
  728|       |
  729|    132|    if ((ctxt == NULL) || (ctxt->myDoc == NULL))
  ------------------
  |  Branch (729:9): [True: 0, False: 132]
  |  Branch (729:27): [True: 0, False: 132]
  ------------------
  730|      0|        return;
  731|       |
  732|    132|    if (ctxt->inSubset == 1)
  ------------------
  |  Branch (732:9): [True: 132, False: 0]
  ------------------
  733|    132|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->intSubset,
  734|    132|                                 name, (xmlElementTypeVal) type, content);
  735|      0|    else if (ctxt->inSubset == 2)
  ------------------
  |  Branch (735:14): [True: 0, False: 0]
  ------------------
  736|      0|        elem = xmlAddElementDecl(&ctxt->vctxt, ctxt->myDoc->extSubset,
  737|      0|                                 name, (xmlElementTypeVal) type, content);
  738|      0|    else {
  739|      0|        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
  740|      0|	     "SAX.xmlSAX2ElementDecl(%s) called while not in subset\n",
  741|      0|	               name, NULL);
  742|      0|        return;
  743|      0|    }
  744|    132|#ifdef LIBXML_VALID_ENABLED
  745|    132|    if (elem == NULL)
  ------------------
  |  Branch (745:9): [True: 0, False: 132]
  ------------------
  746|      0|        ctxt->valid = 0;
  747|    132|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (747:9): [True: 0, False: 132]
  |  Branch (747:27): [True: 0, False: 0]
  ------------------
  748|    132|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (748:9): [True: 0, False: 0]
  |  Branch (748:24): [True: 0, False: 0]
  ------------------
  749|      0|        ctxt->valid &=
  750|      0|            xmlValidateElementDecl(&ctxt->vctxt, ctxt->myDoc, elem);
  751|    132|#endif /* LIBXML_VALID_ENABLED */
  752|    132|}
xmlSAX2SetDocumentLocator:
  877|    486|{
  878|    486|}
xmlSAX2StartDocument:
  888|    486|{
  889|    486|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  890|    486|    xmlDocPtr doc;
  891|       |
  892|    486|    if (ctx == NULL) return;
  ------------------
  |  Branch (892:9): [True: 0, False: 486]
  ------------------
  893|       |
  894|    486|    if (ctxt->html) {
  ------------------
  |  Branch (894:9): [True: 0, False: 486]
  ------------------
  895|      0|#ifdef LIBXML_HTML_ENABLED
  896|      0|	if (ctxt->myDoc == NULL)
  ------------------
  |  Branch (896:6): [True: 0, False: 0]
  ------------------
  897|      0|	    ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);
  898|      0|	if (ctxt->myDoc == NULL) {
  ------------------
  |  Branch (898:6): [True: 0, False: 0]
  ------------------
  899|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  900|      0|	    return;
  901|      0|	}
  902|      0|	ctxt->myDoc->properties = XML_DOC_HTML;
  903|      0|	ctxt->myDoc->parseFlags = ctxt->options;
  904|       |#else
  905|       |        xmlGenericError(xmlGenericErrorContext,
  906|       |		"libxml2 built without HTML support\n");
  907|       |	ctxt->errNo = XML_ERR_INTERNAL_ERROR;
  908|       |	ctxt->instate = XML_PARSER_EOF;
  909|       |	ctxt->disableSAX = 1;
  910|       |	return;
  911|       |#endif
  912|    486|    } else {
  913|    486|	doc = ctxt->myDoc = xmlNewDoc(ctxt->version);
  914|    486|	if (doc != NULL) {
  ------------------
  |  Branch (914:6): [True: 486, False: 0]
  ------------------
  915|    486|	    doc->properties = 0;
  916|    486|	    if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (916:10): [True: 0, False: 486]
  ------------------
  917|      0|	        doc->properties |= XML_DOC_OLD10;
  918|    486|	    doc->parseFlags = ctxt->options;
  919|    486|	    doc->standalone = ctxt->standalone;
  920|    486|	} else {
  921|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  922|      0|	    return;
  923|      0|	}
  924|    486|	if ((ctxt->dictNames) && (doc != NULL)) {
  ------------------
  |  Branch (924:6): [True: 486, False: 0]
  |  Branch (924:27): [True: 486, False: 0]
  ------------------
  925|    486|	    doc->dict = ctxt->dict;
  926|    486|	    xmlDictReference(doc->dict);
  927|    486|	}
  928|    486|    }
  929|    486|    if ((ctxt->myDoc != NULL) && (ctxt->myDoc->URL == NULL) &&
  ------------------
  |  Branch (929:9): [True: 486, False: 0]
  |  Branch (929:34): [True: 486, False: 0]
  ------------------
  930|    486|	(ctxt->input != NULL) && (ctxt->input->filename != NULL)) {
  ------------------
  |  Branch (930:2): [True: 486, False: 0]
  |  Branch (930:27): [True: 0, False: 486]
  ------------------
  931|      0|	ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);
  932|      0|	if (ctxt->myDoc->URL == NULL)
  ------------------
  |  Branch (932:6): [True: 0, False: 0]
  ------------------
  933|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartDocument");
  934|      0|    }
  935|    486|}
xmlSAX2EndDocument:
  945|    485|{
  946|    485|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
  947|    485|    xmlDocPtr doc;
  948|       |
  949|    485|    if (ctx == NULL) return;
  ------------------
  |  Branch (949:9): [True: 0, False: 485]
  ------------------
  950|    485|#ifdef LIBXML_VALID_ENABLED
  951|    485|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (951:9): [True: 0, False: 485]
  |  Branch (951:27): [True: 0, False: 0]
  ------------------
  952|    485|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (952:9): [True: 0, False: 0]
  |  Branch (952:24): [True: 0, False: 0]
  ------------------
  953|      0|	ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);
  954|    485|#endif /* LIBXML_VALID_ENABLED */
  955|       |
  956|    485|    doc = ctxt->myDoc;
  957|    485|    if ((doc != NULL) && (doc->encoding == NULL)) {
  ------------------
  |  Branch (957:9): [True: 485, False: 0]
  |  Branch (957:26): [True: 485, False: 0]
  ------------------
  958|    485|        const xmlChar *encoding = NULL;
  959|       |
  960|    485|        if ((ctxt->input->flags & XML_INPUT_USES_ENC_DECL) ||
  ------------------
  |  |   26|    485|#define XML_INPUT_USES_ENC_DECL     (1u << 4)
  ------------------
  |  Branch (960:13): [True: 0, False: 485]
  ------------------
  961|    485|            (ctxt->input->flags & XML_INPUT_AUTO_ENCODING)) {
  ------------------
  |  |   21|    485|#define XML_INPUT_AUTO_ENCODING     (7u << 1)
  ------------------
  |  Branch (961:13): [True: 0, False: 485]
  ------------------
  962|       |            /* Preserve encoding exactly */
  963|      0|            encoding = ctxt->encoding;
  964|    485|        } else if ((ctxt->input->buf) && (ctxt->input->buf->encoder)) {
  ------------------
  |  Branch (964:20): [True: 485, False: 0]
  |  Branch (964:42): [True: 0, False: 485]
  ------------------
  965|      0|            encoding = BAD_CAST ctxt->input->buf->encoder->name;
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  966|    485|        } else if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    485|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (966:20): [True: 0, False: 485]
  ------------------
  967|      0|            encoding = BAD_CAST "UTF-8";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  968|      0|        }
  969|       |
  970|    485|        if (encoding != NULL) {
  ------------------
  |  Branch (970:13): [True: 0, False: 485]
  ------------------
  971|      0|            doc->encoding = xmlStrdup(encoding);
  972|      0|            if (doc->encoding == NULL)
  ------------------
  |  Branch (972:17): [True: 0, False: 0]
  ------------------
  973|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2EndDocument");
  974|      0|        }
  975|    485|    }
  976|    485|}
xmlSAX2StartElementNs:
 2087|  2.95k|{
 2088|  2.95k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2089|  2.95k|    xmlNodePtr ret;
 2090|  2.95k|    xmlNodePtr parent;
 2091|  2.95k|    xmlNsPtr last = NULL, ns;
 2092|  2.95k|    const xmlChar *uri, *pref;
 2093|  2.95k|    xmlChar *lname = NULL;
 2094|  2.95k|    int i, j;
 2095|       |
 2096|  2.95k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2096:9): [True: 0, False: 2.95k]
  ------------------
 2097|       |    /*
 2098|       |     * First check on validity:
 2099|       |     */
 2100|  2.95k|    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&
  ------------------
  |  Branch (2100:9): [True: 0, False: 2.95k]
  |  Branch (2100:27): [True: 0, False: 0]
  ------------------
 2101|  2.95k|        ((ctxt->myDoc->intSubset == NULL) ||
  ------------------
  |  Branch (2101:10): [True: 0, False: 0]
  ------------------
 2102|      0|	 ((ctxt->myDoc->intSubset->notations == NULL) &&
  ------------------
  |  Branch (2102:4): [True: 0, False: 0]
  ------------------
 2103|      0|	  (ctxt->myDoc->intSubset->elements == NULL) &&
  ------------------
  |  Branch (2103:4): [True: 0, False: 0]
  ------------------
 2104|      0|	  (ctxt->myDoc->intSubset->attributes == NULL) &&
  ------------------
  |  Branch (2104:4): [True: 0, False: 0]
  ------------------
 2105|      0|	  (ctxt->myDoc->intSubset->entities == NULL)))) {
  ------------------
  |  Branch (2105:4): [True: 0, False: 0]
  ------------------
 2106|      0|	xmlErrValid(ctxt, XML_DTD_NO_DTD,
 2107|      0|	  "Validation failed: no DTD found !", NULL, NULL);
 2108|      0|	ctxt->validate = 0;
 2109|      0|    }
 2110|       |
 2111|       |    /*
 2112|       |     * Take care of the rare case of an undefined namespace prefix
 2113|       |     */
 2114|  2.95k|    if ((prefix != NULL) && (URI == NULL)) {
  ------------------
  |  Branch (2114:9): [True: 1, False: 2.95k]
  |  Branch (2114:29): [True: 1, False: 0]
  ------------------
 2115|      1|        if (ctxt->dictNames) {
  ------------------
  |  Branch (2115:13): [True: 1, False: 0]
  ------------------
 2116|      1|	    const xmlChar *fullname;
 2117|       |
 2118|      1|	    fullname = xmlDictQLookup(ctxt->dict, prefix, localname);
 2119|      1|	    if (fullname != NULL)
  ------------------
  |  Branch (2119:10): [True: 1, False: 0]
  ------------------
 2120|      1|	        localname = fullname;
 2121|      1|	} else {
 2122|      0|	    lname = xmlBuildQName(localname, prefix, NULL, 0);
 2123|      0|	}
 2124|      1|    }
 2125|       |    /*
 2126|       |     * allocate the node
 2127|       |     */
 2128|  2.95k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2128:9): [True: 0, False: 2.95k]
  ------------------
 2129|      0|        ret = ctxt->freeElems;
 2130|      0|	ctxt->freeElems = ret->next;
 2131|      0|	ctxt->freeElemsNr--;
 2132|      0|	memset(ret, 0, sizeof(xmlNode));
 2133|      0|        ret->doc = ctxt->myDoc;
 2134|      0|	ret->type = XML_ELEMENT_NODE;
 2135|       |
 2136|      0|	if (ctxt->dictNames)
  ------------------
  |  Branch (2136:6): [True: 0, False: 0]
  ------------------
 2137|      0|	    ret->name = localname;
 2138|      0|	else {
 2139|      0|	    if (lname == NULL)
  ------------------
  |  Branch (2139:10): [True: 0, False: 0]
  ------------------
 2140|      0|		ret->name = xmlStrdup(localname);
 2141|      0|	    else
 2142|      0|	        ret->name = lname;
 2143|      0|	    if (ret->name == NULL) {
  ------------------
  |  Branch (2143:10): [True: 0, False: 0]
  ------------------
 2144|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2145|      0|                xmlFree(ret);
 2146|      0|		return;
 2147|      0|	    }
 2148|      0|	}
 2149|      0|	if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2149:6): [True: 0, False: 0]
  |  Branch (2149:34): [True: 0, False: 0]
  ------------------
 2150|      0|	    xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2151|  2.95k|    } else {
 2152|  2.95k|	if (ctxt->dictNames)
  ------------------
  |  Branch (2152:6): [True: 2.95k, False: 0]
  ------------------
 2153|  2.95k|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2154|  2.95k|	                               (xmlChar *) localname, NULL);
 2155|      0|	else if (lname == NULL)
  ------------------
  |  Branch (2155:11): [True: 0, False: 0]
  ------------------
 2156|      0|	    ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);
 2157|      0|	else
 2158|      0|	    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,
 2159|      0|	                               (xmlChar *) lname, NULL);
 2160|  2.95k|	if (ret == NULL) {
  ------------------
  |  Branch (2160:6): [True: 0, False: 2.95k]
  ------------------
 2161|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2162|      0|	    return;
 2163|      0|	}
 2164|  2.95k|    }
 2165|  2.95k|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2165:9): [True: 2.95k, False: 0]
  ------------------
 2166|  2.95k|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2166:6): [True: 2.95k, False: 0]
  ------------------
 2167|  2.95k|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2167:10): [True: 2.95k, False: 0]
  ------------------
 2168|  2.95k|		ret->line = ctxt->input->line;
 2169|      0|	    else
 2170|      0|	        ret->line = USHRT_MAX;
 2171|  2.95k|	}
 2172|  2.95k|    }
 2173|       |
 2174|       |    /*
 2175|       |     * Build the namespace list
 2176|       |     */
 2177|  2.97k|    for (i = 0,j = 0;j < nb_namespaces;j++) {
  ------------------
  |  Branch (2177:22): [True: 18, False: 2.95k]
  ------------------
 2178|     18|        pref = namespaces[i++];
 2179|     18|	uri = namespaces[i++];
 2180|     18|	ns = xmlNewNs(NULL, uri, pref);
 2181|     18|	if (ns != NULL) {
  ------------------
  |  Branch (2181:6): [True: 18, False: 0]
  ------------------
 2182|     18|	    if (last == NULL) {
  ------------------
  |  Branch (2182:10): [True: 18, False: 0]
  ------------------
 2183|     18|	        ret->nsDef = last = ns;
 2184|     18|	    } else {
 2185|      0|	        last->next = ns;
 2186|      0|		last = ns;
 2187|      0|	    }
 2188|     18|	    if ((URI != NULL) && (prefix == pref))
  ------------------
  |  Branch (2188:10): [True: 6, False: 12]
  |  Branch (2188:27): [True: 6, False: 0]
  ------------------
 2189|      6|		ret->ns = ns;
 2190|     18|	} else {
 2191|       |            /*
 2192|       |             * any out of memory error would already have been raised
 2193|       |             * but we can't be guaranteed it's the actual error due to the
 2194|       |             * API, best is to skip in this case
 2195|       |             */
 2196|      0|	    continue;
 2197|      0|	}
 2198|       |
 2199|     18|        xmlParserNsUpdateSax(ctxt, pref, ns);
 2200|       |
 2201|     18|#ifdef LIBXML_VALID_ENABLED
 2202|     18|	if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2202:6): [True: 18, False: 0]
  |  Branch (2202:23): [True: 0, False: 18]
  |  Branch (2202:41): [True: 0, False: 0]
  ------------------
 2203|     18|	    ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (2203:6): [True: 0, False: 0]
  |  Branch (2203:21): [True: 0, False: 0]
  ------------------
 2204|      0|	    ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,
 2205|      0|	                                           ret, prefix, ns, uri);
 2206|      0|	}
 2207|     18|#endif /* LIBXML_VALID_ENABLED */
 2208|     18|    }
 2209|  2.95k|    ctxt->nodemem = -1;
 2210|       |
 2211|       |    /* Initialize parent before pushing node */
 2212|  2.95k|    parent = ctxt->node;
 2213|  2.95k|    if (parent == NULL)
  ------------------
  |  Branch (2213:9): [True: 480, False: 2.47k]
  ------------------
 2214|    480|        parent = (xmlNodePtr) ctxt->myDoc;
 2215|       |
 2216|       |    /*
 2217|       |     * We are parsing a new node.
 2218|       |     */
 2219|  2.95k|    if (nodePush(ctxt, ret) < 0) {
  ------------------
  |  Branch (2219:9): [True: 0, False: 2.95k]
  ------------------
 2220|      0|        xmlUnlinkNode(ret);
 2221|      0|        xmlFreeNode(ret);
 2222|      0|        return;
 2223|      0|    }
 2224|       |
 2225|       |    /*
 2226|       |     * Link the child element
 2227|       |     */
 2228|  2.95k|    xmlAddChild(parent, ret);
 2229|       |
 2230|       |    /*
 2231|       |     * Insert the defaulted attributes from the DTD only if requested:
 2232|       |     */
 2233|  2.95k|    if ((nb_defaulted != 0) &&
  ------------------
  |  Branch (2233:9): [True: 0, False: 2.95k]
  ------------------
 2234|  2.95k|        ((ctxt->loadsubset & XML_COMPLETE_ATTRS) == 0))
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
  |  Branch (2234:9): [True: 0, False: 0]
  ------------------
 2235|      0|	nb_attributes -= nb_defaulted;
 2236|       |
 2237|       |    /*
 2238|       |     * Search the namespace if it wasn't already found
 2239|       |     * Note that, if prefix is NULL, this searches for the default Ns
 2240|       |     */
 2241|  2.95k|    if ((URI != NULL) && (ret->ns == NULL)) {
  ------------------
  |  Branch (2241:9): [True: 6, False: 2.95k]
  |  Branch (2241:26): [True: 0, False: 6]
  ------------------
 2242|      0|        ret->ns = xmlParserNsLookupSax(ctxt, prefix);
 2243|      0|	if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2243:6): [True: 0, False: 0]
  |  Branch (2243:27): [True: 0, False: 0]
  ------------------
 2244|      0|	    ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);
 2245|      0|	}
 2246|      0|	if (ret->ns == NULL) {
  ------------------
  |  Branch (2246:6): [True: 0, False: 0]
  ------------------
 2247|      0|	    ns = xmlNewNs(ret, NULL, prefix);
 2248|      0|	    if (ns == NULL) {
  ------------------
  |  Branch (2248:10): [True: 0, False: 0]
  ------------------
 2249|       |
 2250|      0|	        xmlSAX2ErrMemory(ctxt, "xmlSAX2StartElementNs");
 2251|      0|		return;
 2252|      0|	    }
 2253|      0|            if (prefix != NULL)
  ------------------
  |  Branch (2253:17): [True: 0, False: 0]
  ------------------
 2254|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2255|      0|                             "Namespace prefix %s was not found\n",
 2256|      0|                             prefix, NULL);
 2257|      0|            else
 2258|      0|                xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 2259|      0|                             "Namespace default prefix was not found\n",
 2260|      0|                             NULL, NULL);
 2261|      0|	}
 2262|      0|    }
 2263|       |
 2264|       |    /*
 2265|       |     * process all the other attributes
 2266|       |     */
 2267|  2.95k|    if (nb_attributes > 0) {
  ------------------
  |  Branch (2267:9): [True: 781, False: 2.17k]
  ------------------
 2268|    781|        xmlAttrPtr prev = NULL;
 2269|       |
 2270|  1.67k|        for (j = 0,i = 0;i < nb_attributes;i++,j+=5) {
  ------------------
  |  Branch (2270:26): [True: 896, False: 781]
  ------------------
 2271|    896|            xmlAttrPtr attr = NULL;
 2272|       |
 2273|       |	    /*
 2274|       |	     * Handle the rare case of an undefined attribute prefix
 2275|       |	     */
 2276|    896|	    if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {
  ------------------
  |  Branch (2276:10): [True: 36, False: 860]
  |  Branch (2276:39): [True: 0, False: 36]
  ------------------
 2277|      0|		if (ctxt->dictNames) {
  ------------------
  |  Branch (2277:7): [True: 0, False: 0]
  ------------------
 2278|      0|		    const xmlChar *fullname;
 2279|       |
 2280|      0|		    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],
 2281|      0|		                              attributes[j]);
 2282|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (2282:11): [True: 0, False: 0]
  ------------------
 2283|      0|                        attr = xmlSAX2AttributeNs(ctxt, fullname, NULL,
 2284|      0|                                                  attributes[j+3],
 2285|      0|                                                  attributes[j+4]);
 2286|      0|                        goto have_attr;
 2287|      0|		    }
 2288|      0|		} else {
 2289|      0|		    lname = xmlBuildQName(attributes[j], attributes[j+1],
 2290|      0|		                          NULL, 0);
 2291|      0|		    if (lname != NULL) {
  ------------------
  |  Branch (2291:11): [True: 0, False: 0]
  ------------------
 2292|      0|                        attr = xmlSAX2AttributeNs(ctxt, lname, NULL,
 2293|      0|                                                  attributes[j+3],
 2294|      0|                                                  attributes[j+4]);
 2295|      0|			xmlFree(lname);
 2296|      0|                        goto have_attr;
 2297|      0|		    }
 2298|      0|		}
 2299|      0|	    }
 2300|    896|            attr = xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],
 2301|    896|                                      attributes[j+3], attributes[j+4]);
 2302|    896|have_attr:
 2303|    896|            if (attr == NULL)
  ------------------
  |  Branch (2303:17): [True: 0, False: 896]
  ------------------
 2304|      0|                continue;
 2305|       |
 2306|       |            /* link at the end to preserve order */
 2307|    896|            if (prev == NULL) {
  ------------------
  |  Branch (2307:17): [True: 781, False: 115]
  ------------------
 2308|    781|                ctxt->node->properties = attr;
 2309|    781|            } else {
 2310|    115|                prev->next = attr;
 2311|    115|                attr->prev = prev;
 2312|    115|            }
 2313|       |
 2314|    896|            prev = attr;
 2315|    896|	}
 2316|    781|    }
 2317|       |
 2318|  2.95k|#ifdef LIBXML_VALID_ENABLED
 2319|       |    /*
 2320|       |     * If it's the Document root, finish the DTD validation and
 2321|       |     * check the document root element for validity
 2322|       |     */
 2323|  2.95k|    if ((ctxt->validate) &&
  ------------------
  |  Branch (2323:9): [True: 0, False: 2.95k]
  ------------------
 2324|  2.95k|        ((ctxt->vctxt.flags & XML_VCTXT_DTD_VALIDATED) == 0)) {
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
  |  Branch (2324:9): [True: 0, False: 0]
  ------------------
 2325|      0|	int chk;
 2326|       |
 2327|      0|	chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);
 2328|      0|	if (chk <= 0)
  ------------------
  |  Branch (2328:6): [True: 0, False: 0]
  ------------------
 2329|      0|	    ctxt->valid = 0;
 2330|      0|	if (chk < 0)
  ------------------
  |  Branch (2330:6): [True: 0, False: 0]
  ------------------
 2331|      0|	    ctxt->wellFormed = 0;
 2332|      0|	ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
 2333|      0|	ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;
  ------------------
  |  |   12|      0|#define XML_VCTXT_DTD_VALIDATED (1u << 0)
  ------------------
 2334|      0|    }
 2335|  2.95k|#endif /* LIBXML_VALID_ENABLED */
 2336|  2.95k|}
xmlSAX2EndElementNs:
 2353|  2.93k|{
 2354|  2.93k|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2355|       |
 2356|  2.93k|    if (ctx == NULL) return;
  ------------------
  |  Branch (2356:9): [True: 0, False: 2.93k]
  ------------------
 2357|  2.93k|    ctxt->nodemem = -1;
 2358|       |
 2359|  2.93k|#ifdef LIBXML_VALID_ENABLED
 2360|  2.93k|    if (ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (2360:9): [True: 0, False: 2.93k]
  |  Branch (2360:27): [True: 0, False: 0]
  ------------------
 2361|  2.93k|        ctxt->myDoc && ctxt->myDoc->intSubset)
  ------------------
  |  Branch (2361:9): [True: 0, False: 0]
  |  Branch (2361:24): [True: 0, False: 0]
  ------------------
 2362|      0|        ctxt->valid &= xmlValidateOneElement(&ctxt->vctxt, ctxt->myDoc,
 2363|      0|                                             ctxt->node);
 2364|  2.93k|#endif /* LIBXML_VALID_ENABLED */
 2365|       |
 2366|       |    /*
 2367|       |     * end of parsing of this node.
 2368|       |     */
 2369|  2.93k|    nodePop(ctxt);
 2370|  2.93k|}
xmlSAX2Characters:
 2541|  4.75k|{
 2542|  4.75k|    xmlSAX2Text((xmlParserCtxtPtr) ctx, ch, len, XML_TEXT_NODE);
 2543|  4.75k|}
xmlSAX2ProcessingInstruction:
 2570|     12|{
 2571|     12|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2572|     12|    xmlNodePtr ret;
 2573|     12|    xmlNodePtr parent;
 2574|       |
 2575|     12|    if (ctx == NULL) return;
  ------------------
  |  Branch (2575:9): [True: 0, False: 12]
  ------------------
 2576|     12|    parent = ctxt->node;
 2577|       |
 2578|     12|    ret = xmlNewDocPI(ctxt->myDoc, target, data);
 2579|     12|    if (ret == NULL) return;
  ------------------
  |  Branch (2579:9): [True: 0, False: 12]
  ------------------
 2580|       |
 2581|     12|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2581:9): [True: 12, False: 0]
  ------------------
 2582|     12|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2582:6): [True: 12, False: 0]
  ------------------
 2583|     12|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2583:10): [True: 12, False: 0]
  ------------------
 2584|     12|		ret->line = ctxt->input->line;
 2585|      0|	    else
 2586|      0|	        ret->line = USHRT_MAX;
 2587|     12|	}
 2588|     12|    }
 2589|     12|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2589:9): [True: 0, False: 12]
  ------------------
 2590|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2591|      0|	return;
 2592|     12|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2592:16): [True: 0, False: 12]
  ------------------
 2593|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2594|      0|	return;
 2595|      0|    }
 2596|     12|    if (parent == NULL) {
  ------------------
  |  Branch (2596:9): [True: 0, False: 12]
  ------------------
 2597|      0|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2598|      0|	return;
 2599|      0|    }
 2600|     12|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2600:9): [True: 12, False: 0]
  ------------------
 2601|     12|	xmlAddChild(parent, ret);
 2602|     12|    } else {
 2603|      0|	xmlAddSibling(parent, ret);
 2604|      0|    }
 2605|     12|}
xmlSAX2Comment:
 2616|     37|{
 2617|     37|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;
 2618|     37|    xmlNodePtr ret;
 2619|     37|    xmlNodePtr parent;
 2620|       |
 2621|     37|    if (ctx == NULL) return;
  ------------------
  |  Branch (2621:9): [True: 0, False: 37]
  ------------------
 2622|     37|    parent = ctxt->node;
 2623|     37|    ret = xmlNewDocComment(ctxt->myDoc, value);
 2624|     37|    if (ret == NULL) return;
  ------------------
  |  Branch (2624:9): [True: 0, False: 37]
  ------------------
 2625|     37|    if (ctxt->linenumbers) {
  ------------------
  |  Branch (2625:9): [True: 37, False: 0]
  ------------------
 2626|     37|	if (ctxt->input != NULL) {
  ------------------
  |  Branch (2626:6): [True: 37, False: 0]
  ------------------
 2627|     37|	    if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2627:10): [True: 37, False: 0]
  ------------------
 2628|     37|		ret->line = ctxt->input->line;
 2629|      0|	    else
 2630|      0|	        ret->line = USHRT_MAX;
 2631|     37|	}
 2632|     37|    }
 2633|       |
 2634|     37|    if (ctxt->inSubset == 1) {
  ------------------
  |  Branch (2634:9): [True: 0, False: 37]
  ------------------
 2635|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);
 2636|      0|	return;
 2637|     37|    } else if (ctxt->inSubset == 2) {
  ------------------
  |  Branch (2637:16): [True: 0, False: 37]
  ------------------
 2638|      0|	xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);
 2639|      0|	return;
 2640|      0|    }
 2641|     37|    if (parent == NULL) {
  ------------------
  |  Branch (2641:9): [True: 0, False: 37]
  ------------------
 2642|      0|        xmlAddChild((xmlNodePtr) ctxt->myDoc, (xmlNodePtr) ret);
 2643|      0|	return;
 2644|      0|    }
 2645|     37|    if (parent->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (2645:9): [True: 37, False: 0]
  ------------------
 2646|     37|	xmlAddChild(parent, ret);
 2647|     37|    } else {
 2648|      0|	xmlAddSibling(parent, ret);
 2649|      0|    }
 2650|     37|}
xmlSAX2CDataBlock:
 2662|     12|{
 2663|     12|    xmlSAX2Text((xmlParserCtxtPtr) ctx, value, len, XML_CDATA_SECTION_NODE);
 2664|     12|}
xmlSAXVersion:
 2706|    486|{
 2707|    486|    if (hdlr == NULL) return(-1);
  ------------------
  |  Branch (2707:9): [True: 0, False: 486]
  ------------------
 2708|    486|    if (version == 2) {
  ------------------
  |  Branch (2708:9): [True: 486, False: 0]
  ------------------
 2709|    486|	hdlr->startElementNs = xmlSAX2StartElementNs;
 2710|    486|	hdlr->endElementNs = xmlSAX2EndElementNs;
 2711|    486|	hdlr->serror = NULL;
 2712|    486|	hdlr->initialized = XML_SAX2_MAGIC;
  ------------------
  |  |  685|    486|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
 2713|    486|#ifdef LIBXML_SAX1_ENABLED
 2714|    486|    } else if (version == 1) {
  ------------------
  |  Branch (2714:16): [True: 0, False: 0]
  ------------------
 2715|      0|	hdlr->initialized = 1;
 2716|      0|#endif /* LIBXML_SAX1_ENABLED */
 2717|      0|    } else
 2718|      0|        return(-1);
 2719|    486|#ifdef LIBXML_SAX1_ENABLED
 2720|    486|    hdlr->startElement = xmlSAX2StartElement;
 2721|    486|    hdlr->endElement = xmlSAX2EndElement;
 2722|       |#else
 2723|       |    hdlr->startElement = NULL;
 2724|       |    hdlr->endElement = NULL;
 2725|       |#endif /* LIBXML_SAX1_ENABLED */
 2726|    486|    hdlr->internalSubset = xmlSAX2InternalSubset;
 2727|    486|    hdlr->externalSubset = xmlSAX2ExternalSubset;
 2728|    486|    hdlr->isStandalone = xmlSAX2IsStandalone;
 2729|    486|    hdlr->hasInternalSubset = xmlSAX2HasInternalSubset;
 2730|    486|    hdlr->hasExternalSubset = xmlSAX2HasExternalSubset;
 2731|    486|    hdlr->resolveEntity = xmlSAX2ResolveEntity;
 2732|    486|    hdlr->getEntity = xmlSAX2GetEntity;
 2733|    486|    hdlr->getParameterEntity = xmlSAX2GetParameterEntity;
 2734|    486|    hdlr->entityDecl = xmlSAX2EntityDecl;
 2735|    486|    hdlr->attributeDecl = xmlSAX2AttributeDecl;
 2736|    486|    hdlr->elementDecl = xmlSAX2ElementDecl;
 2737|    486|    hdlr->notationDecl = xmlSAX2NotationDecl;
 2738|    486|    hdlr->unparsedEntityDecl = xmlSAX2UnparsedEntityDecl;
 2739|    486|    hdlr->setDocumentLocator = xmlSAX2SetDocumentLocator;
 2740|    486|    hdlr->startDocument = xmlSAX2StartDocument;
 2741|    486|    hdlr->endDocument = xmlSAX2EndDocument;
 2742|    486|    hdlr->reference = xmlSAX2Reference;
 2743|    486|    hdlr->characters = xmlSAX2Characters;
 2744|    486|    hdlr->cdataBlock = xmlSAX2CDataBlock;
 2745|    486|    hdlr->ignorableWhitespace = xmlSAX2Characters;
 2746|    486|    hdlr->processingInstruction = xmlSAX2ProcessingInstruction;
 2747|    486|    hdlr->comment = xmlSAX2Comment;
 2748|    486|    hdlr->warning = xmlParserWarning;
 2749|    486|    hdlr->error = xmlParserError;
 2750|    486|    hdlr->fatalError = xmlParserError;
 2751|       |
 2752|    486|    return(0);
 2753|    486|}
SAX2.c:xmlSAX2AttributeNs:
 1867|    896|{
 1868|    896|    xmlAttrPtr ret;
 1869|    896|    xmlNsPtr namespace = NULL;
 1870|    896|    xmlChar *dup = NULL;
 1871|       |
 1872|       |    /*
 1873|       |     * Note: if prefix == NULL, the attribute is not in the default namespace
 1874|       |     */
 1875|    896|    if (prefix != NULL) {
  ------------------
  |  Branch (1875:9): [True: 36, False: 860]
  ------------------
 1876|     36|	namespace = xmlParserNsLookupSax(ctxt, prefix);
 1877|     36|	if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1877:6): [True: 36, False: 0]
  |  Branch (1877:29): [True: 36, False: 0]
  ------------------
 1878|     36|	    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);
 1879|     36|	}
 1880|     36|    }
 1881|       |
 1882|       |    /*
 1883|       |     * allocate the node
 1884|       |     */
 1885|    896|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 896]
  ------------------
 1886|      0|        ret = ctxt->freeAttrs;
 1887|      0|	ctxt->freeAttrs = ret->next;
 1888|      0|	ctxt->freeAttrsNr--;
 1889|    896|    } else {
 1890|    896|        ret = xmlMalloc(sizeof(*ret));
 1891|    896|        if (ret == NULL) {
  ------------------
  |  Branch (1891:13): [True: 0, False: 896]
  ------------------
 1892|      0|            xmlSAX2ErrMemory(ctxt, NULL);
 1893|      0|            return(NULL);
 1894|      0|        }
 1895|    896|    }
 1896|       |
 1897|    896|    memset(ret, 0, sizeof(xmlAttr));
 1898|    896|    ret->type = XML_ATTRIBUTE_NODE;
 1899|       |
 1900|    896|    ret->parent = ctxt->node;
 1901|    896|    ret->doc = ctxt->myDoc;
 1902|    896|    ret->ns = namespace;
 1903|       |
 1904|    896|    if (ctxt->dictNames)
  ------------------
  |  Branch (1904:9): [True: 896, False: 0]
  ------------------
 1905|    896|        ret->name = localname;
 1906|      0|    else
 1907|      0|        ret->name = xmlStrdup(localname);
 1908|       |
 1909|    896|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1909:9): [True: 0, False: 896]
  |  Branch (1909:37): [True: 0, False: 0]
  ------------------
 1910|      0|        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1911|       |
 1912|    896|    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {
  ------------------
  |  Branch (1912:9): [True: 896, False: 0]
  |  Branch (1912:41): [True: 896, False: 0]
  ------------------
 1913|    896|	xmlNodePtr tmp;
 1914|       |
 1915|       |	/*
 1916|       |	 * We know that if there is an entity reference, then
 1917|       |	 * the string has been dup'ed and terminates with 0
 1918|       |	 * otherwise with ' or "
 1919|       |	 */
 1920|    896|	if (*valueend != 0) {
  ------------------
  |  Branch (1920:6): [True: 787, False: 109]
  ------------------
 1921|    787|	    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1922|    787|	    ret->children = tmp;
 1923|    787|	    ret->last = tmp;
 1924|    787|	    if (tmp != NULL) {
  ------------------
  |  Branch (1924:10): [True: 787, False: 0]
  ------------------
 1925|    787|		tmp->doc = ret->doc;
 1926|    787|		tmp->parent = (xmlNodePtr) ret;
 1927|    787|	    }
 1928|    787|	} else {
 1929|    109|	    ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,
 1930|    109|						    valueend - value);
 1931|    109|	    tmp = ret->children;
 1932|    218|	    while (tmp != NULL) {
  ------------------
  |  Branch (1932:13): [True: 109, False: 109]
  ------------------
 1933|    109|	        tmp->doc = ret->doc;
 1934|    109|		tmp->parent = (xmlNodePtr) ret;
 1935|    109|		if (tmp->next == NULL)
  ------------------
  |  Branch (1935:7): [True: 109, False: 0]
  ------------------
 1936|    109|		    ret->last = tmp;
 1937|    109|		tmp = tmp->next;
 1938|    109|	    }
 1939|    109|	}
 1940|    896|    } else if (value != NULL) {
  ------------------
  |  Branch (1940:16): [True: 0, False: 0]
  ------------------
 1941|      0|	xmlNodePtr tmp;
 1942|       |
 1943|      0|	tmp = xmlSAX2TextNode(ctxt, value, valueend - value);
 1944|      0|	ret->children = tmp;
 1945|      0|	ret->last = tmp;
 1946|      0|	if (tmp != NULL) {
  ------------------
  |  Branch (1946:6): [True: 0, False: 0]
  ------------------
 1947|      0|	    tmp->doc = ret->doc;
 1948|      0|	    tmp->parent = (xmlNodePtr) ret;
 1949|      0|	}
 1950|      0|    }
 1951|       |
 1952|    896|#ifdef LIBXML_VALID_ENABLED
 1953|    896|    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&
  ------------------
  |  Branch (1953:9): [True: 896, False: 0]
  |  Branch (1953:26): [True: 0, False: 896]
  |  Branch (1953:44): [True: 0, False: 0]
  ------------------
 1954|    896|        ctxt->myDoc && ctxt->myDoc->intSubset) {
  ------------------
  |  Branch (1954:9): [True: 0, False: 0]
  |  Branch (1954:24): [True: 0, False: 0]
  ------------------
 1955|       |	/*
 1956|       |	 * If we don't substitute entities, the validation should be
 1957|       |	 * done on a value with replaced entities anyway.
 1958|       |	 */
 1959|      0|        if (!ctxt->replaceEntities) {
  ------------------
  |  Branch (1959:13): [True: 0, False: 0]
  ------------------
 1960|      0|	    dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);
 1961|      0|	    if (dup == NULL) {
  ------------------
  |  Branch (1961:10): [True: 0, False: 0]
  ------------------
 1962|      0|	        if (*valueend == 0) {
  ------------------
  |  Branch (1962:14): [True: 0, False: 0]
  ------------------
 1963|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1964|      0|				    ctxt->myDoc, ctxt->node, ret, value);
 1965|      0|		} else {
 1966|       |		    /*
 1967|       |		     * That should already be normalized.
 1968|       |		     * cheaper to finally allocate here than duplicate
 1969|       |		     * entry points in the full validation code
 1970|       |		     */
 1971|      0|		    dup = xmlStrndup(value, valueend - value);
 1972|       |
 1973|      0|		    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 1974|      0|				    ctxt->myDoc, ctxt->node, ret, dup);
 1975|      0|		}
 1976|      0|	    } else {
 1977|       |	        /*
 1978|       |		 * dup now contains a string of the flattened attribute
 1979|       |		 * content with entities substituted. Check if we need to
 1980|       |		 * apply an extra layer of normalization.
 1981|       |		 * It need to be done twice ... it's an extra burden related
 1982|       |		 * to the ability to keep references in attributes
 1983|       |		 */
 1984|      0|		if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (1984:7): [True: 0, False: 0]
  ------------------
 1985|      0|		    xmlChar *nvalnorm;
 1986|      0|		    xmlChar fn[50];
 1987|      0|		    xmlChar *fullname;
 1988|       |
 1989|      0|		    fullname = xmlBuildQName(localname, prefix, fn, 50);
 1990|      0|		    if (fullname != NULL) {
  ------------------
  |  Branch (1990:11): [True: 0, False: 0]
  ------------------
 1991|      0|			ctxt->vctxt.valid = 1;
 1992|      0|		        nvalnorm = xmlValidCtxtNormalizeAttributeValue(
 1993|      0|			                 &ctxt->vctxt, ctxt->myDoc,
 1994|      0|					 ctxt->node, fullname, dup);
 1995|      0|			if (ctxt->vctxt.valid != 1)
  ------------------
  |  Branch (1995:8): [True: 0, False: 0]
  ------------------
 1996|      0|			    ctxt->valid = 0;
 1997|       |
 1998|      0|			if ((fullname != fn) && (fullname != localname))
  ------------------
  |  Branch (1998:8): [True: 0, False: 0]
  |  Branch (1998:28): [True: 0, False: 0]
  ------------------
 1999|      0|			    xmlFree(fullname);
 2000|      0|			if (nvalnorm != NULL) {
  ------------------
  |  Branch (2000:8): [True: 0, False: 0]
  ------------------
 2001|      0|			    xmlFree(dup);
 2002|      0|			    dup = nvalnorm;
 2003|      0|			}
 2004|      0|		    }
 2005|      0|		}
 2006|       |
 2007|      0|		ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2008|      0|			        ctxt->myDoc, ctxt->node, ret, dup);
 2009|      0|	    }
 2010|      0|	} else {
 2011|       |	    /*
 2012|       |	     * if entities already have been substituted, then
 2013|       |	     * the attribute as passed is already normalized
 2014|       |	     */
 2015|      0|	    dup = xmlStrndup(value, valueend - value);
 2016|       |
 2017|      0|	    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,
 2018|      0|	                             ctxt->myDoc, ctxt->node, ret, dup);
 2019|      0|	}
 2020|      0|    } else
 2021|    896|#endif /* LIBXML_VALID_ENABLED */
 2022|    896|           if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&
  ------------------
  |  |  158|    896|#define XML_SKIP_IDS		8
  ------------------
  |  Branch (2022:16): [True: 896, False: 0]
  ------------------
 2023|    896|	       (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||
  ------------------
  |  Branch (2023:11): [True: 896, False: 0]
  |  Branch (2023:43): [True: 896, False: 0]
  ------------------
 2024|    896|	        ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0))) &&
  ------------------
  |  Branch (2024:11): [True: 0, False: 0]
  |  Branch (2024:43): [True: 0, False: 0]
  ------------------
 2025|       |               /* Don't create IDs containing entity references */
 2026|    896|               (ret->children != NULL) &&
  ------------------
  |  Branch (2026:16): [True: 896, False: 0]
  ------------------
 2027|    896|               (ret->children->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2027:16): [True: 896, False: 0]
  ------------------
 2028|    896|               (ret->children->next == NULL)) {
  ------------------
  |  Branch (2028:16): [True: 896, False: 0]
  ------------------
 2029|    896|        xmlChar *content = ret->children->content;
 2030|       |        /*
 2031|       |	 * when validating, the ID registration is done at the attribute
 2032|       |	 * validation level. Otherwise we have to do specific handling here.
 2033|       |	 */
 2034|    896|        if ((prefix == ctxt->str_xml) &&
  ------------------
  |  Branch (2034:13): [True: 36, False: 860]
  ------------------
 2035|    896|	           (localname[0] == 'i') && (localname[1] == 'd') &&
  ------------------
  |  Branch (2035:13): [True: 0, False: 36]
  |  Branch (2035:38): [True: 0, False: 0]
  ------------------
 2036|    896|		   (localname[2] == 0)) {
  ------------------
  |  Branch (2036:6): [True: 0, False: 0]
  ------------------
 2037|       |	    /*
 2038|       |	     * Add the xml:id value
 2039|       |	     *
 2040|       |	     * Open issue: normalization of the value.
 2041|       |	     */
 2042|      0|	    if (xmlValidateNCName(content, 1) != 0) {
  ------------------
  |  Branch (2042:10): [True: 0, False: 0]
  ------------------
 2043|      0|	        xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,
 2044|      0|		      "xml:id : attribute value %s is not an NCName\n",
 2045|      0|			    (const char *) content, NULL);
 2046|      0|	    }
 2047|      0|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2048|    896|	} else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2048:13): [True: 110, False: 786]
  ------------------
 2049|    110|	    xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2050|    786|	} else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {
  ------------------
  |  Branch (2050:13): [True: 0, False: 786]
  ------------------
 2051|      0|	    xmlAddRef(&ctxt->vctxt, ctxt->myDoc, content, ret);
 2052|      0|	}
 2053|    896|    }
 2054|    896|    if (dup != NULL)
  ------------------
  |  Branch (2054:9): [True: 0, False: 896]
  ------------------
 2055|      0|	xmlFree(dup);
 2056|       |
 2057|    896|    return(ret);
 2058|    896|}
SAX2.c:xmlSAX2TextNode:
 1749|  5.53k|xmlSAX2TextNode(xmlParserCtxtPtr ctxt, const xmlChar *str, int len) {
 1750|  5.53k|    xmlNodePtr ret;
 1751|  5.53k|    const xmlChar *intern = NULL;
 1752|       |
 1753|       |    /*
 1754|       |     * Allocate
 1755|       |     */
 1756|  5.53k|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (1756:9): [True: 0, False: 5.53k]
  ------------------
 1757|      0|	ret = ctxt->freeElems;
 1758|      0|	ctxt->freeElems = ret->next;
 1759|      0|	ctxt->freeElemsNr--;
 1760|  5.53k|    } else {
 1761|  5.53k|	ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 1762|  5.53k|    }
 1763|  5.53k|    if (ret == NULL) {
  ------------------
  |  Branch (1763:9): [True: 0, False: 5.53k]
  ------------------
 1764|      0|        xmlErrMemory(ctxt, "xmlSAX2Characters");
 1765|      0|	return(NULL);
 1766|      0|    }
 1767|  5.53k|    memset(ret, 0, sizeof(xmlNode));
 1768|       |    /*
 1769|       |     * intern the formatting blanks found between tags, or the
 1770|       |     * very short strings
 1771|       |     */
 1772|  5.53k|    if (ctxt->dictNames) {
  ------------------
  |  Branch (1772:9): [True: 5.53k, False: 0]
  ------------------
 1773|  5.53k|        xmlChar cur = str[len];
 1774|       |
 1775|  5.53k|	if ((len < (int) (2 * sizeof(void *))) &&
  ------------------
  |  Branch (1775:6): [True: 4.91k, False: 621]
  ------------------
 1776|  5.53k|	    (ctxt->options & XML_PARSE_COMPACT)) {
  ------------------
  |  Branch (1776:6): [True: 0, False: 4.91k]
  ------------------
 1777|       |	    /* store the string in the node overriding properties and nsDef */
 1778|      0|	    xmlChar *tmp = (xmlChar *) &(ret->properties);
 1779|      0|	    memcpy(tmp, str, len);
 1780|      0|	    tmp[len] = 0;
 1781|      0|	    intern = tmp;
 1782|  5.53k|	} else if ((len <= 3) && ((cur == '"') || (cur == '\'') ||
  ------------------
  |  Branch (1782:13): [True: 2.11k, False: 3.41k]
  |  Branch (1782:28): [True: 94, False: 2.02k]
  |  Branch (1782:44): [True: 0, False: 2.02k]
  ------------------
 1783|  2.11k|	    ((cur == '<') && (str[len + 1] != '!')))) {
  ------------------
  |  Branch (1783:7): [True: 2.02k, False: 3]
  |  Branch (1783:23): [True: 2.01k, False: 11]
  ------------------
 1784|  2.10k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1785|  3.43k|	} else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&
  ------------------
  |  |  151|  3.43k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  6.86k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 3.43k]
  |  |  |  |  ------------------
  |  |  |  |   89|  3.43k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 3.43k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 1.37k, False: 2.05k]
  |  |  |  |  ------------------
  |  |  |  |   90|  6.86k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2.05k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1785:34): [True: 1.37k, False: 0]
  |  Branch (1785:48): [True: 1.37k, False: 3]
  ------------------
 1786|  3.43k|	           (str[len + 1] != '!')) {
  ------------------
  |  Branch (1786:13): [True: 1.37k, False: 0]
  ------------------
 1787|  1.37k|	    int i;
 1788|       |
 1789|  5.52k|	    for (i = 1;i < len;i++) {
  ------------------
  |  Branch (1789:17): [True: 4.15k, False: 1.37k]
  ------------------
 1790|  4.15k|		if (!IS_BLANK_CH(str[i])) goto skip;
  ------------------
  |  |  151|  4.15k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  4.15k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 4.14k, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   89|  4.15k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  |  |   90|  4.15k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1791|  4.15k|	    }
 1792|  1.37k|	    intern = xmlDictLookup(ctxt->dict, str, len);
 1793|  1.37k|	}
 1794|  5.53k|    }
 1795|  5.53k|skip:
 1796|  5.53k|    ret->type = XML_TEXT_NODE;
 1797|       |
 1798|  5.53k|    ret->name = xmlStringText;
 1799|  5.53k|    if (intern == NULL) {
  ------------------
  |  Branch (1799:9): [True: 2.05k, False: 3.47k]
  ------------------
 1800|  2.05k|	ret->content = xmlStrndup(str, len);
 1801|  2.05k|	if (ret->content == NULL) {
  ------------------
  |  Branch (1801:6): [True: 0, False: 2.05k]
  ------------------
 1802|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2TextNode");
 1803|      0|	    xmlFree(ret);
 1804|      0|	    return(NULL);
 1805|      0|	}
 1806|  2.05k|    } else
 1807|  3.47k|	ret->content = (xmlChar *) intern;
 1808|       |
 1809|  5.53k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1809:9): [True: 0, False: 5.53k]
  |  Branch (1809:37): [True: 0, False: 0]
  ------------------
 1810|      0|	xmlRegisterNodeDefaultValue(ret);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1811|  5.53k|    return(ret);
 1812|  5.53k|}
SAX2.c:xmlSAX2Text:
 2404|  4.76k|{
 2405|  4.76k|    xmlNodePtr lastChild;
 2406|       |
 2407|  4.76k|    if (ctxt == NULL) return;
  ------------------
  |  Branch (2407:9): [True: 0, False: 4.76k]
  ------------------
 2408|       |    /*
 2409|       |     * Handle the data if any. If there is no child
 2410|       |     * add it as content, otherwise if the last child is text,
 2411|       |     * concatenate it, else create a new node of type text.
 2412|       |     */
 2413|       |
 2414|  4.76k|    if (ctxt->node == NULL) {
  ------------------
  |  Branch (2414:9): [True: 0, False: 4.76k]
  ------------------
 2415|      0|        return;
 2416|      0|    }
 2417|  4.76k|    lastChild = ctxt->node->last;
 2418|       |
 2419|       |    /*
 2420|       |     * Here we needed an accelerator mechanism in case of very large
 2421|       |     * elements. Use an attribute in the structure !!!
 2422|       |     */
 2423|  4.76k|    if (lastChild == NULL) {
  ------------------
  |  Branch (2423:9): [True: 2.34k, False: 2.42k]
  ------------------
 2424|  2.34k|        if (type == XML_TEXT_NODE)
  ------------------
  |  Branch (2424:13): [True: 2.34k, False: 0]
  ------------------
 2425|  2.34k|            lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2426|      0|        else
 2427|      0|            lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2428|  2.34k|	if (lastChild != NULL) {
  ------------------
  |  Branch (2428:6): [True: 2.34k, False: 0]
  ------------------
 2429|  2.34k|	    ctxt->node->children = lastChild;
 2430|  2.34k|	    ctxt->node->last = lastChild;
 2431|  2.34k|	    lastChild->parent = ctxt->node;
 2432|  2.34k|	    lastChild->doc = ctxt->node->doc;
 2433|  2.34k|	    ctxt->nodelen = len;
 2434|  2.34k|	    ctxt->nodemem = len + 1;
 2435|  2.34k|	} else {
 2436|      0|	    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2437|      0|	    return;
 2438|      0|	}
 2439|  2.42k|    } else {
 2440|  2.42k|	int coalesceText = (lastChild != NULL) &&
  ------------------
  |  Branch (2440:21): [True: 2.42k, False: 0]
  ------------------
 2441|  2.42k|	    (lastChild->type == type) &&
  ------------------
  |  Branch (2441:6): [True: 8, False: 2.41k]
  ------------------
 2442|  2.42k|	    ((type != XML_TEXT_NODE) ||
  ------------------
  |  Branch (2442:7): [True: 0, False: 8]
  ------------------
 2443|      8|             (lastChild->name == xmlStringText));
  ------------------
  |  Branch (2443:14): [True: 8, False: 0]
  ------------------
 2444|  2.42k|	if ((coalesceText) && (ctxt->nodemem != 0)) {
  ------------------
  |  Branch (2444:6): [True: 8, False: 2.41k]
  |  Branch (2444:24): [True: 8, False: 0]
  ------------------
 2445|       |	    /*
 2446|       |	     * The whole point of maintaining nodelen and nodemem,
 2447|       |	     * xmlTextConcat is too costly, i.e. compute length,
 2448|       |	     * reallocate a new buffer, move data, append ch. Here
 2449|       |	     * We try to minimize realloc() uses and avoid copying
 2450|       |	     * and recomputing length over and over.
 2451|       |	     */
 2452|      8|	    if (lastChild->content == (xmlChar *)&(lastChild->properties)) {
  ------------------
  |  Branch (2452:10): [True: 0, False: 8]
  ------------------
 2453|      0|		lastChild->content = xmlStrdup(lastChild->content);
 2454|      0|		lastChild->properties = NULL;
 2455|      8|	    } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&
  ------------------
  |  Branch (2455:17): [True: 8, False: 0]
  ------------------
 2456|      8|	               (xmlDictOwns(ctxt->dict, lastChild->content))) {
  ------------------
  |  Branch (2456:17): [True: 3, False: 5]
  ------------------
 2457|      3|		lastChild->content = xmlStrdup(lastChild->content);
 2458|      3|	    }
 2459|      8|	    if (lastChild->content == NULL) {
  ------------------
  |  Branch (2459:10): [True: 0, False: 8]
  ------------------
 2460|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: xmlStrdup returned NULL");
 2461|      0|		return;
 2462|      0| 	    }
 2463|      8|	    if (ctxt->nodelen > INT_MAX - len) {
  ------------------
  |  Branch (2463:10): [True: 0, False: 8]
  ------------------
 2464|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters overflow prevented");
 2465|      0|                return;
 2466|      0|	    }
 2467|      8|            if ((ctxt->nodelen + len > XML_MAX_TEXT_LENGTH) &&
  ------------------
  |  |   42|      8|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (2467:17): [True: 0, False: 8]
  ------------------
 2468|      8|                ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (2468:17): [True: 0, False: 0]
  ------------------
 2469|      0|                xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters: huge text node");
 2470|      0|                return;
 2471|      0|            }
 2472|      8|	    if (ctxt->nodelen + len >= ctxt->nodemem) {
  ------------------
  |  Branch (2472:10): [True: 8, False: 0]
  ------------------
 2473|      8|		xmlChar *newbuf;
 2474|      8|		int size;
 2475|       |
 2476|      8|		size = ctxt->nodemem > INT_MAX - len ?
  ------------------
  |  Branch (2476:10): [True: 0, False: 8]
  ------------------
 2477|      0|                       INT_MAX :
 2478|      8|                       ctxt->nodemem + len;
 2479|      8|		size = size > INT_MAX / 2 ? INT_MAX : size * 2;
  ------------------
  |  Branch (2479:10): [True: 0, False: 8]
  ------------------
 2480|      8|                newbuf = (xmlChar *) xmlRealloc(lastChild->content,size);
 2481|      8|		if (newbuf == NULL) {
  ------------------
  |  Branch (2481:7): [True: 0, False: 8]
  ------------------
 2482|      0|		    xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2483|      0|		    return;
 2484|      0|		}
 2485|      8|		ctxt->nodemem = size;
 2486|      8|		lastChild->content = newbuf;
 2487|      8|	    }
 2488|      8|	    memcpy(&lastChild->content[ctxt->nodelen], ch, len);
 2489|      8|	    ctxt->nodelen += len;
 2490|      8|	    lastChild->content[ctxt->nodelen] = 0;
 2491|  2.41k|	} else if (coalesceText) {
  ------------------
  |  Branch (2491:13): [True: 0, False: 2.41k]
  ------------------
 2492|      0|	    if (xmlTextConcat(lastChild, ch, len)) {
  ------------------
  |  Branch (2492:10): [True: 0, False: 0]
  ------------------
 2493|      0|		xmlSAX2ErrMemory(ctxt, "xmlSAX2Characters");
 2494|      0|	    }
 2495|      0|	    if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2495:10): [True: 0, False: 0]
  ------------------
 2496|      0|		ctxt->nodelen = xmlStrlen(lastChild->content);
 2497|      0|		ctxt->nodemem = ctxt->nodelen + 1;
 2498|      0|	    }
 2499|  2.41k|	} else {
 2500|       |	    /* Mixed content, first time */
 2501|  2.41k|            if (type == XML_TEXT_NODE) {
  ------------------
  |  Branch (2501:17): [True: 2.40k, False: 12]
  ------------------
 2502|  2.40k|                lastChild = xmlSAX2TextNode(ctxt, ch, len);
 2503|  2.40k|                if (lastChild != NULL)
  ------------------
  |  Branch (2503:21): [True: 2.40k, False: 0]
  ------------------
 2504|  2.40k|                    lastChild->doc = ctxt->myDoc;
 2505|  2.40k|            } else
 2506|     12|                lastChild = xmlNewCDataBlock(ctxt->myDoc, ch, len);
 2507|  2.41k|	    if (lastChild != NULL) {
  ------------------
  |  Branch (2507:10): [True: 2.41k, False: 0]
  ------------------
 2508|  2.41k|		xmlAddChild(ctxt->node, lastChild);
 2509|  2.41k|		if (ctxt->node->children != NULL) {
  ------------------
  |  Branch (2509:7): [True: 2.41k, False: 0]
  ------------------
 2510|  2.41k|		    ctxt->nodelen = len;
 2511|  2.41k|		    ctxt->nodemem = len + 1;
 2512|  2.41k|		}
 2513|  2.41k|	    }
 2514|  2.41k|	}
 2515|  2.42k|    }
 2516|       |
 2517|  4.76k|    if ((lastChild != NULL) &&
  ------------------
  |  Branch (2517:9): [True: 4.76k, False: 0]
  ------------------
 2518|  4.76k|        (type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (2518:9): [True: 4.75k, False: 12]
  ------------------
 2519|  4.76k|        (ctxt->linenumbers) &&
  ------------------
  |  Branch (2519:9): [True: 4.75k, False: 0]
  ------------------
 2520|  4.76k|        (ctxt->input != NULL)) {
  ------------------
  |  Branch (2520:9): [True: 4.75k, False: 0]
  ------------------
 2521|  4.75k|        if ((unsigned) ctxt->input->line < (unsigned) USHRT_MAX)
  ------------------
  |  Branch (2521:13): [True: 4.75k, False: 0]
  ------------------
 2522|  4.75k|            lastChild->line = ctxt->input->line;
 2523|      0|        else {
 2524|      0|            lastChild->line = USHRT_MAX;
 2525|      0|            if (ctxt->options & XML_PARSE_BIG_LINES)
  ------------------
  |  Branch (2525:17): [True: 0, False: 0]
  ------------------
 2526|      0|                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;
 2527|      0|        }
 2528|  4.75k|    }
 2529|  4.76k|}

xmlBufCreateSize:
  155|    597|xmlBufCreateSize(size_t size) {
  156|    597|    xmlBufPtr ret;
  157|       |
  158|    597|    if (size == SIZE_MAX)
  ------------------
  |  |   30|    597|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (158:9): [True: 0, False: 597]
  ------------------
  159|      0|        return(NULL);
  160|    597|    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));
  161|    597|    if (ret == NULL) {
  ------------------
  |  Branch (161:9): [True: 0, False: 597]
  ------------------
  162|      0|	xmlBufMemoryError(NULL, "creating buffer");
  163|      0|        return(NULL);
  164|      0|    }
  165|    597|    ret->use = 0;
  166|    597|    ret->error = 0;
  167|    597|    ret->buffer = NULL;
  168|    597|    ret->alloc = xmlBufferAllocScheme;
  ------------------
  |  |  679|    597|  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)
  |  |  ------------------
  |  |  |  |  500|    597|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  169|    597|    ret->size = (size ? size + 1 : 0);         /* +1 for ending null */
  ------------------
  |  Branch (169:18): [True: 488, False: 109]
  ------------------
  170|    597|    UPDATE_COMPAT(ret);
  ------------------
  |  |   61|    597|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 597, False: 0]
  |  |  ------------------
  |  |   62|    597|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    597|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 597, False: 0]
  |  |  ------------------
  |  |   64|    597|     else buf->compat_use = INT_MAX;
  ------------------
  171|    597|    if (ret->size){
  ------------------
  |  Branch (171:9): [True: 488, False: 109]
  ------------------
  172|    488|        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);
  173|    488|        if (ret->content == NULL) {
  ------------------
  |  Branch (173:13): [True: 0, False: 488]
  ------------------
  174|      0|	    xmlBufMemoryError(ret, "creating buffer");
  175|      0|            xmlFree(ret);
  176|      0|            return(NULL);
  177|      0|        }
  178|    488|        ret->content[0] = 0;
  179|    488|    } else
  180|    109|	ret->content = NULL;
  181|    597|    ret->contentIO = NULL;
  182|    597|    return(ret);
  183|    597|}
xmlBufDetach:
  196|    111|xmlBufDetach(xmlBufPtr buf) {
  197|    111|    xmlChar *ret;
  198|       |
  199|    111|    if (buf == NULL)
  ------------------
  |  Branch (199:9): [True: 0, False: 111]
  ------------------
  200|      0|        return(NULL);
  201|    111|    if (buf->buffer != NULL)
  ------------------
  |  Branch (201:9): [True: 0, False: 111]
  ------------------
  202|      0|        return(NULL);
  203|    111|    if (buf->error)
  ------------------
  |  Branch (203:9): [True: 0, False: 111]
  ------------------
  204|      0|        return(NULL);
  205|       |
  206|    111|    ret = buf->content;
  207|    111|    buf->content = NULL;
  208|    111|    buf->size = 0;
  209|    111|    buf->use = 0;
  210|    111|    UPDATE_COMPAT(buf);
  ------------------
  |  |   61|    111|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 111, False: 0]
  |  |  ------------------
  |  |   62|    111|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    111|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 111, False: 0]
  |  |  ------------------
  |  |   64|    111|     else buf->compat_use = INT_MAX;
  ------------------
  211|       |
  212|    111|    return ret;
  213|    111|}
xmlBufSetAllocationScheme:
  242|    597|                          xmlBufferAllocationScheme scheme) {
  243|    597|    if ((buf == NULL) || (buf->error != 0)) {
  ------------------
  |  Branch (243:9): [True: 0, False: 597]
  |  Branch (243:26): [True: 0, False: 597]
  ------------------
  244|      0|        return(-1);
  245|      0|    }
  246|    597|    if (buf->alloc == XML_BUFFER_ALLOC_IO)
  ------------------
  |  Branch (246:9): [True: 0, False: 597]
  ------------------
  247|      0|        return(-1);
  248|    597|    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||
  ------------------
  |  Branch (248:9): [True: 597, False: 0]
  ------------------
  249|    597|        (scheme == XML_BUFFER_ALLOC_EXACT) ||
  ------------------
  |  Branch (249:9): [True: 0, False: 0]
  ------------------
  250|    597|        (scheme == XML_BUFFER_ALLOC_HYBRID) ||
  ------------------
  |  Branch (250:9): [True: 0, False: 0]
  ------------------
  251|    597|	(scheme == XML_BUFFER_ALLOC_BOUNDED)) {
  ------------------
  |  Branch (251:2): [True: 0, False: 0]
  ------------------
  252|    597|	buf->alloc = scheme;
  253|    597|        if (buf->buffer)
  ------------------
  |  Branch (253:13): [True: 0, False: 597]
  ------------------
  254|      0|            buf->buffer->alloc = scheme;
  255|    597|        return(0);
  256|    597|    }
  257|       |    /*
  258|       |     * Switching a buffer ALLOC_IO has the side effect of initializing
  259|       |     * the contentIO field with the current content
  260|       |     */
  261|      0|    if (scheme == XML_BUFFER_ALLOC_IO) {
  ------------------
  |  Branch (261:9): [True: 0, False: 0]
  ------------------
  262|      0|        buf->alloc = XML_BUFFER_ALLOC_IO;
  263|      0|        buf->contentIO = buf->content;
  264|      0|    }
  265|      0|    return(-1);
  266|    597|}
xmlBufFree:
  276|    597|xmlBufFree(xmlBufPtr buf) {
  277|    597|    if (buf == NULL) {
  ------------------
  |  Branch (277:9): [True: 0, False: 597]
  ------------------
  278|      0|	return;
  279|      0|    }
  280|       |
  281|    597|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&
  ------------------
  |  Branch (281:9): [True: 0, False: 597]
  ------------------
  282|    597|        (buf->contentIO != NULL)) {
  ------------------
  |  Branch (282:9): [True: 0, False: 0]
  ------------------
  283|      0|        xmlFree(buf->contentIO);
  284|    597|    } else if (buf->content != NULL) {
  ------------------
  |  Branch (284:16): [True: 486, False: 111]
  ------------------
  285|    486|        xmlFree(buf->content);
  286|    486|    }
  287|    597|    xmlFree(buf);
  288|    597|}
xmlBufShrink:
  328|    107|xmlBufShrink(xmlBufPtr buf, size_t len) {
  329|    107|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (329:9): [True: 0, False: 107]
  |  Branch (329:26): [True: 0, False: 107]
  ------------------
  330|    107|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    107|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 107]
  |  |  ------------------
  |  |   73|    107|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    107|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 107]
  |  |  ------------------
  |  |   76|    107|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  331|    107|    if (len == 0) return(0);
  ------------------
  |  Branch (331:9): [True: 0, False: 107]
  ------------------
  332|    107|    if (len > buf->use) return(0);
  ------------------
  |  Branch (332:9): [True: 0, False: 107]
  ------------------
  333|       |
  334|    107|    buf->use -= len;
  335|    107|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (335:9): [True: 0, False: 107]
  |  Branch (335:48): [True: 0, False: 0]
  ------------------
  336|       |	/*
  337|       |	 * we just move the content pointer, but also make sure
  338|       |	 * the perceived buffer size has shrunk accordingly
  339|       |	 */
  340|      0|        buf->content += len;
  341|      0|	buf->size -= len;
  342|       |
  343|       |        /*
  344|       |	 * sometimes though it maybe be better to really shrink
  345|       |	 * on IO buffers
  346|       |	 */
  347|      0|	if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (347:6): [True: 0, False: 0]
  |  Branch (347:45): [True: 0, False: 0]
  ------------------
  348|      0|	    size_t start_buf = buf->content - buf->contentIO;
  349|      0|	    if (start_buf >= buf->size) {
  ------------------
  |  Branch (349:10): [True: 0, False: 0]
  ------------------
  350|      0|		memmove(buf->contentIO, &buf->content[0], buf->use);
  351|      0|		buf->content = buf->contentIO;
  352|      0|		buf->content[buf->use] = 0;
  353|      0|		buf->size += start_buf;
  354|      0|	    }
  355|      0|	}
  356|    107|    } else {
  357|    107|	memmove(buf->content, &buf->content[len], buf->use);
  358|    107|	buf->content[buf->use] = 0;
  359|    107|    }
  360|    107|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    107|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 107, False: 0]
  |  |  ------------------
  |  |   62|    107|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    107|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 107, False: 0]
  |  |  ------------------
  |  |   64|    107|     else buf->compat_use = INT_MAX;
  ------------------
  361|    107|    return(len);
  362|    107|}
xmlBufGrow:
  443|  24.6k|xmlBufGrow(xmlBufPtr buf, int len) {
  444|  24.6k|    size_t ret;
  445|       |
  446|  24.6k|    if ((buf == NULL) || (len < 0)) return(-1);
  ------------------
  |  Branch (446:9): [True: 0, False: 24.6k]
  |  Branch (446:26): [True: 0, False: 24.6k]
  ------------------
  447|  24.6k|    if (len == 0)
  ------------------
  |  Branch (447:9): [True: 0, False: 24.6k]
  ------------------
  448|      0|        return(0);
  449|  24.6k|    ret = xmlBufGrowInternal(buf, len);
  450|  24.6k|    if (buf->error != 0)
  ------------------
  |  Branch (450:9): [True: 0, False: 24.6k]
  ------------------
  451|      0|        return(-1);
  452|  24.6k|    return(ret > INT_MAX ? INT_MAX : ret);
  ------------------
  |  Branch (452:12): [True: 0, False: 24.6k]
  ------------------
  453|  24.6k|}
xmlBufEnd:
  509|  24.6k|{
  510|  24.6k|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (510:9): [True: 0, False: 24.6k]
  |  Branch (510:19): [True: 0, False: 24.6k]
  ------------------
  511|      0|        return NULL;
  512|  24.6k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  24.6k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   73|  24.6k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  24.6k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   76|  24.6k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  513|       |
  514|  24.6k|    return(&buf->content[buf->use]);
  515|  24.6k|}
xmlBufAddLen:
  529|  24.6k|xmlBufAddLen(xmlBufPtr buf, size_t len) {
  530|  24.6k|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (530:9): [True: 0, False: 24.6k]
  |  Branch (530:26): [True: 0, False: 24.6k]
  ------------------
  531|      0|        return(-1);
  532|  24.6k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  24.6k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   73|  24.6k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  24.6k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   76|  24.6k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  533|  24.6k|    if (len >= (buf->size - buf->use))
  ------------------
  |  Branch (533:9): [True: 0, False: 24.6k]
  ------------------
  534|      0|        return(-1);
  535|  24.6k|    buf->use += len;
  536|  24.6k|    buf->content[buf->use] = 0;
  537|  24.6k|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|  24.6k|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 24.6k, False: 0]
  |  |  ------------------
  |  |   62|  24.6k|     else buf->compat_size = INT_MAX;			    \
  |  |   63|  24.6k|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 24.6k, False: 0]
  |  |  ------------------
  |  |   64|  24.6k|     else buf->compat_use = INT_MAX;
  ------------------
  538|  24.6k|    return(0);
  539|  24.6k|}
xmlBufIsEmpty:
  611|    109|{
  612|    109|    if ((!buf) || (buf->error))
  ------------------
  |  Branch (612:9): [True: 0, False: 109]
  |  Branch (612:19): [True: 0, False: 109]
  ------------------
  613|      0|        return(-1);
  614|    109|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    109|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 109]
  |  |  ------------------
  |  |   73|    109|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    109|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 109]
  |  |  ------------------
  |  |   76|    109|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  615|       |
  616|    109|    return(buf->use == 0);
  617|    109|}
xmlBufResize:
  630|    110|{
  631|    110|    size_t newSize;
  632|    110|    xmlChar* rebuf = NULL;
  633|    110|    size_t start_buf;
  634|       |
  635|    110|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (635:9): [True: 0, False: 110]
  |  Branch (635:26): [True: 0, False: 110]
  ------------------
  636|      0|        return(0);
  637|    110|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    110|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 110]
  |  |  ------------------
  |  |   73|    110|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    110|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 110]
  |  |  ------------------
  |  |   76|    110|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  638|       |
  639|    110|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (639:9): [True: 0, False: 110]
  ------------------
  640|       |        /*
  641|       |	 * Used to provide parsing limits
  642|       |	 */
  643|      0|        if (size >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (643:13): [True: 0, False: 0]
  ------------------
  644|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  645|      0|	    return(0);
  646|      0|	}
  647|      0|    }
  648|       |
  649|       |    /* Don't resize if we don't have to */
  650|    110|    if (size < buf->size)
  ------------------
  |  Branch (650:9): [True: 0, False: 110]
  ------------------
  651|      0|        return 1;
  652|       |
  653|       |    /* figure out new size */
  654|    110|    switch (buf->alloc){
  655|      0|	case XML_BUFFER_ALLOC_IO:
  ------------------
  |  Branch (655:2): [True: 0, False: 110]
  ------------------
  656|    110|	case XML_BUFFER_ALLOC_DOUBLEIT:
  ------------------
  |  Branch (656:2): [True: 110, False: 0]
  ------------------
  657|       |	    /*take care of empty case*/
  658|    110|            if (buf->size == 0) {
  ------------------
  |  Branch (658:17): [True: 109, False: 1]
  ------------------
  659|    109|                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|    109|#define SIZE_MAX ((size_t) -1)
  ------------------
                              newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (659:28): [True: 0, False: 109]
  ------------------
  660|    109|            } else {
  661|      1|                newSize = buf->size;
  662|      1|            }
  663|    111|	    while (size > newSize) {
  ------------------
  |  Branch (663:13): [True: 1, False: 110]
  ------------------
  664|      1|	        if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      1|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (664:14): [True: 0, False: 1]
  ------------------
  665|      0|	            xmlBufMemoryError(buf, "growing buffer");
  666|      0|	            return 0;
  667|      0|	        }
  668|      1|	        newSize *= 2;
  669|      1|	    }
  670|    110|	    break;
  671|    110|	case XML_BUFFER_ALLOC_EXACT:
  ------------------
  |  Branch (671:2): [True: 0, False: 110]
  ------------------
  672|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (672:24): [True: 0, False: 0]
  ------------------
  673|      0|	    break;
  674|      0|        case XML_BUFFER_ALLOC_HYBRID:
  ------------------
  |  Branch (674:9): [True: 0, False: 110]
  ------------------
  675|      0|            if (buf->use < BASE_BUFFER_SIZE)
  ------------------
  |  |   58|      0|#define BASE_BUFFER_SIZE 4096
  ------------------
  |  Branch (675:17): [True: 0, False: 0]
  ------------------
  676|      0|                newSize = size;
  677|      0|            else {
  678|      0|                newSize = buf->size;
  679|      0|                while (size > newSize) {
  ------------------
  |  Branch (679:24): [True: 0, False: 0]
  ------------------
  680|      0|                    if (newSize > SIZE_MAX / 2) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (680:25): [True: 0, False: 0]
  ------------------
  681|      0|                        xmlBufMemoryError(buf, "growing buffer");
  682|      0|                        return 0;
  683|      0|                    }
  684|      0|                    newSize *= 2;
  685|      0|                }
  686|      0|            }
  687|      0|            break;
  688|       |
  689|      0|	default:
  ------------------
  |  Branch (689:2): [True: 0, False: 110]
  ------------------
  690|      0|            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                          newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (690:24): [True: 0, False: 0]
  ------------------
  691|      0|	    break;
  692|    110|    }
  693|       |
  694|    110|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (694:9): [True: 0, False: 110]
  |  Branch (694:48): [True: 0, False: 0]
  ------------------
  695|      0|        start_buf = buf->content - buf->contentIO;
  696|       |
  697|      0|        if (start_buf > newSize) {
  ------------------
  |  Branch (697:13): [True: 0, False: 0]
  ------------------
  698|       |	    /* move data back to start */
  699|      0|	    memmove(buf->contentIO, buf->content, buf->use);
  700|      0|	    buf->content = buf->contentIO;
  701|      0|	    buf->content[buf->use] = 0;
  702|      0|	    buf->size += start_buf;
  703|      0|	} else {
  704|      0|	    rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);
  705|      0|	    if (rebuf == NULL) {
  ------------------
  |  Branch (705:10): [True: 0, False: 0]
  ------------------
  706|      0|		xmlBufMemoryError(buf, "growing buffer");
  707|      0|		return 0;
  708|      0|	    }
  709|      0|	    buf->contentIO = rebuf;
  710|      0|	    buf->content = rebuf + start_buf;
  711|      0|	}
  712|    110|    } else {
  713|    110|	if (buf->content == NULL) {
  ------------------
  |  Branch (713:6): [True: 109, False: 1]
  ------------------
  714|    109|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  715|    109|	    buf->use = 0;
  716|    109|            if (rebuf != NULL)
  ------------------
  |  Branch (716:17): [True: 109, False: 0]
  ------------------
  717|    109|	        rebuf[buf->use] = 0;
  718|    109|	} else if (buf->size - buf->use < 100) {
  ------------------
  |  Branch (718:13): [True: 1, False: 0]
  ------------------
  719|      1|	    rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);
  720|      1|        } else {
  721|       |	    /*
  722|       |	     * if we are reallocating a buffer far from being full, it's
  723|       |	     * better to make a new allocation and copy only the used range
  724|       |	     * and free the old one.
  725|       |	     */
  726|      0|	    rebuf = (xmlChar *) xmlMallocAtomic(newSize);
  727|      0|	    if (rebuf != NULL) {
  ------------------
  |  Branch (727:10): [True: 0, False: 0]
  ------------------
  728|      0|		memcpy(rebuf, buf->content, buf->use);
  729|      0|		xmlFree(buf->content);
  730|      0|		rebuf[buf->use] = 0;
  731|      0|	    }
  732|      0|	}
  733|    110|	if (rebuf == NULL) {
  ------------------
  |  Branch (733:6): [True: 0, False: 110]
  ------------------
  734|      0|	    xmlBufMemoryError(buf, "growing buffer");
  735|      0|	    return 0;
  736|      0|	}
  737|    110|	buf->content = rebuf;
  738|    110|    }
  739|    110|    buf->size = newSize;
  740|    110|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    110|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 110, False: 0]
  |  |  ------------------
  |  |   62|    110|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    110|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 110, False: 0]
  |  |  ------------------
  |  |   64|    110|     else buf->compat_use = INT_MAX;
  ------------------
  741|       |
  742|    110|    return 1;
  743|    110|}
xmlBufAdd:
  758|    215|xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {
  759|    215|    size_t needSize;
  760|       |
  761|    215|    if ((str == NULL) || (buf == NULL) || (buf->error))
  ------------------
  |  Branch (761:9): [True: 0, False: 215]
  |  Branch (761:26): [True: 0, False: 215]
  |  Branch (761:43): [True: 0, False: 215]
  ------------------
  762|      0|	return -1;
  763|    215|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    215|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 215]
  |  |  ------------------
  |  |   73|    215|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    215|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 215]
  |  |  ------------------
  |  |   76|    215|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  764|       |
  765|    215|    if (len < -1) {
  ------------------
  |  Branch (765:9): [True: 0, False: 215]
  ------------------
  766|      0|	return -1;
  767|      0|    }
  768|    215|    if (len == 0) return 0;
  ------------------
  |  Branch (768:9): [True: 0, False: 215]
  ------------------
  769|       |
  770|    215|    if (len < 0)
  ------------------
  |  Branch (770:9): [True: 106, False: 109]
  ------------------
  771|    106|        len = xmlStrlen(str);
  772|       |
  773|    215|    if (len < 0) return -1;
  ------------------
  |  Branch (773:9): [True: 0, False: 215]
  ------------------
  774|    215|    if (len == 0) return 0;
  ------------------
  |  Branch (774:9): [True: 0, False: 215]
  ------------------
  775|       |
  776|       |    /* Note that both buf->size and buf->use can be zero here. */
  777|    215|    if ((size_t) len >= buf->size - buf->use) {
  ------------------
  |  Branch (777:9): [True: 110, False: 105]
  ------------------
  778|    110|        if ((size_t) len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|    110|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (778:13): [True: 0, False: 110]
  ------------------
  779|      0|            xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  780|      0|            return(-1);
  781|      0|        }
  782|    110|        needSize = buf->use + len + 1;
  783|    110|	if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (783:6): [True: 0, False: 110]
  ------------------
  784|       |	    /*
  785|       |	     * Used to provide parsing limits
  786|       |	     */
  787|      0|	    if (needSize >= XML_MAX_TEXT_LENGTH) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (787:10): [True: 0, False: 0]
  ------------------
  788|      0|		xmlBufMemoryError(buf, "buffer error: text too long\n");
  789|      0|		return(-1);
  790|      0|	    }
  791|      0|	}
  792|    110|        if (!xmlBufResize(buf, needSize)){
  ------------------
  |  Branch (792:13): [True: 0, False: 110]
  ------------------
  793|      0|	    xmlBufMemoryError(buf, "growing buffer");
  794|      0|            return XML_ERR_NO_MEMORY;
  795|      0|        }
  796|    110|    }
  797|       |
  798|    215|    memmove(&buf->content[buf->use], str, len);
  799|    215|    buf->use += len;
  800|    215|    buf->content[buf->use] = 0;
  801|    215|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|    215|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 215, False: 0]
  |  |  ------------------
  |  |   62|    215|     else buf->compat_size = INT_MAX;			    \
  |  |   63|    215|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 215, False: 0]
  |  |  ------------------
  |  |   64|    215|     else buf->compat_use = INT_MAX;
  ------------------
  802|    215|    return 0;
  803|    215|}
xmlBufCat:
  816|    106|xmlBufCat(xmlBufPtr buf, const xmlChar *str) {
  817|    106|    if ((buf == NULL) || (buf->error))
  ------------------
  |  Branch (817:9): [True: 0, False: 106]
  |  Branch (817:26): [True: 0, False: 106]
  ------------------
  818|      0|        return(-1);
  819|    106|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    106|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 106]
  |  |  ------------------
  |  |   73|    106|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    106|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 106]
  |  |  ------------------
  |  |   76|    106|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  820|    106|    if (str == NULL) return -1;
  ------------------
  |  Branch (820:9): [True: 0, False: 106]
  ------------------
  821|    106|    return xmlBufAdd(buf, str, -1);
  822|    106|}
xmlBufResetInput:
 1019|    486|xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input) {
 1020|    486|    if (input == NULL)
  ------------------
  |  Branch (1020:9): [True: 0, False: 486]
  ------------------
 1021|      0|        return(-1);
 1022|    486|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1022:9): [True: 0, False: 486]
  |  Branch (1022:26): [True: 0, False: 486]
  ------------------
 1023|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1024|      0|        return(-1);
 1025|      0|    }
 1026|    486|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|    486|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 486]
  |  |  ------------------
  |  |   73|    486|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|    486|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 486]
  |  |  ------------------
  |  |   76|    486|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1027|    486|    input->base = input->cur = buf->content;
 1028|    486|    input->end = &buf->content[buf->use];
 1029|    486|    return(0);
 1030|    486|}
xmlBufUpdateInput:
 1044|  24.7k|xmlBufUpdateInput(xmlBufPtr buf, xmlParserInputPtr input, size_t pos) {
 1045|  24.7k|    if (input == NULL)
  ------------------
  |  Branch (1045:9): [True: 0, False: 24.7k]
  ------------------
 1046|      0|        return(-1);
 1047|       |    /*
 1048|       |     * TODO: It might be safer to keep using the buffer content if there
 1049|       |     * was an error.
 1050|       |     */
 1051|  24.7k|    if ((buf == NULL) || (buf->error)) {
  ------------------
  |  Branch (1051:9): [True: 0, False: 24.7k]
  |  Branch (1051:26): [True: 0, False: 24.7k]
  ------------------
 1052|      0|        input->base = input->cur = input->end = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1053|      0|        return(-1);
 1054|      0|    }
 1055|  24.7k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  24.7k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 24.7k]
  |  |  ------------------
  |  |   73|  24.7k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  24.7k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 24.7k]
  |  |  ------------------
  |  |   76|  24.7k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
 1056|  24.7k|    input->base = buf->content;
 1057|  24.7k|    input->cur = input->base + pos;
 1058|  24.7k|    input->end = &buf->content[buf->use];
 1059|  24.7k|    return(0);
 1060|  24.7k|}
buf.c:xmlBufGrowInternal:
  376|  24.6k|xmlBufGrowInternal(xmlBufPtr buf, size_t len) {
  377|  24.6k|    size_t size;
  378|  24.6k|    xmlChar *newbuf;
  379|       |
  380|  24.6k|    if ((buf == NULL) || (buf->error != 0)) return(0);
  ------------------
  |  Branch (380:9): [True: 0, False: 24.6k]
  |  Branch (380:26): [True: 0, False: 24.6k]
  ------------------
  381|  24.6k|    CHECK_COMPAT(buf)
  ------------------
  |  |   72|  24.6k|     if (buf->size != (size_t) buf->compat_size)	    \
  |  |  ------------------
  |  |  |  Branch (72:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   73|  24.6k|         if (buf->compat_size < INT_MAX)		    \
  |  |  ------------------
  |  |  |  Branch (73:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   74|      0|	     buf->size = buf->compat_size;		    \
  |  |   75|  24.6k|     if (buf->use != (size_t) buf->compat_use)		    \
  |  |  ------------------
  |  |  |  Branch (75:10): [True: 0, False: 24.6k]
  |  |  ------------------
  |  |   76|  24.6k|         if (buf->compat_use < INT_MAX)			    \
  |  |  ------------------
  |  |  |  Branch (76:14): [True: 0, False: 0]
  |  |  ------------------
  |  |   77|      0|	     buf->use = buf->compat_use;
  ------------------
  382|       |
  383|  24.6k|    if (len < buf->size - buf->use)
  ------------------
  |  Branch (383:9): [True: 24.6k, False: 0]
  ------------------
  384|  24.6k|        return(buf->size - buf->use - 1);
  385|      0|    if (len >= SIZE_MAX - buf->use) {
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (385:9): [True: 0, False: 0]
  ------------------
  386|      0|        xmlBufMemoryError(buf, "growing buffer past SIZE_MAX");
  387|      0|        return(0);
  388|      0|    }
  389|       |
  390|      0|    if (buf->size > (size_t) len) {
  ------------------
  |  Branch (390:9): [True: 0, False: 0]
  ------------------
  391|      0|        size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = buf->size > SIZE_MAX / 2 ? SIZE_MAX : buf->size * 2;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (391:16): [True: 0, False: 0]
  ------------------
  392|      0|    } else {
  393|      0|        size = buf->use + len;
  394|      0|        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
                      size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;
  ------------------
  |  |   30|      0|#define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (394:16): [True: 0, False: 0]
  ------------------
  395|      0|    }
  396|       |
  397|      0|    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {
  ------------------
  |  Branch (397:9): [True: 0, False: 0]
  ------------------
  398|       |        /*
  399|       |	 * Used to provide parsing limits
  400|       |	 */
  401|      0|        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (401:13): [True: 0, False: 0]
  ------------------
  402|      0|	    (buf->size >= XML_MAX_TEXT_LENGTH)) {
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (402:6): [True: 0, False: 0]
  ------------------
  403|      0|	    xmlBufMemoryError(buf, "buffer error: text too long\n");
  404|      0|	    return(0);
  405|      0|	}
  406|      0|	if (size >= XML_MAX_TEXT_LENGTH)
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  |  Branch (406:6): [True: 0, False: 0]
  ------------------
  407|      0|	    size = XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
  408|      0|    }
  409|      0|    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {
  ------------------
  |  Branch (409:9): [True: 0, False: 0]
  |  Branch (409:48): [True: 0, False: 0]
  ------------------
  410|      0|        size_t start_buf = buf->content - buf->contentIO;
  411|       |
  412|      0|	newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);
  413|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (413:6): [True: 0, False: 0]
  ------------------
  414|      0|	    xmlBufMemoryError(buf, "growing buffer");
  415|      0|	    return(0);
  416|      0|	}
  417|      0|	buf->contentIO = newbuf;
  418|      0|	buf->content = newbuf + start_buf;
  419|      0|    } else {
  420|      0|	newbuf = (xmlChar *) xmlRealloc(buf->content, size);
  421|      0|	if (newbuf == NULL) {
  ------------------
  |  Branch (421:6): [True: 0, False: 0]
  ------------------
  422|      0|	    xmlBufMemoryError(buf, "growing buffer");
  423|      0|	    return(0);
  424|      0|	}
  425|      0|	buf->content = newbuf;
  426|      0|    }
  427|      0|    buf->size = size;
  428|      0|    UPDATE_COMPAT(buf)
  ------------------
  |  |   61|      0|     if (buf->size < INT_MAX) buf->compat_size = buf->size; \
  |  |  ------------------
  |  |  |  Branch (61:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   62|      0|     else buf->compat_size = INT_MAX;			    \
  |  |   63|      0|     if (buf->use < INT_MAX) buf->compat_use = buf->use; \
  |  |  ------------------
  |  |  |  Branch (63:10): [True: 0, False: 0]
  |  |  ------------------
  |  |   64|      0|     else buf->compat_use = INT_MAX;
  ------------------
  429|      0|    return(buf->size - buf->use - 1);
  430|      0|}

xmlCharInRange:
  170|     51|xmlCharInRange (unsigned int val, const xmlChRangeGroup *rptr) {
  171|     51|    int low, high, mid;
  172|     51|    const xmlChSRange *sptr;
  173|     51|    const xmlChLRange *lptr;
  174|       |
  175|     51|    if (rptr == NULL) return(0);
  ------------------
  |  Branch (175:9): [True: 0, False: 51]
  ------------------
  176|     51|    if (val < 0x10000) {	/* is val in 'short' or 'long'  array? */
  ------------------
  |  Branch (176:9): [True: 51, False: 0]
  ------------------
  177|     51|	if (rptr->nbShortRange == 0)
  ------------------
  |  Branch (177:6): [True: 0, False: 51]
  ------------------
  178|      0|	    return 0;
  179|     51|	low = 0;
  180|     51|	high = rptr->nbShortRange - 1;
  181|     51|	sptr = rptr->shortRange;
  182|    360|	while (low <= high) {
  ------------------
  |  Branch (182:9): [True: 360, False: 0]
  ------------------
  183|    360|	    mid = (low + high) / 2;
  184|    360|	    if ((unsigned short) val < sptr[mid].low) {
  ------------------
  |  Branch (184:10): [True: 303, False: 57]
  ------------------
  185|    303|		high = mid - 1;
  186|    303|	    } else {
  187|     57|	        if ((unsigned short) val > sptr[mid].high) {
  ------------------
  |  Branch (187:14): [True: 6, False: 51]
  ------------------
  188|      6|		    low = mid + 1;
  189|     51|		} else {
  190|     51|		    return 1;
  191|     51|		}
  192|     57|	    }
  193|    360|	}
  194|     51|    } else {
  195|      0|	if (rptr->nbLongRange == 0) {
  ------------------
  |  Branch (195:6): [True: 0, False: 0]
  ------------------
  196|      0|	    return 0;
  197|      0|	}
  198|      0|	low = 0;
  199|      0|	high = rptr->nbLongRange - 1;
  200|      0|	lptr = rptr->longRange;
  201|      0|	while (low <= high) {
  ------------------
  |  Branch (201:9): [True: 0, False: 0]
  ------------------
  202|      0|	    mid = (low + high) / 2;
  203|      0|	    if (val < lptr[mid].low) {
  ------------------
  |  Branch (203:10): [True: 0, False: 0]
  ------------------
  204|      0|		high = mid - 1;
  205|      0|	    } else {
  206|      0|	        if (val > lptr[mid].high) {
  ------------------
  |  Branch (206:14): [True: 0, False: 0]
  ------------------
  207|      0|		    low = mid + 1;
  208|      0|		} else {
  209|      0|		    return 1;
  210|      0|		}
  211|      0|	    }
  212|      0|	}
  213|      0|    }
  214|      0|    return 0;
  215|     51|}

xmlInitDictInternal:
   99|      2|xmlInitDictInternal(void) {
  100|      2|    xmlInitMutex(&xmlDictMutex);
  101|      2|}
xmlDictCreate:
  262|    486|xmlDictCreate(void) {
  263|    486|    xmlDictPtr dict;
  264|       |
  265|    486|    xmlInitParser();
  266|       |
  267|    486|    dict = xmlMalloc(sizeof(xmlDict));
  268|    486|    if (dict == NULL)
  ------------------
  |  Branch (268:9): [True: 0, False: 486]
  ------------------
  269|      0|        return(NULL);
  270|    486|    dict->ref_counter = 1;
  271|    486|    dict->limit = 0;
  272|       |
  273|    486|    dict->size = 0;
  274|    486|    dict->nbElems = 0;
  275|    486|    dict->table = NULL;
  276|    486|    dict->strings = NULL;
  277|    486|    dict->subdict = NULL;
  278|    486|    dict->seed = xmlRandom();
  279|    486|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  280|    486|    dict->seed = 0;
  281|    486|#endif
  282|    486|    return(dict);
  283|    486|}
xmlDictReference:
  317|    574|xmlDictReference(xmlDictPtr dict) {
  318|    574|    if (dict == NULL) return -1;
  ------------------
  |  Branch (318:9): [True: 0, False: 574]
  ------------------
  319|    574|    xmlMutexLock(&xmlDictMutex);
  320|    574|    dict->ref_counter++;
  321|    574|    xmlMutexUnlock(&xmlDictMutex);
  322|    574|    return(0);
  323|    574|}
xmlDictFree:
  333|  1.06k|xmlDictFree(xmlDictPtr dict) {
  334|  1.06k|    xmlDictStringsPtr pool, nextp;
  335|       |
  336|  1.06k|    if (dict == NULL)
  ------------------
  |  Branch (336:9): [True: 0, False: 1.06k]
  ------------------
  337|      0|	return;
  338|       |
  339|       |    /* decrement the counter, it may be shared by a parser and docs */
  340|  1.06k|    xmlMutexLock(&xmlDictMutex);
  341|  1.06k|    dict->ref_counter--;
  342|  1.06k|    if (dict->ref_counter > 0) {
  ------------------
  |  Branch (342:9): [True: 574, False: 486]
  ------------------
  343|    574|        xmlMutexUnlock(&xmlDictMutex);
  344|    574|        return;
  345|    574|    }
  346|       |
  347|    486|    xmlMutexUnlock(&xmlDictMutex);
  348|       |
  349|    486|    if (dict->subdict != NULL) {
  ------------------
  |  Branch (349:9): [True: 0, False: 486]
  ------------------
  350|      0|        xmlDictFree(dict->subdict);
  351|      0|    }
  352|       |
  353|    486|    if (dict->table) {
  ------------------
  |  Branch (353:9): [True: 486, False: 0]
  ------------------
  354|    486|	xmlFree(dict->table);
  355|    486|    }
  356|    486|    pool = dict->strings;
  357|    972|    while (pool != NULL) {
  ------------------
  |  Branch (357:12): [True: 486, False: 486]
  ------------------
  358|    486|        nextp = pool->next;
  359|    486|	xmlFree(pool);
  360|    486|	pool = nextp;
  361|    486|    }
  362|    486|    xmlFree(dict);
  363|    486|}
xmlDictOwns:
  376|  11.1k|xmlDictOwns(xmlDictPtr dict, const xmlChar *str) {
  377|  11.1k|    xmlDictStringsPtr pool;
  378|       |
  379|  11.1k|    if ((dict == NULL) || (str == NULL))
  ------------------
  |  Branch (379:9): [True: 0, False: 11.1k]
  |  Branch (379:27): [True: 0, False: 11.1k]
  ------------------
  380|      0|	return(-1);
  381|  11.1k|    pool = dict->strings;
  382|  14.0k|    while (pool != NULL) {
  ------------------
  |  Branch (382:12): [True: 11.1k, False: 2.96k]
  ------------------
  383|  11.1k|        if ((str >= &pool->array[0]) && (str <= pool->free))
  ------------------
  |  Branch (383:13): [True: 8.77k, False: 2.34k]
  |  Branch (383:41): [True: 8.15k, False: 618]
  ------------------
  384|  8.15k|	    return(1);
  385|  2.96k|	pool = pool->next;
  386|  2.96k|    }
  387|  2.96k|    if (dict->subdict)
  ------------------
  |  Branch (387:9): [True: 0, False: 2.96k]
  ------------------
  388|      0|        return(xmlDictOwns(dict->subdict, str));
  389|  2.96k|    return(0);
  390|  2.96k|}
xmlDictSetLimit:
  421|    486|xmlDictSetLimit(xmlDictPtr dict, size_t limit) {
  422|    486|    size_t ret;
  423|       |
  424|    486|    if (dict == NULL)
  ------------------
  |  Branch (424:9): [True: 0, False: 486]
  ------------------
  425|      0|	return(0);
  426|    486|    ret = dict->limit;
  427|    486|    dict->limit = limit;
  428|    486|    return(ret);
  429|    486|}
xmlDictComputeHash:
  512|     12|xmlDictComputeHash(const xmlDict *dict, const xmlChar *string) {
  513|     12|    size_t len;
  514|     12|    return(xmlDictHashName(dict->seed, string, SIZE_MAX, &len));
  ------------------
  |  |   35|     12|  #define SIZE_MAX ((size_t) -1)
  ------------------
  515|     12|}
xmlDictCombineHash:
  521|    224|xmlDictCombineHash(unsigned v1, unsigned v2) {
  522|       |    /*
  523|       |     * The upper bit of hash values is always set, so we have to operate on
  524|       |     * 31-bit hashes here.
  525|       |     */
  526|    224|    v1 ^= v2;
  527|    224|    v1 += HASH_ROL31(v2, 5);
  ------------------
  |  |  517|    224|#define HASH_ROL31(x,n) ((x) << (n) | ((x) & 0x7FFFFFFF) >> (31 - (n)))
  ------------------
  528|       |
  529|    224|    return((v1 & 0xFFFFFFFF) | 0x80000000);
  530|    224|}
xmlDictLookup:
  824|  6.11k|xmlDictLookup(xmlDictPtr dict, const xmlChar *name, int len) {
  825|  6.11k|    const xmlDictEntry *entry;
  826|       |
  827|  6.11k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  828|  6.11k|    if (entry == NULL)
  ------------------
  |  Branch (828:9): [True: 88, False: 6.02k]
  ------------------
  829|     88|        return(NULL);
  830|  6.02k|    return(entry->name);
  831|  6.11k|}
xmlDictLookupHashed:
  845|  3.93k|xmlDictLookupHashed(xmlDictPtr dict, const xmlChar *name, int len) {
  846|  3.93k|    const xmlDictEntry *entry;
  847|  3.93k|    xmlHashedString ret;
  848|       |
  849|  3.93k|    entry = xmlDictLookupInternal(dict, NULL, name, len, 1);
  850|       |
  851|  3.93k|    if (entry == NULL) {
  ------------------
  |  Branch (851:9): [True: 0, False: 3.93k]
  ------------------
  852|      0|        ret.name = NULL;
  853|      0|        ret.hashValue = 0;
  854|  3.93k|    } else {
  855|  3.93k|        ret = *entry;
  856|  3.93k|    }
  857|       |
  858|  3.93k|    return(ret);
  859|  3.93k|}
xmlDictQLookup:
  894|      1|xmlDictQLookup(xmlDictPtr dict, const xmlChar *prefix, const xmlChar *name) {
  895|      1|    const xmlDictEntry *entry;
  896|       |
  897|      1|    entry = xmlDictLookupInternal(dict, prefix, name, -1, 1);
  898|      1|    if (entry == NULL)
  ------------------
  |  Branch (898:9): [True: 0, False: 1]
  ------------------
  899|      0|        return(NULL);
  900|      1|    return(entry->name);
  901|      1|}
xmlInitRandom:
  918|      2|xmlInitRandom(void) {
  919|      2|    int var;
  920|       |
  921|      2|    xmlInitMutex(&xmlRngMutex);
  922|       |
  923|       |    /* TODO: Get seed values from system PRNG */
  924|       |
  925|      2|    globalRngState[0] = (unsigned) time(NULL) ^
  926|      2|                        HASH_ROL((unsigned) (size_t) &xmlInitRandom, 8);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  927|      2|    globalRngState[1] = HASH_ROL((unsigned) (size_t) &xmlRngMutex, 16) ^
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  928|      2|                        HASH_ROL((unsigned) (size_t) &var, 24);
  ------------------
  |  |   12|      2|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  929|      2|}
xmlRandom:
  951|  1.55k|xmlRandom(void) {
  952|  1.55k|#ifdef XML_THREAD_LOCAL
  953|  1.55k|    if (!localRngInitialized) {
  ------------------
  |  Branch (953:9): [True: 1, False: 1.55k]
  ------------------
  954|      1|        xmlMutexLock(&xmlRngMutex);
  955|      1|        localRngState[0] = xoroshiro64ss(globalRngState);
  956|      1|        localRngState[1] = xoroshiro64ss(globalRngState);
  957|      1|        localRngInitialized = 1;
  958|      1|        xmlMutexUnlock(&xmlRngMutex);
  959|      1|    }
  960|       |
  961|  1.55k|    return(xoroshiro64ss(localRngState));
  962|       |#else
  963|       |    unsigned ret;
  964|       |
  965|       |    xmlMutexLock(&xmlRngMutex);
  966|       |    ret = xoroshiro64ss(globalRngState);
  967|       |    xmlMutexUnlock(&xmlRngMutex);
  968|       |
  969|       |    return(ret);
  970|       |#endif
  971|  1.55k|}
dict.c:xmlDictHashName:
  465|  9.97k|                size_t *plen) {
  466|  9.97k|    unsigned h1, h2;
  467|  9.97k|    size_t i;
  468|       |
  469|  9.97k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  9.97k|    do { \
  |  |   24|  9.97k|        h1 = seed ^ 0x3b00; \
  |  |   25|  9.97k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  9.97k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  9.97k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  470|       |
  471|  61.0k|    for (i = 0; i < maxLen && data[i]; i++) {
  ------------------
  |  Branch (471:17): [True: 51.5k, False: 9.50k]
  |  Branch (471:31): [True: 51.0k, False: 465]
  ------------------
  472|  51.0k|        HASH_UPDATE(h1, h2, data[i]);
  ------------------
  |  |   29|  51.0k|    do { \
  |  |   30|  51.0k|        h1 += ch; \
  |  |   31|  51.0k|        h1 += h1 << 3; \
  |  |   32|  51.0k|        h2 += h1; \
  |  |   33|  51.0k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  51.0k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  51.0k|        h2 += h2 << 2; \
  |  |   35|  51.0k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  473|  51.0k|    }
  474|       |
  475|  9.97k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  9.97k|    do { \
  |  |   40|  9.97k|        h1 ^= h2; \
  |  |   41|  9.97k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  9.97k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  9.97k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  9.97k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  9.97k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  9.97k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  9.97k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  9.97k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  9.97k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  9.97k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  476|       |
  477|  9.97k|    *plen = i;
  478|  9.97k|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|  9.97k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  479|  9.97k|}
dict.c:xmlDictLookupInternal:
  679|  10.0k|                      const xmlChar *name, int maybeLen, int update) {
  680|  10.0k|    xmlDictEntry *entry = NULL;
  681|  10.0k|    const xmlChar *ret;
  682|  10.0k|    unsigned hashValue;
  683|  10.0k|    size_t maxLen, len, plen, klen;
  684|  10.0k|    int found = 0;
  685|       |
  686|  10.0k|    if ((dict == NULL) || (name == NULL))
  ------------------
  |  Branch (686:9): [True: 0, False: 10.0k]
  |  Branch (686:27): [True: 88, False: 9.96k]
  ------------------
  687|     88|	return(NULL);
  688|       |
  689|  9.96k|    maxLen = (maybeLen < 0) ? SIZE_MAX : (size_t) maybeLen;
  ------------------
  |  |   35|    454|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (689:14): [True: 454, False: 9.50k]
  ------------------
  690|       |
  691|  9.96k|    if (prefix == NULL) {
  ------------------
  |  Branch (691:9): [True: 9.96k, False: 1]
  ------------------
  692|  9.96k|        hashValue = xmlDictHashName(dict->seed, name, maxLen, &len);
  693|  9.96k|        if (len > INT_MAX / 2)
  ------------------
  |  Branch (693:13): [True: 0, False: 9.96k]
  ------------------
  694|      0|            return(NULL);
  695|  9.96k|        klen = len;
  696|  9.96k|    } else {
  697|      1|        hashValue = xmlDictHashQName(dict->seed, prefix, name, &plen, &len);
  698|      1|        if ((len > INT_MAX / 2) || (plen >= INT_MAX / 2 - len))
  ------------------
  |  Branch (698:13): [True: 0, False: 1]
  |  Branch (698:36): [True: 0, False: 1]
  ------------------
  699|      0|            return(NULL);
  700|      1|        klen = plen + 1 + len;
  701|      1|    }
  702|       |
  703|  9.96k|    if ((dict->limit > 0) && (klen >= dict->limit))
  ------------------
  |  Branch (703:9): [True: 9.96k, False: 0]
  |  Branch (703:30): [True: 0, False: 9.96k]
  ------------------
  704|      0|        return(NULL);
  705|       |
  706|       |    /*
  707|       |     * Check for an existing entry
  708|       |     */
  709|  9.96k|    if (dict->size > 0)
  ------------------
  |  Branch (709:9): [True: 9.47k, False: 486]
  ------------------
  710|  9.47k|        entry = xmlDictFindEntry(dict, prefix, name, klen, hashValue, &found);
  711|  9.96k|    if (found)
  ------------------
  |  Branch (711:9): [True: 5.59k, False: 4.36k]
  ------------------
  712|  5.59k|        return(entry);
  713|       |
  714|  4.36k|    if ((dict->subdict != NULL) && (dict->subdict->size > 0)) {
  ------------------
  |  Branch (714:9): [True: 0, False: 4.36k]
  |  Branch (714:36): [True: 0, False: 0]
  ------------------
  715|      0|        xmlDictEntry *subEntry;
  716|      0|        unsigned subHashValue;
  717|       |
  718|      0|        if (prefix == NULL)
  ------------------
  |  Branch (718:13): [True: 0, False: 0]
  ------------------
  719|      0|            subHashValue = xmlDictHashName(dict->subdict->seed, name, len,
  720|      0|                                           &len);
  721|      0|        else
  722|      0|            subHashValue = xmlDictHashQName(dict->subdict->seed, prefix, name,
  723|      0|                                            &plen, &len);
  724|      0|        subEntry = xmlDictFindEntry(dict->subdict, prefix, name, klen,
  725|      0|                                    subHashValue, &found);
  726|      0|        if (found)
  ------------------
  |  Branch (726:13): [True: 0, False: 0]
  ------------------
  727|      0|            return(subEntry);
  728|      0|    }
  729|       |
  730|  4.36k|    if (!update)
  ------------------
  |  Branch (730:9): [True: 0, False: 4.36k]
  ------------------
  731|      0|        return(NULL);
  732|       |
  733|       |    /*
  734|       |     * Grow the hash table if needed
  735|       |     */
  736|  4.36k|    if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   39|  4.36k|#define MAX_FILL_DENOM 8
  ------------------
                  if (dict->nbElems + 1 > dict->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   38|  4.36k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (736:9): [True: 816, False: 3.55k]
  ------------------
  737|    816|        unsigned newSize, mask, displ, pos;
  738|       |
  739|    816|        if (dict->size == 0) {
  ------------------
  |  Branch (739:13): [True: 486, False: 330]
  ------------------
  740|    486|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   40|    486|#define MIN_HASH_SIZE 8
  ------------------
  741|    486|        } else {
  742|    330|            if (dict->size >= MAX_HASH_SIZE)
  ------------------
  |  |   41|    330|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (742:17): [True: 0, False: 330]
  ------------------
  743|      0|                return(NULL);
  744|    330|            newSize = dict->size * 2;
  745|    330|        }
  746|    816|        if (xmlDictGrow(dict, newSize) != 0)
  ------------------
  |  Branch (746:13): [True: 0, False: 816]
  ------------------
  747|      0|            return(NULL);
  748|       |
  749|       |        /*
  750|       |         * Find new entry
  751|       |         */
  752|    816|        mask = dict->size - 1;
  753|    816|        displ = 0;
  754|    816|        pos = hashValue & mask;
  755|    816|        entry = &dict->table[pos];
  756|       |
  757|  1.06k|        while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (757:16): [True: 256, False: 806]
  ------------------
  758|  1.06k|               ((pos - entry->hashValue) & mask) >= displ) {
  ------------------
  |  Branch (758:16): [True: 246, False: 10]
  ------------------
  759|    246|            displ++;
  760|    246|            pos++;
  761|    246|            entry++;
  762|    246|            if ((pos & mask) == 0)
  ------------------
  |  Branch (762:17): [True: 9, False: 237]
  ------------------
  763|      9|                entry = dict->table;
  764|    246|        }
  765|    816|    }
  766|       |
  767|  4.36k|    if (prefix == NULL)
  ------------------
  |  Branch (767:9): [True: 4.36k, False: 1]
  ------------------
  768|  4.36k|        ret = xmlDictAddString(dict, name, len);
  769|      1|    else
  770|      1|        ret = xmlDictAddQString(dict, prefix, plen, name, len);
  771|  4.36k|    if (ret == NULL)
  ------------------
  |  Branch (771:9): [True: 0, False: 4.36k]
  ------------------
  772|      0|        return(NULL);
  773|       |
  774|       |    /*
  775|       |     * Shift the remainder of the probe sequence to the right
  776|       |     */
  777|  4.36k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (777:9): [True: 496, False: 3.87k]
  ------------------
  778|    496|        const xmlDictEntry *end = &dict->table[dict->size];
  779|    496|        const xmlDictEntry *cur = entry;
  780|       |
  781|  1.03k|        do {
  782|  1.03k|            cur++;
  783|  1.03k|            if (cur >= end)
  ------------------
  |  Branch (783:17): [True: 89, False: 945]
  ------------------
  784|     89|                cur = dict->table;
  785|  1.03k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (785:18): [True: 538, False: 496]
  ------------------
  786|       |
  787|    496|        if (cur < entry) {
  ------------------
  |  Branch (787:13): [True: 89, False: 407]
  ------------------
  788|       |            /*
  789|       |             * If we traversed the end of the buffer, handle the part
  790|       |             * at the start of the buffer.
  791|       |             */
  792|     89|            memmove(&dict->table[1], dict->table,
  793|     89|                    (char *) cur - (char *) dict->table);
  794|     89|            cur = end - 1;
  795|     89|            dict->table[0] = *cur;
  796|     89|        }
  797|       |
  798|    496|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  799|    496|    }
  800|       |
  801|       |    /*
  802|       |     * Populate entry
  803|       |     */
  804|  4.36k|    entry->hashValue = hashValue;
  805|  4.36k|    entry->name = ret;
  806|       |
  807|  4.36k|    dict->nbElems++;
  808|       |
  809|  4.36k|    return(entry);
  810|  4.36k|}
dict.c:xmlDictHashQName:
  484|      1|                 size_t *pplen, size_t *plen) {
  485|      1|    unsigned h1, h2;
  486|      1|    size_t i;
  487|       |
  488|      1|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|      1|    do { \
  |  |   24|      1|        h1 = seed ^ 0x3b00; \
  |  |   25|      1|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|      1|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  489|       |
  490|      2|    for (i = 0; prefix[i] != 0; i++) {
  ------------------
  |  Branch (490:17): [True: 1, False: 1]
  ------------------
  491|      1|        HASH_UPDATE(h1, h2, prefix[i]);
  ------------------
  |  |   29|      1|    do { \
  |  |   30|      1|        h1 += ch; \
  |  |   31|      1|        h1 += h1 << 3; \
  |  |   32|      1|        h2 += h1; \
  |  |   33|      1|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      1|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      1|        h2 += h2 << 2; \
  |  |   35|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  492|      1|    }
  493|      1|    *pplen = i;
  494|       |
  495|      1|    HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      1|    do { \
  |  |   30|      1|        h1 += ch; \
  |  |   31|      1|        h1 += h1 << 3; \
  |  |   32|      1|        h2 += h1; \
  |  |   33|      1|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      1|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      1|        h2 += h2 << 2; \
  |  |   35|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  496|       |
  497|      4|    for (i = 0; name[i] != 0; i++) {
  ------------------
  |  Branch (497:17): [True: 3, False: 1]
  ------------------
  498|      3|        HASH_UPDATE(h1, h2, name[i]);
  ------------------
  |  |   29|      3|    do { \
  |  |   30|      3|        h1 += ch; \
  |  |   31|      3|        h1 += h1 << 3; \
  |  |   32|      3|        h2 += h1; \
  |  |   33|      3|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      3|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      3|        h2 += h2 << 2; \
  |  |   35|      3|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  499|      3|    }
  500|      1|    *plen = i;
  501|       |
  502|      1|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|      1|    do { \
  |  |   40|      1|        h1 ^= h2; \
  |  |   41|      1|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|      1|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|      1|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|      1|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|      1|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|      1|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|      1|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|      1|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|      1|        h2 &= 0xFFFFFFFF; \
  |  |   46|      1|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  503|       |
  504|       |    /*
  505|       |     * Always set the upper bit of hash values since 0 means an unoccupied
  506|       |     * bucket.
  507|       |     */
  508|      1|    return(h2 | MAX_HASH_SIZE);
  ------------------
  |  |   41|      1|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  509|      1|}
dict.c:xmlDictFindEntry:
  549|  9.47k|                 int *pfound) {
  550|  9.47k|    xmlDictEntry *entry;
  551|  9.47k|    unsigned mask, pos, displ;
  552|  9.47k|    int found = 0;
  553|       |
  554|  9.47k|    mask = dict->size - 1;
  555|  9.47k|    pos = hashValue & mask;
  556|  9.47k|    entry = &dict->table[pos];
  557|       |
  558|  9.47k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (558:9): [True: 7.44k, False: 2.03k]
  ------------------
  559|       |        /*
  560|       |         * Robin hood hashing: abort if the displacement of the entry
  561|       |         * is smaller than the displacement of the key we look for.
  562|       |         * This also stops at the correct position when inserting.
  563|       |         */
  564|  7.44k|        displ = 0;
  565|       |
  566|  11.8k|        do {
  567|  11.8k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (567:17): [True: 5.59k, False: 6.29k]
  ------------------
  568|  5.59k|                if (prefix == NULL) {
  ------------------
  |  Branch (568:21): [True: 5.59k, False: 0]
  ------------------
  569|       |                    /*
  570|       |                     * name is not necessarily null-terminated.
  571|       |                     */
  572|  5.59k|                    if ((strncmp((const char *) entry->name,
  ------------------
  |  Branch (572:25): [True: 5.59k, False: 0]
  ------------------
  573|  5.59k|                                 (const char *) name, len) == 0) &&
  574|  5.59k|                        (entry->name[len] == 0)) {
  ------------------
  |  Branch (574:25): [True: 5.59k, False: 0]
  ------------------
  575|  5.59k|                        found = 1;
  576|  5.59k|                        break;
  577|  5.59k|                    }
  578|  5.59k|                } else {
  579|      0|                    if (xmlStrQEqual(prefix, name, entry->name)) {
  ------------------
  |  Branch (579:25): [True: 0, False: 0]
  ------------------
  580|      0|                        found = 1;
  581|      0|                        break;
  582|      0|                    }
  583|      0|                }
  584|  5.59k|            }
  585|       |
  586|  6.29k|            displ++;
  587|  6.29k|            pos++;
  588|  6.29k|            entry++;
  589|  6.29k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (589:17): [True: 279, False: 6.01k]
  ------------------
  590|    279|                entry = dict->table;
  591|  6.29k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (591:18): [True: 5.17k, False: 1.11k]
  ------------------
  592|  6.29k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (592:18): [True: 4.44k, False: 736]
  ------------------
  593|  7.44k|    }
  594|       |
  595|      0|    *pfound = found;
  596|  9.47k|    return(entry);
  597|  9.47k|}
dict.c:xmlDictGrow:
  609|    816|xmlDictGrow(xmlDictPtr dict, unsigned size) {
  610|    816|    const xmlDictEntry *oldentry, *oldend, *end;
  611|    816|    xmlDictEntry *table;
  612|    816|    unsigned oldsize, i;
  613|       |
  614|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  615|    816|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   35|    816|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (615:9): [True: 0, False: 816]
  ------------------
  616|      0|        return(-1);
  617|    816|    table = xmlMalloc(size * sizeof(table[0]));
  618|    816|    if (table == NULL)
  ------------------
  |  Branch (618:9): [True: 0, False: 816]
  ------------------
  619|      0|        return(-1);
  620|    816|    memset(table, 0, size * sizeof(table[0]));
  621|       |
  622|    816|    oldsize = dict->size;
  623|    816|    if (oldsize == 0)
  ------------------
  |  Branch (623:9): [True: 486, False: 330]
  ------------------
  624|    486|        goto done;
  625|       |
  626|    330|    oldend = &dict->table[oldsize];
  627|    330|    end = &table[size];
  628|       |
  629|       |    /*
  630|       |     * Robin Hood sorting order is maintained if we
  631|       |     *
  632|       |     * - compute dict indices with modulo
  633|       |     * - resize by an integer factor
  634|       |     * - start to copy from the beginning of a probe sequence
  635|       |     */
  636|    330|    oldentry = dict->table;
  637|  1.26k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (637:12): [True: 936, False: 330]
  ------------------
  638|    936|        if (++oldentry >= oldend)
  ------------------
  |  Branch (638:13): [True: 0, False: 936]
  ------------------
  639|      0|            oldentry = dict->table;
  640|    936|    }
  641|       |
  642|  4.21k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (642:17): [True: 3.88k, False: 330]
  ------------------
  643|  3.88k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (643:13): [True: 3.40k, False: 486]
  ------------------
  644|  3.40k|            xmlDictEntry *entry = &table[oldentry->hashValue & (size - 1)];
  645|       |
  646|  4.08k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (646:20): [True: 687, False: 3.40k]
  ------------------
  647|    687|                if (++entry >= end)
  ------------------
  |  Branch (647:21): [True: 43, False: 644]
  ------------------
  648|     43|                    entry = table;
  649|    687|            }
  650|  3.40k|            *entry = *oldentry;
  651|  3.40k|        }
  652|       |
  653|  3.88k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (653:13): [True: 330, False: 3.55k]
  ------------------
  654|    330|            oldentry = dict->table;
  655|  3.88k|    }
  656|       |
  657|    330|    xmlFree(dict->table);
  658|       |
  659|    816|done:
  660|    816|    dict->table = table;
  661|    816|    dict->size = size;
  662|       |
  663|    816|    return(0);
  664|    330|}
dict.c:xmlDictAddString:
  136|  4.36k|xmlDictAddString(xmlDictPtr dict, const xmlChar *name, unsigned int namelen) {
  137|  4.36k|    xmlDictStringsPtr pool;
  138|  4.36k|    const xmlChar *ret;
  139|  4.36k|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  140|  4.36k|    size_t limit = 0;
  141|       |
  142|  4.36k|    pool = dict->strings;
  143|  4.36k|    while (pool != NULL) {
  ------------------
  |  Branch (143:12): [True: 3.87k, False: 486]
  ------------------
  144|  3.87k|	if ((size_t)(pool->end - pool->free) > namelen)
  ------------------
  |  Branch (144:6): [True: 3.87k, False: 0]
  ------------------
  145|  3.87k|	    goto found_pool;
  146|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (146:6): [True: 0, False: 0]
  ------------------
  147|      0|        limit += pool->size;
  148|      0|	pool = pool->next;
  149|      0|    }
  150|       |    /*
  151|       |     * Not found, need to allocate
  152|       |     */
  153|    486|    if (pool == NULL) {
  ------------------
  |  Branch (153:9): [True: 486, False: 0]
  ------------------
  154|    486|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (154:13): [True: 486, False: 0]
  |  Branch (154:34): [True: 0, False: 486]
  ------------------
  155|      0|            return(NULL);
  156|      0|        }
  157|       |
  158|    486|        if (size == 0) {
  ------------------
  |  Branch (158:13): [True: 486, False: 0]
  ------------------
  159|    486|            size = 1000;
  160|    486|        } else {
  161|      0|            if (size < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (161:17): [True: 0, False: 0]
  ------------------
  162|      0|                size *= 4; /* exponential growth */
  163|      0|            else
  164|      0|                size = SIZE_MAX - sizeof(xmlDictStrings);
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  165|      0|        }
  166|    486|        if (size / 4 < namelen) {
  ------------------
  |  Branch (166:13): [True: 0, False: 486]
  ------------------
  167|      0|            if ((size_t) namelen + 0 < (SIZE_MAX - sizeof(xmlDictStrings)) / 4)
  ------------------
  |  |   35|      0|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (167:17): [True: 0, False: 0]
  ------------------
  168|      0|                size = 4 * (size_t) namelen; /* just in case ! */
  169|      0|            else
  170|      0|                return(NULL);
  171|      0|        }
  172|    486|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  173|    486|	if (pool == NULL)
  ------------------
  |  Branch (173:6): [True: 0, False: 486]
  ------------------
  174|      0|	    return(NULL);
  175|    486|	pool->size = size;
  176|    486|	pool->nbStrings = 0;
  177|    486|	pool->free = &pool->array[0];
  178|    486|	pool->end = &pool->array[size];
  179|    486|	pool->next = dict->strings;
  180|    486|	dict->strings = pool;
  181|    486|    }
  182|  4.36k|found_pool:
  183|  4.36k|    ret = pool->free;
  184|  4.36k|    memcpy(pool->free, name, namelen);
  185|  4.36k|    pool->free += namelen;
  186|  4.36k|    *(pool->free++) = 0;
  187|  4.36k|    pool->nbStrings++;
  188|  4.36k|    return(ret);
  189|    486|}
dict.c:xmlDictAddQString:
  206|      1|{
  207|      1|    xmlDictStringsPtr pool;
  208|      1|    const xmlChar *ret;
  209|      1|    size_t size = 0; /* + sizeof(_xmlDictStrings) == 1024 */
  210|      1|    size_t limit = 0;
  211|       |
  212|      1|    pool = dict->strings;
  213|      1|    while (pool != NULL) {
  ------------------
  |  Branch (213:12): [True: 1, False: 0]
  ------------------
  214|      1|	if ((size_t)(pool->end - pool->free) > namelen + plen + 1)
  ------------------
  |  Branch (214:6): [True: 1, False: 0]
  ------------------
  215|      1|	    goto found_pool;
  216|      0|	if (pool->size > size) size = pool->size;
  ------------------
  |  Branch (216:6): [True: 0, False: 0]
  ------------------
  217|      0|        limit += pool->size;
  218|      0|	pool = pool->next;
  219|      0|    }
  220|       |    /*
  221|       |     * Not found, need to allocate
  222|       |     */
  223|      0|    if (pool == NULL) {
  ------------------
  |  Branch (223:9): [True: 0, False: 0]
  ------------------
  224|      0|        if ((dict->limit > 0) && (limit > dict->limit)) {
  ------------------
  |  Branch (224:13): [True: 0, False: 0]
  |  Branch (224:34): [True: 0, False: 0]
  ------------------
  225|      0|            return(NULL);
  226|      0|        }
  227|       |
  228|      0|        if (size == 0) size = 1000;
  ------------------
  |  Branch (228:13): [True: 0, False: 0]
  ------------------
  229|      0|	else size *= 4; /* exponential growth */
  230|      0|        if (size < 4 * (namelen + plen + 1))
  ------------------
  |  Branch (230:13): [True: 0, False: 0]
  ------------------
  231|      0|	    size = 4 * (namelen + plen + 1); /* just in case ! */
  232|      0|	pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);
  233|      0|	if (pool == NULL)
  ------------------
  |  Branch (233:6): [True: 0, False: 0]
  ------------------
  234|      0|	    return(NULL);
  235|      0|	pool->size = size;
  236|      0|	pool->nbStrings = 0;
  237|      0|	pool->free = &pool->array[0];
  238|      0|	pool->end = &pool->array[size];
  239|      0|	pool->next = dict->strings;
  240|      0|	dict->strings = pool;
  241|      0|    }
  242|      1|found_pool:
  243|      1|    ret = pool->free;
  244|      1|    memcpy(pool->free, prefix, plen);
  245|      1|    pool->free += plen;
  246|      1|    *(pool->free++) = ':';
  247|      1|    memcpy(pool->free, name, namelen);
  248|      1|    pool->free += namelen;
  249|      1|    *(pool->free++) = 0;
  250|      1|    pool->nbStrings++;
  251|      1|    return(ret);
  252|      0|}
dict.c:xoroshiro64ss:
  938|  1.55k|xoroshiro64ss(unsigned *s) {
  939|  1.55k|    unsigned s0 = s[0];
  940|  1.55k|    unsigned s1 = s[1];
  941|  1.55k|    unsigned result = HASH_ROL(s0 * 0x9E3779BB, 5) * 5;
  ------------------
  |  |   12|  1.55k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  942|       |
  943|  1.55k|    s1 ^= s0;
  944|  1.55k|    s[0] = HASH_ROL(s0, 26) ^ s1 ^ (s1 << 9);
  ------------------
  |  |   12|  1.55k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  945|  1.55k|    s[1] = HASH_ROL(s1, 13);
  ------------------
  |  |   12|  1.55k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  ------------------
  946|       |
  947|  1.55k|    return(result & 0xFFFFFFFF);
  948|  1.55k|}

xmlInitEncodingInternal:
 1470|      2|xmlInitEncodingInternal(void) {
 1471|      2|    unsigned short int tst = 0x1234;
 1472|      2|    unsigned char *ptr = (unsigned char *) &tst;
 1473|       |
 1474|      2|    if (*ptr == 0x12) xmlLittleEndian = 0;
  ------------------
  |  Branch (1474:9): [True: 0, False: 2]
  ------------------
 1475|      2|    else xmlLittleEndian = 1;
 1476|      2|}
xmlGetCharEncodingHandler:
 1547|    486|xmlGetCharEncodingHandler(xmlCharEncoding enc) {
 1548|    486|    xmlCharEncodingHandlerPtr handler;
 1549|       |
 1550|    486|    switch (enc) {
 1551|      0|        case XML_CHAR_ENCODING_ERROR:
  ------------------
  |  Branch (1551:9): [True: 0, False: 486]
  ------------------
 1552|      0|	    return(NULL);
 1553|    486|        case XML_CHAR_ENCODING_NONE:
  ------------------
  |  Branch (1553:9): [True: 486, False: 0]
  ------------------
 1554|    486|	    return(NULL);
 1555|      0|        case XML_CHAR_ENCODING_UTF8:
  ------------------
  |  Branch (1555:9): [True: 0, False: 486]
  ------------------
 1556|      0|	    return(NULL);
 1557|      0|        case XML_CHAR_ENCODING_UTF16LE:
  ------------------
  |  Branch (1557:9): [True: 0, False: 486]
  ------------------
 1558|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16LEHandler);
 1559|      0|        case XML_CHAR_ENCODING_UTF16BE:
  ------------------
  |  Branch (1559:9): [True: 0, False: 486]
  ------------------
 1560|      0|	    return((xmlCharEncodingHandlerPtr) xmlUTF16BEHandler);
 1561|      0|        case XML_CHAR_ENCODING_EBCDIC:
  ------------------
  |  Branch (1561:9): [True: 0, False: 486]
  ------------------
 1562|      0|            handler = xmlFindCharEncodingHandler("EBCDIC");
 1563|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1563:17): [True: 0, False: 0]
  ------------------
 1564|      0|            handler = xmlFindCharEncodingHandler("ebcdic");
 1565|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1565:17): [True: 0, False: 0]
  ------------------
 1566|      0|            handler = xmlFindCharEncodingHandler("EBCDIC-US");
 1567|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1567:17): [True: 0, False: 0]
  ------------------
 1568|      0|            handler = xmlFindCharEncodingHandler("IBM-037");
 1569|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1569:17): [True: 0, False: 0]
  ------------------
 1570|      0|	    break;
 1571|      0|        case XML_CHAR_ENCODING_UCS4BE:
  ------------------
  |  Branch (1571:9): [True: 0, False: 486]
  ------------------
 1572|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1573|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1573:17): [True: 0, False: 0]
  ------------------
 1574|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1575|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1575:17): [True: 0, False: 0]
  ------------------
 1576|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1577|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1577:17): [True: 0, False: 0]
  ------------------
 1578|      0|	    break;
 1579|      0|        case XML_CHAR_ENCODING_UCS4LE:
  ------------------
  |  Branch (1579:9): [True: 0, False: 486]
  ------------------
 1580|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-4");
 1581|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1581:17): [True: 0, False: 0]
  ------------------
 1582|      0|            handler = xmlFindCharEncodingHandler("UCS-4");
 1583|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1583:17): [True: 0, False: 0]
  ------------------
 1584|      0|            handler = xmlFindCharEncodingHandler("UCS4");
 1585|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1585:17): [True: 0, False: 0]
  ------------------
 1586|      0|	    break;
 1587|      0|        case XML_CHAR_ENCODING_UCS4_2143:
  ------------------
  |  Branch (1587:9): [True: 0, False: 486]
  ------------------
 1588|      0|	    break;
 1589|      0|        case XML_CHAR_ENCODING_UCS4_3412:
  ------------------
  |  Branch (1589:9): [True: 0, False: 486]
  ------------------
 1590|      0|	    break;
 1591|      0|        case XML_CHAR_ENCODING_UCS2:
  ------------------
  |  Branch (1591:9): [True: 0, False: 486]
  ------------------
 1592|      0|            handler = xmlFindCharEncodingHandler("ISO-10646-UCS-2");
 1593|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1593:17): [True: 0, False: 0]
  ------------------
 1594|      0|            handler = xmlFindCharEncodingHandler("UCS-2");
 1595|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1595:17): [True: 0, False: 0]
  ------------------
 1596|      0|            handler = xmlFindCharEncodingHandler("UCS2");
 1597|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1597:17): [True: 0, False: 0]
  ------------------
 1598|      0|	    break;
 1599|       |
 1600|       |	    /*
 1601|       |	     * We used to keep ISO Latin encodings native in the
 1602|       |	     * generated data. This led to so many problems that
 1603|       |	     * this has been removed. One can still change this
 1604|       |	     * back by registering no-ops encoders for those
 1605|       |	     */
 1606|      0|        case XML_CHAR_ENCODING_8859_1:
  ------------------
  |  Branch (1606:9): [True: 0, False: 486]
  ------------------
 1607|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-1");
 1608|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1608:10): [True: 0, False: 0]
  ------------------
 1609|      0|	    break;
 1610|      0|        case XML_CHAR_ENCODING_8859_2:
  ------------------
  |  Branch (1610:9): [True: 0, False: 486]
  ------------------
 1611|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-2");
 1612|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1612:10): [True: 0, False: 0]
  ------------------
 1613|      0|	    break;
 1614|      0|        case XML_CHAR_ENCODING_8859_3:
  ------------------
  |  Branch (1614:9): [True: 0, False: 486]
  ------------------
 1615|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-3");
 1616|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1616:10): [True: 0, False: 0]
  ------------------
 1617|      0|	    break;
 1618|      0|        case XML_CHAR_ENCODING_8859_4:
  ------------------
  |  Branch (1618:9): [True: 0, False: 486]
  ------------------
 1619|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-4");
 1620|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1620:10): [True: 0, False: 0]
  ------------------
 1621|      0|	    break;
 1622|      0|        case XML_CHAR_ENCODING_8859_5:
  ------------------
  |  Branch (1622:9): [True: 0, False: 486]
  ------------------
 1623|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-5");
 1624|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1624:10): [True: 0, False: 0]
  ------------------
 1625|      0|	    break;
 1626|      0|        case XML_CHAR_ENCODING_8859_6:
  ------------------
  |  Branch (1626:9): [True: 0, False: 486]
  ------------------
 1627|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-6");
 1628|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1628:10): [True: 0, False: 0]
  ------------------
 1629|      0|	    break;
 1630|      0|        case XML_CHAR_ENCODING_8859_7:
  ------------------
  |  Branch (1630:9): [True: 0, False: 486]
  ------------------
 1631|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-7");
 1632|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1632:10): [True: 0, False: 0]
  ------------------
 1633|      0|	    break;
 1634|      0|        case XML_CHAR_ENCODING_8859_8:
  ------------------
  |  Branch (1634:9): [True: 0, False: 486]
  ------------------
 1635|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-8");
 1636|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1636:10): [True: 0, False: 0]
  ------------------
 1637|      0|	    break;
 1638|      0|        case XML_CHAR_ENCODING_8859_9:
  ------------------
  |  Branch (1638:9): [True: 0, False: 486]
  ------------------
 1639|      0|	    handler = xmlFindCharEncodingHandler("ISO-8859-9");
 1640|      0|	    if (handler != NULL) return(handler);
  ------------------
  |  Branch (1640:10): [True: 0, False: 0]
  ------------------
 1641|      0|	    break;
 1642|       |
 1643|       |
 1644|      0|        case XML_CHAR_ENCODING_2022_JP:
  ------------------
  |  Branch (1644:9): [True: 0, False: 486]
  ------------------
 1645|      0|            handler = xmlFindCharEncodingHandler("ISO-2022-JP");
 1646|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1646:17): [True: 0, False: 0]
  ------------------
 1647|      0|	    break;
 1648|      0|        case XML_CHAR_ENCODING_SHIFT_JIS:
  ------------------
  |  Branch (1648:9): [True: 0, False: 486]
  ------------------
 1649|      0|            handler = xmlFindCharEncodingHandler("SHIFT-JIS");
 1650|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1650:17): [True: 0, False: 0]
  ------------------
 1651|      0|            handler = xmlFindCharEncodingHandler("SHIFT_JIS");
 1652|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1652:17): [True: 0, False: 0]
  ------------------
 1653|      0|            handler = xmlFindCharEncodingHandler("Shift_JIS");
 1654|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1654:17): [True: 0, False: 0]
  ------------------
 1655|      0|	    break;
 1656|      0|        case XML_CHAR_ENCODING_EUC_JP:
  ------------------
  |  Branch (1656:9): [True: 0, False: 486]
  ------------------
 1657|      0|            handler = xmlFindCharEncodingHandler("EUC-JP");
 1658|      0|            if (handler != NULL) return(handler);
  ------------------
  |  Branch (1658:17): [True: 0, False: 0]
  ------------------
 1659|      0|	    break;
 1660|      0|	default:
  ------------------
  |  Branch (1660:2): [True: 0, False: 486]
  ------------------
 1661|      0|	    break;
 1662|    486|    }
 1663|       |
 1664|      0|    return(NULL);
 1665|    486|}

xmlGetPredefinedEntity:
  295|    105|xmlGetPredefinedEntity(const xmlChar *name) {
  296|    105|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (296:9): [True: 0, False: 105]
  ------------------
  297|    105|    switch (name[0]) {
  298|      0|        case 'l':
  ------------------
  |  Branch (298:9): [True: 0, False: 105]
  ------------------
  299|      0|	    if (xmlStrEqual(name, BAD_CAST "lt"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (299:10): [True: 0, False: 0]
  ------------------
  300|      0|	        return(&xmlEntityLt);
  301|      0|	    break;
  302|      0|        case 'g':
  ------------------
  |  Branch (302:9): [True: 0, False: 105]
  ------------------
  303|      0|	    if (xmlStrEqual(name, BAD_CAST "gt"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (303:10): [True: 0, False: 0]
  ------------------
  304|      0|	        return(&xmlEntityGt);
  305|      0|	    break;
  306|    105|        case 'a':
  ------------------
  |  Branch (306:9): [True: 105, False: 0]
  ------------------
  307|    105|	    if (xmlStrEqual(name, BAD_CAST "amp"))
  ------------------
  |  |   35|    105|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (307:10): [True: 102, False: 3]
  ------------------
  308|    102|	        return(&xmlEntityAmp);
  309|      3|	    if (xmlStrEqual(name, BAD_CAST "apos"))
  ------------------
  |  |   35|      3|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (309:10): [True: 0, False: 3]
  ------------------
  310|      0|	        return(&xmlEntityApos);
  311|      3|	    break;
  312|      3|        case 'q':
  ------------------
  |  Branch (312:9): [True: 0, False: 105]
  ------------------
  313|      0|	    if (xmlStrEqual(name, BAD_CAST "quot"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (313:10): [True: 0, False: 0]
  ------------------
  314|      0|	        return(&xmlEntityQuot);
  315|      0|	    break;
  316|      0|	default:
  ------------------
  |  Branch (316:2): [True: 0, False: 105]
  ------------------
  317|      0|	    break;
  318|    105|    }
  319|      3|    return(NULL);
  320|    105|}
xmlGetDocEntity:
  540|      1|xmlGetDocEntity(const xmlDoc *doc, const xmlChar *name) {
  541|      1|    xmlEntityPtr cur;
  542|      1|    xmlEntitiesTablePtr table;
  543|       |
  544|      1|    if (doc != NULL) {
  ------------------
  |  Branch (544:9): [True: 1, False: 0]
  ------------------
  545|      1|	if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {
  ------------------
  |  Branch (545:6): [True: 0, False: 1]
  |  Branch (545:34): [True: 0, False: 0]
  ------------------
  546|      0|	    table = (xmlEntitiesTablePtr) doc->intSubset->entities;
  547|      0|	    cur = xmlGetEntityFromTable(table, name);
  548|      0|	    if (cur != NULL)
  ------------------
  |  Branch (548:10): [True: 0, False: 0]
  ------------------
  549|      0|		return(cur);
  550|      0|	}
  551|      1|	if (doc->standalone != 1) {
  ------------------
  |  Branch (551:6): [True: 1, False: 0]
  ------------------
  552|      1|	    if ((doc->extSubset != NULL) &&
  ------------------
  |  Branch (552:10): [True: 0, False: 1]
  ------------------
  553|      1|		(doc->extSubset->entities != NULL)) {
  ------------------
  |  Branch (553:3): [True: 0, False: 0]
  ------------------
  554|      0|		table = (xmlEntitiesTablePtr) doc->extSubset->entities;
  555|      0|		cur = xmlGetEntityFromTable(table, name);
  556|      0|		if (cur != NULL)
  ------------------
  |  Branch (556:7): [True: 0, False: 0]
  ------------------
  557|      0|		    return(cur);
  558|      0|	    }
  559|      1|	}
  560|      1|    }
  561|      1|    return(xmlGetPredefinedEntity(name));
  562|      1|}

xmlSetGenericErrorFunc:
  114|      2|xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler) {
  115|      2|    xmlGenericErrorContext = ctx;
  ------------------
  |  |  876|      2|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  116|      2|    if (handler != NULL)
  ------------------
  |  Branch (116:9): [True: 2, False: 0]
  ------------------
  117|      2|	xmlGenericError = handler;
  ------------------
  |  |  875|      2|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      2|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  118|      0|    else
  119|      0|	xmlGenericError = xmlGenericErrorDefaultFunc;
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  120|      2|}
__xmlRaiseError:
  475|    396|{
  476|    396|    xmlParserCtxtPtr ctxt = NULL;
  477|    396|    xmlNodePtr node = (xmlNodePtr) nod;
  478|    396|    char *str = NULL;
  479|    396|    xmlParserInputPtr input = NULL;
  480|    396|    xmlErrorPtr to = &xmlLastError;
  ------------------
  |  |  874|    396|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    396|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  481|    396|    xmlNodePtr baseptr = NULL;
  482|       |
  483|    396|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (483:9): [True: 0, False: 396]
  ------------------
  484|      0|        return;
  485|    396|    if ((xmlGetWarningsDefaultValue == 0) && (level == XML_ERR_WARNING))
  ------------------
  |  |  865|    396|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    396|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (485:9): [True: 0, False: 396]
  |  Branch (485:46): [True: 0, False: 0]
  ------------------
  486|      0|        return;
  487|    396|    if ((domain == XML_FROM_PARSER) || (domain == XML_FROM_HTML) ||
  ------------------
  |  Branch (487:9): [True: 265, False: 131]
  |  Branch (487:40): [True: 0, False: 131]
  ------------------
  488|    396|        (domain == XML_FROM_DTD) || (domain == XML_FROM_NAMESPACE) ||
  ------------------
  |  Branch (488:9): [True: 0, False: 131]
  |  Branch (488:37): [True: 2, False: 129]
  ------------------
  489|    396|	(domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {
  ------------------
  |  Branch (489:2): [True: 0, False: 129]
  |  Branch (489:29): [True: 0, False: 129]
  ------------------
  490|    267|	ctxt = (xmlParserCtxtPtr) ctx;
  491|       |
  492|    267|        if (ctxt != NULL) {
  ------------------
  |  Branch (492:13): [True: 267, False: 0]
  ------------------
  493|    267|            if (level == XML_ERR_WARNING) {
  ------------------
  |  Branch (493:17): [True: 0, False: 267]
  ------------------
  494|      0|                if (ctxt->nbWarnings >= XML_MAX_ERRORS)
  ------------------
  |  |   20|      0|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (494:21): [True: 0, False: 0]
  ------------------
  495|      0|                    return;
  496|      0|                ctxt->nbWarnings += 1;
  497|    267|            } else {
  498|    267|                if (ctxt->nbErrors >= XML_MAX_ERRORS)
  ------------------
  |  |   20|    267|#define XML_MAX_ERRORS 100
  ------------------
  |  Branch (498:21): [True: 0, False: 267]
  ------------------
  499|      0|                    return;
  500|    267|                ctxt->nbErrors += 1;
  501|    267|            }
  502|       |
  503|    267|            if ((schannel == NULL) && (ctxt->sax != NULL) &&
  ------------------
  |  Branch (503:17): [True: 267, False: 0]
  |  Branch (503:39): [True: 267, False: 0]
  ------------------
  504|    267|                (ctxt->sax->initialized == XML_SAX2_MAGIC) &&
  ------------------
  |  |  685|    267|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (504:17): [True: 267, False: 0]
  ------------------
  505|    267|                (ctxt->sax->serror != NULL)) {
  ------------------
  |  Branch (505:17): [True: 0, False: 267]
  ------------------
  506|      0|                schannel = ctxt->sax->serror;
  507|      0|                data = ctxt->userData;
  508|      0|            }
  509|    267|        }
  510|    267|    }
  511|       |    /*
  512|       |     * Check if structured error handler set
  513|       |     */
  514|    396|    if (schannel == NULL) {
  ------------------
  |  Branch (514:9): [True: 396, False: 0]
  ------------------
  515|    396|	schannel = xmlStructuredError;
  ------------------
  |  |  877|    396|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    396|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  516|       |	/*
  517|       |	 * if user has defined handler, change data ptr to user's choice
  518|       |	 */
  519|    396|	if (schannel != NULL)
  ------------------
  |  Branch (519:6): [True: 0, False: 396]
  ------------------
  520|      0|	    data = xmlStructuredErrorContext;
  ------------------
  |  |  878|      0|  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  521|    396|    }
  522|       |    /*
  523|       |     * Formatting the message
  524|       |     */
  525|    396|    if (msg == NULL) {
  ------------------
  |  Branch (525:9): [True: 0, False: 396]
  ------------------
  526|      0|        str = (char *) xmlStrdup(BAD_CAST "No error message provided");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  527|    396|    } else {
  528|    396|        XML_GET_VAR_STR(msg, str);
  ------------------
  |  |   22|    396|#define XML_GET_VAR_STR(msg, str) {				\
  |  |   23|    396|    int       size, prev_size = -1;				\
  |  |   24|    396|    int       chars;						\
  |  |   25|    396|    char      *larger;						\
  |  |   26|    396|    va_list   ap;						\
  |  |   27|    396|								\
  |  |   28|    396|    str = (char *) xmlMalloc(150);				\
  |  |   29|    396|    if (str != NULL) {						\
  |  |  ------------------
  |  |  |  Branch (29:9): [True: 395, False: 1]
  |  |  ------------------
  |  |   30|    395|								\
  |  |   31|    395|    size = 150;							\
  |  |   32|    395|								\
  |  |   33|    790|    while (size < 64000) {					\
  |  |  ------------------
  |  |  |  Branch (33:12): [True: 790, False: 0]
  |  |  ------------------
  |  |   34|    790|	va_start(ap, msg);					\
  |  |   35|    790|	chars = vsnprintf(str, size, msg, ap);			\
  |  |   36|    790|	va_end(ap);						\
  |  |   37|    790|	if ((chars > -1) && (chars < size)) {			\
  |  |  ------------------
  |  |  |  Branch (37:6): [True: 790, False: 0]
  |  |  |  Branch (37:22): [True: 790, False: 0]
  |  |  ------------------
  |  |   38|    790|	    if (prev_size == chars) {				\
  |  |  ------------------
  |  |  |  Branch (38:10): [True: 395, False: 395]
  |  |  ------------------
  |  |   39|    395|		break;						\
  |  |   40|    395|	    } else {						\
  |  |   41|    395|		prev_size = chars;				\
  |  |   42|    395|	    }							\
  |  |   43|    790|	}							\
  |  |   44|    790|	if (chars > -1)						\
  |  |  ------------------
  |  |  |  Branch (44:6): [True: 395, False: 0]
  |  |  ------------------
  |  |   45|    395|	    size += chars + 1;					\
  |  |   46|    395|	else							\
  |  |   47|    395|	    size += 100;					\
  |  |   48|    395|	if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\
  |  |  ------------------
  |  |  |  Branch (48:6): [True: 0, False: 395]
  |  |  ------------------
  |  |   49|      0|	    break;						\
  |  |   50|      0|	}							\
  |  |   51|    395|	str = larger;						\
  |  |   52|    395|    }}								\
  |  |   53|    396|}
  ------------------
  529|    396|    }
  530|       |
  531|       |    /*
  532|       |     * specific processing if a parser context is provided
  533|       |     */
  534|    396|    if (ctxt != NULL) {
  ------------------
  |  Branch (534:9): [True: 267, False: 129]
  ------------------
  535|    267|        if (file == NULL) {
  ------------------
  |  Branch (535:13): [True: 267, False: 0]
  ------------------
  536|    267|            input = ctxt->input;
  537|    267|            if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (537:17): [True: 267, False: 0]
  |  Branch (537:36): [True: 267, False: 0]
  ------------------
  538|    267|                (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (538:17): [True: 0, False: 267]
  ------------------
  539|      0|                input = ctxt->inputTab[ctxt->inputNr - 2];
  540|      0|            }
  541|    267|            if (input != NULL) {
  ------------------
  |  Branch (541:17): [True: 267, False: 0]
  ------------------
  542|    267|                file = input->filename;
  543|    267|                line = input->line;
  544|    267|                col = input->col;
  545|    267|            }
  546|    267|        }
  547|    267|        to = &ctxt->lastError;
  548|    267|    } else if ((node != NULL) && (file == NULL)) {
  ------------------
  |  Branch (548:16): [True: 0, False: 129]
  |  Branch (548:34): [True: 0, False: 0]
  ------------------
  549|      0|	int i;
  550|       |
  551|      0|	if ((node->doc != NULL) && (node->doc->URL != NULL)) {
  ------------------
  |  Branch (551:6): [True: 0, False: 0]
  |  Branch (551:29): [True: 0, False: 0]
  ------------------
  552|      0|	    baseptr = node;
  553|       |/*	    file = (const char *) node->doc->URL; */
  554|      0|	}
  555|      0|	for (i = 0;
  556|      0|	     ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (556:8): [True: 0, False: 0]
  |  Branch (556:20): [True: 0, False: 0]
  |  Branch (556:38): [True: 0, False: 0]
  ------------------
  557|      0|	     i++)
  558|      0|	     node = node->parent;
  559|      0|        if ((baseptr == NULL) && (node != NULL) &&
  ------------------
  |  Branch (559:13): [True: 0, False: 0]
  |  Branch (559:34): [True: 0, False: 0]
  ------------------
  560|      0|	    (node->doc != NULL) && (node->doc->URL != NULL))
  ------------------
  |  Branch (560:6): [True: 0, False: 0]
  |  Branch (560:29): [True: 0, False: 0]
  ------------------
  561|      0|	    baseptr = node;
  562|       |
  563|      0|	if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (563:6): [True: 0, False: 0]
  |  Branch (563:24): [True: 0, False: 0]
  ------------------
  564|      0|	    line = node->line;
  565|      0|	if ((line == 0) || (line == 65535))
  ------------------
  |  Branch (565:6): [True: 0, False: 0]
  |  Branch (565:21): [True: 0, False: 0]
  ------------------
  566|      0|	    line = xmlGetLineNo(node);
  567|      0|    }
  568|       |
  569|       |    /*
  570|       |     * Save the information about the error
  571|       |     */
  572|    396|    xmlResetError(to);
  573|    396|    to->domain = domain;
  574|    396|    to->code = code;
  575|    396|    to->message = str;
  576|    396|    to->level = level;
  577|    396|    if (file != NULL)
  ------------------
  |  Branch (577:9): [True: 0, False: 396]
  ------------------
  578|      0|        to->file = (char *) xmlStrdup((const xmlChar *) file);
  579|    396|    else if (baseptr != NULL) {
  ------------------
  |  Branch (579:14): [True: 0, False: 396]
  ------------------
  580|      0|#ifdef LIBXML_XINCLUDE_ENABLED
  581|       |	/*
  582|       |	 * We check if the error is within an XInclude section and,
  583|       |	 * if so, attempt to print out the href of the XInclude instead
  584|       |	 * of the usual "base" (doc->URL) for the node (bug 152623).
  585|       |	 */
  586|      0|        xmlNodePtr prev = baseptr;
  587|      0|        char *href = NULL;
  588|      0|	int inclcount = 0;
  589|      0|	while (prev != NULL) {
  ------------------
  |  Branch (589:9): [True: 0, False: 0]
  ------------------
  590|      0|	    if (prev->prev == NULL)
  ------------------
  |  Branch (590:10): [True: 0, False: 0]
  ------------------
  591|      0|	        prev = prev->parent;
  592|      0|	    else {
  593|      0|	        prev = prev->prev;
  594|      0|		if (prev->type == XML_XINCLUDE_START) {
  ------------------
  |  Branch (594:7): [True: 0, False: 0]
  ------------------
  595|      0|		    if (inclcount > 0) {
  ------------------
  |  Branch (595:11): [True: 0, False: 0]
  ------------------
  596|      0|                        --inclcount;
  597|      0|                    } else {
  598|      0|                        href = (char *) xmlGetProp(prev, BAD_CAST "href");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  599|      0|                        if (href != NULL)
  ------------------
  |  Branch (599:29): [True: 0, False: 0]
  ------------------
  600|      0|		            break;
  601|      0|                    }
  602|      0|		} else if (prev->type == XML_XINCLUDE_END)
  ------------------
  |  Branch (602:14): [True: 0, False: 0]
  ------------------
  603|      0|		    inclcount++;
  604|      0|	    }
  605|      0|	}
  606|      0|        if (href != NULL)
  ------------------
  |  Branch (606:13): [True: 0, False: 0]
  ------------------
  607|      0|            to->file = href;
  608|      0|	else
  609|      0|#endif
  610|      0|	    to->file = (char *) xmlStrdup(baseptr->doc->URL);
  611|      0|	if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {
  ------------------
  |  Branch (611:6): [True: 0, False: 0]
  |  Branch (611:28): [True: 0, False: 0]
  |  Branch (611:46): [True: 0, False: 0]
  ------------------
  612|      0|	    to->file = (char *) xmlStrdup(node->doc->URL);
  613|      0|	}
  614|      0|    }
  615|    396|    to->line = line;
  616|    396|    if (str1 != NULL)
  ------------------
  |  Branch (616:9): [True: 148, False: 248]
  ------------------
  617|    148|        to->str1 = (char *) xmlStrdup((const xmlChar *) str1);
  618|    396|    if (str2 != NULL)
  ------------------
  |  Branch (618:9): [True: 94, False: 302]
  ------------------
  619|     94|        to->str2 = (char *) xmlStrdup((const xmlChar *) str2);
  620|    396|    if (str3 != NULL)
  ------------------
  |  Branch (620:9): [True: 0, False: 396]
  ------------------
  621|      0|        to->str3 = (char *) xmlStrdup((const xmlChar *) str3);
  622|    396|    to->int1 = int1;
  623|    396|    to->int2 = col;
  624|    396|    to->node = node;
  625|    396|    to->ctxt = ctx;
  626|       |
  627|    396|    if (to != &xmlLastError)
  ------------------
  |  |  874|    396|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    396|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (627:9): [True: 267, False: 129]
  ------------------
  628|    267|        xmlCopyError(to,&xmlLastError);
  ------------------
  |  |  874|    267|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    267|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  629|       |
  630|    396|    if (schannel != NULL) {
  ------------------
  |  Branch (630:9): [True: 0, False: 396]
  ------------------
  631|      0|	schannel(data, to);
  632|      0|	return;
  633|      0|    }
  634|       |
  635|       |    /*
  636|       |     * Find the callback channel if channel param is NULL
  637|       |     */
  638|    396|    if ((ctxt != NULL) && (channel == NULL) &&
  ------------------
  |  Branch (638:9): [True: 267, False: 129]
  |  Branch (638:27): [True: 267, False: 0]
  ------------------
  639|    396|        (xmlStructuredError == NULL) && (ctxt->sax != NULL)) {
  ------------------
  |  |  877|    267|  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)
  |  |  ------------------
  |  |  |  |  500|    267|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (639:9): [True: 267, False: 0]
  |  Branch (639:41): [True: 267, False: 0]
  ------------------
  640|    267|        if (level == XML_ERR_WARNING)
  ------------------
  |  Branch (640:13): [True: 0, False: 267]
  ------------------
  641|      0|	    channel = ctxt->sax->warning;
  642|    267|        else
  643|    267|	    channel = ctxt->sax->error;
  644|    267|	data = ctxt->userData;
  645|    267|    } else if (channel == NULL) {
  ------------------
  |  Branch (645:16): [True: 129, False: 0]
  ------------------
  646|    129|	channel = xmlGenericError;
  ------------------
  |  |  875|    129|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    129|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  647|    129|	if (ctxt != NULL) {
  ------------------
  |  Branch (647:6): [True: 0, False: 129]
  ------------------
  648|      0|	    data = ctxt;
  649|    129|	} else {
  650|    129|	    data = xmlGenericErrorContext;
  ------------------
  |  |  876|    129|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    129|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  651|    129|	}
  652|    129|    }
  653|    396|    if (channel == NULL)
  ------------------
  |  Branch (653:9): [True: 0, False: 396]
  ------------------
  654|      0|        return;
  655|       |
  656|    396|    if ((channel == xmlParserError) ||
  ------------------
  |  Branch (656:9): [True: 267, False: 129]
  ------------------
  657|    396|        (channel == xmlParserWarning) ||
  ------------------
  |  Branch (657:9): [True: 0, False: 129]
  ------------------
  658|    396|	(channel == xmlParserValidityError) ||
  ------------------
  |  Branch (658:2): [True: 0, False: 129]
  ------------------
  659|    396|	(channel == xmlParserValidityWarning))
  ------------------
  |  Branch (659:2): [True: 0, False: 129]
  ------------------
  660|    267|	xmlReportError(to, ctxt, str, NULL, NULL);
  661|    129|    else if (((void(*)(void)) channel == (void(*)(void)) fprintf) ||
  ------------------
  |  Branch (661:14): [True: 0, False: 129]
  ------------------
  662|    129|             (channel == xmlGenericErrorDefaultFunc))
  ------------------
  |  Branch (662:14): [True: 0, False: 129]
  ------------------
  663|      0|	xmlReportError(to, ctxt, str, channel, data);
  664|    129|    else
  665|    129|	channel(data, "%s", str);
  666|    396|}
xmlResetError:
  901|  1.13k|{
  902|  1.13k|    if (err == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 1.13k]
  ------------------
  903|      0|        return;
  904|  1.13k|    if (err->code == XML_ERR_OK)
  ------------------
  |  Branch (904:9): [True: 605, False: 533]
  ------------------
  905|    605|        return;
  906|    533|    if (err->message != NULL)
  ------------------
  |  Branch (906:9): [True: 395, False: 138]
  ------------------
  907|    395|        xmlFree(err->message);
  908|    533|    if (err->file != NULL)
  ------------------
  |  Branch (908:9): [True: 0, False: 533]
  ------------------
  909|      0|        xmlFree(err->file);
  910|    533|    if (err->str1 != NULL)
  ------------------
  |  Branch (910:9): [True: 275, False: 258]
  ------------------
  911|    275|        xmlFree(err->str1);
  912|    533|    if (err->str2 != NULL)
  ------------------
  |  Branch (912:9): [True: 94, False: 439]
  ------------------
  913|     94|        xmlFree(err->str2);
  914|    533|    if (err->str3 != NULL)
  ------------------
  |  Branch (914:9): [True: 0, False: 533]
  ------------------
  915|      0|        xmlFree(err->str3);
  916|    533|    memset(err, 0, sizeof(xmlError));
  917|    533|    err->code = XML_ERR_OK;
  918|    533|}
xmlResetLastError:
  928|    488|{
  929|    488|    if (xmlLastError.code == XML_ERR_OK)
  ------------------
  |  |  874|    488|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    488|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (929:9): [True: 369, False: 119]
  ------------------
  930|    369|        return;
  931|    119|    xmlResetError(&xmlLastError);
  ------------------
  |  |  874|    119|  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)
  |  |  ------------------
  |  |  |  |  500|    119|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  932|    119|}
xmlCopyError:
  984|    267|xmlCopyError(const xmlError *from, xmlErrorPtr to) {
  985|    267|    char *message, *file, *str1, *str2, *str3;
  986|       |
  987|    267|    if ((from == NULL) || (to == NULL))
  ------------------
  |  Branch (987:9): [True: 0, False: 267]
  |  Branch (987:27): [True: 0, False: 267]
  ------------------
  988|      0|        return(-1);
  989|       |
  990|    267|    message = (char *) xmlStrdup((xmlChar *) from->message);
  991|    267|    file = (char *) xmlStrdup ((xmlChar *) from->file);
  992|    267|    str1 = (char *) xmlStrdup ((xmlChar *) from->str1);
  993|    267|    str2 = (char *) xmlStrdup ((xmlChar *) from->str2);
  994|    267|    str3 = (char *) xmlStrdup ((xmlChar *) from->str3);
  995|       |
  996|    267|    if (to->message != NULL)
  ------------------
  |  Branch (996:9): [True: 207, False: 60]
  ------------------
  997|    207|        xmlFree(to->message);
  998|    267|    if (to->file != NULL)
  ------------------
  |  Branch (998:9): [True: 0, False: 267]
  ------------------
  999|      0|        xmlFree(to->file);
 1000|    267|    if (to->str1 != NULL)
  ------------------
  |  Branch (1000:9): [True: 33, False: 234]
  ------------------
 1001|     33|        xmlFree(to->str1);
 1002|    267|    if (to->str2 != NULL)
  ------------------
  |  Branch (1002:9): [True: 11, False: 256]
  ------------------
 1003|     11|        xmlFree(to->str2);
 1004|    267|    if (to->str3 != NULL)
  ------------------
  |  Branch (1004:9): [True: 0, False: 267]
  ------------------
 1005|      0|        xmlFree(to->str3);
 1006|    267|    to->domain = from->domain;
 1007|    267|    to->code = from->code;
 1008|    267|    to->level = from->level;
 1009|    267|    to->line = from->line;
 1010|    267|    to->node = from->node;
 1011|    267|    to->int1 = from->int1;
 1012|    267|    to->int2 = from->int2;
 1013|    267|    to->node = from->node;
 1014|    267|    to->ctxt = from->ctxt;
 1015|    267|    to->message = message;
 1016|    267|    to->file = file;
 1017|    267|    to->str1 = str1;
 1018|    267|    to->str2 = str2;
 1019|    267|    to->str3 = str3;
 1020|       |
 1021|    267|    return 0;
 1022|    267|}
error.c:xmlParserPrintFileContextInternal:
  175|    267|		xmlGenericErrorFunc channel, void *data ) {
  176|    267|    const xmlChar *cur, *base, *start;
  177|    267|    unsigned int n, col;	/* GCC warns if signed, because compared with sizeof() */
  178|    267|    xmlChar  content[81]; /* space for 80 chars + line terminator */
  179|    267|    xmlChar *ctnt;
  180|       |
  181|    267|    if ((input == NULL) || (input->cur == NULL))
  ------------------
  |  Branch (181:9): [True: 0, False: 267]
  |  Branch (181:28): [True: 0, False: 267]
  ------------------
  182|      0|        return;
  183|       |
  184|    267|    cur = input->cur;
  185|    267|    base = input->base;
  186|       |    /* skip backwards over any end-of-lines */
  187|    294|    while ((cur > base) && ((*(cur) == '\n') || (*(cur) == '\r'))) {
  ------------------
  |  Branch (187:12): [True: 293, False: 1]
  |  Branch (187:29): [True: 27, False: 266]
  |  Branch (187:49): [True: 0, False: 266]
  ------------------
  188|     27|	cur--;
  189|     27|    }
  190|    267|    n = 0;
  191|       |    /* search backwards for beginning-of-line (to max buff size) */
  192|  5.10k|    while ((n < sizeof(content) - 1) && (cur > base) &&
  ------------------
  |  Branch (192:12): [True: 5.10k, False: 6]
  |  Branch (192:41): [True: 5.04k, False: 52]
  ------------------
  193|  5.10k|	   (*cur != '\n') && (*cur != '\r')) {
  ------------------
  |  Branch (193:5): [True: 4.84k, False: 209]
  |  Branch (193:23): [True: 4.84k, False: 0]
  ------------------
  194|  4.84k|        cur--;
  195|  4.84k|        n++;
  196|  4.84k|    }
  197|    267|    if ((n > 0) && ((*cur == '\n') || (*cur == '\r'))) {
  ------------------
  |  Branch (197:9): [True: 266, False: 1]
  |  Branch (197:21): [True: 209, False: 57]
  |  Branch (197:39): [True: 0, False: 57]
  ------------------
  198|    209|        cur++;
  199|    209|    } else {
  200|       |        /* skip over continuation bytes */
  201|    280|        while ((cur < input->cur) && ((*cur & 0xC0) == 0x80))
  ------------------
  |  Branch (201:16): [True: 279, False: 1]
  |  Branch (201:38): [True: 222, False: 57]
  ------------------
  202|    222|            cur++;
  203|     58|    }
  204|       |    /* calculate the error position in terms of the current position */
  205|    267|    col = input->cur - cur;
  206|       |    /* search forward for end-of-line (to max buff size) */
  207|    267|    n = 0;
  208|    267|    start = cur;
  209|       |    /* copy selected text to our buffer */
  210|  4.10k|    while ((*cur != 0) && (*(cur) != '\n') && (*(cur) != '\r')) {
  ------------------
  |  Branch (210:12): [True: 3.93k, False: 167]
  |  Branch (210:27): [True: 3.86k, False: 67]
  |  Branch (210:47): [True: 3.86k, False: 0]
  ------------------
  211|  3.86k|        int len = input->end - cur;
  212|  3.86k|        int c = xmlGetUTF8Char(cur, &len);
  213|       |
  214|  3.86k|        if ((c < 0) || (n + len > sizeof(content)-1))
  ------------------
  |  Branch (214:13): [True: 29, False: 3.83k]
  |  Branch (214:24): [True: 4, False: 3.83k]
  ------------------
  215|     33|            break;
  216|  3.83k|        cur += len;
  217|  3.83k|	n += len;
  218|  3.83k|    }
  219|    267|    memcpy(content, start, n);
  220|    267|    content[n] = 0;
  221|       |    /* print out the selected text */
  222|    267|    channel(data ,"%s\n", content);
  223|       |    /* create blank line with problem pointer */
  224|    267|    n = 0;
  225|    267|    ctnt = content;
  226|       |    /* (leave buffer space for pointer + line terminator) */
  227|  3.20k|    while ((n<col) && (n++ < sizeof(content)-2) && (*ctnt != 0)) {
  ------------------
  |  Branch (227:12): [True: 3.06k, False: 139]
  |  Branch (227:23): [True: 3.06k, False: 0]
  |  Branch (227:52): [True: 2.93k, False: 128]
  ------------------
  228|  2.93k|	if (*(ctnt) != '\t')
  ------------------
  |  Branch (228:6): [True: 2.93k, False: 0]
  ------------------
  229|  2.93k|	    *(ctnt) = ' ';
  230|  2.93k|	ctnt++;
  231|  2.93k|    }
  232|    267|    *ctnt++ = '^';
  233|    267|    *ctnt = 0;
  234|    267|    channel(data ,"%s\n", content);
  235|    267|}
error.c:xmlReportError:
  261|    267|{
  262|    267|    char *file = NULL;
  263|    267|    int line = 0;
  264|    267|    int code = -1;
  265|    267|    int domain;
  266|    267|    const xmlChar *name = NULL;
  267|    267|    xmlNodePtr node;
  268|    267|    xmlErrorLevel level;
  269|    267|    xmlParserInputPtr input = NULL;
  270|    267|    xmlParserInputPtr cur = NULL;
  271|       |
  272|    267|    if (err == NULL)
  ------------------
  |  Branch (272:9): [True: 0, False: 267]
  ------------------
  273|      0|        return;
  274|       |
  275|    267|    if (channel == NULL) {
  ------------------
  |  Branch (275:9): [True: 267, False: 0]
  ------------------
  276|    267|	channel = xmlGenericError;
  ------------------
  |  |  875|    267|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|    267|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  277|    267|	data = xmlGenericErrorContext;
  ------------------
  |  |  876|    267|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|    267|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  278|    267|    }
  279|    267|    file = err->file;
  280|    267|    line = err->line;
  281|    267|    code = err->code;
  282|    267|    domain = err->domain;
  283|    267|    level = err->level;
  284|    267|    node = err->node;
  285|       |
  286|    267|    if (code == XML_ERR_OK)
  ------------------
  |  Branch (286:9): [True: 0, False: 267]
  ------------------
  287|      0|        return;
  288|       |
  289|    267|    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (289:9): [True: 0, False: 267]
  |  Branch (289:27): [True: 0, False: 0]
  ------------------
  290|      0|        name = node->name;
  291|       |
  292|       |    /*
  293|       |     * Maintain the compatibility with the legacy error handling
  294|       |     */
  295|    267|    if (ctxt != NULL) {
  ------------------
  |  Branch (295:9): [True: 267, False: 0]
  ------------------
  296|    267|        input = ctxt->input;
  297|    267|        if ((input != NULL) && (input->filename == NULL) &&
  ------------------
  |  Branch (297:13): [True: 267, False: 0]
  |  Branch (297:32): [True: 267, False: 0]
  ------------------
  298|    267|            (ctxt->inputNr > 1)) {
  ------------------
  |  Branch (298:13): [True: 0, False: 267]
  ------------------
  299|      0|            cur = input;
  300|      0|            input = ctxt->inputTab[ctxt->inputNr - 2];
  301|      0|        }
  302|    267|        if (input != NULL) {
  ------------------
  |  Branch (302:13): [True: 267, False: 0]
  ------------------
  303|    267|            if (input->filename)
  ------------------
  |  Branch (303:17): [True: 0, False: 267]
  ------------------
  304|      0|                channel(data, "%s:%d: ", input->filename, input->line);
  305|    267|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (305:22): [True: 267, False: 0]
  |  Branch (305:37): [True: 265, False: 2]
  ------------------
  306|    265|                channel(data, "Entity: line %d: ", input->line);
  307|    267|        }
  308|    267|    } else {
  309|      0|        if (file != NULL)
  ------------------
  |  Branch (309:13): [True: 0, False: 0]
  ------------------
  310|      0|            channel(data, "%s:%d: ", file, line);
  311|      0|        else if ((line != 0) &&
  ------------------
  |  Branch (311:18): [True: 0, False: 0]
  ------------------
  312|      0|	         ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||
  ------------------
  |  Branch (312:12): [True: 0, False: 0]
  |  Branch (312:43): [True: 0, False: 0]
  ------------------
  313|      0|		  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||
  ------------------
  |  Branch (313:5): [True: 0, False: 0]
  |  Branch (313:36): [True: 0, False: 0]
  ------------------
  314|      0|		  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))
  ------------------
  |  Branch (314:5): [True: 0, False: 0]
  |  Branch (314:36): [True: 0, False: 0]
  ------------------
  315|      0|            channel(data, "Entity: line %d: ", line);
  316|      0|    }
  317|    267|    if (name != NULL) {
  ------------------
  |  Branch (317:9): [True: 0, False: 267]
  ------------------
  318|      0|        channel(data, "element %s: ", name);
  319|      0|    }
  320|    267|    switch (domain) {
  321|    265|        case XML_FROM_PARSER:
  ------------------
  |  Branch (321:9): [True: 265, False: 2]
  ------------------
  322|    265|            channel(data, "parser ");
  323|    265|            break;
  324|      2|        case XML_FROM_NAMESPACE:
  ------------------
  |  Branch (324:9): [True: 2, False: 265]
  ------------------
  325|      2|            channel(data, "namespace ");
  326|      2|            break;
  327|      0|        case XML_FROM_DTD:
  ------------------
  |  Branch (327:9): [True: 0, False: 267]
  ------------------
  328|      0|        case XML_FROM_VALID:
  ------------------
  |  Branch (328:9): [True: 0, False: 267]
  ------------------
  329|      0|            channel(data, "validity ");
  330|      0|            break;
  331|      0|        case XML_FROM_HTML:
  ------------------
  |  Branch (331:9): [True: 0, False: 267]
  ------------------
  332|      0|            channel(data, "HTML parser ");
  333|      0|            break;
  334|      0|        case XML_FROM_MEMORY:
  ------------------
  |  Branch (334:9): [True: 0, False: 267]
  ------------------
  335|      0|            channel(data, "memory ");
  336|      0|            break;
  337|      0|        case XML_FROM_OUTPUT:
  ------------------
  |  Branch (337:9): [True: 0, False: 267]
  ------------------
  338|      0|            channel(data, "output ");
  339|      0|            break;
  340|      0|        case XML_FROM_IO:
  ------------------
  |  Branch (340:9): [True: 0, False: 267]
  ------------------
  341|      0|            channel(data, "I/O ");
  342|      0|            break;
  343|      0|        case XML_FROM_XINCLUDE:
  ------------------
  |  Branch (343:9): [True: 0, False: 267]
  ------------------
  344|      0|            channel(data, "XInclude ");
  345|      0|            break;
  346|      0|        case XML_FROM_XPATH:
  ------------------
  |  Branch (346:9): [True: 0, False: 267]
  ------------------
  347|      0|            channel(data, "XPath ");
  348|      0|            break;
  349|      0|        case XML_FROM_XPOINTER:
  ------------------
  |  Branch (349:9): [True: 0, False: 267]
  ------------------
  350|      0|            channel(data, "parser ");
  351|      0|            break;
  352|      0|        case XML_FROM_REGEXP:
  ------------------
  |  Branch (352:9): [True: 0, False: 267]
  ------------------
  353|      0|            channel(data, "regexp ");
  354|      0|            break;
  355|      0|        case XML_FROM_MODULE:
  ------------------
  |  Branch (355:9): [True: 0, False: 267]
  ------------------
  356|      0|            channel(data, "module ");
  357|      0|            break;
  358|      0|        case XML_FROM_SCHEMASV:
  ------------------
  |  Branch (358:9): [True: 0, False: 267]
  ------------------
  359|      0|            channel(data, "Schemas validity ");
  360|      0|            break;
  361|      0|        case XML_FROM_SCHEMASP:
  ------------------
  |  Branch (361:9): [True: 0, False: 267]
  ------------------
  362|      0|            channel(data, "Schemas parser ");
  363|      0|            break;
  364|      0|        case XML_FROM_RELAXNGP:
  ------------------
  |  Branch (364:9): [True: 0, False: 267]
  ------------------
  365|      0|            channel(data, "Relax-NG parser ");
  366|      0|            break;
  367|      0|        case XML_FROM_RELAXNGV:
  ------------------
  |  Branch (367:9): [True: 0, False: 267]
  ------------------
  368|      0|            channel(data, "Relax-NG validity ");
  369|      0|            break;
  370|      0|        case XML_FROM_CATALOG:
  ------------------
  |  Branch (370:9): [True: 0, False: 267]
  ------------------
  371|      0|            channel(data, "Catalog ");
  372|      0|            break;
  373|      0|        case XML_FROM_C14N:
  ------------------
  |  Branch (373:9): [True: 0, False: 267]
  ------------------
  374|      0|            channel(data, "C14N ");
  375|      0|            break;
  376|      0|        case XML_FROM_XSLT:
  ------------------
  |  Branch (376:9): [True: 0, False: 267]
  ------------------
  377|      0|            channel(data, "XSLT ");
  378|      0|            break;
  379|      0|        case XML_FROM_I18N:
  ------------------
  |  Branch (379:9): [True: 0, False: 267]
  ------------------
  380|      0|            channel(data, "encoding ");
  381|      0|            break;
  382|      0|        case XML_FROM_SCHEMATRONV:
  ------------------
  |  Branch (382:9): [True: 0, False: 267]
  ------------------
  383|      0|            channel(data, "schematron ");
  384|      0|            break;
  385|      0|        case XML_FROM_BUFFER:
  ------------------
  |  Branch (385:9): [True: 0, False: 267]
  ------------------
  386|      0|            channel(data, "internal buffer ");
  387|      0|            break;
  388|      0|        case XML_FROM_URI:
  ------------------
  |  Branch (388:9): [True: 0, False: 267]
  ------------------
  389|      0|            channel(data, "URI ");
  390|      0|            break;
  391|      0|        default:
  ------------------
  |  Branch (391:9): [True: 0, False: 267]
  ------------------
  392|      0|            break;
  393|    267|    }
  394|    267|    switch (level) {
  ------------------
  |  Branch (394:13): [True: 0, False: 267]
  ------------------
  395|      0|        case XML_ERR_NONE:
  ------------------
  |  Branch (395:9): [True: 0, False: 267]
  ------------------
  396|      0|            channel(data, ": ");
  397|      0|            break;
  398|      0|        case XML_ERR_WARNING:
  ------------------
  |  Branch (398:9): [True: 0, False: 267]
  ------------------
  399|      0|            channel(data, "warning : ");
  400|      0|            break;
  401|      2|        case XML_ERR_ERROR:
  ------------------
  |  Branch (401:9): [True: 2, False: 265]
  ------------------
  402|      2|            channel(data, "error : ");
  403|      2|            break;
  404|    265|        case XML_ERR_FATAL:
  ------------------
  |  Branch (404:9): [True: 265, False: 2]
  ------------------
  405|    265|            channel(data, "error : ");
  406|    265|            break;
  407|    267|    }
  408|    267|    if (str != NULL) {
  ------------------
  |  Branch (408:9): [True: 267, False: 0]
  ------------------
  409|    267|        int len;
  410|    267|	len = xmlStrlen((const xmlChar *)str);
  411|    267|	if ((len > 0) && (str[len - 1] != '\n'))
  ------------------
  |  Branch (411:6): [True: 267, False: 0]
  |  Branch (411:19): [True: 0, False: 267]
  ------------------
  412|      0|	    channel(data, "%s\n", str);
  413|    267|	else
  414|    267|	    channel(data, "%s", str);
  415|    267|    } else {
  416|      0|        channel(data, "%s\n", "out of memory error");
  417|      0|    }
  418|       |
  419|    267|    if (ctxt != NULL) {
  ------------------
  |  Branch (419:9): [True: 267, False: 0]
  ------------------
  420|    267|        xmlParserPrintFileContextInternal(input, channel, data);
  421|    267|        if (cur != NULL) {
  ------------------
  |  Branch (421:13): [True: 0, False: 267]
  ------------------
  422|      0|            if (cur->filename)
  ------------------
  |  Branch (422:17): [True: 0, False: 0]
  ------------------
  423|      0|                channel(data, "%s:%d: \n", cur->filename, cur->line);
  424|      0|            else if ((line != 0) && (domain == XML_FROM_PARSER))
  ------------------
  |  Branch (424:22): [True: 0, False: 0]
  |  Branch (424:37): [True: 0, False: 0]
  ------------------
  425|      0|                channel(data, "Entity: line %d: \n", cur->line);
  426|      0|            xmlParserPrintFileContextInternal(cur, channel, data);
  427|      0|        }
  428|    267|    }
  429|    267|    if ((domain == XML_FROM_XPATH) && (err->str1 != NULL) &&
  ------------------
  |  Branch (429:9): [True: 0, False: 267]
  |  Branch (429:39): [True: 0, False: 0]
  ------------------
  430|    267|        (err->int1 < 100) &&
  ------------------
  |  Branch (430:9): [True: 0, False: 0]
  ------------------
  431|    267|	(err->int1 < xmlStrlen((const xmlChar *)err->str1))) {
  ------------------
  |  Branch (431:2): [True: 0, False: 0]
  ------------------
  432|      0|	xmlChar buf[150];
  433|      0|	int i;
  434|       |
  435|      0|	channel(data, "%s\n", err->str1);
  436|      0|	for (i=0;i < err->int1;i++)
  ------------------
  |  Branch (436:11): [True: 0, False: 0]
  ------------------
  437|      0|	     buf[i] = ' ';
  438|      0|	buf[i++] = '^';
  439|      0|	buf[i] = 0;
  440|      0|	channel(data, "%s\n", buf);
  441|      0|    }
  442|    267|}

xmlFuzzErrorFunc:
   56|  1.75k|                 ...) {
   57|  1.75k|}
xmlFuzzMemSetup:
  103|      2|xmlFuzzMemSetup(void) {
  104|      2|    xmlMemSetup(free, xmlFuzzMalloc, xmlFuzzRealloc, xmlMemStrdup);
  105|      2|}
xmlFuzzMemSetLimit:
  108|    972|xmlFuzzMemSetLimit(size_t limit) {
  109|    972|    fuzzNumAllocs = 0;
  110|    972|    fuzzMaxAllocs = limit ? limit + XML_FUZZ_MALLOC_OFFSET : 0;
  ------------------
  |  |   69|     13|#define XML_FUZZ_MALLOC_OFFSET  0
  ------------------
  |  Branch (110:21): [True: 13, False: 959]
  ------------------
  111|    972|    fuzzAllocFailed = 0;
  112|    972|}
xmlFuzzDataInit:
  125|    488|xmlFuzzDataInit(const char *data, size_t size) {
  126|    488|    fuzzData.data = data;
  127|    488|    fuzzData.size = size;
  128|    488|    fuzzData.ptr = data;
  129|    488|    fuzzData.remaining = size;
  130|       |
  131|    488|    fuzzData.outBuf = xmlMalloc(size + 1);
  132|    488|    fuzzData.outPtr = fuzzData.outBuf;
  133|       |
  134|    488|    fuzzData.entities = xmlHashCreate(8);
  135|    488|    fuzzData.mainUrl = NULL;
  136|    488|    fuzzData.mainEntity = NULL;
  137|    488|}
xmlFuzzDataCleanup:
  145|    488|xmlFuzzDataCleanup(void) {
  146|    488|    xmlFree(fuzzData.outBuf);
  147|    488|    xmlHashFree(fuzzData.entities, xmlHashDefaultDeallocator);
  148|    488|}
xmlFuzzReadInt:
  181|    488|xmlFuzzReadInt(int size) {
  182|    488|    size_t ret = 0;
  183|       |
  184|  2.44k|    while ((size > 0) && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (184:12): [True: 1.95k, False: 488]
  |  Branch (184:26): [True: 1.95k, False: 0]
  ------------------
  185|  1.95k|        unsigned char c = (unsigned char) *fuzzData.ptr++;
  186|  1.95k|        fuzzData.remaining--;
  187|  1.95k|        ret = (ret << 8) | c;
  188|  1.95k|        size--;
  189|  1.95k|    }
  190|       |
  191|    488|    return ret;
  192|    488|}
xmlFuzzReadString:
  245|    976|xmlFuzzReadString(size_t *size) {
  246|    976|    const char *out = fuzzData.outPtr;
  247|       |
  248|   112k|    while (fuzzData.remaining > 0) {
  ------------------
  |  Branch (248:12): [True: 112k, False: 9]
  ------------------
  249|   112k|        int c = *fuzzData.ptr++;
  250|   112k|        fuzzData.remaining--;
  251|       |
  252|   112k|        if ((c == '\\') && (fuzzData.remaining > 0)) {
  ------------------
  |  Branch (252:13): [True: 976, False: 111k]
  |  Branch (252:28): [True: 976, False: 0]
  ------------------
  253|    976|            int c2 = *fuzzData.ptr;
  254|       |
  255|    976|            if (c2 == '\n') {
  ------------------
  |  Branch (255:17): [True: 967, False: 9]
  ------------------
  256|    967|                fuzzData.ptr++;
  257|    967|                fuzzData.remaining--;
  258|    967|                if (size != NULL)
  ------------------
  |  Branch (258:21): [True: 967, False: 0]
  ------------------
  259|    967|                    *size = fuzzData.outPtr - out;
  260|    967|                *fuzzData.outPtr++ = '\0';
  261|    967|                return(out);
  262|    967|            }
  263|      9|            if (c2 == '\\') {
  ------------------
  |  Branch (263:17): [True: 0, False: 9]
  ------------------
  264|      0|                fuzzData.ptr++;
  265|      0|                fuzzData.remaining--;
  266|      0|            }
  267|      9|        }
  268|       |
  269|   111k|        *fuzzData.outPtr++ = c;
  270|   111k|    }
  271|       |
  272|      9|    if (fuzzData.outPtr > out) {
  ------------------
  |  Branch (272:9): [True: 7, False: 2]
  ------------------
  273|      7|        if (size != NULL)
  ------------------
  |  Branch (273:13): [True: 7, False: 0]
  ------------------
  274|      7|            *size = fuzzData.outPtr - out;
  275|      7|        *fuzzData.outPtr++ = '\0';
  276|      7|        return(out);
  277|      7|    }
  278|       |
  279|      2|    if (size != NULL)
  ------------------
  |  Branch (279:9): [True: 2, False: 0]
  ------------------
  280|      2|        *size = 0;
  281|      2|    return(NULL);
  282|      9|}
fuzz.c:xmlFuzzMalloc:
   73|  52.0k|xmlFuzzMalloc(size_t size) {
   74|  52.0k|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (74:9): [True: 498, False: 51.5k]
  ------------------
   75|    498|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (75:13): [True: 185, False: 313]
  ------------------
   76|       |#if XML_FUZZ_MALLOC_ABORT
   77|       |            abort();
   78|       |#endif
   79|    185|            fuzzAllocFailed = 1;
   80|    185|            return(NULL);
   81|    185|        }
   82|    313|        fuzzNumAllocs += 1;
   83|    313|    }
   84|  51.8k|    return malloc(size);
   85|  52.0k|}
fuzz.c:xmlFuzzRealloc:
   88|    891|xmlFuzzRealloc(void *ptr, size_t size) {
   89|    891|    if (fuzzMaxAllocs > 0) {
  ------------------
  |  Branch (89:9): [True: 3, False: 888]
  ------------------
   90|      3|        if (fuzzNumAllocs >= fuzzMaxAllocs - 1) {
  ------------------
  |  Branch (90:13): [True: 0, False: 3]
  ------------------
   91|       |#if XML_FUZZ_MALLOC_ABORT
   92|       |            abort();
   93|       |#endif
   94|      0|            fuzzAllocFailed = 1;
   95|      0|            return(NULL);
   96|      0|        }
   97|      3|        fuzzNumAllocs += 1;
   98|      3|    }
   99|    891|    return realloc(ptr, size);
  100|    891|}

LLVMFuzzerInitialize:
   13|      2|                     char ***argv ATTRIBUTE_UNUSED) {
   14|      2|    xmlFuzzMemSetup();
   15|      2|    xmlInitParser();
   16|      2|    xmlSetGenericErrorFunc(NULL, xmlFuzzErrorFunc);
   17|       |
   18|      2|    return 0;
   19|      2|}
LLVMFuzzerTestOneInput:
   22|    488|LLVMFuzzerTestOneInput(const char *data, size_t size) {
   23|    488|    xmlDocPtr doc;
   24|    488|    const char *expr, *xml;
   25|    488|    size_t maxAlloc, exprSize, xmlSize;
   26|       |
   27|    488|    if (size > 10000)
  ------------------
  |  Branch (27:9): [True: 0, False: 488]
  ------------------
   28|      0|        return(0);
   29|       |
   30|    488|    xmlFuzzDataInit(data, size);
   31|       |
   32|    488|    maxAlloc = xmlFuzzReadInt(4) % (size + 1);
   33|    488|    expr = xmlFuzzReadString(&exprSize);
   34|    488|    xml = xmlFuzzReadString(&xmlSize);
   35|       |
   36|       |    /* Recovery mode allows more input to be fuzzed. */
   37|    488|    doc = xmlReadMemory(xml, xmlSize, NULL, NULL, XML_PARSE_RECOVER);
   38|    488|    if (doc != NULL) {
  ------------------
  |  Branch (38:9): [True: 486, False: 2]
  ------------------
   39|    486|        xmlXPathContextPtr xpctxt;
   40|       |
   41|    486|        xmlFuzzMemSetLimit(maxAlloc);
   42|       |
   43|    486|        xpctxt = xmlXPathNewContext(doc);
   44|    486|        if (xpctxt != NULL) {
  ------------------
  |  Branch (44:13): [True: 486, False: 0]
  ------------------
   45|       |            /* Operation limit to avoid timeout */
   46|    486|            xpctxt->opLimit = 500000;
   47|       |
   48|    486|            xmlXPathFreeObject(xmlXPtrEval(BAD_CAST expr, xpctxt));
  ------------------
  |  |   35|    486|#define BAD_CAST (xmlChar *)
  ------------------
   49|    486|            xmlXPathFreeContext(xpctxt);
   50|    486|        }
   51|       |
   52|    486|        xmlFuzzMemSetLimit(0);
   53|    486|        xmlFreeDoc(doc);
   54|    486|    }
   55|       |
   56|    488|    xmlFuzzDataCleanup();
   57|    488|    xmlResetLastError();
   58|       |
   59|    488|    return(0);
   60|    488|}

xmlInitGlobalsInternal:
  566|      2|void xmlInitGlobalsInternal(void) {
  567|      2|    xmlInitMutex(&xmlThrDefMutex);
  568|       |
  569|      2|#ifdef HAVE_POSIX_THREADS
  570|      2|#ifdef XML_PTHREAD_WEAK
  571|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (571:9): [True: 2, False: 0]
  ------------------
  572|      2|        libxml_is_threaded =
  573|      2|            (pthread_getspecific != NULL) &&
  ------------------
  |  Branch (573:13): [True: 2, False: 0]
  ------------------
  574|      2|            (pthread_setspecific != NULL) &&
  ------------------
  |  Branch (574:13): [True: 2, False: 0]
  ------------------
  575|      2|            (pthread_key_create != NULL) &&
  ------------------
  |  Branch (575:13): [True: 2, False: 0]
  ------------------
  576|      2|            (pthread_key_delete != NULL) &&
  ------------------
  |  Branch (576:13): [True: 2, False: 0]
  ------------------
  577|       |            /*
  578|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  579|       |             * Let's assume it's available if all the other functions are.
  580|       |             */
  581|       |            /* (pthread_equal != NULL) && */
  582|      2|            (pthread_self != NULL);
  ------------------
  |  Branch (582:13): [True: 2, False: 0]
  ------------------
  583|      2|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (583:9): [True: 0, False: 2]
  ------------------
  584|      0|        return;
  585|      2|#endif /* XML_PTHREAD_WEAK */
  586|      2|    pthread_key_create(&globalkey, xmlFreeGlobalState);
  587|      2|    mainthread = pthread_self();
  588|       |#elif defined(HAVE_WIN32_THREADS)
  589|       |#ifndef USE_TLS
  590|       |    globalkey = TlsAlloc();
  591|       |#endif
  592|       |    mainthread = GetCurrentThreadId();
  593|       |#endif
  594|      2|}
__xmlLastError:
  892|  1.66k|    type *__##name(void) { \
  893|  1.66k|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|  1.66k|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 1.66k, False: 0]
  |  |  ------------------
  ------------------
  894|  1.66k|            return (&name); \
  895|  1.66k|        else \
  896|  1.66k|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|  1.66k|    }
__xmlGenericError:
  892|    426|    type *__##name(void) { \
  893|    426|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    426|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 426, False: 0]
  |  |  ------------------
  ------------------
  894|    426|            return (&name); \
  895|    426|        else \
  896|    426|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    426|    }
__xmlGenericErrorContext:
  892|    426|    type *__##name(void) { \
  893|    426|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    426|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 426, False: 0]
  |  |  ------------------
  ------------------
  894|    426|            return (&name); \
  895|    426|        else \
  896|    426|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    426|    }
__xmlStructuredError:
  892|    663|    type *__##name(void) { \
  893|    663|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    663|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 663, False: 0]
  |  |  ------------------
  ------------------
  894|    663|            return (&name); \
  895|    663|        else \
  896|    663|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    663|    }
__xmlDefaultSAXLocator:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlDoValidityCheckingDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlGetWarningsDefaultValue:
  892|    396|    type *__##name(void) { \
  893|    396|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    396|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 396, False: 0]
  |  |  ------------------
  ------------------
  894|    396|            return (&name); \
  895|    396|        else \
  896|    396|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    396|    }
__xmlKeepBlanksDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlLineNumbersDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlLoadExtDtdDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlPedanticParserDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlSubstituteEntitiesDefaultValue:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlDefaultSAXHandler:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
__xmlBufferAllocScheme:
  892|    597|    type *__##name(void) { \
  893|    597|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    597|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 597, False: 0]
  |  |  ------------------
  ------------------
  894|    597|            return (&name); \
  895|    597|        else \
  896|    597|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    597|    }
__xmlDefaultBufferSize:
  892|    486|    type *__##name(void) { \
  893|    486|        if (IS_MAIN_THREAD) \
  ------------------
  |  |   62|    486|#define IS_MAIN_THREAD (xmlIsMainThreadInternal())
  |  |  ------------------
  |  |  |  Branch (62:24): [True: 486, False: 0]
  |  |  ------------------
  ------------------
  894|    486|            return (&name); \
  895|    486|        else \
  896|    486|            return (&xmlGetThreadLocalStorage(0)->gs_##name); \
  897|    486|    }
globals.c:xmlIsMainThreadInternal:
  660|  8.54k|xmlIsMainThreadInternal(void) {
  661|  8.54k|    if (parserInitialized == 0) {
  ------------------
  |  Branch (661:9): [True: 2, False: 8.54k]
  ------------------
  662|      2|        xmlInitParser();
  663|      2|        parserInitialized = 1;
  664|      2|    }
  665|       |
  666|  8.54k|#ifdef HAVE_POSIX_THREADS
  667|  8.54k|#ifdef XML_PTHREAD_WEAK
  668|  8.54k|    if (libxml_is_threaded == 0)
  ------------------
  |  Branch (668:9): [True: 0, False: 8.54k]
  ------------------
  669|      0|        return (1);
  670|  8.54k|#endif
  671|  8.54k|    return (pthread_equal(mainthread, pthread_self()));
  672|       |#elif defined HAVE_WIN32_THREADS
  673|       |    return (mainthread == GetCurrentThreadId());
  674|       |#else
  675|       |    return (1);
  676|       |#endif
  677|  8.54k|}

xmlHashCreate:
  160|  1.06k|xmlHashCreate(int size) {
  161|  1.06k|    xmlHashTablePtr hash;
  162|       |
  163|  1.06k|    xmlInitParser();
  164|       |
  165|  1.06k|    hash = xmlMalloc(sizeof(*hash));
  166|  1.06k|    if (hash == NULL)
  ------------------
  |  Branch (166:9): [True: 0, False: 1.06k]
  ------------------
  167|      0|        return(NULL);
  168|  1.06k|    hash->dict = NULL;
  169|  1.06k|    hash->size = 0;
  170|  1.06k|    hash->table = NULL;
  171|  1.06k|    hash->nbElems = 0;
  172|  1.06k|    hash->randomSeed = xmlRandom();
  173|  1.06k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  174|  1.06k|    hash->randomSeed = 0;
  175|  1.06k|#endif
  176|       |
  177|       |    /*
  178|       |     * Unless a larger size is passed, the backing table is created
  179|       |     * lazily with MIN_HASH_SIZE capacity. In practice, there are many
  180|       |     * hash tables which are never filled.
  181|       |     */
  182|  1.06k|    if (size > MIN_HASH_SIZE) {
  ------------------
  |  |   30|  1.06k|#define MIN_HASH_SIZE 8
  ------------------
  |  Branch (182:9): [True: 28, False: 1.04k]
  ------------------
  183|     28|        unsigned newSize = MIN_HASH_SIZE * 2;
  ------------------
  |  |   30|     28|#define MIN_HASH_SIZE 8
  ------------------
  184|       |
  185|     28|        while ((newSize < (unsigned) size) && (newSize < MAX_HASH_SIZE))
  ------------------
  |  |   31|      0|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (185:16): [True: 0, False: 28]
  |  Branch (185:47): [True: 0, False: 0]
  ------------------
  186|      0|            newSize *= 2;
  187|       |
  188|     28|        if (xmlHashGrow(hash, newSize) != 0) {
  ------------------
  |  Branch (188:13): [True: 0, False: 28]
  ------------------
  189|      0|            xmlFree(hash);
  190|      0|            return(NULL);
  191|      0|        }
  192|     28|    }
  193|       |
  194|  1.06k|    return(hash);
  195|  1.06k|}
xmlHashCreateDict:
  209|     88|xmlHashCreateDict(int size, xmlDictPtr dict) {
  210|     88|    xmlHashTablePtr hash;
  211|       |
  212|     88|    hash = xmlHashCreate(size);
  213|     88|    if (hash != NULL) {
  ------------------
  |  Branch (213:9): [True: 88, False: 0]
  ------------------
  214|     88|        hash->dict = dict;
  215|     88|        xmlDictReference(dict);
  216|     88|    }
  217|     88|    return(hash);
  218|     88|}
xmlHashFree:
  229|  2.03k|xmlHashFree(xmlHashTablePtr hash, xmlHashDeallocator dealloc) {
  230|  2.03k|    if (hash == NULL)
  ------------------
  |  Branch (230:9): [True: 966, False: 1.06k]
  ------------------
  231|    966|        return;
  232|       |
  233|  1.06k|    if (hash->table) {
  ------------------
  |  Branch (233:9): [True: 580, False: 488]
  ------------------
  234|    580|        const xmlHashEntry *end = &hash->table[hash->size];
  235|    580|        const xmlHashEntry *entry;
  236|       |
  237|  16.9k|        for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (237:35): [True: 16.3k, False: 580]
  ------------------
  238|  16.3k|            if (entry->hashValue == 0)
  ------------------
  |  Branch (238:17): [True: 2.54k, False: 13.8k]
  ------------------
  239|  2.54k|                continue;
  240|  13.8k|            if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (240:17): [True: 336, False: 13.5k]
  |  Branch (240:38): [True: 336, False: 0]
  ------------------
  241|    336|                dealloc(entry->payload, entry->key);
  242|  13.8k|            if (hash->dict == NULL) {
  ------------------
  |  Branch (242:17): [True: 13.4k, False: 396]
  ------------------
  243|  13.4k|                if (entry->key)
  ------------------
  |  Branch (243:21): [True: 13.4k, False: 0]
  ------------------
  244|  13.4k|                    xmlFree(entry->key);
  245|  13.4k|                if (entry->key2)
  ------------------
  |  Branch (245:21): [True: 477, False: 12.9k]
  ------------------
  246|    477|                    xmlFree(entry->key2);
  247|  13.4k|                if (entry->key3)
  ------------------
  |  Branch (247:21): [True: 0, False: 13.4k]
  ------------------
  248|      0|                    xmlFree(entry->key3);
  249|  13.4k|            }
  250|  13.8k|        }
  251|       |
  252|    580|        xmlFree(hash->table);
  253|    580|    }
  254|       |
  255|  1.06k|    if (hash->dict)
  ------------------
  |  Branch (255:9): [True: 88, False: 980]
  ------------------
  256|     88|        xmlDictFree(hash->dict);
  257|       |
  258|  1.06k|    xmlFree(hash);
  259|  1.06k|}
xmlHashDefaultDeallocator:
  603|      6|xmlHashDefaultDeallocator(void *entry, const xmlChar *key ATTRIBUTE_UNUSED) {
  604|      6|    xmlFree(entry);
  605|      6|}
xmlHashAddEntry:
  621|    110|xmlHashAddEntry(xmlHashTablePtr hash, const xmlChar *key, void *payload) {
  622|    110|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload, NULL, 0));
  623|    110|}
xmlHashAddEntry2:
  640|  13.8k|                 const xmlChar *key2, void *payload) {
  641|  13.8k|    return(xmlHashUpdateInternal(hash, key, key2, NULL, payload, NULL, 0));
  642|  13.8k|}
xmlHashAddEntry3:
  661|     88|                 void *payload) {
  662|     88|    return(xmlHashUpdateInternal(hash, key, key2, key3, payload, NULL, 0));
  663|     88|}
xmlHashUpdateEntry:
  679|      6|                   void *payload, xmlHashDeallocator dealloc) {
  680|      6|    return(xmlHashUpdateInternal(hash, key, NULL, NULL, payload,
  681|      6|                                 dealloc, 1));
  682|      6|}
xmlHashLookup:
  739|     19|xmlHashLookup(xmlHashTablePtr hash, const xmlChar *key) {
  740|     19|    return(xmlHashLookup3(hash, key, NULL, NULL));
  741|     19|}
xmlHashLookup2:
  755|    642|              const xmlChar *key2) {
  756|    642|    return(xmlHashLookup3(hash, key, key2, NULL));
  757|    642|}
xmlHashQLookup2:
  790|    132|                const xmlChar *name2) {
  791|    132|    return(xmlHashQLookup3(hash, prefix, name, prefix2, name2, NULL, NULL));
  792|    132|}
xmlHashLookup3:
  807|    815|               const xmlChar *key2, const xmlChar *key3) {
  808|    815|    const xmlHashEntry *entry;
  809|    815|    unsigned hashValue;
  810|    815|    int found;
  811|       |
  812|    815|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (812:9): [True: 0, False: 815]
  |  Branch (812:27): [True: 44, False: 771]
  |  Branch (812:48): [True: 0, False: 771]
  ------------------
  813|     44|        return(NULL);
  814|    771|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
  815|    771|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  816|    771|    if (found)
  ------------------
  |  Branch (816:9): [True: 435, False: 336]
  ------------------
  817|    435|        return(entry->payload);
  818|    336|    return(NULL);
  819|    771|}
xmlHashQLookup3:
  840|    132|                const xmlChar *prefix3, const xmlChar *name3) {
  841|    132|    const xmlHashEntry *entry;
  842|    132|    unsigned hashValue, mask, pos, displ;
  843|       |
  844|    132|    if ((hash == NULL) || (hash->size == 0) || (name == NULL))
  ------------------
  |  Branch (844:9): [True: 0, False: 132]
  |  Branch (844:27): [True: 0, False: 132]
  |  Branch (844:48): [True: 0, False: 132]
  ------------------
  845|      0|        return(NULL);
  846|       |
  847|    132|    hashValue = xmlHashQNameValue(hash->randomSeed, prefix, name, prefix2,
  848|    132|                                  name2, prefix3, name3);
  849|    132|    mask = hash->size - 1;
  850|    132|    pos = hashValue & mask;
  851|    132|    entry = &hash->table[pos];
  852|       |
  853|    132|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (853:9): [True: 132, False: 0]
  ------------------
  854|    132|        displ = 0;
  855|    132|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|    132|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  856|       |
  857|    132|        do {
  858|    132|            if ((hashValue == entry->hashValue) &&
  ------------------
  |  Branch (858:17): [True: 110, False: 22]
  ------------------
  859|    132|                (xmlStrQEqual(prefix, name, entry->key)) &&
  ------------------
  |  Branch (859:17): [True: 110, False: 0]
  ------------------
  860|    132|                (xmlStrQEqual(prefix2, name2, entry->key2)) &&
  ------------------
  |  Branch (860:17): [True: 110, False: 0]
  ------------------
  861|    132|                (xmlStrQEqual(prefix3, name3, entry->key3)))
  ------------------
  |  Branch (861:17): [True: 110, False: 0]
  ------------------
  862|    110|                return(entry->payload);
  863|       |
  864|     22|            displ++;
  865|     22|            pos++;
  866|     22|            entry++;
  867|     22|            if ((pos & mask) == 0)
  ------------------
  |  Branch (867:17): [True: 0, False: 22]
  ------------------
  868|      0|                entry = hash->table;
  869|     22|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (869:18): [True: 0, False: 22]
  ------------------
  870|     22|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (870:18): [True: 0, False: 0]
  ------------------
  871|    132|    }
  872|       |
  873|     22|    return(NULL);
  874|    132|}
xmlHashScanFull:
  914|     22|xmlHashScanFull(xmlHashTablePtr hash, xmlHashScannerFull scan, void *data) {
  915|     22|    const xmlHashEntry *entry, *end;
  916|       |
  917|     22|    if ((hash == NULL) || (hash->size == 0) || (scan == NULL))
  ------------------
  |  Branch (917:9): [True: 0, False: 22]
  |  Branch (917:27): [True: 0, False: 22]
  |  Branch (917:48): [True: 0, False: 22]
  ------------------
  918|      0|        return;
  919|       |
  920|     22|    end = &hash->table[hash->size];
  921|       |
  922|    374|    for (entry = hash->table; entry < end; entry++) {
  ------------------
  |  Branch (922:31): [True: 352, False: 22]
  ------------------
  923|    352|        if ((entry->hashValue != 0) && (entry->payload != NULL))
  ------------------
  |  Branch (923:13): [True: 88, False: 264]
  |  Branch (923:40): [True: 88, False: 0]
  ------------------
  924|     88|            scan(entry->payload, data, entry->key, entry->key2, entry->key3);
  925|    352|    }
  926|     22|}
xmlHashSize:
 1033|     22|xmlHashSize(xmlHashTablePtr hash) {
 1034|     22|    if (hash == NULL)
  ------------------
  |  Branch (1034:9): [True: 0, False: 22]
  ------------------
 1035|      0|        return(-1);
 1036|     22|    return(hash->nbElems);
 1037|     22|}
xmlHashRemoveEntry2:
 1070|     22|                    const xmlChar *key2, xmlHashDeallocator dealloc) {
 1071|     22|    return(xmlHashRemoveEntry3(hash, key, key2, NULL, dealloc));
 1072|     22|}
xmlHashRemoveEntry3:
 1092|     22|                    xmlHashDeallocator dealloc) {
 1093|     22|    xmlHashEntry *entry, *cur, *next;
 1094|     22|    unsigned hashValue, mask, pos, nextpos;
 1095|     22|    int found;
 1096|       |
 1097|     22|    if ((hash == NULL) || (hash->size == 0) || (key == NULL))
  ------------------
  |  Branch (1097:9): [True: 0, False: 22]
  |  Branch (1097:27): [True: 0, False: 22]
  |  Branch (1097:48): [True: 0, False: 22]
  ------------------
 1098|      0|        return(-1);
 1099|       |
 1100|     22|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, NULL);
 1101|     22|    entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
 1102|     22|    if (!found)
  ------------------
  |  Branch (1102:9): [True: 0, False: 22]
  ------------------
 1103|      0|        return(-1);
 1104|       |
 1105|     22|    if ((dealloc != NULL) && (entry->payload != NULL))
  ------------------
  |  Branch (1105:9): [True: 0, False: 22]
  |  Branch (1105:30): [True: 0, False: 0]
  ------------------
 1106|      0|        dealloc(entry->payload, entry->key);
 1107|     22|    if (hash->dict == NULL) {
  ------------------
  |  Branch (1107:9): [True: 0, False: 22]
  ------------------
 1108|      0|        if (entry->key)
  ------------------
  |  Branch (1108:13): [True: 0, False: 0]
  ------------------
 1109|      0|            xmlFree(entry->key);
 1110|      0|        if (entry->key2)
  ------------------
  |  Branch (1110:13): [True: 0, False: 0]
  ------------------
 1111|      0|            xmlFree(entry->key2);
 1112|      0|        if (entry->key3)
  ------------------
  |  Branch (1112:13): [True: 0, False: 0]
  ------------------
 1113|      0|            xmlFree(entry->key3);
 1114|      0|    }
 1115|       |
 1116|       |    /*
 1117|       |     * Find end of probe sequence. Entries at their initial probe
 1118|       |     * position start a new sequence.
 1119|       |     */
 1120|     22|    mask = hash->size - 1;
 1121|     22|    pos = entry - hash->table;
 1122|     22|    cur = entry;
 1123|       |
 1124|     22|    while (1) {
  ------------------
  |  Branch (1124:12): [Folded - Ignored]
  ------------------
 1125|     22|        nextpos = pos + 1;
 1126|     22|        next = cur + 1;
 1127|     22|        if ((nextpos & mask) == 0)
  ------------------
  |  Branch (1127:13): [True: 0, False: 22]
  ------------------
 1128|      0|            next = hash->table;
 1129|       |
 1130|     22|        if ((next->hashValue == 0) ||
  ------------------
  |  Branch (1130:13): [True: 22, False: 0]
  ------------------
 1131|     22|            (((next->hashValue - nextpos) & mask) == 0))
  ------------------
  |  Branch (1131:13): [True: 0, False: 0]
  ------------------
 1132|     22|            break;
 1133|       |
 1134|      0|        cur = next;
 1135|      0|        pos = nextpos;
 1136|      0|    }
 1137|       |
 1138|       |    /*
 1139|       |     * Backward shift
 1140|       |     */
 1141|     22|    next = entry + 1;
 1142|       |
 1143|     22|    if (cur < entry) {
  ------------------
  |  Branch (1143:9): [True: 0, False: 22]
  ------------------
 1144|      0|        xmlHashEntry *end = &hash->table[hash->size];
 1145|       |
 1146|      0|        memmove(entry, next, (char *) end - (char *) next);
 1147|      0|        entry = hash->table;
 1148|      0|        end[-1] = *entry;
 1149|      0|        next = entry + 1;
 1150|      0|    }
 1151|       |
 1152|     22|    memmove(entry, next, (char *) cur - (char *) entry);
 1153|       |
 1154|       |    /*
 1155|       |     * Update entry
 1156|       |     */
 1157|     22|    cur->hashValue = 0;
 1158|       |
 1159|     22|    hash->nbElems--;
 1160|       |
 1161|     22|    return(0);
 1162|     22|}
hash.c:xmlHashGrow:
  354|  1.55k|xmlHashGrow(xmlHashTablePtr hash, unsigned size) {
  355|  1.55k|    const xmlHashEntry *oldentry, *oldend, *end;
  356|  1.55k|    xmlHashEntry *table;
  357|  1.55k|    unsigned oldsize, i;
  358|       |
  359|       |    /* Add 0 to avoid spurious -Wtype-limits warning on 64-bit GCC */
  360|  1.55k|    if ((size_t) size + 0 > SIZE_MAX / sizeof(table[0]))
  ------------------
  |  |   25|  1.55k|  #define SIZE_MAX ((size_t) -1)
  ------------------
  |  Branch (360:9): [True: 0, False: 1.55k]
  ------------------
  361|      0|        return(-1);
  362|  1.55k|    table = xmlMalloc(size * sizeof(table[0]));
  363|  1.55k|    if (table == NULL)
  ------------------
  |  Branch (363:9): [True: 14, False: 1.54k]
  ------------------
  364|     14|        return(-1);
  365|  1.54k|    memset(table, 0, size * sizeof(table[0]));
  366|       |
  367|  1.54k|    oldsize = hash->size;
  368|  1.54k|    if (oldsize == 0)
  ------------------
  |  Branch (368:9): [True: 580, False: 961]
  ------------------
  369|    580|        goto done;
  370|       |
  371|    961|    oldend = &hash->table[oldsize];
  372|    961|    end = &table[size];
  373|       |
  374|       |    /*
  375|       |     * Robin Hood sorting order is maintained if we
  376|       |     *
  377|       |     * - compute hash indices with modulo
  378|       |     * - resize by an integer factor
  379|       |     * - start to copy from the beginning of a probe sequence
  380|       |     */
  381|    961|    oldentry = hash->table;
  382|  3.84k|    while (oldentry->hashValue != 0) {
  ------------------
  |  Branch (382:12): [True: 2.88k, False: 961]
  ------------------
  383|  2.88k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (383:13): [True: 0, False: 2.88k]
  ------------------
  384|      0|            oldentry = hash->table;
  385|  2.88k|    }
  386|       |
  387|  12.4k|    for (i = 0; i < oldsize; i++) {
  ------------------
  |  Branch (387:17): [True: 11.5k, False: 961]
  ------------------
  388|  11.5k|        if (oldentry->hashValue != 0) {
  ------------------
  |  Branch (388:13): [True: 10.0k, False: 1.44k]
  ------------------
  389|  10.0k|            xmlHashEntry *entry = &table[oldentry->hashValue & (size - 1)];
  390|       |
  391|  13.4k|            while (entry->hashValue != 0) {
  ------------------
  |  Branch (391:20): [True: 3.36k, False: 10.0k]
  ------------------
  392|  3.36k|                if (++entry >= end)
  ------------------
  |  Branch (392:21): [True: 0, False: 3.36k]
  ------------------
  393|      0|                    entry = table;
  394|  3.36k|            }
  395|  10.0k|            *entry = *oldentry;
  396|  10.0k|        }
  397|       |
  398|  11.5k|        if (++oldentry >= oldend)
  ------------------
  |  Branch (398:13): [True: 961, False: 10.5k]
  ------------------
  399|    961|            oldentry = hash->table;
  400|  11.5k|    }
  401|       |
  402|    961|    xmlFree(hash->table);
  403|       |
  404|  1.54k|done:
  405|  1.54k|    hash->table = table;
  406|  1.54k|    hash->size = size;
  407|       |
  408|  1.54k|    return(0);
  409|    961|}
hash.c:xmlHashUpdateInternal:
  427|  14.0k|                      void *payload, xmlHashDeallocator dealloc, int update) {
  428|  14.0k|    xmlChar *copy, *copy2, *copy3;
  429|  14.0k|    xmlHashEntry *entry = NULL;
  430|  14.0k|    size_t lengths[3];
  431|  14.0k|    unsigned hashValue;
  432|  14.0k|    int found = 0;
  433|       |
  434|  14.0k|    if ((hash == NULL) || (key == NULL))
  ------------------
  |  Branch (434:9): [True: 0, False: 14.0k]
  |  Branch (434:27): [True: 0, False: 14.0k]
  ------------------
  435|      0|        return(-1);
  436|       |
  437|       |    /*
  438|       |     * Check for an existing entry
  439|       |     */
  440|  14.0k|    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);
  441|  14.0k|    if (hash->size > 0)
  ------------------
  |  Branch (441:9): [True: 13.4k, False: 552]
  ------------------
  442|  13.4k|        entry = xmlHashFindEntry(hash, key, key2, key3, hashValue, &found);
  443|  14.0k|    if (found) {
  ------------------
  |  Branch (443:9): [True: 0, False: 14.0k]
  ------------------
  444|      0|        if (update) {
  ------------------
  |  Branch (444:13): [True: 0, False: 0]
  ------------------
  445|      0|            if (dealloc)
  ------------------
  |  Branch (445:17): [True: 0, False: 0]
  ------------------
  446|      0|                dealloc(entry->payload, entry->key);
  447|      0|            entry->payload = payload;
  448|      0|            return(0);
  449|      0|        } else {
  450|       |            /*
  451|       |             * xmlHashAddEntry found an existing entry.
  452|       |             *
  453|       |             * TODO: We should return a different error code here to
  454|       |             * distinguish from malloc failures.
  455|       |             */
  456|      0|            return(-1);
  457|      0|        }
  458|      0|    }
  459|       |
  460|       |    /*
  461|       |     * Grow the hash table if needed
  462|       |     */
  463|  14.0k|    if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   29|  14.0k|#define MAX_FILL_DENOM 8
  ------------------
                  if (hash->nbElems + 1 > hash->size / MAX_FILL_DENOM * MAX_FILL_NUM) {
  ------------------
  |  |   28|  14.0k|#define MAX_FILL_NUM 7
  ------------------
  |  Branch (463:9): [True: 1.52k, False: 12.5k]
  ------------------
  464|  1.52k|        unsigned newSize, mask, displ, pos;
  465|       |
  466|  1.52k|        if (hash->size == 0) {
  ------------------
  |  Branch (466:13): [True: 552, False: 975]
  ------------------
  467|    552|            newSize = MIN_HASH_SIZE;
  ------------------
  |  |   30|    552|#define MIN_HASH_SIZE 8
  ------------------
  468|    975|        } else {
  469|       |            /* This guarantees that nbElems < INT_MAX */
  470|    975|            if (hash->size >= MAX_HASH_SIZE)
  ------------------
  |  |   31|    975|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  |  Branch (470:17): [True: 0, False: 975]
  ------------------
  471|      0|                return(-1);
  472|    975|            newSize = hash->size * 2;
  473|    975|        }
  474|  1.52k|        if (xmlHashGrow(hash, newSize) != 0)
  ------------------
  |  Branch (474:13): [True: 14, False: 1.51k]
  ------------------
  475|     14|            return(-1);
  476|       |
  477|       |        /*
  478|       |         * Find new entry
  479|       |         */
  480|  1.51k|        mask = hash->size - 1;
  481|  1.51k|        displ = 0;
  482|  1.51k|        pos = hashValue & mask;
  483|  1.51k|        entry = &hash->table[pos];
  484|       |
  485|  1.51k|        if (entry->hashValue != 0) {
  ------------------
  |  Branch (485:13): [True: 481, False: 1.03k]
  ------------------
  486|    962|            do {
  487|    962|                displ++;
  488|    962|                pos++;
  489|    962|                entry++;
  490|    962|                if ((pos & mask) == 0)
  ------------------
  |  Branch (490:21): [True: 0, False: 962]
  ------------------
  491|      0|                    entry = hash->table;
  492|    962|            } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (492:22): [True: 962, False: 0]
  ------------------
  493|    962|                     ((pos - entry->hashValue) & mask) >= displ);
  ------------------
  |  Branch (493:22): [True: 481, False: 481]
  ------------------
  494|    481|        }
  495|  1.51k|    }
  496|       |
  497|       |    /*
  498|       |     * Copy keys
  499|       |     */
  500|  14.0k|    if (hash->dict != NULL) {
  ------------------
  |  Branch (500:9): [True: 418, False: 13.6k]
  ------------------
  501|    418|        if (xmlDictOwns(hash->dict, key)) {
  ------------------
  |  Branch (501:13): [True: 308, False: 110]
  ------------------
  502|    308|            copy = (xmlChar *) key;
  503|    308|        } else {
  504|    110|            copy = (xmlChar *) xmlDictLookup(hash->dict, key, -1);
  505|    110|            if (copy == NULL)
  ------------------
  |  Branch (505:17): [True: 0, False: 110]
  ------------------
  506|      0|                return(-1);
  507|    110|        }
  508|       |
  509|    418|        if ((key2 == NULL) || (xmlDictOwns(hash->dict, key2))) {
  ------------------
  |  Branch (509:13): [True: 330, False: 88]
  |  Branch (509:31): [True: 88, False: 0]
  ------------------
  510|    418|            copy2 = (xmlChar *) key2;
  511|    418|        } else {
  512|      0|            copy2 = (xmlChar *) xmlDictLookup(hash->dict, key2, -1);
  513|      0|            if (copy2 == NULL)
  ------------------
  |  Branch (513:17): [True: 0, False: 0]
  ------------------
  514|      0|                return(-1);
  515|      0|        }
  516|    418|        if ((key3 == NULL) || (xmlDictOwns(hash->dict, key3))) {
  ------------------
  |  Branch (516:13): [True: 330, False: 88]
  |  Branch (516:31): [True: 88, False: 0]
  ------------------
  517|    418|            copy3 = (xmlChar *) key3;
  518|    418|        } else {
  519|      0|            copy3 = (xmlChar *) xmlDictLookup(hash->dict, key3, -1);
  520|      0|            if (copy3 == NULL)
  ------------------
  |  Branch (520:17): [True: 0, False: 0]
  ------------------
  521|      0|                return(-1);
  522|      0|        }
  523|  13.6k|    } else {
  524|  13.6k|        copy = xmlMalloc(lengths[0] + 1);
  525|  13.6k|        if (copy == NULL)
  ------------------
  |  Branch (525:13): [True: 150, False: 13.4k]
  ------------------
  526|    150|            return(-1);
  527|  13.4k|        memcpy(copy, key, lengths[0] + 1);
  528|       |
  529|  13.4k|        if (key2 != NULL) {
  ------------------
  |  Branch (529:13): [True: 477, False: 12.9k]
  ------------------
  530|    477|            copy2 = xmlMalloc(lengths[1] + 1);
  531|    477|            if (copy2 == NULL) {
  ------------------
  |  Branch (531:17): [True: 0, False: 477]
  ------------------
  532|      0|                xmlFree(copy);
  533|      0|                return(-1);
  534|      0|            }
  535|    477|            memcpy(copy2, key2, lengths[1] + 1);
  536|  12.9k|        } else {
  537|  12.9k|            copy2 = NULL;
  538|  12.9k|        }
  539|       |
  540|  13.4k|        if (key3 != NULL) {
  ------------------
  |  Branch (540:13): [True: 0, False: 13.4k]
  ------------------
  541|      0|            copy3 = xmlMalloc(lengths[2] + 1);
  542|      0|            if (copy3 == NULL) {
  ------------------
  |  Branch (542:17): [True: 0, False: 0]
  ------------------
  543|      0|                xmlFree(copy);
  544|      0|                xmlFree(copy2);
  545|      0|                return(-1);
  546|      0|            }
  547|      0|            memcpy(copy3, key3, lengths[2] + 1);
  548|  13.4k|        } else {
  549|  13.4k|            copy3 = NULL;
  550|  13.4k|        }
  551|  13.4k|    }
  552|       |
  553|       |    /*
  554|       |     * Shift the remainder of the probe sequence to the right
  555|       |     */
  556|  13.8k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (556:9): [True: 5.31k, False: 8.55k]
  ------------------
  557|  5.31k|        const xmlHashEntry *end = &hash->table[hash->size];
  558|  5.31k|        const xmlHashEntry *cur = entry;
  559|       |
  560|  17.7k|        do {
  561|  17.7k|            cur++;
  562|  17.7k|            if (cur >= end)
  ------------------
  |  Branch (562:17): [True: 1.43k, False: 16.3k]
  ------------------
  563|  1.43k|                cur = hash->table;
  564|  17.7k|        } while (cur->hashValue != 0);
  ------------------
  |  Branch (564:18): [True: 12.4k, False: 5.31k]
  ------------------
  565|       |
  566|  5.31k|        if (cur < entry) {
  ------------------
  |  Branch (566:13): [True: 1.43k, False: 3.88k]
  ------------------
  567|       |            /*
  568|       |             * If we traversed the end of the buffer, handle the part
  569|       |             * at the start of the buffer.
  570|       |             */
  571|  1.43k|            memmove(&hash->table[1], hash->table,
  572|  1.43k|                    (char *) cur - (char *) hash->table);
  573|  1.43k|            cur = end - 1;
  574|  1.43k|            hash->table[0] = *cur;
  575|  1.43k|        }
  576|       |
  577|  5.31k|        memmove(&entry[1], entry, (char *) cur - (char *) entry);
  578|  5.31k|    }
  579|       |
  580|       |    /*
  581|       |     * Populate entry
  582|       |     */
  583|  13.8k|    entry->key = copy;
  584|  13.8k|    entry->key2 = copy2;
  585|  13.8k|    entry->key3 = copy3;
  586|  13.8k|    entry->payload = payload;
  587|       |    /* OR with MAX_HASH_SIZE to make sure that the value is non-zero */
  588|  13.8k|    entry->hashValue = hashValue | MAX_HASH_SIZE;
  ------------------
  |  |   31|  13.8k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  589|       |
  590|  13.8k|    hash->nbElems++;
  591|       |
  592|  13.8k|    return(0);
  593|  14.0k|}
hash.c:xmlHashValue:
   62|  14.8k|             const xmlChar *key3, size_t *lengths) {
   63|  14.8k|    unsigned h1, h2;
   64|  14.8k|    size_t i;
   65|       |
   66|  14.8k|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|  14.8k|    do { \
  |  |   24|  14.8k|        h1 = seed ^ 0x3b00; \
  |  |   25|  14.8k|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|  14.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|  14.8k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   67|       |
   68|   124k|    for (i = 0; key[i] != 0; i++) {
  ------------------
  |  Branch (68:17): [True: 109k, False: 14.8k]
  ------------------
   69|   109k|        HASH_UPDATE(h1, h2, key[i]);
  ------------------
  |  |   29|   109k|    do { \
  |  |   30|   109k|        h1 += ch; \
  |  |   31|   109k|        h1 += h1 << 3; \
  |  |   32|   109k|        h2 += h1; \
  |  |   33|   109k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|   109k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|   109k|        h2 += h2 << 2; \
  |  |   35|   109k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   70|   109k|    }
   71|  14.8k|    if (lengths)
  ------------------
  |  Branch (71:9): [True: 14.0k, False: 793]
  ------------------
   72|  14.0k|        lengths[0] = i;
   73|       |
   74|  14.8k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  14.8k|    do { \
  |  |   30|  14.8k|        h1 += ch; \
  |  |   31|  14.8k|        h1 += h1 << 3; \
  |  |   32|  14.8k|        h2 += h1; \
  |  |   33|  14.8k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  14.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  14.8k|        h2 += h2 << 2; \
  |  |   35|  14.8k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   75|       |
   76|  14.8k|    if (key2 != NULL) {
  ------------------
  |  Branch (76:9): [True: 684, False: 14.1k]
  ------------------
   77|  21.6k|        for (i = 0; key2[i] != 0; i++) {
  ------------------
  |  Branch (77:21): [True: 20.9k, False: 684]
  ------------------
   78|  20.9k|            HASH_UPDATE(h1, h2, key2[i]);
  ------------------
  |  |   29|  20.9k|    do { \
  |  |   30|  20.9k|        h1 += ch; \
  |  |   31|  20.9k|        h1 += h1 << 3; \
  |  |   32|  20.9k|        h2 += h1; \
  |  |   33|  20.9k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  20.9k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  20.9k|        h2 += h2 << 2; \
  |  |   35|  20.9k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   79|  20.9k|        }
   80|    684|        if (lengths)
  ------------------
  |  Branch (80:13): [True: 574, False: 110]
  ------------------
   81|    574|            lengths[1] = i;
   82|    684|    }
   83|       |
   84|  14.8k|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|  14.8k|    do { \
  |  |   30|  14.8k|        h1 += ch; \
  |  |   31|  14.8k|        h1 += h1 << 3; \
  |  |   32|  14.8k|        h2 += h1; \
  |  |   33|  14.8k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  14.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  14.8k|        h2 += h2 << 2; \
  |  |   35|  14.8k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   85|       |
   86|  14.8k|    if (key3 != NULL) {
  ------------------
  |  Branch (86:9): [True: 242, False: 14.5k]
  ------------------
   87|  1.71k|        for (i = 0; key3[i] != 0; i++) {
  ------------------
  |  Branch (87:21): [True: 1.47k, False: 242]
  ------------------
   88|  1.47k|            HASH_UPDATE(h1, h2, key3[i]);
  ------------------
  |  |   29|  1.47k|    do { \
  |  |   30|  1.47k|        h1 += ch; \
  |  |   31|  1.47k|        h1 += h1 << 3; \
  |  |   32|  1.47k|        h2 += h1; \
  |  |   33|  1.47k|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|  1.47k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|  1.47k|        h2 += h2 << 2; \
  |  |   35|  1.47k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   89|  1.47k|        }
   90|    242|        if (lengths)
  ------------------
  |  Branch (90:13): [True: 88, False: 154]
  ------------------
   91|     88|            lengths[2] = i;
   92|    242|    }
   93|       |
   94|  14.8k|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|  14.8k|    do { \
  |  |   40|  14.8k|        h1 ^= h2; \
  |  |   41|  14.8k|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|  14.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|  14.8k|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|  14.8k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|  14.8k|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|  14.8k|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|  14.8k|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|  14.8k|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|  14.8k|        h2 &= 0xFFFFFFFF; \
  |  |   46|  14.8k|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
   95|       |
   96|  14.8k|    return(h2);
   97|  14.8k|}
hash.c:xmlHashFindEntry:
  294|  14.2k|                 unsigned hashValue, int *pfound) {
  295|  14.2k|    xmlHashEntry *entry;
  296|  14.2k|    unsigned mask, pos, displ;
  297|  14.2k|    int found = 0;
  298|       |
  299|  14.2k|    mask = hash->size - 1;
  300|  14.2k|    pos = hashValue & mask;
  301|  14.2k|    entry = &hash->table[pos];
  302|       |
  303|  14.2k|    if (entry->hashValue != 0) {
  ------------------
  |  Branch (303:9): [True: 8.89k, False: 5.38k]
  ------------------
  304|       |        /*
  305|       |         * Robin hood hashing: abort if the displacement of the entry
  306|       |         * is smaller than the displacement of the key we look for.
  307|       |         * This also stops at the correct position when inserting.
  308|       |         */
  309|  8.89k|        displ = 0;
  310|  8.89k|        hashValue |= MAX_HASH_SIZE;
  ------------------
  |  |   31|  8.89k|#define MAX_HASH_SIZE (1u << 31)
  ------------------
  311|       |
  312|  18.8k|        do {
  313|  18.8k|            if (entry->hashValue == hashValue) {
  ------------------
  |  Branch (313:17): [True: 457, False: 18.4k]
  ------------------
  314|    457|                if (hash->dict) {
  ------------------
  |  Branch (314:21): [True: 279, False: 178]
  ------------------
  315|    279|                    if ((entry->key == key) &&
  ------------------
  |  Branch (315:25): [True: 264, False: 15]
  ------------------
  316|    279|                        (entry->key2 == key2) &&
  ------------------
  |  Branch (316:25): [True: 264, False: 0]
  ------------------
  317|    279|                        (entry->key3 == key3)) {
  ------------------
  |  Branch (317:25): [True: 264, False: 0]
  ------------------
  318|    264|                        found = 1;
  319|    264|                        break;
  320|    264|                    }
  321|    279|                }
  322|    193|                if ((strcmp((const char *) entry->key,
  ------------------
  |  Branch (322:21): [True: 193, False: 0]
  ------------------
  323|    193|                            (const char *) key) == 0) &&
  324|    193|                    (xmlFastStrEqual(entry->key2, key2)) &&
  ------------------
  |  Branch (324:21): [True: 193, False: 0]
  ------------------
  325|    193|                    (xmlFastStrEqual(entry->key3, key3))) {
  ------------------
  |  Branch (325:21): [True: 193, False: 0]
  ------------------
  326|    193|                    found = 1;
  327|    193|                    break;
  328|    193|                }
  329|    193|            }
  330|       |
  331|  18.4k|            displ++;
  332|  18.4k|            pos++;
  333|  18.4k|            entry++;
  334|  18.4k|            if ((pos & mask) == 0)
  ------------------
  |  Branch (334:17): [True: 2.02k, False: 16.3k]
  ------------------
  335|  2.02k|                entry = hash->table;
  336|  18.4k|        } while ((entry->hashValue != 0) &&
  ------------------
  |  Branch (336:18): [True: 15.8k, False: 2.51k]
  ------------------
  337|  18.4k|                 (((pos - entry->hashValue) & mask) >= displ));
  ------------------
  |  Branch (337:18): [True: 9.97k, False: 5.91k]
  ------------------
  338|  8.89k|    }
  339|       |
  340|      0|    *pfound = found;
  341|  14.2k|    return(entry);
  342|  14.2k|}
hash.c:xmlHashQNameValue:
  104|    132|                  const xmlChar *prefix3, const xmlChar *name3) {
  105|    132|    unsigned h1, h2, ch;
  106|       |
  107|    132|    HASH_INIT(h1, h2, seed);
  ------------------
  |  |   23|    132|    do { \
  |  |   24|    132|        h1 = seed ^ 0x3b00; \
  |  |   25|    132|        h2 = HASH_ROL(seed, 15); \
  |  |  ------------------
  |  |  |  |   12|    132|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   26|    132|    } while (0)
  |  |  ------------------
  |  |  |  Branch (26:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  108|       |
  109|    132|    if (prefix != NULL) {
  ------------------
  |  Branch (109:9): [True: 0, False: 132]
  ------------------
  110|      0|        while ((ch = *prefix++) != 0) {
  ------------------
  |  Branch (110:16): [True: 0, False: 0]
  ------------------
  111|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  112|      0|        }
  113|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  114|      0|    }
  115|    132|    if (name != NULL) {
  ------------------
  |  Branch (115:9): [True: 132, False: 0]
  ------------------
  116|  1.01k|        while ((ch = *name++) != 0) {
  ------------------
  |  Branch (116:16): [True: 880, False: 132]
  ------------------
  117|    880|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    880|    do { \
  |  |   30|    880|        h1 += ch; \
  |  |   31|    880|        h1 += h1 << 3; \
  |  |   32|    880|        h2 += h1; \
  |  |   33|    880|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    880|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    880|        h2 += h2 << 2; \
  |  |   35|    880|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  118|    880|        }
  119|    132|    }
  120|    132|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|    132|    do { \
  |  |   30|    132|        h1 += ch; \
  |  |   31|    132|        h1 += h1 << 3; \
  |  |   32|    132|        h2 += h1; \
  |  |   33|    132|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    132|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    132|        h2 += h2 << 2; \
  |  |   35|    132|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  121|    132|    if (prefix2 != NULL) {
  ------------------
  |  Branch (121:9): [True: 0, False: 132]
  ------------------
  122|      0|        while ((ch = *prefix2++) != 0) {
  ------------------
  |  Branch (122:16): [True: 0, False: 0]
  ------------------
  123|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  124|      0|        }
  125|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  126|      0|    }
  127|    132|    if (name2 != NULL) {
  ------------------
  |  Branch (127:9): [True: 132, False: 0]
  ------------------
  128|    440|        while ((ch = *name2++) != 0) {
  ------------------
  |  Branch (128:16): [True: 308, False: 132]
  ------------------
  129|    308|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|    308|    do { \
  |  |   30|    308|        h1 += ch; \
  |  |   31|    308|        h1 += h1 << 3; \
  |  |   32|    308|        h2 += h1; \
  |  |   33|    308|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    308|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    308|        h2 += h2 << 2; \
  |  |   35|    308|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  130|    308|        }
  131|    132|    }
  132|    132|    HASH_UPDATE(h1, h2, 0);
  ------------------
  |  |   29|    132|    do { \
  |  |   30|    132|        h1 += ch; \
  |  |   31|    132|        h1 += h1 << 3; \
  |  |   32|    132|        h2 += h1; \
  |  |   33|    132|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|    132|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|    132|        h2 += h2 << 2; \
  |  |   35|    132|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  133|    132|    if (prefix3 != NULL) {
  ------------------
  |  Branch (133:9): [True: 0, False: 132]
  ------------------
  134|      0|        while ((ch = *prefix3++) != 0) {
  ------------------
  |  Branch (134:16): [True: 0, False: 0]
  ------------------
  135|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  136|      0|        }
  137|      0|        HASH_UPDATE(h1, h2, ':');
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  138|      0|    }
  139|    132|    if (name3 != NULL) {
  ------------------
  |  Branch (139:9): [True: 0, False: 132]
  ------------------
  140|      0|        while ((ch = *name3++) != 0) {
  ------------------
  |  Branch (140:16): [True: 0, False: 0]
  ------------------
  141|      0|            HASH_UPDATE(h1, h2, ch);
  ------------------
  |  |   29|      0|    do { \
  |  |   30|      0|        h1 += ch; \
  |  |   31|      0|        h1 += h1 << 3; \
  |  |   32|      0|        h2 += h1; \
  |  |   33|      0|        h2 = HASH_ROL(h2, 7); \
  |  |  ------------------
  |  |  |  |   12|      0|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   34|      0|        h2 += h2 << 2; \
  |  |   35|      0|    } while (0)
  |  |  ------------------
  |  |  |  Branch (35:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  142|      0|        }
  143|      0|    }
  144|       |
  145|    132|    HASH_FINISH(h1, h2);
  ------------------
  |  |   39|    132|    do { \
  |  |   40|    132|        h1 ^= h2; \
  |  |   41|    132|        h1 += HASH_ROL(h2, 14); \
  |  |  ------------------
  |  |  |  |   12|    132|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   42|    132|        h2 ^= h1; h2 += HASH_ROR(h1, 6); \
  |  |  ------------------
  |  |  |  |   13|    132|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   43|    132|        h1 ^= h2; h1 += HASH_ROL(h2, 5); \
  |  |  ------------------
  |  |  |  |   12|    132|#define HASH_ROL(x,n) ((x) << (n) | ((x) & 0xFFFFFFFF) >> (32 - (n)))
  |  |  ------------------
  |  |   44|    132|        h2 ^= h1; h2 += HASH_ROR(h1, 8); \
  |  |  ------------------
  |  |  |  |   13|    132|#define HASH_ROR(x,n) (((x) & 0xFFFFFFFF) >> (n) | (x) << (32 - (n)))
  |  |  ------------------
  |  |   45|    132|        h2 &= 0xFFFFFFFF; \
  |  |   46|    132|    } while (0)
  |  |  ------------------
  |  |  |  Branch (46:14): [Folded - Ignored]
  |  |  ------------------
  ------------------
  146|       |
  147|    132|    return(h2);
  148|    132|}
hash.c:xmlFastStrEqual:
  269|    386|xmlFastStrEqual(const xmlChar *s1, const xmlChar *s2) {
  270|    386|    if (s1 == NULL)
  ------------------
  |  Branch (270:9): [True: 386, False: 0]
  ------------------
  271|    386|        return(s2 == NULL);
  272|      0|    else
  273|      0|        return((s2 != NULL) &&
  ------------------
  |  Branch (273:16): [True: 0, False: 0]
  ------------------
  274|      0|               (strcmp((const char *) s1, (const char *) s2) == 0));
  ------------------
  |  Branch (274:16): [True: 0, False: 0]
  ------------------
  275|    386|}

xmlParserNsCreate:
 1407|    486|xmlParserNsCreate(void) {
 1408|    486|    xmlParserNsData *nsdb = xmlMalloc(sizeof(*nsdb));
 1409|       |
 1410|    486|    if (nsdb == NULL)
  ------------------
  |  Branch (1410:9): [True: 0, False: 486]
  ------------------
 1411|      0|        return(NULL);
 1412|    486|    memset(nsdb, 0, sizeof(*nsdb));
 1413|    486|    nsdb->defaultNsIndex = INT_MAX;
 1414|       |
 1415|    486|    return(nsdb);
 1416|    486|}
xmlParserNsFree:
 1425|    486|xmlParserNsFree(xmlParserNsData *nsdb) {
 1426|    486|    if (nsdb == NULL)
  ------------------
  |  Branch (1426:9): [True: 0, False: 486]
  ------------------
 1427|      0|        return;
 1428|       |
 1429|    486|    xmlFree(nsdb->extra);
 1430|    486|    xmlFree(nsdb->hash);
 1431|    486|    xmlFree(nsdb);
 1432|    486|}
xmlParserNsLookupSax:
 1560|     36|xmlParserNsLookupSax(xmlParserCtxtPtr ctxt, const xmlChar *prefix) {
 1561|     36|    xmlHashedString hprefix;
 1562|     36|    int nsIndex;
 1563|       |
 1564|     36|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1564:9): [True: 36, False: 0]
  ------------------
 1565|     36|        return(NULL);
 1566|       |
 1567|      0|    hprefix.name = prefix;
 1568|      0|    if (prefix != NULL)
  ------------------
  |  Branch (1568:9): [True: 0, False: 0]
  ------------------
 1569|      0|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1570|      0|    else
 1571|      0|        hprefix.hashValue = 0;
 1572|      0|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1573|      0|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1573:9): [True: 0, False: 0]
  ------------------
 1574|      0|        return(NULL);
 1575|       |
 1576|      0|    return(ctxt->nsdb->extra[nsIndex].saxData);
 1577|      0|}
xmlParserNsUpdateSax:
 1593|     18|                     void *saxData) {
 1594|     18|    xmlHashedString hprefix;
 1595|     18|    int nsIndex;
 1596|       |
 1597|     18|    if (prefix == ctxt->str_xml)
  ------------------
  |  Branch (1597:9): [True: 0, False: 18]
  ------------------
 1598|      0|        return(-1);
 1599|       |
 1600|     18|    hprefix.name = prefix;
 1601|     18|    if (prefix != NULL)
  ------------------
  |  Branch (1601:9): [True: 12, False: 6]
  ------------------
 1602|     12|        hprefix.hashValue = xmlDictComputeHash(ctxt->dict, prefix);
 1603|      6|    else
 1604|      6|        hprefix.hashValue = 0;
 1605|     18|    nsIndex = xmlParserNsLookup(ctxt, &hprefix, NULL);
 1606|     18|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1606:9): [True: 0, False: 18]
  ------------------
 1607|      0|        return(-1);
 1608|       |
 1609|     18|    ctxt->nsdb->extra[nsIndex].saxData = saxData;
 1610|     18|    return(0);
 1611|     18|}
inputPush:
 1893|    486|{
 1894|    486|    if ((ctxt == NULL) || (value == NULL))
  ------------------
  |  Branch (1894:9): [True: 0, False: 486]
  |  Branch (1894:27): [True: 0, False: 486]
  ------------------
 1895|      0|        return(-1);
 1896|    486|    if (ctxt->inputNr >= ctxt->inputMax) {
  ------------------
  |  Branch (1896:9): [True: 0, False: 486]
  ------------------
 1897|      0|        size_t newSize = ctxt->inputMax * 2;
 1898|      0|        xmlParserInputPtr *tmp;
 1899|       |
 1900|      0|        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,
 1901|      0|                                               newSize * sizeof(*tmp));
 1902|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (1902:13): [True: 0, False: 0]
  ------------------
 1903|      0|            xmlErrMemory(ctxt, NULL);
 1904|      0|            return (-1);
 1905|      0|        }
 1906|      0|        ctxt->inputTab = tmp;
 1907|      0|        ctxt->inputMax = newSize;
 1908|      0|    }
 1909|    486|    ctxt->inputTab[ctxt->inputNr] = value;
 1910|    486|    ctxt->input = value;
 1911|    486|    return (ctxt->inputNr++);
 1912|    486|}
inputPop:
 1923|  1.45k|{
 1924|  1.45k|    xmlParserInputPtr ret;
 1925|       |
 1926|  1.45k|    if (ctxt == NULL)
  ------------------
  |  Branch (1926:9): [True: 0, False: 1.45k]
  ------------------
 1927|      0|        return(NULL);
 1928|  1.45k|    if (ctxt->inputNr <= 0)
  ------------------
  |  Branch (1928:9): [True: 972, False: 486]
  ------------------
 1929|    972|        return (NULL);
 1930|    486|    ctxt->inputNr--;
 1931|    486|    if (ctxt->inputNr > 0)
  ------------------
  |  Branch (1931:9): [True: 0, False: 486]
  ------------------
 1932|      0|        ctxt->input = ctxt->inputTab[ctxt->inputNr - 1];
 1933|    486|    else
 1934|    486|        ctxt->input = NULL;
 1935|    486|    ret = ctxt->inputTab[ctxt->inputNr];
 1936|    486|    ctxt->inputTab[ctxt->inputNr] = NULL;
 1937|    486|    return (ret);
 1938|  1.45k|}
nodePush:
 1952|  2.95k|{
 1953|  2.95k|    if (ctxt == NULL) return(0);
  ------------------
  |  Branch (1953:9): [True: 0, False: 2.95k]
  ------------------
 1954|  2.95k|    if (ctxt->nodeNr >= ctxt->nodeMax) {
  ------------------
  |  Branch (1954:9): [True: 0, False: 2.95k]
  ------------------
 1955|      0|        xmlNodePtr *tmp;
 1956|       |
 1957|      0|	tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,
 1958|      0|                                      ctxt->nodeMax * 2 *
 1959|      0|                                      sizeof(ctxt->nodeTab[0]));
 1960|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (1960:13): [True: 0, False: 0]
  ------------------
 1961|      0|            xmlErrMemory(ctxt, NULL);
 1962|      0|            return (-1);
 1963|      0|        }
 1964|      0|        ctxt->nodeTab = tmp;
 1965|      0|	ctxt->nodeMax *= 2;
 1966|      0|    }
 1967|  2.95k|    if ((((unsigned int) ctxt->nodeNr) > xmlParserMaxDepth) &&
  ------------------
  |  Branch (1967:9): [True: 0, False: 2.95k]
  ------------------
 1968|  2.95k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (1968:9): [True: 0, False: 0]
  ------------------
 1969|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
 1970|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
 1971|      0|			  xmlParserMaxDepth);
 1972|      0|	xmlHaltParser(ctxt);
 1973|      0|	return(-1);
 1974|      0|    }
 1975|  2.95k|    ctxt->nodeTab[ctxt->nodeNr] = value;
 1976|  2.95k|    ctxt->node = value;
 1977|  2.95k|    return (ctxt->nodeNr++);
 1978|  2.95k|}
nodePop:
 1992|  2.94k|{
 1993|  2.94k|    xmlNodePtr ret;
 1994|       |
 1995|  2.94k|    if (ctxt == NULL) return(NULL);
  ------------------
  |  Branch (1995:9): [True: 0, False: 2.94k]
  ------------------
 1996|  2.94k|    if (ctxt->nodeNr <= 0)
  ------------------
  |  Branch (1996:9): [True: 0, False: 2.94k]
  ------------------
 1997|      0|        return (NULL);
 1998|  2.94k|    ctxt->nodeNr--;
 1999|  2.94k|    if (ctxt->nodeNr > 0)
  ------------------
  |  Branch (1999:9): [True: 2.47k, False: 471]
  ------------------
 2000|  2.47k|        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];
 2001|    471|    else
 2002|    471|        ctxt->node = NULL;
 2003|  2.94k|    ret = ctxt->nodeTab[ctxt->nodeNr];
 2004|  2.94k|    ctxt->nodeTab[ctxt->nodeNr] = NULL;
 2005|  2.94k|    return (ret);
 2006|  2.94k|}
namePop:
 2139|  2.94k|{
 2140|  2.94k|    const xmlChar *ret;
 2141|       |
 2142|  2.94k|    if ((ctxt == NULL) || (ctxt->nameNr <= 0))
  ------------------
  |  Branch (2142:9): [True: 0, False: 2.94k]
  |  Branch (2142:27): [True: 0, False: 2.94k]
  ------------------
 2143|      0|        return (NULL);
 2144|  2.94k|    ctxt->nameNr--;
 2145|  2.94k|    if (ctxt->nameNr > 0)
  ------------------
  |  Branch (2145:9): [True: 2.47k, False: 471]
  ------------------
 2146|  2.47k|        ctxt->name = ctxt->nameTab[ctxt->nameNr - 1];
 2147|    471|    else
 2148|    471|        ctxt->name = NULL;
 2149|  2.94k|    ret = ctxt->nameTab[ctxt->nameNr];
 2150|  2.94k|    ctxt->nameTab[ctxt->nameNr] = NULL;
 2151|  2.94k|    return (ret);
 2152|  2.94k|}
xmlSkipBlankChars:
 2311|  11.2k|xmlSkipBlankChars(xmlParserCtxtPtr ctxt) {
 2312|  11.2k|    int res = 0;
 2313|       |
 2314|       |    /*
 2315|       |     * It's Okay to use CUR/NEXT here since all the blanks are on
 2316|       |     * the ASCII range.
 2317|       |     */
 2318|  11.2k|    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||
  ------------------
  |  Branch (2318:10): [True: 11.2k, False: 0]
  |  Branch (2318:34): [True: 9.41k, False: 1.85k]
  ------------------
 2319|  11.2k|        (ctxt->instate == XML_PARSER_START)) {
  ------------------
  |  Branch (2319:9): [True: 0, False: 1.85k]
  ------------------
 2320|  9.41k|	const xmlChar *cur;
 2321|       |	/*
 2322|       |	 * if we are in the document content, go really fast
 2323|       |	 */
 2324|  9.41k|	cur = ctxt->input->cur;
 2325|  9.41k|	while (IS_BLANK_CH(*cur)) {
 2326|  1.56k|	    if (*cur == '\n') {
  ------------------
  |  Branch (2326:10): [True: 400, False: 1.16k]
  ------------------
 2327|    400|		ctxt->input->line++; ctxt->input->col = 1;
 2328|  1.16k|	    } else {
 2329|  1.16k|		ctxt->input->col++;
 2330|  1.16k|	    }
 2331|  1.56k|	    cur++;
 2332|  1.56k|	    if (res < INT_MAX)
  ------------------
  |  Branch (2332:10): [True: 1.56k, False: 0]
  ------------------
 2333|  1.56k|		res++;
 2334|  1.56k|	    if (*cur == 0) {
  ------------------
  |  Branch (2334:10): [True: 165, False: 1.40k]
  ------------------
 2335|    165|		ctxt->input->cur = cur;
 2336|    165|		xmlParserGrow(ctxt);
 2337|    165|		cur = ctxt->input->cur;
 2338|    165|	    }
 2339|  1.56k|	}
 2340|  9.41k|	ctxt->input->cur = cur;
 2341|  9.41k|    } else {
 2342|  1.85k|        int expandPE = ((ctxt->external != 0) || (ctxt->inputNr != 1));
  ------------------
  |  Branch (2342:25): [True: 0, False: 1.85k]
  |  Branch (2342:50): [True: 0, False: 1.85k]
  ------------------
 2343|       |
 2344|  2.83k|	while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (2344:9): [True: 2.83k, False: 0]
  ------------------
 2345|  2.83k|            if (IS_BLANK_CH(CUR)) { /* CHECKED tstblanks.xml */
  ------------------
  |  |  151|  2.83k|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|  2.83k|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 729, False: 2.10k]
  |  |  |  |  ------------------
  |  |  |  |   89|  2.83k|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 2.10k, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 243, False: 1.85k]
  |  |  |  |  ------------------
  |  |  |  |   90|  2.83k|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 1.85k]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 2346|    972|		NEXT;
  ------------------
  |  | 2275|    972|#define NEXT xmlNextChar(ctxt)
  ------------------
 2347|  1.85k|	    } else if (CUR == '%') {
  ------------------
  |  | 2222|  1.85k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2347:17): [True: 0, False: 1.85k]
  ------------------
 2348|       |                /*
 2349|       |                 * Need to handle support of entities branching here
 2350|       |                 */
 2351|      0|	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	        if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (2351:14): [True: 0, False: 0]
  |  Branch (2351:58): [True: 0, False: 0]
  ------------------
 2352|      0|                    break;
 2353|      0|	        xmlParsePEReference(ctxt);
 2354|  1.85k|            } else if (CUR == 0) {
  ------------------
  |  | 2222|  1.85k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (2354:24): [True: 0, False: 1.85k]
  ------------------
 2355|      0|                unsigned long consumed;
 2356|      0|                xmlEntityPtr ent;
 2357|       |
 2358|      0|                if (ctxt->inputNr <= 1)
  ------------------
  |  Branch (2358:21): [True: 0, False: 0]
  ------------------
 2359|      0|                    break;
 2360|       |
 2361|      0|                consumed = ctxt->input->consumed;
 2362|      0|                xmlSaturatedAddSizeT(&consumed,
 2363|      0|                                     ctxt->input->cur - ctxt->input->base);
 2364|       |
 2365|       |                /*
 2366|       |                 * Add to sizeentities when parsing an external entity
 2367|       |                 * for the first time.
 2368|       |                 */
 2369|      0|                ent = ctxt->input->entity;
 2370|      0|                if ((ent->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
  ------------------
  |  Branch (2370:21): [True: 0, False: 0]
  ------------------
 2371|      0|                    ((ent->flags & XML_ENT_PARSED) == 0)) {
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (2371:21): [True: 0, False: 0]
  ------------------
 2372|      0|                    ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 2373|       |
 2374|      0|                    xmlSaturatedAdd(&ctxt->sizeentities, consumed);
 2375|      0|                }
 2376|       |
 2377|      0|                xmlParserEntityCheck(ctxt, consumed);
 2378|       |
 2379|      0|                xmlPopInput(ctxt);
 2380|  1.85k|            } else {
 2381|  1.85k|                break;
 2382|  1.85k|            }
 2383|       |
 2384|       |            /*
 2385|       |             * Also increase the counter when entering or exiting a PERef.
 2386|       |             * The spec says: "When a parameter-entity reference is recognized
 2387|       |             * in the DTD and included, its replacement text MUST be enlarged
 2388|       |             * by the attachment of one leading and one following space (#x20)
 2389|       |             * character."
 2390|       |             */
 2391|    972|	    if (res < INT_MAX)
  ------------------
  |  Branch (2391:10): [True: 972, False: 0]
  ------------------
 2392|    972|		res++;
 2393|    972|        }
 2394|  1.85k|    }
 2395|  11.2k|    return(res);
 2396|  11.2k|}
xmlSplitQName:
 3152|     88|xmlSplitQName(xmlParserCtxtPtr ctxt, const xmlChar *name, xmlChar **prefix) {
 3153|     88|    xmlChar buf[XML_MAX_NAMELEN + 5];
 3154|     88|    xmlChar *buffer = NULL;
 3155|     88|    int len = 0;
 3156|     88|    int max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|     88|#define XML_MAX_NAMELEN 100
  ------------------
 3157|     88|    xmlChar *ret = NULL;
 3158|     88|    const xmlChar *cur = name;
 3159|     88|    int c;
 3160|       |
 3161|     88|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (3161:9): [True: 0, False: 88]
  ------------------
 3162|     88|    *prefix = NULL;
 3163|       |
 3164|     88|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (3164:9): [True: 0, False: 88]
  ------------------
 3165|       |
 3166|       |#ifndef XML_XML_NAMESPACE
 3167|       |    /* xml: prefix is not really a namespace */
 3168|       |    if ((cur[0] == 'x') && (cur[1] == 'm') &&
 3169|       |        (cur[2] == 'l') && (cur[3] == ':'))
 3170|       |	return(xmlStrdup(name));
 3171|       |#endif
 3172|       |
 3173|       |    /* nasty but well=formed */
 3174|     88|    if (cur[0] == ':')
  ------------------
  |  Branch (3174:9): [True: 0, False: 88]
  ------------------
 3175|      0|	return(xmlStrdup(name));
 3176|       |
 3177|     88|    c = *cur++;
 3178|    308|    while ((c != 0) && (c != ':') && (len < max)) { /* tested bigname.xml */
  ------------------
  |  Branch (3178:12): [True: 220, False: 88]
  |  Branch (3178:24): [True: 220, False: 0]
  |  Branch (3178:38): [True: 220, False: 0]
  ------------------
 3179|    220|	buf[len++] = c;
 3180|    220|	c = *cur++;
 3181|    220|    }
 3182|     88|    if (len >= max) {
  ------------------
  |  Branch (3182:9): [True: 0, False: 88]
  ------------------
 3183|       |	/*
 3184|       |	 * Okay someone managed to make a huge name, so he's ready to pay
 3185|       |	 * for the processing speed.
 3186|       |	 */
 3187|      0|	max = len * 2;
 3188|       |
 3189|      0|	buffer = (xmlChar *) xmlMallocAtomic(max);
 3190|      0|	if (buffer == NULL) {
  ------------------
  |  Branch (3190:6): [True: 0, False: 0]
  ------------------
 3191|      0|	    xmlErrMemory(ctxt, NULL);
 3192|      0|	    return(NULL);
 3193|      0|	}
 3194|      0|	memcpy(buffer, buf, len);
 3195|      0|	while ((c != 0) && (c != ':')) { /* tested bigname.xml */
  ------------------
  |  Branch (3195:9): [True: 0, False: 0]
  |  Branch (3195:21): [True: 0, False: 0]
  ------------------
 3196|      0|	    if (len + 10 > max) {
  ------------------
  |  Branch (3196:10): [True: 0, False: 0]
  ------------------
 3197|      0|	        xmlChar *tmp;
 3198|       |
 3199|      0|		max *= 2;
 3200|      0|		tmp = (xmlChar *) xmlRealloc(buffer, max);
 3201|      0|		if (tmp == NULL) {
  ------------------
  |  Branch (3201:7): [True: 0, False: 0]
  ------------------
 3202|      0|		    xmlFree(buffer);
 3203|      0|		    xmlErrMemory(ctxt, NULL);
 3204|      0|		    return(NULL);
 3205|      0|		}
 3206|      0|		buffer = tmp;
 3207|      0|	    }
 3208|      0|	    buffer[len++] = c;
 3209|      0|	    c = *cur++;
 3210|      0|	}
 3211|      0|	buffer[len] = 0;
 3212|      0|    }
 3213|       |
 3214|     88|    if ((c == ':') && (*cur == 0)) {
  ------------------
  |  Branch (3214:9): [True: 0, False: 88]
  |  Branch (3214:23): [True: 0, False: 0]
  ------------------
 3215|      0|        if (buffer != NULL)
  ------------------
  |  Branch (3215:13): [True: 0, False: 0]
  ------------------
 3216|      0|	    xmlFree(buffer);
 3217|      0|	*prefix = NULL;
 3218|      0|	return(xmlStrdup(name));
 3219|      0|    }
 3220|       |
 3221|     88|    if (buffer == NULL)
  ------------------
  |  Branch (3221:9): [True: 88, False: 0]
  ------------------
 3222|     88|	ret = xmlStrndup(buf, len);
 3223|      0|    else {
 3224|      0|	ret = buffer;
 3225|      0|	buffer = NULL;
 3226|      0|	max = XML_MAX_NAMELEN;
  ------------------
  |  |   89|      0|#define XML_MAX_NAMELEN 100
  ------------------
 3227|      0|    }
 3228|       |
 3229|       |
 3230|     88|    if (c == ':') {
  ------------------
  |  Branch (3230:9): [True: 0, False: 88]
  ------------------
 3231|      0|	c = *cur;
 3232|      0|        *prefix = ret;
 3233|      0|	if (c == 0) {
  ------------------
  |  Branch (3233:6): [True: 0, False: 0]
  ------------------
 3234|      0|	    return(xmlStrndup(BAD_CAST "", 0));
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 3235|      0|	}
 3236|      0|	len = 0;
 3237|       |
 3238|       |	/*
 3239|       |	 * Check that the first character is proper to start
 3240|       |	 * a new name
 3241|       |	 */
 3242|      0|	if (!(((c >= 0x61) && (c <= 0x7A)) ||
  ------------------
  |  Branch (3242:9): [True: 0, False: 0]
  |  Branch (3242:24): [True: 0, False: 0]
  ------------------
 3243|      0|	      ((c >= 0x41) && (c <= 0x5A)) ||
  ------------------
  |  Branch (3243:9): [True: 0, False: 0]
  |  Branch (3243:24): [True: 0, False: 0]
  ------------------
 3244|      0|	      (c == '_') || (c == ':'))) {
  ------------------
  |  Branch (3244:8): [True: 0, False: 0]
  |  Branch (3244:22): [True: 0, False: 0]
  ------------------
 3245|      0|	    int l;
 3246|      0|	    int first = CUR_SCHAR(cur, l);
  ------------------
  |  | 2292|      0|#define CUR_SCHAR(s, l) xmlStringCurrentChar(ctxt, s, &l)
  ------------------
 3247|       |
 3248|      0|	    if (!IS_LETTER(first) && (first != '_')) {
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3248:31): [True: 0, False: 0]
  ------------------
 3249|      0|		xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,
 3250|      0|			    "Name %s is not XML Namespace compliant\n",
 3251|      0|				  name);
 3252|      0|	    }
 3253|      0|	}
 3254|      0|	cur++;
 3255|       |
 3256|      0|	while ((c != 0) && (len < max)) { /* tested bigname2.xml */
  ------------------
  |  Branch (3256:9): [True: 0, False: 0]
  |  Branch (3256:21): [True: 0, False: 0]
  ------------------
 3257|      0|	    buf[len++] = c;
 3258|      0|	    c = *cur++;
 3259|      0|	}
 3260|      0|	if (len >= max) {
  ------------------
  |  Branch (3260:6): [True: 0, False: 0]
  ------------------
 3261|       |	    /*
 3262|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 3263|       |	     * for the processing speed.
 3264|       |	     */
 3265|      0|	    max = len * 2;
 3266|       |
 3267|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 3268|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (3268:10): [True: 0, False: 0]
  ------------------
 3269|      0|	        xmlErrMemory(ctxt, NULL);
 3270|      0|		return(NULL);
 3271|      0|	    }
 3272|      0|	    memcpy(buffer, buf, len);
 3273|      0|	    while (c != 0) { /* tested bigname2.xml */
  ------------------
  |  Branch (3273:13): [True: 0, False: 0]
  ------------------
 3274|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (3274:7): [True: 0, False: 0]
  ------------------
 3275|      0|		    xmlChar *tmp;
 3276|       |
 3277|      0|		    max *= 2;
 3278|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 3279|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (3279:11): [True: 0, False: 0]
  ------------------
 3280|      0|			xmlErrMemory(ctxt, NULL);
 3281|      0|			xmlFree(buffer);
 3282|      0|			return(NULL);
 3283|      0|		    }
 3284|      0|		    buffer = tmp;
 3285|      0|		}
 3286|      0|		buffer[len++] = c;
 3287|      0|		c = *cur++;
 3288|      0|	    }
 3289|      0|	    buffer[len] = 0;
 3290|      0|	}
 3291|       |
 3292|      0|	if (buffer == NULL)
  ------------------
  |  Branch (3292:6): [True: 0, False: 0]
  ------------------
 3293|      0|	    ret = xmlStrndup(buf, len);
 3294|      0|	else {
 3295|      0|	    ret = buffer;
 3296|      0|	}
 3297|      0|    }
 3298|       |
 3299|     88|    return(ret);
 3300|     88|}
xmlParseName:
 3524|    642|xmlParseName(xmlParserCtxtPtr ctxt) {
 3525|    642|    const xmlChar *in;
 3526|    642|    const xmlChar *ret;
 3527|    642|    size_t count = 0;
 3528|    642|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3528:24): [True: 0, False: 642]
  ------------------
 3529|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3530|    642|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  1.28k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3531|       |
 3532|    642|    GROW;
  ------------------
  |  | 2270|    642|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    642|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 84, False: 558]
  |  |  ------------------
  |  | 2271|    642|	xmlParserGrow(ctxt);
  ------------------
 3533|    642|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3533:9): [True: 0, False: 642]
  ------------------
 3534|      0|        return(NULL);
 3535|       |
 3536|       |    /*
 3537|       |     * Accelerator for simple ASCII names
 3538|       |     */
 3539|    642|    in = ctxt->input->cur;
 3540|    642|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3540:10): [True: 632, False: 10]
  |  Branch (3540:27): [True: 632, False: 0]
  ------------------
 3541|    642|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3541:3): [True: 4, False: 6]
  |  Branch (3541:20): [True: 4, False: 0]
  ------------------
 3542|    642|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (3542:2): [True: 0, False: 6]
  |  Branch (3542:18): [True: 0, False: 6]
  ------------------
 3543|    636|	in++;
 3544|  2.63k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3544:10): [True: 1.97k, False: 658]
  |  Branch (3544:27): [True: 1.97k, False: 1]
  ------------------
 3545|  2.63k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3545:10): [True: 22, False: 637]
  |  Branch (3545:27): [True: 21, False: 1]
  ------------------
 3546|  2.63k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3546:10): [True: 198, False: 440]
  |  Branch (3546:27): [True: 0, False: 198]
  ------------------
 3547|  2.63k|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3547:9): [True: 0, False: 638]
  |  Branch (3547:25): [True: 0, False: 638]
  ------------------
 3548|  2.63k|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (3548:9): [True: 2, False: 636]
  |  Branch (3548:25): [True: 0, False: 636]
  ------------------
 3549|  1.99k|	    in++;
 3550|    636|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3550:6): [True: 634, False: 2]
  |  Branch (3550:19): [True: 633, False: 1]
  ------------------
 3551|    633|	    count = in - ctxt->input->cur;
 3552|    633|            if (count > maxLength) {
  ------------------
  |  Branch (3552:17): [True: 0, False: 633]
  ------------------
 3553|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3554|      0|                return(NULL);
 3555|      0|            }
 3556|    633|	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);
 3557|    633|	    ctxt->input->cur = in;
 3558|    633|	    ctxt->input->col += count;
 3559|    633|	    if (ret == NULL)
  ------------------
  |  Branch (3559:10): [True: 0, False: 633]
  ------------------
 3560|      0|	        xmlErrMemory(ctxt, NULL);
 3561|    633|	    return(ret);
 3562|    633|	}
 3563|    636|    }
 3564|       |    /* accelerator for special cases */
 3565|      9|    return(xmlParseNameComplex(ctxt));
 3566|    642|}
xmlParseExternalID:
 4835|     23|xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
 4836|     23|    xmlChar *URI = NULL;
 4837|       |
 4838|     23|    *publicID = NULL;
 4839|     23|    if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {
  ------------------
  |  | 2233|     23|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     46|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     46|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 23]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     23|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4840|      0|        SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4841|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4841:6): [True: 0, False: 0]
  ------------------
 4842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4843|      0|	                   "Space required after 'SYSTEM'\n");
 4844|      0|	}
 4845|      0|	URI = xmlParseSystemLiteral(ctxt);
 4846|      0|	if (URI == NULL) {
  ------------------
  |  Branch (4846:6): [True: 0, False: 0]
  ------------------
 4847|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4848|      0|        }
 4849|     23|    } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {
  ------------------
  |  | 2233|     23|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     46|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     46|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 23]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     23|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4850|      0|        SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4851|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4851:6): [True: 0, False: 0]
  ------------------
 4852|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4853|      0|		    "Space required after 'PUBLIC'\n");
 4854|      0|	}
 4855|      0|	*publicID = xmlParsePubidLiteral(ctxt);
 4856|      0|	if (*publicID == NULL) {
  ------------------
  |  Branch (4856:6): [True: 0, False: 0]
  ------------------
 4857|      0|	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 4858|      0|	}
 4859|      0|	if (strict) {
  ------------------
  |  Branch (4859:6): [True: 0, False: 0]
  ------------------
 4860|       |	    /*
 4861|       |	     * We don't handle [83] so "S SystemLiteral" is required.
 4862|       |	     */
 4863|      0|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4863:10): [True: 0, False: 0]
  ------------------
 4864|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 4865|      0|			"Space required after the Public Identifier\n");
 4866|      0|	    }
 4867|      0|	} else {
 4868|       |	    /*
 4869|       |	     * We handle [83] so we return immediately, if
 4870|       |	     * "S SystemLiteral" is not detected. We skip blanks if no
 4871|       |             * system literal was found, but this is harmless since we must
 4872|       |             * be at the end of a NotationDecl.
 4873|       |	     */
 4874|      0|	    if (SKIP_BLANKS == 0) return(NULL);
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (4874:10): [True: 0, False: 0]
  ------------------
 4875|      0|	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
              	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4875:10): [True: 0, False: 0]
  |  Branch (4875:27): [True: 0, False: 0]
  ------------------
 4876|      0|	}
 4877|      0|	URI = xmlParseSystemLiteral(ctxt);
 4878|      0|	if (URI == NULL) {
  ------------------
  |  Branch (4878:6): [True: 0, False: 0]
  ------------------
 4879|      0|	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
 4880|      0|        }
 4881|      0|    }
 4882|     23|    return(URI);
 4883|     23|}
xmlParseComment:
 5029|     37|xmlParseComment(xmlParserCtxtPtr ctxt) {
 5030|     37|    xmlChar *buf = NULL;
 5031|     37|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     37|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5032|     37|    size_t len = 0;
 5033|     37|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5033:24): [True: 0, False: 37]
  ------------------
 5034|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5035|     37|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     74|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5036|     37|    xmlParserInputState state;
 5037|     37|    const xmlChar *in;
 5038|     37|    size_t nbchar = 0;
 5039|     37|    int ccol;
 5040|     37|    int inputid;
 5041|       |
 5042|       |    /*
 5043|       |     * Check that there is a comment right here.
 5044|       |     */
 5045|     37|    if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2221|     37|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5045:9): [True: 0, False: 37]
  |  Branch (5045:25): [True: 0, False: 37]
  ------------------
 5046|      0|        return;
 5047|     37|    SKIP(2);
  ------------------
  |  | 2245|     37|#define SKIP(val) do {							\
  |  | 2246|     37|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     37|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2248|     37|        xmlParserGrow(ctxt);						\
  |  | 2249|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5048|     37|    if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2221|     37|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '-') || (NXT(1) != '-'))
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5048:9): [True: 0, False: 37]
  |  Branch (5048:25): [True: 0, False: 37]
  ------------------
 5049|      0|        return;
 5050|     37|    state = ctxt->instate;
 5051|     37|    ctxt->instate = XML_PARSER_COMMENT;
 5052|     37|    inputid = ctxt->input->id;
 5053|     37|    SKIP(2);
  ------------------
  |  | 2245|     37|#define SKIP(val) do {							\
  |  | 2246|     37|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     37|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2248|     37|        xmlParserGrow(ctxt);						\
  |  | 2249|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5054|     37|    GROW;
  ------------------
  |  | 2270|     37|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     37|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 37, False: 0]
  |  |  ------------------
  |  | 2271|     37|	xmlParserGrow(ctxt);
  ------------------
 5055|       |
 5056|       |    /*
 5057|       |     * Accelerated common case where input don't need to be
 5058|       |     * modified before passing it to the handler.
 5059|       |     */
 5060|     37|    in = ctxt->input->cur;
 5061|     37|    do {
 5062|     37|	if (*in == 0xA) {
  ------------------
  |  Branch (5062:6): [True: 0, False: 37]
  ------------------
 5063|      0|	    do {
 5064|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5065|      0|		in++;
 5066|      0|	    } while (*in == 0xA);
  ------------------
  |  Branch (5066:15): [True: 0, False: 0]
  ------------------
 5067|      0|	}
 5068|     37|get_more:
 5069|     37|        ccol = ctxt->input->col;
 5070|    122|	while (((*in > '-') && (*in <= 0x7F)) ||
  ------------------
  |  Branch (5070:10): [True: 85, False: 37]
  |  Branch (5070:25): [True: 85, False: 0]
  ------------------
 5071|    122|	       ((*in >= 0x20) && (*in < '-')) ||
  ------------------
  |  Branch (5071:10): [True: 37, False: 0]
  |  Branch (5071:27): [True: 0, False: 37]
  ------------------
 5072|    122|	       (*in == 0x09)) {
  ------------------
  |  Branch (5072:9): [True: 0, False: 37]
  ------------------
 5073|     85|		    in++;
 5074|     85|		    ccol++;
 5075|     85|	}
 5076|     37|	ctxt->input->col = ccol;
 5077|     37|	if (*in == 0xA) {
  ------------------
  |  Branch (5077:6): [True: 0, False: 37]
  ------------------
 5078|      0|	    do {
 5079|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5080|      0|		in++;
 5081|      0|	    } while (*in == 0xA);
  ------------------
  |  Branch (5081:15): [True: 0, False: 0]
  ------------------
 5082|      0|	    goto get_more;
 5083|      0|	}
 5084|     37|	nbchar = in - ctxt->input->cur;
 5085|       |	/*
 5086|       |	 * save current set of data
 5087|       |	 */
 5088|     37|	if (nbchar > 0) {
  ------------------
  |  Branch (5088:6): [True: 37, False: 0]
  ------------------
 5089|     37|            if (buf == NULL) {
  ------------------
  |  Branch (5089:17): [True: 37, False: 0]
  ------------------
 5090|     37|                if ((*in == '-') && (in[1] == '-'))
  ------------------
  |  Branch (5090:21): [True: 37, False: 0]
  |  Branch (5090:37): [True: 37, False: 0]
  ------------------
 5091|     37|                    size = nbchar + 1;
 5092|      0|                else
 5093|      0|                    size = XML_PARSER_BUFFER_SIZE + nbchar;
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5094|     37|                buf = (xmlChar *) xmlMallocAtomic(size);
 5095|     37|                if (buf == NULL) {
  ------------------
  |  Branch (5095:21): [True: 0, False: 37]
  ------------------
 5096|      0|                    xmlErrMemory(ctxt, NULL);
 5097|      0|                    ctxt->instate = state;
 5098|      0|                    return;
 5099|      0|                }
 5100|     37|                len = 0;
 5101|     37|            } else if (len + nbchar + 1 >= size) {
  ------------------
  |  Branch (5101:24): [True: 0, False: 0]
  ------------------
 5102|      0|                xmlChar *new_buf;
 5103|      0|                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|      0|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5104|      0|                new_buf = (xmlChar *) xmlRealloc(buf, size);
 5105|      0|                if (new_buf == NULL) {
  ------------------
  |  Branch (5105:21): [True: 0, False: 0]
  ------------------
 5106|      0|                    xmlFree (buf);
 5107|      0|                    xmlErrMemory(ctxt, NULL);
 5108|      0|                    ctxt->instate = state;
 5109|      0|                    return;
 5110|      0|                }
 5111|      0|                buf = new_buf;
 5112|      0|            }
 5113|     37|            memcpy(&buf[len], ctxt->input->cur, nbchar);
 5114|     37|            len += nbchar;
 5115|     37|            buf[len] = 0;
 5116|     37|	}
 5117|     37|        if (len > maxLength) {
  ------------------
  |  Branch (5117:13): [True: 0, False: 37]
  ------------------
 5118|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 5119|      0|                         "Comment too big found", NULL);
 5120|      0|            xmlFree (buf);
 5121|      0|            return;
 5122|      0|        }
 5123|     37|	ctxt->input->cur = in;
 5124|     37|	if (*in == 0xA) {
  ------------------
  |  Branch (5124:6): [True: 0, False: 37]
  ------------------
 5125|      0|	    in++;
 5126|      0|	    ctxt->input->line++; ctxt->input->col = 1;
 5127|      0|	}
 5128|     37|	if (*in == 0xD) {
  ------------------
  |  Branch (5128:6): [True: 0, False: 37]
  ------------------
 5129|      0|	    in++;
 5130|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (5130:10): [True: 0, False: 0]
  ------------------
 5131|      0|		ctxt->input->cur = in;
 5132|      0|		in++;
 5133|      0|		ctxt->input->line++; ctxt->input->col = 1;
 5134|      0|		goto get_more;
 5135|      0|	    }
 5136|      0|	    in--;
 5137|      0|	}
 5138|     37|	SHRINK;
  ------------------
  |  | 2265|     37|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 37, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|     37|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     37|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2267|     37|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     37|	xmlParserShrink(ctxt);
  ------------------
 5139|     37|	GROW;
  ------------------
  |  | 2270|     37|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     37|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 37, False: 0]
  |  |  ------------------
  |  | 2271|     37|	xmlParserGrow(ctxt);
  ------------------
 5140|     37|        if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5140:13): [True: 0, False: 37]
  ------------------
 5141|      0|            xmlFree(buf);
 5142|      0|            return;
 5143|      0|        }
 5144|     37|	in = ctxt->input->cur;
 5145|     37|	if (*in == '-') {
  ------------------
  |  Branch (5145:6): [True: 37, False: 0]
  ------------------
 5146|     37|	    if (in[1] == '-') {
  ------------------
  |  Branch (5146:10): [True: 37, False: 0]
  ------------------
 5147|     37|	        if (in[2] == '>') {
  ------------------
  |  Branch (5147:14): [True: 37, False: 0]
  ------------------
 5148|     37|		    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (5148:11): [True: 0, False: 37]
  ------------------
 5149|      0|			xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5150|      0|			               "comment doesn't start and stop in the"
 5151|      0|                                       " same entity\n");
 5152|      0|		    }
 5153|     37|		    SKIP(3);
  ------------------
  |  | 2245|     37|#define SKIP(val) do {							\
  |  | 2246|     37|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     37|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 37]
  |  |  ------------------
  |  | 2248|     37|        xmlParserGrow(ctxt);						\
  |  | 2249|     37|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5154|     37|		    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&
  ------------------
  |  Branch (5154:11): [True: 37, False: 0]
  |  Branch (5154:34): [True: 37, False: 0]
  ------------------
 5155|     37|		        (!ctxt->disableSAX)) {
  ------------------
  |  Branch (5155:11): [True: 37, False: 0]
  ------------------
 5156|     37|			if (buf != NULL)
  ------------------
  |  Branch (5156:8): [True: 37, False: 0]
  ------------------
 5157|     37|			    ctxt->sax->comment(ctxt->userData, buf);
 5158|      0|			else
 5159|      0|			    ctxt->sax->comment(ctxt->userData, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 5160|     37|		    }
 5161|     37|		    if (buf != NULL)
  ------------------
  |  Branch (5161:11): [True: 37, False: 0]
  ------------------
 5162|     37|		        xmlFree(buf);
 5163|     37|		    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5163:11): [True: 37, False: 0]
  ------------------
 5164|     37|			ctxt->instate = state;
 5165|     37|		    return;
 5166|     37|		}
 5167|      0|		if (buf != NULL) {
  ------------------
  |  Branch (5167:7): [True: 0, False: 0]
  ------------------
 5168|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5169|      0|		                      "Double hyphen within comment: "
 5170|      0|                                      "<!--%.50s\n",
 5171|      0|				      buf);
 5172|      0|		} else
 5173|      0|		    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,
 5174|      0|		                      "Double hyphen within comment\n", NULL);
 5175|      0|                if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5175:21): [True: 0, False: 0]
  ------------------
 5176|      0|                    xmlFree(buf);
 5177|      0|                    return;
 5178|      0|                }
 5179|      0|		in++;
 5180|      0|		ctxt->input->col++;
 5181|      0|	    }
 5182|      0|	    in++;
 5183|      0|	    ctxt->input->col++;
 5184|      0|	    goto get_more;
 5185|     37|	}
 5186|     37|    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (5186:15): [True: 0, False: 0]
  |  Branch (5186:32): [True: 0, False: 0]
  |  Branch (5186:50): [True: 0, False: 0]
  |  Branch (5186:67): [True: 0, False: 0]
  ------------------
 5187|      0|    xmlParseCommentComplex(ctxt, buf, len, size);
 5188|      0|    ctxt->instate = state;
 5189|      0|    return;
 5190|     37|}
xmlParsePITarget:
 5207|     13|xmlParsePITarget(xmlParserCtxtPtr ctxt) {
 5208|     13|    const xmlChar *name;
 5209|       |
 5210|     13|    name = xmlParseName(ctxt);
 5211|     13|    if ((name != NULL) &&
  ------------------
  |  Branch (5211:9): [True: 12, False: 1]
  ------------------
 5212|     13|        ((name[0] == 'x') || (name[0] == 'X')) &&
  ------------------
  |  Branch (5212:10): [True: 0, False: 12]
  |  Branch (5212:30): [True: 0, False: 12]
  ------------------
 5213|     13|        ((name[1] == 'm') || (name[1] == 'M')) &&
  ------------------
  |  Branch (5213:10): [True: 0, False: 0]
  |  Branch (5213:30): [True: 0, False: 0]
  ------------------
 5214|     13|        ((name[2] == 'l') || (name[2] == 'L'))) {
  ------------------
  |  Branch (5214:10): [True: 0, False: 0]
  |  Branch (5214:30): [True: 0, False: 0]
  ------------------
 5215|      0|	int i;
 5216|      0|	if ((name[0] == 'x') && (name[1] == 'm') &&
  ------------------
  |  Branch (5216:6): [True: 0, False: 0]
  |  Branch (5216:26): [True: 0, False: 0]
  ------------------
 5217|      0|	    (name[2] == 'l') && (name[3] == 0)) {
  ------------------
  |  Branch (5217:6): [True: 0, False: 0]
  |  Branch (5217:26): [True: 0, False: 0]
  ------------------
 5218|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5219|      0|		 "XML declaration allowed only at the start of the document\n");
 5220|      0|	    return(name);
 5221|      0|	} else if (name[3] == 0) {
  ------------------
  |  Branch (5221:13): [True: 0, False: 0]
  ------------------
 5222|      0|	    xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);
 5223|      0|	    return(name);
 5224|      0|	}
 5225|      0|	for (i = 0;;i++) {
 5226|      0|	    if (xmlW3CPIs[i] == NULL) break;
  ------------------
  |  Branch (5226:10): [True: 0, False: 0]
  ------------------
 5227|      0|	    if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))
  ------------------
  |  Branch (5227:10): [True: 0, False: 0]
  ------------------
 5228|      0|	        return(name);
 5229|      0|	}
 5230|      0|	xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,
 5231|      0|		      "xmlParsePITarget: invalid name prefix 'xml'\n",
 5232|      0|		      NULL, NULL);
 5233|      0|    }
 5234|     13|    if ((name != NULL) && (xmlStrchr(name, ':') != NULL)) {
  ------------------
  |  Branch (5234:9): [True: 12, False: 1]
  |  Branch (5234:27): [True: 0, False: 12]
  ------------------
 5235|      0|	xmlNsErr(ctxt, XML_NS_ERR_COLON,
 5236|      0|		 "colons are forbidden from PI names '%s'\n", name, NULL, NULL);
 5237|      0|    }
 5238|     13|    return(name);
 5239|     13|}
xmlParsePI:
 5317|     13|xmlParsePI(xmlParserCtxtPtr ctxt) {
 5318|     13|    xmlChar *buf = NULL;
 5319|     13|    size_t len = 0;
 5320|     13|    size_t size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     13|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 5321|     13|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (5321:24): [True: 0, False: 13]
  ------------------
 5322|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 5323|     13|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     26|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 5324|     13|    int cur, l;
 5325|     13|    const xmlChar *target;
 5326|     13|    xmlParserInputState state;
 5327|       |
 5328|     13|    if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|     13|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|     13|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5328:9): [True: 13, False: 0]
  |  Branch (5328:25): [True: 13, False: 0]
  ------------------
 5329|     13|	int inputid = ctxt->input->id;
 5330|     13|	state = ctxt->instate;
 5331|     13|        ctxt->instate = XML_PARSER_PI;
 5332|       |	/*
 5333|       |	 * this is a Processing Instruction.
 5334|       |	 */
 5335|     13|	SKIP(2);
  ------------------
  |  | 2245|     13|#define SKIP(val) do {							\
  |  | 2246|     13|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     13|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 1, False: 12]
  |  |  ------------------
  |  | 2248|     13|        xmlParserGrow(ctxt);						\
  |  | 2249|     13|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5336|       |
 5337|       |	/*
 5338|       |	 * Parse the target name and check for special support like
 5339|       |	 * namespace.
 5340|       |	 */
 5341|     13|        target = xmlParsePITarget(ctxt);
 5342|     13|	if (target != NULL) {
  ------------------
  |  Branch (5342:6): [True: 12, False: 1]
  ------------------
 5343|     12|	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|     12|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5343:10): [True: 0, False: 12]
  |  Branch (5343:26): [True: 0, False: 0]
  ------------------
 5344|      0|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5344:7): [True: 0, False: 0]
  ------------------
 5345|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5346|      0|	                           "PI declaration doesn't start and stop in"
 5347|      0|                                   " the same entity\n");
 5348|      0|		}
 5349|      0|		SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5350|       |
 5351|       |		/*
 5352|       |		 * SAX: PI detected.
 5353|       |		 */
 5354|      0|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5354:7): [True: 0, False: 0]
  |  Branch (5354:22): [True: 0, False: 0]
  ------------------
 5355|      0|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5355:7): [True: 0, False: 0]
  ------------------
 5356|      0|		    ctxt->sax->processingInstruction(ctxt->userData,
 5357|      0|		                                     target, NULL);
 5358|      0|		if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5358:7): [True: 0, False: 0]
  ------------------
 5359|      0|		    ctxt->instate = state;
 5360|      0|		return;
 5361|      0|	    }
 5362|     12|	    buf = (xmlChar *) xmlMallocAtomic(size);
 5363|     12|	    if (buf == NULL) {
  ------------------
  |  Branch (5363:10): [True: 0, False: 12]
  ------------------
 5364|      0|		xmlErrMemory(ctxt, NULL);
 5365|      0|		ctxt->instate = state;
 5366|      0|		return;
 5367|      0|	    }
 5368|     12|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     12|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5368:10): [True: 0, False: 12]
  ------------------
 5369|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 5370|      0|			  "ParsePI: PI %s space expected\n", target);
 5371|      0|	    }
 5372|     12|	    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     12|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5373|     60|	    while (IS_CHAR(cur) && /* checked */
  ------------------
  |  |  125|     60|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    120|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 60, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 60, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    120|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     60|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 60, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 60]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     60|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 60]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     60|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 60, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    120|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 5374|     60|		   ((cur != '?') || (NXT(1) != '>'))) {
  ------------------
  |  | 2223|     12|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (5374:7): [True: 48, False: 12]
  |  Branch (5374:23): [True: 0, False: 12]
  ------------------
 5375|     48|		if (len + 5 >= size) {
  ------------------
  |  Branch (5375:7): [True: 0, False: 48]
  ------------------
 5376|      0|		    xmlChar *tmp;
 5377|      0|                    size_t new_size = size * 2;
 5378|      0|		    tmp = (xmlChar *) xmlRealloc(buf, new_size);
 5379|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (5379:11): [True: 0, False: 0]
  ------------------
 5380|      0|			xmlErrMemory(ctxt, NULL);
 5381|      0|			xmlFree(buf);
 5382|      0|			ctxt->instate = state;
 5383|      0|			return;
 5384|      0|		    }
 5385|      0|		    buf = tmp;
 5386|      0|                    size = new_size;
 5387|      0|		}
 5388|     48|		COPY_BUF(buf, len, cur);
  ------------------
  |  | 2295|     48|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 48, False: 0]
  |  |  ------------------
  |  | 2296|     48|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 5389|     48|                if (len > maxLength) {
  ------------------
  |  Branch (5389:21): [True: 0, False: 48]
  ------------------
 5390|      0|                    xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5391|      0|                                      "PI %s too big found", target);
 5392|      0|                    xmlFree(buf);
 5393|      0|                    ctxt->instate = state;
 5394|      0|                    return;
 5395|      0|                }
 5396|     48|		NEXTL(l);
  ------------------
  |  | 2284|     48|#define NEXTL(l) do {							\
  |  | 2285|     48|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 48]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     48|    } else ctxt->input->col++;						\
  |  | 2288|     48|    ctxt->input->cur += l;				\
  |  | 2289|     48|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5397|     48|		cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     48|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 5398|     48|	    }
 5399|     12|	    buf[len] = 0;
 5400|     12|            if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (5400:17): [True: 0, False: 12]
  ------------------
 5401|      0|                xmlFree(buf);
 5402|      0|                return;
 5403|      0|            }
 5404|     12|	    if (cur != '?') {
  ------------------
  |  Branch (5404:10): [True: 0, False: 12]
  ------------------
 5405|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 5406|      0|		      "ParsePI: PI %s never end ...\n", target);
 5407|     12|	    } else {
 5408|     12|		if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (5408:7): [True: 0, False: 12]
  ------------------
 5409|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 5410|      0|	                           "PI declaration doesn't start and stop in"
 5411|      0|                                   " the same entity\n");
 5412|      0|		}
 5413|     12|		SKIP(2);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5414|       |
 5415|     12|#ifdef LIBXML_CATALOG_ENABLED
 5416|     12|		if (((state == XML_PARSER_MISC) ||
  ------------------
  |  Branch (5416:8): [True: 0, False: 12]
  ------------------
 5417|     12|	             (state == XML_PARSER_START)) &&
  ------------------
  |  Branch (5417:15): [True: 0, False: 12]
  ------------------
 5418|     12|		    (xmlStrEqual(target, XML_CATALOG_PI))) {
  ------------------
  |  |   45|      0|    (const xmlChar *) "oasis-xml-catalog"
  ------------------
  |  Branch (5418:7): [True: 0, False: 0]
  ------------------
 5419|      0|		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
 5420|      0|		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
  ------------------
  |  Branch (5420:11): [True: 0, False: 0]
  ------------------
 5421|      0|			(allow == XML_CATA_ALLOW_ALL))
  ------------------
  |  Branch (5421:4): [True: 0, False: 0]
  ------------------
 5422|      0|			xmlParseCatalogPI(ctxt, buf);
 5423|      0|		}
 5424|     12|#endif
 5425|       |
 5426|       |
 5427|       |		/*
 5428|       |		 * SAX: PI detected.
 5429|       |		 */
 5430|     12|		if ((ctxt->sax) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (5430:7): [True: 12, False: 0]
  |  Branch (5430:22): [True: 12, False: 0]
  ------------------
 5431|     12|		    (ctxt->sax->processingInstruction != NULL))
  ------------------
  |  Branch (5431:7): [True: 12, False: 0]
  ------------------
 5432|     12|		    ctxt->sax->processingInstruction(ctxt->userData,
 5433|     12|		                                     target, buf);
 5434|     12|	    }
 5435|     12|	    xmlFree(buf);
 5436|     12|	} else {
 5437|      1|	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 5438|      1|	}
 5439|     13|	if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (5439:6): [True: 13, False: 0]
  ------------------
 5440|     13|	    ctxt->instate = state;
 5441|     13|    }
 5442|     13|}
xmlParseDefaultDecl:
 5824|     88|xmlParseDefaultDecl(xmlParserCtxtPtr ctxt, xmlChar **value) {
 5825|     88|    int val;
 5826|     88|    xmlChar *ret;
 5827|       |
 5828|     88|    *value = NULL;
 5829|     88|    if (CMP9(CUR_PTR, '#', 'R', 'E', 'Q', 'U', 'I', 'R', 'E', 'D')) {
  ------------------
  |  | 2239|     88|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|    176|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|    176|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|    176|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|    176|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|    176|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 88]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|     88|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|     88|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 5830|      0|	SKIP(9);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5831|      0|	return(XML_ATTRIBUTE_REQUIRED);
 5832|      0|    }
 5833|     88|    if (CMP8(CUR_PTR, '#', 'I', 'M', 'P', 'L', 'I', 'E', 'D')) {
  ------------------
  |  | 2237|     88|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|    176|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|    176|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|    176|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|    176|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|     88|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 88, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 88, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 88, False: 0]
  |  |  ------------------
  ------------------
 5834|     88|	SKIP(8);
  ------------------
  |  | 2245|     88|#define SKIP(val) do {							\
  |  | 2246|     88|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     88|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 88]
  |  |  ------------------
  |  | 2248|     88|        xmlParserGrow(ctxt);						\
  |  | 2249|     88|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5835|     88|	return(XML_ATTRIBUTE_IMPLIED);
 5836|     88|    }
 5837|      0|    val = XML_ATTRIBUTE_NONE;
 5838|      0|    if (CMP6(CUR_PTR, '#', 'F', 'I', 'X', 'E', 'D')) {
  ------------------
  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 5839|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 5840|      0|	val = XML_ATTRIBUTE_FIXED;
 5841|      0|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (5841:6): [True: 0, False: 0]
  ------------------
 5842|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 5843|      0|			   "Space required after '#FIXED'\n");
 5844|      0|	}
 5845|      0|    }
 5846|      0|    ret = xmlParseAttValue(ctxt);
 5847|      0|    ctxt->instate = XML_PARSER_DTD;
 5848|      0|    if (ret == NULL) {
  ------------------
  |  Branch (5848:9): [True: 0, False: 0]
  ------------------
 5849|      0|	xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,
 5850|      0|		       "Attribute default value declaration error\n");
 5851|      0|    } else
 5852|      0|        *value = ret;
 5853|      0|    return(val);
 5854|     88|}
xmlParseAttributeType:
 6082|     88|xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
 6083|     88|    if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2231|     88|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    176|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 22, False: 66]
  |  |  |  |  |  Branch (2228:41): [True: 22, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     88|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 22, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 22, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 22, False: 0]
  |  |  ------------------
  ------------------
 6084|     22|	SKIP(5);
  ------------------
  |  | 2245|     22|#define SKIP(val) do {							\
  |  | 2246|     22|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     22|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 22]
  |  |  ------------------
  |  | 2248|     22|        xmlParserGrow(ctxt);						\
  |  | 2249|     22|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6085|     22|	return(XML_ATTRIBUTE_CDATA);
 6086|     66|     } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {
  ------------------
  |  | 2233|     66|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|    132|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|    132|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 66, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 66, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     66|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 66]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6087|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6088|      0|	return(XML_ATTRIBUTE_IDREFS);
 6089|     66|     } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {
  ------------------
  |  | 2231|     66|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    132|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 66, False: 0]
  |  |  |  |  |  Branch (2228:41): [True: 66, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|     66|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 0, False: 66]
  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6090|      0|	SKIP(5);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6091|      0|	return(XML_ATTRIBUTE_IDREF);
 6092|     66|     } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
                   } else if ((RAW == 'I') && (NXT(1) == 'D')) {
  ------------------
  |  | 2223|     66|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6092:17): [True: 66, False: 0]
  |  Branch (6092:33): [True: 66, False: 0]
  ------------------
 6093|     66|        SKIP(2);
  ------------------
  |  | 2245|     66|#define SKIP(val) do {							\
  |  | 2246|     66|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     66|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 66]
  |  |  ------------------
  |  | 2248|     66|        xmlParserGrow(ctxt);						\
  |  | 2249|     66|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6094|     66|	return(XML_ATTRIBUTE_ID);
 6095|     66|     } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
  ------------------
  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6096|      0|	SKIP(6);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6097|      0|	return(XML_ATTRIBUTE_ENTITY);
 6098|      0|     } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {
  ------------------
  |  | 2237|      0|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6099|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6100|      0|	return(XML_ATTRIBUTE_ENTITIES);
 6101|      0|     } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {
  ------------------
  |  | 2237|      0|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6102|      0|	SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6103|      0|	return(XML_ATTRIBUTE_NMTOKENS);
 6104|      0|     } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {
  ------------------
  |  | 2235|      0|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|      0|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|      0|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|      0|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|      0|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 6105|      0|	SKIP(7);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6106|      0|	return(XML_ATTRIBUTE_NMTOKEN);
 6107|      0|     }
 6108|      0|     return(xmlParseEnumeratedType(ctxt, tree));
 6109|     88|}
xmlParseAttributeListDecl:
 6125|     88|xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
 6126|     88|    const xmlChar *elemName;
 6127|     88|    const xmlChar *attrName;
 6128|     88|    xmlEnumerationPtr tree;
 6129|       |
 6130|     88|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|     88|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|     88|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6130:9): [True: 0, False: 88]
  |  Branch (6130:25): [True: 0, False: 88]
  ------------------
 6131|      0|        return;
 6132|     88|    SKIP(2);
  ------------------
  |  | 2245|     88|#define SKIP(val) do {							\
  |  | 2246|     88|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     88|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 88]
  |  |  ------------------
  |  | 2248|     88|        xmlParserGrow(ctxt);						\
  |  | 2249|     88|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6133|       |
 6134|     88|    if (CMP7(CUR_PTR, 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
  ------------------
  |  | 2235|     88|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    176|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    176|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    176|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     88|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 88, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 88, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 88, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 88, False: 0]
  |  |  ------------------
  ------------------
 6135|     88|	int inputid = ctxt->input->id;
 6136|       |
 6137|     88|	SKIP(7);
  ------------------
  |  | 2245|     88|#define SKIP(val) do {							\
  |  | 2246|     88|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     88|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 88]
  |  |  ------------------
  |  | 2248|     88|        xmlParserGrow(ctxt);						\
  |  | 2249|     88|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6138|     88|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     88|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6138:6): [True: 0, False: 88]
  ------------------
 6139|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6140|      0|		                 "Space required after '<!ATTLIST'\n");
 6141|      0|	}
 6142|     88|        elemName = xmlParseName(ctxt);
 6143|     88|	if (elemName == NULL) {
  ------------------
  |  Branch (6143:6): [True: 0, False: 88]
  ------------------
 6144|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6145|      0|			   "ATTLIST: no name for Element\n");
 6146|      0|	    return;
 6147|      0|	}
 6148|     88|	SKIP_BLANKS;
  ------------------
  |  | 2273|     88|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6149|     88|	GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6150|    176|	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|    176|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6150:9): [True: 88, False: 88]
  |  Branch (6150:25): [True: 88, False: 0]
  ------------------
 6151|     88|	    int type;
 6152|     88|	    int def;
 6153|     88|	    xmlChar *defaultValue = NULL;
 6154|       |
 6155|     88|	    GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6156|     88|            tree = NULL;
 6157|     88|	    attrName = xmlParseName(ctxt);
 6158|     88|	    if (attrName == NULL) {
  ------------------
  |  Branch (6158:10): [True: 0, False: 88]
  ------------------
 6159|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6160|      0|			       "ATTLIST: no name for Attribute\n");
 6161|      0|		break;
 6162|      0|	    }
 6163|     88|	    GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6164|     88|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     88|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6164:10): [True: 0, False: 88]
  ------------------
 6165|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6166|      0|		        "Space required after the attribute name\n");
 6167|      0|		break;
 6168|      0|	    }
 6169|       |
 6170|     88|	    type = xmlParseAttributeType(ctxt, &tree);
 6171|     88|	    if (type <= 0) {
  ------------------
  |  Branch (6171:10): [True: 0, False: 88]
  ------------------
 6172|      0|	        break;
 6173|      0|	    }
 6174|       |
 6175|     88|	    GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6176|     88|	    if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|     88|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6176:10): [True: 0, False: 88]
  ------------------
 6177|      0|		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6178|      0|			       "Space required after the attribute type\n");
 6179|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6179:14): [True: 0, False: 0]
  ------------------
 6180|      0|		    xmlFreeEnumeration(tree);
 6181|      0|		break;
 6182|      0|	    }
 6183|       |
 6184|     88|	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
 6185|     88|	    if (def <= 0) {
  ------------------
  |  Branch (6185:10): [True: 0, False: 88]
  ------------------
 6186|      0|                if (defaultValue != NULL)
  ------------------
  |  Branch (6186:21): [True: 0, False: 0]
  ------------------
 6187|      0|		    xmlFree(defaultValue);
 6188|      0|	        if (tree != NULL)
  ------------------
  |  Branch (6188:14): [True: 0, False: 0]
  ------------------
 6189|      0|		    xmlFreeEnumeration(tree);
 6190|      0|	        break;
 6191|      0|	    }
 6192|     88|	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
  ------------------
  |  Branch (6192:10): [True: 66, False: 22]
  |  Branch (6192:43): [True: 0, False: 66]
  ------------------
 6193|      0|	        xmlAttrNormalizeSpace(defaultValue, defaultValue);
 6194|       |
 6195|     88|	    GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6196|     88|            if (RAW != '>') {
  ------------------
  |  | 2221|     88|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6196:17): [True: 0, False: 88]
  ------------------
 6197|      0|		if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6197:7): [True: 0, False: 0]
  ------------------
 6198|      0|		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6199|      0|			"Space required after the attribute default value\n");
 6200|      0|		    if (defaultValue != NULL)
  ------------------
  |  Branch (6200:11): [True: 0, False: 0]
  ------------------
 6201|      0|			xmlFree(defaultValue);
 6202|      0|		    if (tree != NULL)
  ------------------
  |  Branch (6202:11): [True: 0, False: 0]
  ------------------
 6203|      0|			xmlFreeEnumeration(tree);
 6204|      0|		    break;
 6205|      0|		}
 6206|      0|	    }
 6207|     88|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6207:10): [True: 88, False: 0]
  |  Branch (6207:33): [True: 88, False: 0]
  ------------------
 6208|     88|		(ctxt->sax->attributeDecl != NULL))
  ------------------
  |  Branch (6208:3): [True: 88, False: 0]
  ------------------
 6209|     88|		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
 6210|     88|	                        type, def, defaultValue, tree);
 6211|      0|	    else if (tree != NULL)
  ------------------
  |  Branch (6211:15): [True: 0, False: 0]
  ------------------
 6212|      0|		xmlFreeEnumeration(tree);
 6213|       |
 6214|     88|	    if ((ctxt->sax2) && (defaultValue != NULL) &&
  ------------------
  |  Branch (6214:10): [True: 88, False: 0]
  |  Branch (6214:26): [True: 0, False: 88]
  ------------------
 6215|     88|	        (def != XML_ATTRIBUTE_IMPLIED) &&
  ------------------
  |  Branch (6215:10): [True: 0, False: 0]
  ------------------
 6216|     88|		(def != XML_ATTRIBUTE_REQUIRED)) {
  ------------------
  |  Branch (6216:3): [True: 0, False: 0]
  ------------------
 6217|      0|		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 6218|      0|	    }
 6219|     88|	    if (ctxt->sax2) {
  ------------------
  |  Branch (6219:10): [True: 88, False: 0]
  ------------------
 6220|     88|		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 6221|     88|	    }
 6222|     88|	    if (defaultValue != NULL)
  ------------------
  |  Branch (6222:10): [True: 0, False: 88]
  ------------------
 6223|      0|	        xmlFree(defaultValue);
 6224|     88|	    GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6225|     88|	}
 6226|     88|	if (RAW == '>') {
  ------------------
  |  | 2221|     88|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6226:6): [True: 88, False: 0]
  ------------------
 6227|     88|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6227:10): [True: 0, False: 88]
  ------------------
 6228|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6229|      0|                               "Attribute list declaration doesn't start and"
 6230|      0|                               " stop in the same entity\n");
 6231|      0|	    }
 6232|     88|	    NEXT;
  ------------------
  |  | 2275|     88|#define NEXT xmlNextChar(ctxt)
  ------------------
 6233|     88|	}
 6234|     88|    }
 6235|     88|}
xmlParseElementMixedContentDecl:
 6259|     44|xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
 6260|     44|    xmlElementContentPtr ret = NULL, cur = NULL, n;
 6261|     44|    const xmlChar *elem = NULL;
 6262|       |
 6263|     44|    GROW;
  ------------------
  |  | 2270|     44|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     44|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 44]
  |  |  ------------------
  |  | 2271|     44|	xmlParserGrow(ctxt);
  ------------------
 6264|     44|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|     44|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|     88|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|     88|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|     88|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|     44|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 44, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 44, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 44, False: 0]
  |  |  ------------------
  ------------------
 6265|     44|	SKIP(7);
  ------------------
  |  | 2245|     44|#define SKIP(val) do {							\
  |  | 2246|     44|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     44|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 44]
  |  |  ------------------
  |  | 2248|     44|        xmlParserGrow(ctxt);						\
  |  | 2249|     44|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6266|     44|	SKIP_BLANKS;
  ------------------
  |  | 2273|     44|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6267|     44|	if (RAW == ')') {
  ------------------
  |  | 2221|     44|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6267:6): [True: 44, False: 0]
  ------------------
 6268|     44|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6268:10): [True: 0, False: 44]
  ------------------
 6269|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6270|      0|                               "Element content declaration doesn't start and"
 6271|      0|                               " stop in the same entity\n");
 6272|      0|	    }
 6273|     44|	    NEXT;
  ------------------
  |  | 2275|     44|#define NEXT xmlNextChar(ctxt)
  ------------------
 6274|     44|	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6275|     44|	    if (ret == NULL)
  ------------------
  |  Branch (6275:10): [True: 0, False: 44]
  ------------------
 6276|      0|	        return(NULL);
 6277|     44|	    if (RAW == '*') {
  ------------------
  |  | 2221|     44|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6277:10): [True: 0, False: 44]
  ------------------
 6278|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6279|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6280|      0|	    }
 6281|     44|	    return(ret);
 6282|     44|	}
 6283|      0|	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '(') || (RAW == '|')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6283:6): [True: 0, False: 0]
  |  Branch (6283:22): [True: 0, False: 0]
  ------------------
 6284|      0|	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 6285|      0|	    if (ret == NULL) return(NULL);
  ------------------
  |  Branch (6285:10): [True: 0, False: 0]
  ------------------
 6286|      0|	}
 6287|      0|	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6287:9): [True: 0, False: 0]
  |  Branch (6287:25): [True: 0, False: 0]
  ------------------
 6288|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6289|      0|	    if (elem == NULL) {
  ------------------
  |  Branch (6289:10): [True: 0, False: 0]
  ------------------
 6290|      0|	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6291|      0|		if (ret == NULL) {
  ------------------
  |  Branch (6291:7): [True: 0, False: 0]
  ------------------
 6292|      0|		    xmlFreeDocElementContent(ctxt->myDoc, cur);
 6293|      0|                    return(NULL);
 6294|      0|                }
 6295|      0|		ret->c1 = cur;
 6296|      0|		if (cur != NULL)
  ------------------
  |  Branch (6296:7): [True: 0, False: 0]
  ------------------
 6297|      0|		    cur->parent = ret;
 6298|      0|		cur = ret;
 6299|      0|	    } else {
 6300|      0|	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6301|      0|		if (n == NULL) {
  ------------------
  |  Branch (6301:7): [True: 0, False: 0]
  ------------------
 6302|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6303|      0|                    return(NULL);
 6304|      0|                }
 6305|      0|		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6306|      0|		if (n->c1 != NULL)
  ------------------
  |  Branch (6306:7): [True: 0, False: 0]
  ------------------
 6307|      0|		    n->c1->parent = n;
 6308|      0|	        cur->c2 = n;
 6309|      0|		if (n != NULL)
  ------------------
  |  Branch (6309:7): [True: 0, False: 0]
  ------------------
 6310|      0|		    n->parent = cur;
 6311|      0|		cur = n;
 6312|      0|	    }
 6313|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6314|      0|	    elem = xmlParseName(ctxt);
 6315|      0|	    if (elem == NULL) {
  ------------------
  |  Branch (6315:10): [True: 0, False: 0]
  ------------------
 6316|      0|		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6317|      0|			"xmlParseElementMixedContentDecl : Name expected\n");
 6318|      0|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6319|      0|		return(NULL);
 6320|      0|	    }
 6321|      0|	    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6322|      0|	    GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6323|      0|	}
 6324|      0|	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == ')') && (NXT(1) == '*')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6324:6): [True: 0, False: 0]
  |  Branch (6324:22): [True: 0, False: 0]
  ------------------
 6325|      0|	    if (elem != NULL) {
  ------------------
  |  Branch (6325:10): [True: 0, False: 0]
  ------------------
 6326|      0|		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,
 6327|      0|		                               XML_ELEMENT_CONTENT_ELEMENT);
 6328|      0|		if (cur->c2 != NULL)
  ------------------
  |  Branch (6328:7): [True: 0, False: 0]
  ------------------
 6329|      0|		    cur->c2->parent = cur;
 6330|      0|            }
 6331|      0|            if (ret != NULL)
  ------------------
  |  Branch (6331:17): [True: 0, False: 0]
  ------------------
 6332|      0|                ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6333|      0|	    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6333:10): [True: 0, False: 0]
  ------------------
 6334|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6335|      0|                               "Element content declaration doesn't start and"
 6336|      0|                               " stop in the same entity\n");
 6337|      0|	    }
 6338|      0|	    SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6339|      0|	} else {
 6340|      0|	    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6341|      0|	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 6342|      0|	    return(NULL);
 6343|      0|	}
 6344|       |
 6345|      0|    } else {
 6346|      0|	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
 6347|      0|    }
 6348|      0|    return(ret);
 6349|     44|}
xmlParseElementContentDecl:
 6711|    111|                           xmlElementContentPtr *result) {
 6712|       |
 6713|    111|    xmlElementContentPtr tree = NULL;
 6714|    111|    int inputid = ctxt->input->id;
 6715|    111|    int res;
 6716|       |
 6717|    111|    *result = NULL;
 6718|       |
 6719|    111|    if (RAW != '(') {
  ------------------
  |  | 2221|    111|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6719:9): [True: 0, False: 111]
  ------------------
 6720|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6721|      0|		"xmlParseElementContentDecl : %s '(' expected\n", name);
 6722|      0|	return(-1);
 6723|      0|    }
 6724|    111|    NEXT;
  ------------------
  |  | 2275|    111|#define NEXT xmlNextChar(ctxt)
  ------------------
 6725|    111|    GROW;
  ------------------
  |  | 2270|    111|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    111|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 111]
  |  |  ------------------
  |  | 2271|    111|	xmlParserGrow(ctxt);
  ------------------
 6726|    111|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (6726:9): [True: 0, False: 111]
  ------------------
 6727|      0|        return(-1);
 6728|    111|    SKIP_BLANKS;
  ------------------
  |  | 2273|    111|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6729|    111|    if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
  ------------------
  |  | 2235|    111|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    222|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    222|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    222|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 44, False: 67]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    111|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 44, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 44, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 44, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 44, False: 0]
  |  |  ------------------
  ------------------
 6730|     44|        tree = xmlParseElementMixedContentDecl(ctxt, inputid);
 6731|     44|	res = XML_ELEMENT_TYPE_MIXED;
 6732|     67|    } else {
 6733|     67|        tree = xmlParseElementChildrenContentDeclPriv(ctxt, inputid, 1);
 6734|     67|	res = XML_ELEMENT_TYPE_ELEMENT;
 6735|     67|    }
 6736|    111|    SKIP_BLANKS;
  ------------------
  |  | 2273|    111|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6737|    111|    *result = tree;
 6738|    111|    return(res);
 6739|    111|}
xmlParseElementDecl:
 6757|    133|xmlParseElementDecl(xmlParserCtxtPtr ctxt) {
 6758|    133|    const xmlChar *name;
 6759|    133|    int ret = -1;
 6760|    133|    xmlElementContentPtr content  = NULL;
 6761|       |
 6762|    133|    if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2222|    133|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!'))
  ------------------
  |  | 2223|    133|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6762:9): [True: 0, False: 133]
  |  Branch (6762:25): [True: 0, False: 133]
  ------------------
 6763|      0|        return(ret);
 6764|    133|    SKIP(2);
  ------------------
  |  | 2245|    133|#define SKIP(val) do {							\
  |  | 2246|    133|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    133|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 133]
  |  |  ------------------
  |  | 2248|    133|        xmlParserGrow(ctxt);						\
  |  | 2249|    133|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6765|       |
 6766|       |    /* GROW; done in the caller */
 6767|    133|    if (CMP7(CUR_PTR, 'E', 'L', 'E', 'M', 'E', 'N', 'T')) {
  ------------------
  |  | 2235|    133|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    266|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    266|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    266|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 133, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 133, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    133|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 133, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 133, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 133, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 133, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 133, False: 0]
  |  |  ------------------
  ------------------
 6768|    133|	int inputid = ctxt->input->id;
 6769|       |
 6770|    133|	SKIP(7);
  ------------------
  |  | 2245|    133|#define SKIP(val) do {							\
  |  | 2246|    133|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    133|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 133]
  |  |  ------------------
  |  | 2248|    133|        xmlParserGrow(ctxt);						\
  |  | 2249|    133|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6771|    133|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    133|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6771:6): [True: 0, False: 133]
  ------------------
 6772|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6773|      0|		           "Space required after 'ELEMENT'\n");
 6774|      0|	    return(-1);
 6775|      0|	}
 6776|    133|        name = xmlParseName(ctxt);
 6777|    133|	if (name == NULL) {
  ------------------
  |  Branch (6777:6): [True: 0, False: 133]
  ------------------
 6778|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 6779|      0|			   "xmlParseElementDecl: no name for Element\n");
 6780|      0|	    return(-1);
 6781|      0|	}
 6782|    133|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    133|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (6782:6): [True: 0, False: 133]
  ------------------
 6783|      0|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 6784|      0|			   "Space required after the element name\n");
 6785|      0|	}
 6786|    133|	if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {
  ------------------
  |  | 2231|    133|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    266|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 22, False: 111]
  |  |  |  |  |  Branch (2228:41): [True: 22, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2229|    133|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 22, False: 0]
  |  |  |  |  |  Branch (2229:41): [True: 22, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 22, False: 0]
  |  |  ------------------
  ------------------
 6787|     22|	    SKIP(5);
  ------------------
  |  | 2245|     22|#define SKIP(val) do {							\
  |  | 2246|     22|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     22|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 22]
  |  |  ------------------
  |  | 2248|     22|        xmlParserGrow(ctxt);						\
  |  | 2249|     22|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6788|       |	    /*
 6789|       |	     * Element must always be empty.
 6790|       |	     */
 6791|     22|	    ret = XML_ELEMENT_TYPE_EMPTY;
 6792|    111|	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2221|    111|#define RAW (*ctxt->input->cur)
  ------------------
              	} else if ((RAW == 'A') && (NXT(1) == 'N') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6792:13): [True: 0, False: 111]
  |  Branch (6792:29): [True: 0, False: 0]
  ------------------
 6793|    111|	           (NXT(2) == 'Y')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (6793:13): [True: 0, False: 0]
  ------------------
 6794|      0|	    SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 6795|       |	    /*
 6796|       |	     * Element is a generic container.
 6797|       |	     */
 6798|      0|	    ret = XML_ELEMENT_TYPE_ANY;
 6799|    111|	} else if (RAW == '(') {
  ------------------
  |  | 2221|    111|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6799:13): [True: 111, False: 0]
  ------------------
 6800|    111|	    ret = xmlParseElementContentDecl(ctxt, name, &content);
 6801|    111|	} else {
 6802|       |	    /*
 6803|       |	     * [ WFC: PEs in Internal Subset ] error handling.
 6804|       |	     */
 6805|      0|	    if ((RAW == '%') && (ctxt->external == 0) &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6805:10): [True: 0, False: 0]
  |  Branch (6805:26): [True: 0, False: 0]
  ------------------
 6806|      0|	        (ctxt->inputNr == 1)) {
  ------------------
  |  Branch (6806:10): [True: 0, False: 0]
  ------------------
 6807|      0|		xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,
 6808|      0|	  "PEReference: forbidden within markup decl in internal subset\n");
 6809|      0|	    } else {
 6810|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,
 6811|      0|		      "xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n");
 6812|      0|            }
 6813|      0|	    return(-1);
 6814|      0|	}
 6815|       |
 6816|    133|	SKIP_BLANKS;
  ------------------
  |  | 2273|    133|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6817|       |
 6818|    133|	if (RAW != '>') {
  ------------------
  |  | 2221|    133|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6818:6): [True: 1, False: 132]
  ------------------
 6819|      1|	    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
 6820|      1|	    if (content != NULL) {
  ------------------
  |  Branch (6820:10): [True: 0, False: 1]
  ------------------
 6821|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6822|      0|	    }
 6823|    132|	} else {
 6824|    132|	    if (inputid != ctxt->input->id) {
  ------------------
  |  Branch (6824:10): [True: 0, False: 132]
  ------------------
 6825|      0|		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6826|      0|                               "Element declaration doesn't start and stop in"
 6827|      0|                               " the same entity\n");
 6828|      0|	    }
 6829|       |
 6830|    132|	    NEXT;
  ------------------
  |  | 2275|    132|#define NEXT xmlNextChar(ctxt)
  ------------------
 6831|    132|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
  ------------------
  |  Branch (6831:10): [True: 132, False: 0]
  |  Branch (6831:33): [True: 132, False: 0]
  ------------------
 6832|    132|		(ctxt->sax->elementDecl != NULL)) {
  ------------------
  |  Branch (6832:3): [True: 132, False: 0]
  ------------------
 6833|    132|		if (content != NULL)
  ------------------
  |  Branch (6833:7): [True: 110, False: 22]
  ------------------
 6834|    110|		    content->parent = NULL;
 6835|    132|	        ctxt->sax->elementDecl(ctxt->userData, name, ret,
 6836|    132|		                       content);
 6837|    132|		if ((content != NULL) && (content->parent == NULL)) {
  ------------------
  |  Branch (6837:7): [True: 110, False: 22]
  |  Branch (6837:28): [True: 0, False: 110]
  ------------------
 6838|       |		    /*
 6839|       |		     * this is a trick: if xmlAddElementDecl is called,
 6840|       |		     * instead of copying the full tree it is plugged directly
 6841|       |		     * if called from the parser. Avoid duplicating the
 6842|       |		     * interfaces or change the API/ABI
 6843|       |		     */
 6844|      0|		    xmlFreeDocElementContent(ctxt->myDoc, content);
 6845|      0|		}
 6846|    132|	    } else if (content != NULL) {
  ------------------
  |  Branch (6846:17): [True: 0, False: 0]
  ------------------
 6847|      0|		xmlFreeDocElementContent(ctxt->myDoc, content);
 6848|      0|	    }
 6849|    132|	}
 6850|    133|    }
 6851|    133|    return(ret);
 6852|    133|}
xmlParseMarkupDecl:
 7015|    221|xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {
 7016|    221|    GROW;
  ------------------
  |  | 2270|    221|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    221|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 221]
  |  |  ------------------
  |  | 2271|    221|	xmlParserGrow(ctxt);
  ------------------
 7017|    221|    if (CUR == '<') {
  ------------------
  |  | 2222|    221|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (7017:9): [True: 221, False: 0]
  ------------------
 7018|    221|        if (NXT(1) == '!') {
  ------------------
  |  | 2223|    221|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7018:13): [True: 221, False: 0]
  ------------------
 7019|    221|	    switch (NXT(2)) {
  ------------------
  |  | 2223|    221|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
 7020|    133|	        case 'E':
  ------------------
  |  Branch (7020:10): [True: 133, False: 88]
  ------------------
 7021|    133|		    if (NXT(3) == 'L')
  ------------------
  |  | 2223|    133|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7021:11): [True: 133, False: 0]
  ------------------
 7022|    133|			xmlParseElementDecl(ctxt);
 7023|      0|		    else if (NXT(3) == 'N')
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7023:16): [True: 0, False: 0]
  ------------------
 7024|      0|			xmlParseEntityDecl(ctxt);
 7025|      0|                    else
 7026|      0|                        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7027|    133|		    break;
 7028|     88|	        case 'A':
  ------------------
  |  Branch (7028:10): [True: 88, False: 133]
  ------------------
 7029|     88|		    xmlParseAttributeListDecl(ctxt);
 7030|     88|		    break;
 7031|      0|	        case 'N':
  ------------------
  |  Branch (7031:10): [True: 0, False: 221]
  ------------------
 7032|      0|		    xmlParseNotationDecl(ctxt);
 7033|      0|		    break;
 7034|      0|	        case '-':
  ------------------
  |  Branch (7034:10): [True: 0, False: 221]
  ------------------
 7035|      0|		    xmlParseComment(ctxt);
 7036|      0|		    break;
 7037|      0|		default:
  ------------------
  |  Branch (7037:3): [True: 0, False: 221]
  ------------------
 7038|       |		    /* there is an error but it will be detected later */
 7039|      0|                    SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 7040|      0|		    break;
 7041|    221|	    }
 7042|    221|	} else if (NXT(1) == '?') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7042:13): [True: 0, False: 0]
  ------------------
 7043|      0|	    xmlParsePI(ctxt);
 7044|      0|	}
 7045|    221|    }
 7046|       |
 7047|       |    /*
 7048|       |     * detect requirement to exit there and act accordingly
 7049|       |     * and avoid having instate overridden later on
 7050|       |     */
 7051|    221|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7051:9): [True: 0, False: 221]
  ------------------
 7052|      0|        return;
 7053|       |
 7054|    221|    ctxt->instate = XML_PARSER_DTD;
 7055|    221|}
xmlParseReference:
 7222|      1|xmlParseReference(xmlParserCtxtPtr ctxt) {
 7223|      1|    xmlEntityPtr ent;
 7224|      1|    xmlChar *val;
 7225|      1|    int was_checked;
 7226|      1|    xmlNodePtr list = NULL;
 7227|      1|    xmlParserErrors ret = XML_ERR_OK;
 7228|       |
 7229|       |
 7230|      1|    if (RAW != '&')
  ------------------
  |  | 2221|      1|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7230:9): [True: 0, False: 1]
  ------------------
 7231|      0|        return;
 7232|       |
 7233|       |    /*
 7234|       |     * Simple case of a CharRef
 7235|       |     */
 7236|      1|    if (NXT(1) == '#') {
  ------------------
  |  | 2223|      1|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (7236:9): [True: 0, False: 1]
  ------------------
 7237|      0|	int i = 0;
 7238|      0|	xmlChar out[16];
 7239|      0|	int value = xmlParseCharRef(ctxt);
 7240|       |
 7241|      0|	if (value == 0)
  ------------------
  |  Branch (7241:6): [True: 0, False: 0]
  ------------------
 7242|      0|	    return;
 7243|       |
 7244|       |        /*
 7245|       |         * Just encode the value in UTF-8
 7246|       |         */
 7247|      0|        COPY_BUF(out, i, value);
  ------------------
  |  | 2295|      0|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2296|      0|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 7248|      0|        out[i] = 0;
 7249|      0|        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7249:13): [True: 0, False: 0]
  |  Branch (7249:36): [True: 0, False: 0]
  ------------------
 7250|      0|            (!ctxt->disableSAX))
  ------------------
  |  Branch (7250:13): [True: 0, False: 0]
  ------------------
 7251|      0|            ctxt->sax->characters(ctxt->userData, out, i);
 7252|      0|	return;
 7253|      0|    }
 7254|       |
 7255|       |    /*
 7256|       |     * We are seeing an entity reference
 7257|       |     */
 7258|      1|    ent = xmlParseEntityRef(ctxt);
 7259|      1|    if (ent == NULL) return;
  ------------------
  |  Branch (7259:9): [True: 1, False: 0]
  ------------------
 7260|      0|    if (!ctxt->wellFormed)
  ------------------
  |  Branch (7260:9): [True: 0, False: 0]
  ------------------
 7261|      0|	return;
 7262|      0|    was_checked = ent->flags & XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 7263|       |
 7264|       |    /* special case of predefined entities */
 7265|      0|    if ((ent->name == NULL) ||
  ------------------
  |  Branch (7265:9): [True: 0, False: 0]
  ------------------
 7266|      0|        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7266:9): [True: 0, False: 0]
  ------------------
 7267|      0|	val = ent->content;
 7268|      0|	if (val == NULL) return;
  ------------------
  |  Branch (7268:6): [True: 0, False: 0]
  ------------------
 7269|       |	/*
 7270|       |	 * inline the entity.
 7271|       |	 */
 7272|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&
  ------------------
  |  Branch (7272:6): [True: 0, False: 0]
  |  Branch (7272:29): [True: 0, False: 0]
  ------------------
 7273|      0|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (7273:6): [True: 0, False: 0]
  ------------------
 7274|      0|	    ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));
 7275|      0|	return;
 7276|      0|    }
 7277|       |
 7278|       |    /*
 7279|       |     * The first reference to the entity trigger a parsing phase
 7280|       |     * where the ent->children is filled with the result from
 7281|       |     * the parsing.
 7282|       |     * Note: external parsed entities will not be loaded, it is not
 7283|       |     * required for a non-validating parser, unless the parsing option
 7284|       |     * of validating, or substituting entities were given. Doing so is
 7285|       |     * far more secure as the parser will only process data coming from
 7286|       |     * the document entity by default.
 7287|       |     *
 7288|       |     * FIXME: This doesn't work correctly since entities can be
 7289|       |     * expanded with different namespace declarations in scope.
 7290|       |     * For example:
 7291|       |     *
 7292|       |     * <!DOCTYPE doc [
 7293|       |     *   <!ENTITY ent "<ns:elem/>">
 7294|       |     * ]>
 7295|       |     * <doc>
 7296|       |     *   <decl1 xmlns:ns="urn:ns1">
 7297|       |     *     &ent;
 7298|       |     *   </decl1>
 7299|       |     *   <decl2 xmlns:ns="urn:ns2">
 7300|       |     *     &ent;
 7301|       |     *   </decl2>
 7302|       |     * </doc>
 7303|       |     *
 7304|       |     * Proposed fix:
 7305|       |     *
 7306|       |     * - Remove the ent->owner optimization which tries to avoid the
 7307|       |     *   initial copy of the entity. Always make entities own the
 7308|       |     *   subtree.
 7309|       |     * - Ignore current namespace declarations when parsing the
 7310|       |     *   entity. If a prefix can't be resolved, don't report an error
 7311|       |     *   but mark it as unresolved.
 7312|       |     * - Try to resolve these prefixes when expanding the entity.
 7313|       |     *   This will require a specialized version of xmlStaticCopyNode
 7314|       |     *   which can also make use of the namespace hash table to avoid
 7315|       |     *   quadratic behavior.
 7316|       |     *
 7317|       |     * Alternatively, we could simply reparse the entity on each
 7318|       |     * expansion like we already do with custom SAX callbacks.
 7319|       |     * External entity content should be cached in this case.
 7320|       |     */
 7321|      0|    if (((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (7321:9): [True: 0, False: 0]
  ------------------
 7322|      0|        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
  ------------------
  |  Branch (7322:10): [True: 0, False: 0]
  ------------------
 7323|      0|         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {
  ------------------
  |  Branch (7323:10): [True: 0, False: 0]
  ------------------
 7324|      0|	unsigned long oldsizeentcopy = ctxt->sizeentcopy;
 7325|       |
 7326|       |	/*
 7327|       |	 * This is a bit hackish but this seems the best
 7328|       |	 * way to make sure both SAX and DOM entity support
 7329|       |	 * behaves okay.
 7330|       |	 */
 7331|      0|	void *user_data;
 7332|      0|	if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7332:6): [True: 0, False: 0]
  ------------------
 7333|      0|	    user_data = NULL;
 7334|      0|	else
 7335|      0|	    user_data = ctxt->userData;
 7336|       |
 7337|       |        /* Avoid overflow as much as possible */
 7338|      0|        ctxt->sizeentcopy = 0;
 7339|       |
 7340|      0|        if (ent->flags & XML_ENT_EXPANDING) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (7340:13): [True: 0, False: 0]
  ------------------
 7341|      0|            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7342|      0|            xmlHaltParser(ctxt);
 7343|      0|            return;
 7344|      0|        }
 7345|       |
 7346|      0|        ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7347|       |
 7348|       |	/*
 7349|       |	 * Check that this entity is well formed
 7350|       |	 * 4.3.2: An internal general parsed entity is well-formed
 7351|       |	 * if its replacement text matches the production labeled
 7352|       |	 * content.
 7353|       |	 */
 7354|      0|	if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7354:6): [True: 0, False: 0]
  ------------------
 7355|      0|	    ctxt->depth++;
 7356|      0|	    ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,
 7357|      0|	                                              user_data, &list);
 7358|      0|	    ctxt->depth--;
 7359|       |
 7360|      0|	} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
  ------------------
  |  Branch (7360:13): [True: 0, False: 0]
  ------------------
 7361|      0|	    ctxt->depth++;
 7362|      0|	    ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,
 7363|      0|	                                   user_data, ctxt->depth, ent->URI,
 7364|      0|					   ent->ExternalID, &list);
 7365|      0|	    ctxt->depth--;
 7366|      0|	} else {
 7367|      0|	    ret = XML_ERR_ENTITY_PE_INTERNAL;
 7368|      0|	    xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7369|      0|			 "invalid entity type found\n", NULL);
 7370|      0|	}
 7371|       |
 7372|      0|        ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 7373|      0|        ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
                      ent->flags |= XML_ENT_PARSED | XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 7374|      0|        ent->expandedSize = ctxt->sizeentcopy;
 7375|      0|	if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7375:6): [True: 0, False: 0]
  ------------------
 7376|      0|            xmlHaltParser(ctxt);
 7377|      0|	    xmlFreeNodeList(list);
 7378|      0|	    return;
 7379|      0|	}
 7380|      0|	if (xmlParserEntityCheck(ctxt, oldsizeentcopy)) {
  ------------------
  |  Branch (7380:6): [True: 0, False: 0]
  ------------------
 7381|      0|	    xmlFreeNodeList(list);
 7382|      0|	    return;
 7383|      0|	}
 7384|       |
 7385|      0|	if ((ret == XML_ERR_OK) && (list != NULL)) {
  ------------------
  |  Branch (7385:6): [True: 0, False: 0]
  |  Branch (7385:29): [True: 0, False: 0]
  ------------------
 7386|      0|            ent->children = list;
 7387|       |            /*
 7388|       |             * Prune it directly in the generated document
 7389|       |             * except for single text nodes.
 7390|       |             */
 7391|      0|            if ((ctxt->replaceEntities == 0) ||
  ------------------
  |  Branch (7391:17): [True: 0, False: 0]
  ------------------
 7392|      0|                (ctxt->parseMode == XML_PARSE_READER) ||
  ------------------
  |  Branch (7392:17): [True: 0, False: 0]
  ------------------
 7393|      0|                ((list->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (7393:18): [True: 0, False: 0]
  ------------------
 7394|      0|                 (list->next == NULL))) {
  ------------------
  |  Branch (7394:18): [True: 0, False: 0]
  ------------------
 7395|      0|                ent->owner = 1;
 7396|      0|                while (list != NULL) {
  ------------------
  |  Branch (7396:24): [True: 0, False: 0]
  ------------------
 7397|      0|                    list->parent = (xmlNodePtr) ent;
 7398|      0|                    if (list->doc != ent->doc)
  ------------------
  |  Branch (7398:25): [True: 0, False: 0]
  ------------------
 7399|      0|                        xmlSetTreeDoc(list, ent->doc);
 7400|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7400:25): [True: 0, False: 0]
  ------------------
 7401|      0|                        ent->last = list;
 7402|      0|                    list = list->next;
 7403|      0|                }
 7404|      0|                list = NULL;
 7405|      0|            } else {
 7406|      0|                ent->owner = 0;
 7407|      0|                while (list != NULL) {
  ------------------
  |  Branch (7407:24): [True: 0, False: 0]
  ------------------
 7408|      0|                    list->parent = (xmlNodePtr) ctxt->node;
 7409|      0|                    list->doc = ctxt->myDoc;
 7410|      0|                    if (list->next == NULL)
  ------------------
  |  Branch (7410:25): [True: 0, False: 0]
  ------------------
 7411|      0|                        ent->last = list;
 7412|      0|                    list = list->next;
 7413|      0|                }
 7414|      0|                list = ent->children;
 7415|       |#ifdef LIBXML_LEGACY_ENABLED
 7416|       |                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7417|       |                    xmlAddEntityReference(ent, list, NULL);
 7418|       |#endif /* LIBXML_LEGACY_ENABLED */
 7419|      0|            }
 7420|      0|	} else if ((ret != XML_ERR_OK) &&
  ------------------
  |  Branch (7420:13): [True: 0, False: 0]
  ------------------
 7421|      0|		   (ret != XML_WAR_UNDECLARED_ENTITY)) {
  ------------------
  |  Branch (7421:6): [True: 0, False: 0]
  ------------------
 7422|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7423|      0|		     "Entity '%s' failed to parse\n", ent->name);
 7424|      0|            if (ent->content != NULL)
  ------------------
  |  Branch (7424:17): [True: 0, False: 0]
  ------------------
 7425|      0|                ent->content[0] = 0;
 7426|      0|	} else if (list != NULL) {
  ------------------
  |  Branch (7426:13): [True: 0, False: 0]
  ------------------
 7427|      0|	    xmlFreeNodeList(list);
 7428|      0|	    list = NULL;
 7429|      0|	}
 7430|       |
 7431|       |        /* Prevent entity from being parsed and expanded twice (Bug 760367). */
 7432|      0|        was_checked = 0;
 7433|      0|    }
 7434|       |
 7435|       |    /*
 7436|       |     * Now that the entity content has been gathered
 7437|       |     * provide it to the application, this can take different forms based
 7438|       |     * on the parsing modes.
 7439|       |     */
 7440|      0|    if (ent->children == NULL) {
  ------------------
  |  Branch (7440:9): [True: 0, False: 0]
  ------------------
 7441|       |	/*
 7442|       |	 * Probably running in SAX mode and the callbacks don't
 7443|       |	 * build the entity content. So unless we already went
 7444|       |	 * though parsing for first checking go though the entity
 7445|       |	 * content to generate callbacks associated to the entity
 7446|       |	 */
 7447|      0|	if (was_checked != 0) {
  ------------------
  |  Branch (7447:6): [True: 0, False: 0]
  ------------------
 7448|      0|	    void *user_data;
 7449|       |	    /*
 7450|       |	     * This is a bit hackish but this seems the best
 7451|       |	     * way to make sure both SAX and DOM entity support
 7452|       |	     * behaves okay.
 7453|       |	     */
 7454|      0|	    if (ctxt->userData == ctxt)
  ------------------
  |  Branch (7454:10): [True: 0, False: 0]
  ------------------
 7455|      0|		user_data = NULL;
 7456|      0|	    else
 7457|      0|		user_data = ctxt->userData;
 7458|       |
 7459|      0|	    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {
  ------------------
  |  Branch (7459:10): [True: 0, False: 0]
  ------------------
 7460|      0|		ctxt->depth++;
 7461|      0|		ret = xmlParseBalancedChunkMemoryInternal(ctxt,
 7462|      0|				   ent->content, user_data, NULL);
 7463|      0|		ctxt->depth--;
 7464|      0|	    } else if (ent->etype ==
  ------------------
  |  Branch (7464:17): [True: 0, False: 0]
  ------------------
 7465|      0|		       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
 7466|      0|	        unsigned long oldsizeentities = ctxt->sizeentities;
 7467|       |
 7468|      0|		ctxt->depth++;
 7469|      0|		ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,
 7470|      0|			   ctxt->sax, user_data, ctxt->depth,
 7471|      0|			   ent->URI, ent->ExternalID, NULL);
 7472|      0|		ctxt->depth--;
 7473|       |
 7474|       |                /* Undo the change to sizeentities */
 7475|      0|                ctxt->sizeentities = oldsizeentities;
 7476|      0|	    } else {
 7477|      0|		ret = XML_ERR_ENTITY_PE_INTERNAL;
 7478|      0|		xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,
 7479|      0|			     "invalid entity type found\n", NULL);
 7480|      0|	    }
 7481|      0|	    if (ret == XML_ERR_ENTITY_LOOP) {
  ------------------
  |  Branch (7481:10): [True: 0, False: 0]
  ------------------
 7482|      0|		xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 7483|      0|		return;
 7484|      0|	    }
 7485|      0|            if (xmlParserEntityCheck(ctxt, 0))
  ------------------
  |  Branch (7485:17): [True: 0, False: 0]
  ------------------
 7486|      0|                return;
 7487|      0|	}
 7488|      0|	if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7488:6): [True: 0, False: 0]
  |  Branch (7488:29): [True: 0, False: 0]
  ------------------
 7489|      0|	    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7489:6): [True: 0, False: 0]
  |  Branch (7489:38): [True: 0, False: 0]
  ------------------
 7490|       |	    /*
 7491|       |	     * Entity reference callback comes second, it's somewhat
 7492|       |	     * superfluous but a compatibility to historical behaviour
 7493|       |	     */
 7494|      0|	    ctxt->sax->reference(ctxt->userData, ent->name);
 7495|      0|	}
 7496|      0|	return;
 7497|      0|    }
 7498|       |
 7499|       |    /*
 7500|       |     * We also check for amplification if entities aren't substituted.
 7501|       |     * They might be expanded later.
 7502|       |     */
 7503|      0|    if ((was_checked != 0) &&
  ------------------
  |  Branch (7503:9): [True: 0, False: 0]
  ------------------
 7504|      0|        (xmlParserEntityCheck(ctxt, ent->expandedSize)))
  ------------------
  |  Branch (7504:9): [True: 0, False: 0]
  ------------------
 7505|      0|        return;
 7506|       |
 7507|       |    /*
 7508|       |     * If we didn't get any children for the entity being built
 7509|       |     */
 7510|      0|    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&
  ------------------
  |  Branch (7510:9): [True: 0, False: 0]
  |  Branch (7510:32): [True: 0, False: 0]
  ------------------
 7511|      0|	(ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (7511:2): [True: 0, False: 0]
  |  Branch (7511:34): [True: 0, False: 0]
  ------------------
 7512|       |	/*
 7513|       |	 * Create a node.
 7514|       |	 */
 7515|      0|	ctxt->sax->reference(ctxt->userData, ent->name);
 7516|      0|	return;
 7517|      0|    }
 7518|       |
 7519|      0|    if (ctxt->replaceEntities)  {
  ------------------
  |  Branch (7519:9): [True: 0, False: 0]
  ------------------
 7520|       |	/*
 7521|       |	 * There is a problem on the handling of _private for entities
 7522|       |	 * (bug 155816): Should we copy the content of the field from
 7523|       |	 * the entity (possibly overwriting some value set by the user
 7524|       |	 * when a copy is created), should we leave it alone, or should
 7525|       |	 * we try to take care of different situations?  The problem
 7526|       |	 * is exacerbated by the usage of this field by the xmlReader.
 7527|       |	 * To fix this bug, we look at _private on the created node
 7528|       |	 * and, if it's NULL, we copy in whatever was in the entity.
 7529|       |	 * If it's not NULL we leave it alone.  This is somewhat of a
 7530|       |	 * hack - maybe we should have further tests to determine
 7531|       |	 * what to do.
 7532|       |	 */
 7533|      0|	if (ctxt->node != NULL) {
  ------------------
  |  Branch (7533:6): [True: 0, False: 0]
  ------------------
 7534|       |	    /*
 7535|       |	     * Seems we are generating the DOM content, do
 7536|       |	     * a simple tree copy for all references except the first
 7537|       |	     * In the first occurrence list contains the replacement.
 7538|       |	     */
 7539|      0|	    if (((list == NULL) && (ent->owner == 0)) ||
  ------------------
  |  Branch (7539:11): [True: 0, False: 0]
  |  Branch (7539:29): [True: 0, False: 0]
  ------------------
 7540|      0|		(ctxt->parseMode == XML_PARSE_READER)) {
  ------------------
  |  Branch (7540:3): [True: 0, False: 0]
  ------------------
 7541|      0|		xmlNodePtr nw = NULL, cur, firstChild = NULL;
 7542|       |
 7543|       |		/*
 7544|       |		 * when operating on a reader, the entities definitions
 7545|       |		 * are always owning the entities subtree.
 7546|       |		if (ctxt->parseMode == XML_PARSE_READER)
 7547|       |		    ent->owner = 1;
 7548|       |		 */
 7549|       |
 7550|      0|		cur = ent->children;
 7551|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7551:10): [True: 0, False: 0]
  ------------------
 7552|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7553|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7553:11): [True: 0, False: 0]
  ------------------
 7554|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7554:8): [True: 0, False: 0]
  ------------------
 7555|      0|			    nw->_private = cur->_private;
 7556|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7556:8): [True: 0, False: 0]
  ------------------
 7557|      0|			    firstChild = nw;
 7558|      0|			}
 7559|      0|			nw = xmlAddChild(ctxt->node, nw);
 7560|      0|		    }
 7561|      0|		    if (cur == ent->last) {
  ------------------
  |  Branch (7561:11): [True: 0, False: 0]
  ------------------
 7562|       |			/*
 7563|       |			 * needed to detect some strange empty
 7564|       |			 * node cases in the reader tests
 7565|       |			 */
 7566|      0|			if ((ctxt->parseMode == XML_PARSE_READER) &&
  ------------------
  |  Branch (7566:8): [True: 0, False: 0]
  ------------------
 7567|      0|			    (nw != NULL) &&
  ------------------
  |  Branch (7567:8): [True: 0, False: 0]
  ------------------
 7568|      0|			    (nw->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7568:8): [True: 0, False: 0]
  ------------------
 7569|      0|			    (nw->children == NULL))
  ------------------
  |  Branch (7569:8): [True: 0, False: 0]
  ------------------
 7570|      0|			    nw->extra = 1;
 7571|       |
 7572|      0|			break;
 7573|      0|		    }
 7574|      0|		    cur = cur->next;
 7575|      0|		}
 7576|       |#ifdef LIBXML_LEGACY_ENABLED
 7577|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7578|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7579|       |#endif /* LIBXML_LEGACY_ENABLED */
 7580|      0|	    } else if ((list == NULL) || (ctxt->inputNr > 0)) {
  ------------------
  |  Branch (7580:17): [True: 0, False: 0]
  |  Branch (7580:35): [True: 0, False: 0]
  ------------------
 7581|      0|		xmlNodePtr nw = NULL, cur, next, last,
 7582|      0|			   firstChild = NULL;
 7583|       |
 7584|       |		/*
 7585|       |		 * Copy the entity child list and make it the new
 7586|       |		 * entity child list. The goal is to make sure any
 7587|       |		 * ID or REF referenced will be the one from the
 7588|       |		 * document content and not the entity copy.
 7589|       |		 */
 7590|      0|		cur = ent->children;
 7591|      0|		ent->children = NULL;
 7592|      0|		last = ent->last;
 7593|      0|		ent->last = NULL;
 7594|      0|		while (cur != NULL) {
  ------------------
  |  Branch (7594:10): [True: 0, False: 0]
  ------------------
 7595|      0|		    next = cur->next;
 7596|      0|		    cur->next = NULL;
 7597|      0|		    cur->parent = NULL;
 7598|      0|		    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);
 7599|      0|		    if (nw != NULL) {
  ------------------
  |  Branch (7599:11): [True: 0, False: 0]
  ------------------
 7600|      0|			if (nw->_private == NULL)
  ------------------
  |  Branch (7600:8): [True: 0, False: 0]
  ------------------
 7601|      0|			    nw->_private = cur->_private;
 7602|      0|			if (firstChild == NULL){
  ------------------
  |  Branch (7602:8): [True: 0, False: 0]
  ------------------
 7603|      0|			    firstChild = cur;
 7604|      0|			}
 7605|      0|			xmlAddChild((xmlNodePtr) ent, nw);
 7606|      0|		    }
 7607|      0|		    xmlAddChild(ctxt->node, cur);
 7608|      0|		    if (cur == last)
  ------------------
  |  Branch (7608:11): [True: 0, False: 0]
  ------------------
 7609|      0|			break;
 7610|      0|		    cur = next;
 7611|      0|		}
 7612|      0|		if (ent->owner == 0)
  ------------------
  |  Branch (7612:7): [True: 0, False: 0]
  ------------------
 7613|      0|		    ent->owner = 1;
 7614|       |#ifdef LIBXML_LEGACY_ENABLED
 7615|       |		if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)
 7616|       |		  xmlAddEntityReference(ent, firstChild, nw);
 7617|       |#endif /* LIBXML_LEGACY_ENABLED */
 7618|      0|	    } else {
 7619|      0|		const xmlChar *nbktext;
 7620|       |
 7621|       |		/*
 7622|       |		 * the name change is to avoid coalescing of the
 7623|       |		 * node with a possible previous text one which
 7624|       |		 * would make ent->children a dangling pointer
 7625|       |		 */
 7626|      0|		nbktext = xmlDictLookup(ctxt->dict, BAD_CAST "nbktext",
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7627|      0|					-1);
 7628|      0|		if (ent->children->type == XML_TEXT_NODE)
  ------------------
  |  Branch (7628:7): [True: 0, False: 0]
  ------------------
 7629|      0|		    ent->children->name = nbktext;
 7630|      0|		if ((ent->last != ent->children) &&
  ------------------
  |  Branch (7630:7): [True: 0, False: 0]
  ------------------
 7631|      0|		    (ent->last->type == XML_TEXT_NODE))
  ------------------
  |  Branch (7631:7): [True: 0, False: 0]
  ------------------
 7632|      0|		    ent->last->name = nbktext;
 7633|      0|		xmlAddChildList(ctxt->node, ent->children);
 7634|      0|	    }
 7635|       |
 7636|       |	    /*
 7637|       |	     * This is to avoid a nasty side effect, see
 7638|       |	     * characters() in SAX.c
 7639|       |	     */
 7640|      0|	    ctxt->nodemem = 0;
 7641|      0|	    ctxt->nodelen = 0;
 7642|      0|	    return;
 7643|      0|	}
 7644|      0|    }
 7645|      0|}
xmlParseEntityRef:
 7678|    106|xmlParseEntityRef(xmlParserCtxtPtr ctxt) {
 7679|    106|    const xmlChar *name;
 7680|    106|    xmlEntityPtr ent = NULL;
 7681|       |
 7682|    106|    GROW;
  ------------------
  |  | 2270|    106|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    106|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 40, False: 66]
  |  |  ------------------
  |  | 2271|    106|	xmlParserGrow(ctxt);
  ------------------
 7683|    106|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7683:9): [True: 0, False: 106]
  ------------------
 7684|      0|        return(NULL);
 7685|       |
 7686|    106|    if (RAW != '&')
  ------------------
  |  | 2221|    106|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7686:9): [True: 0, False: 106]
  ------------------
 7687|      0|        return(NULL);
 7688|    106|    NEXT;
  ------------------
  |  | 2275|    106|#define NEXT xmlNextChar(ctxt)
  ------------------
 7689|    106|    name = xmlParseName(ctxt);
 7690|    106|    if (name == NULL) {
  ------------------
  |  Branch (7690:9): [True: 3, False: 103]
  ------------------
 7691|      3|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 7692|      3|		       "xmlParseEntityRef: no name\n");
 7693|      3|        return(NULL);
 7694|      3|    }
 7695|    103|    if (RAW != ';') {
  ------------------
  |  | 2221|    103|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (7695:9): [True: 0, False: 103]
  ------------------
 7696|      0|	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
 7697|      0|	return(NULL);
 7698|      0|    }
 7699|    103|    NEXT;
  ------------------
  |  | 2275|    103|#define NEXT xmlNextChar(ctxt)
  ------------------
 7700|       |
 7701|       |    /*
 7702|       |     * Predefined entities override any extra definition
 7703|       |     */
 7704|    103|    if ((ctxt->options & XML_PARSE_OLDSAX) == 0) {
  ------------------
  |  Branch (7704:9): [True: 103, False: 0]
  ------------------
 7705|    103|        ent = xmlGetPredefinedEntity(name);
 7706|    103|        if (ent != NULL)
  ------------------
  |  Branch (7706:13): [True: 102, False: 1]
  ------------------
 7707|    102|            return(ent);
 7708|    103|    }
 7709|       |
 7710|       |    /*
 7711|       |     * Ask first SAX for entity resolution, otherwise try the
 7712|       |     * entities which may have stored in the parser context.
 7713|       |     */
 7714|      1|    if (ctxt->sax != NULL) {
  ------------------
  |  Branch (7714:9): [True: 1, False: 0]
  ------------------
 7715|      1|	if (ctxt->sax->getEntity != NULL)
  ------------------
  |  Branch (7715:6): [True: 1, False: 0]
  ------------------
 7716|      1|	    ent = ctxt->sax->getEntity(ctxt->userData, name);
 7717|      1|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7717:6): [True: 0, False: 1]
  |  Branch (7717:34): [True: 0, False: 0]
  ------------------
 7718|      1|	    (ctxt->options & XML_PARSE_OLDSAX))
  ------------------
  |  Branch (7718:6): [True: 0, False: 0]
  ------------------
 7719|      0|	    ent = xmlGetPredefinedEntity(name);
 7720|      1|	if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&
  ------------------
  |  Branch (7720:6): [True: 0, False: 1]
  |  Branch (7720:34): [True: 0, False: 0]
  ------------------
 7721|      1|	    (ctxt->userData==ctxt)) {
  ------------------
  |  Branch (7721:6): [True: 0, False: 0]
  ------------------
 7722|      0|	    ent = xmlSAX2GetEntity(ctxt, name);
 7723|      0|	}
 7724|      1|    }
 7725|      1|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (7725:9): [True: 0, False: 1]
  ------------------
 7726|      0|	return(NULL);
 7727|       |    /*
 7728|       |     * [ WFC: Entity Declared ]
 7729|       |     * In a document without any DTD, a document with only an
 7730|       |     * internal DTD subset which contains no parameter entity
 7731|       |     * references, or a document with "standalone='yes'", the
 7732|       |     * Name given in the entity reference must match that in an
 7733|       |     * entity declaration, except that well-formed documents
 7734|       |     * need not declare any of the following entities: amp, lt,
 7735|       |     * gt, apos, quot.
 7736|       |     * The declaration of a parameter entity must precede any
 7737|       |     * reference to it.
 7738|       |     * Similarly, the declaration of a general entity must
 7739|       |     * precede any reference to it which appears in a default
 7740|       |     * value in an attribute-list declaration. Note that if
 7741|       |     * entities are declared in the external subset or in
 7742|       |     * external parameter entities, a non-validating processor
 7743|       |     * is not obligated to read and process their declarations;
 7744|       |     * for such documents, the rule that an entity must be
 7745|       |     * declared is a well-formedness constraint only if
 7746|       |     * standalone='yes'.
 7747|       |     */
 7748|      1|    if (ent == NULL) {
  ------------------
  |  Branch (7748:9): [True: 1, False: 0]
  ------------------
 7749|      1|	if ((ctxt->standalone == 1) ||
  ------------------
  |  Branch (7749:6): [True: 0, False: 1]
  ------------------
 7750|      1|	    ((ctxt->hasExternalSubset == 0) &&
  ------------------
  |  Branch (7750:7): [True: 1, False: 0]
  ------------------
 7751|      1|	     (ctxt->hasPErefs == 0))) {
  ------------------
  |  Branch (7751:7): [True: 1, False: 0]
  ------------------
 7752|      1|	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
 7753|      1|		     "Entity '%s' not defined\n", name);
 7754|      1|	} else {
 7755|      0|	    xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,
 7756|      0|		     "Entity '%s' not defined\n", name);
 7757|      0|	    if ((ctxt->inSubset == 0) &&
  ------------------
  |  Branch (7757:10): [True: 0, False: 0]
  ------------------
 7758|      0|		(ctxt->sax != NULL) &&
  ------------------
  |  Branch (7758:3): [True: 0, False: 0]
  ------------------
 7759|      0|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (7759:17): [True: 0, False: 0]
  ------------------
 7760|      0|		(ctxt->sax->reference != NULL)) {
  ------------------
  |  Branch (7760:3): [True: 0, False: 0]
  ------------------
 7761|      0|		ctxt->sax->reference(ctxt->userData, name);
 7762|      0|	    }
 7763|      0|	}
 7764|      1|	ctxt->valid = 0;
 7765|      1|    }
 7766|       |
 7767|       |    /*
 7768|       |     * [ WFC: Parsed Entity ]
 7769|       |     * An entity reference must not contain the name of an
 7770|       |     * unparsed entity
 7771|       |     */
 7772|      0|    else if (ent->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {
  ------------------
  |  Branch (7772:14): [True: 0, False: 0]
  ------------------
 7773|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,
 7774|      0|		 "Entity reference to unparsed entity %s\n", name);
 7775|      0|    }
 7776|       |
 7777|       |    /*
 7778|       |     * [ WFC: No External Entity References ]
 7779|       |     * Attribute values cannot contain direct or indirect
 7780|       |     * entity references to external entities.
 7781|       |     */
 7782|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7782:14): [True: 0, False: 0]
  ------------------
 7783|      0|	     (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {
  ------------------
  |  Branch (7783:7): [True: 0, False: 0]
  ------------------
 7784|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,
 7785|      0|	     "Attribute references external entity '%s'\n", name);
 7786|      0|    }
 7787|       |    /*
 7788|       |     * [ WFC: No < in Attribute Values ]
 7789|       |     * The replacement text of any entity referred to directly or
 7790|       |     * indirectly in an attribute value (other than "&lt;") must
 7791|       |     * not contain a <.
 7792|       |     */
 7793|      0|    else if ((ctxt->instate == XML_PARSER_ATTRIBUTE_VALUE) &&
  ------------------
  |  Branch (7793:14): [True: 0, False: 0]
  ------------------
 7794|      0|	     (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (7794:7): [True: 0, False: 0]
  ------------------
 7795|      0|	if ((ent->flags & XML_ENT_CHECKED_LT) == 0) {
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
  |  Branch (7795:6): [True: 0, False: 0]
  ------------------
 7796|      0|            if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))
  ------------------
  |  Branch (7796:17): [True: 0, False: 0]
  |  Branch (7796:43): [True: 0, False: 0]
  ------------------
 7797|      0|                ent->flags |= XML_ENT_CONTAINS_LT;
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
 7798|      0|            ent->flags |= XML_ENT_CHECKED_LT;
  ------------------
  |  |   17|      0|#define XML_ENT_CHECKED_LT  (1<<3)
  ------------------
 7799|      0|        }
 7800|      0|        if (ent->flags & XML_ENT_CONTAINS_LT)
  ------------------
  |  |   18|      0|#define XML_ENT_CONTAINS_LT (1<<4)
  ------------------
  |  Branch (7800:13): [True: 0, False: 0]
  ------------------
 7801|      0|            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,
 7802|      0|                    "'<' in entity '%s' is not allowed in attributes "
 7803|      0|                    "values\n", name);
 7804|      0|    }
 7805|       |
 7806|       |    /*
 7807|       |     * Internal check, no parameter entities here ...
 7808|       |     */
 7809|      0|    else {
 7810|      0|	switch (ent->etype) {
 7811|      0|	    case XML_INTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7811:6): [True: 0, False: 0]
  ------------------
 7812|      0|	    case XML_EXTERNAL_PARAMETER_ENTITY:
  ------------------
  |  Branch (7812:6): [True: 0, False: 0]
  ------------------
 7813|      0|	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,
 7814|      0|	     "Attempt to reference the parameter entity '%s'\n",
 7815|      0|			      name);
 7816|      0|	    break;
 7817|      0|	    default:
  ------------------
  |  Branch (7817:6): [True: 0, False: 0]
  ------------------
 7818|      0|	    break;
 7819|      0|	}
 7820|      0|    }
 7821|       |
 7822|       |    /*
 7823|       |     * [ WFC: No Recursion ]
 7824|       |     * A parsed entity must not contain a recursive reference
 7825|       |     * to itself, either directly or indirectly.
 7826|       |     * Done somewhere else
 7827|       |     */
 7828|      1|    return(ent);
 7829|      1|}
xmlParseDocTypeDecl:
 8461|     23|xmlParseDocTypeDecl(xmlParserCtxtPtr ctxt) {
 8462|     23|    const xmlChar *name = NULL;
 8463|     23|    xmlChar *ExternalID = NULL;
 8464|     23|    xmlChar *URI = NULL;
 8465|       |
 8466|       |    /*
 8467|       |     * We know that '<!DOCTYPE' has been detected.
 8468|       |     */
 8469|     23|    SKIP(9);
  ------------------
  |  | 2245|     23|#define SKIP(val) do {							\
  |  | 2246|     23|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     23|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 23]
  |  |  ------------------
  |  | 2248|     23|        xmlParserGrow(ctxt);						\
  |  | 2249|     23|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 8470|       |
 8471|     23|    SKIP_BLANKS;
  ------------------
  |  | 2273|     23|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8472|       |
 8473|       |    /*
 8474|       |     * Parse the DOCTYPE name.
 8475|       |     */
 8476|     23|    name = xmlParseName(ctxt);
 8477|     23|    if (name == NULL) {
  ------------------
  |  Branch (8477:9): [True: 0, False: 23]
  ------------------
 8478|      0|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 8479|      0|		       "xmlParseDocTypeDecl : no DOCTYPE name !\n");
 8480|      0|    }
 8481|     23|    ctxt->intSubName = name;
 8482|       |
 8483|     23|    SKIP_BLANKS;
  ------------------
  |  | 2273|     23|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8484|       |
 8485|       |    /*
 8486|       |     * Check for SystemID and ExternalID
 8487|       |     */
 8488|     23|    URI = xmlParseExternalID(ctxt, &ExternalID, 1);
 8489|       |
 8490|     23|    if ((URI != NULL) || (ExternalID != NULL)) {
  ------------------
  |  Branch (8490:9): [True: 0, False: 23]
  |  Branch (8490:26): [True: 0, False: 23]
  ------------------
 8491|      0|        ctxt->hasExternalSubset = 1;
 8492|      0|    }
 8493|     23|    ctxt->extSubURI = URI;
 8494|     23|    ctxt->extSubSystem = ExternalID;
 8495|       |
 8496|     23|    SKIP_BLANKS;
  ------------------
  |  | 2273|     23|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8497|       |
 8498|       |    /*
 8499|       |     * Create and update the internal subset.
 8500|       |     */
 8501|     23|    if ((ctxt->sax != NULL) && (ctxt->sax->internalSubset != NULL) &&
  ------------------
  |  Branch (8501:9): [True: 23, False: 0]
  |  Branch (8501:32): [True: 23, False: 0]
  ------------------
 8502|     23|	(!ctxt->disableSAX))
  ------------------
  |  Branch (8502:2): [True: 23, False: 0]
  ------------------
 8503|     23|	ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);
 8504|     23|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8504:9): [True: 0, False: 23]
  ------------------
 8505|      0|	return;
 8506|       |
 8507|       |    /*
 8508|       |     * Is there any internal subset declarations ?
 8509|       |     * they are handled separately in xmlParseInternalSubset()
 8510|       |     */
 8511|     23|    if (RAW == '[')
  ------------------
  |  | 2221|     23|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8511:9): [True: 23, False: 0]
  ------------------
 8512|     23|	return;
 8513|       |
 8514|       |    /*
 8515|       |     * We should be at the end of the DOCTYPE declaration.
 8516|       |     */
 8517|      0|    if (RAW != '>') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8517:9): [True: 0, False: 0]
  ------------------
 8518|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8519|      0|    }
 8520|      0|    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 8521|      0|}
xmlParseCDSect:
10109|     12|xmlParseCDSect(xmlParserCtxtPtr ctxt) {
10110|     12|    xmlChar *buf = NULL;
10111|     12|    int len = 0;
10112|     12|    int size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|     12|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
10113|     12|    int r, rl;
10114|     12|    int	s, sl;
10115|     12|    int cur, l;
10116|     12|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (10116:21): [True: 0, False: 12]
  ------------------
10117|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
10118|     12|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|     12|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
10119|       |
10120|     12|    if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2222|     12|#define CUR (*ctxt->input->cur)
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     12|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                  if ((CUR != '<') || (NXT(1) != '!') || (NXT(2) != '['))
  ------------------
  |  | 2223|     12|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10120:9): [True: 0, False: 12]
  |  Branch (10120:25): [True: 0, False: 12]
  |  Branch (10120:44): [True: 0, False: 12]
  ------------------
10121|      0|        return;
10122|     12|    SKIP(3);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10123|       |
10124|     12|    if (!CMP6(CUR_PTR, 'C', 'D', 'A', 'T', 'A', '['))
  ------------------
  |  | 2233|     12|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  ------------------
  |  |  |  | 2231|     24|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2228|     24|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2228:5): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (2228:41): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  | 2229|     12|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2229:5): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (2229:41): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2231:34): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2233:38): [True: 12, False: 0]
  |  |  ------------------
  ------------------
10125|      0|        return;
10126|     12|    SKIP(6);
  ------------------
  |  | 2245|     12|#define SKIP(val) do {							\
  |  | 2246|     12|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|     12|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2248|     12|        xmlParserGrow(ctxt);						\
  |  | 2249|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10127|       |
10128|     12|    ctxt->instate = XML_PARSER_CDATA_SECTION;
10129|     12|    r = CUR_CHAR(rl);
  ------------------
  |  | 2291|     12|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10130|     12|    if (!IS_CHAR(r)) {
  ------------------
  |  |  125|     12|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     12|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     12|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     12|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     12|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     12|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     12|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10130:9): [True: 0, False: 12]
  ------------------
10131|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10132|      0|        goto out;
10133|      0|    }
10134|     12|    NEXTL(rl);
  ------------------
  |  | 2284|     12|#define NEXTL(l) do {							\
  |  | 2285|     12|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     12|    } else ctxt->input->col++;						\
  |  | 2288|     12|    ctxt->input->cur += l;				\
  |  | 2289|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10135|     12|    s = CUR_CHAR(sl);
  ------------------
  |  | 2291|     12|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10136|     12|    if (!IS_CHAR(s)) {
  ------------------
  |  |  125|     12|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     12|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|     12|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     12|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 12, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     12|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 12]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     12|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     12|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10136:9): [True: 0, False: 12]
  ------------------
10137|      0|	xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);
10138|      0|        goto out;
10139|      0|    }
10140|     12|    NEXTL(sl);
  ------------------
  |  | 2284|     12|#define NEXTL(l) do {							\
  |  | 2285|     12|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     12|    } else ctxt->input->col++;						\
  |  | 2288|     12|    ctxt->input->cur += l;				\
  |  | 2289|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10141|     12|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     12|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10142|     12|    buf = (xmlChar *) xmlMallocAtomic(size);
10143|     12|    if (buf == NULL) {
  ------------------
  |  Branch (10143:9): [True: 0, False: 12]
  ------------------
10144|      0|	xmlErrMemory(ctxt, NULL);
10145|      0|        goto out;
10146|      0|    }
10147|     60|    while (IS_CHAR(cur) &&
  ------------------
  |  |  125|     60|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    120|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:24): [True: 60, False: 0]
  |  |  |  |  |  Branch (118:25): [True: 60, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|    120|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|     60|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 60, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 60]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|     60|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 60]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|     60|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 60, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    120|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10148|     60|           ((r != ']') || (s != ']') || (cur != '>'))) {
  ------------------
  |  Branch (10148:13): [True: 48, False: 12]
  |  Branch (10148:27): [True: 0, False: 12]
  |  Branch (10148:41): [True: 0, False: 12]
  ------------------
10149|     48|	if (len + 5 >= size) {
  ------------------
  |  Branch (10149:6): [True: 0, False: 48]
  ------------------
10150|      0|	    xmlChar *tmp;
10151|       |
10152|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size * 2);
10153|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10153:10): [True: 0, False: 0]
  ------------------
10154|      0|		xmlErrMemory(ctxt, NULL);
10155|      0|                goto out;
10156|      0|	    }
10157|      0|	    buf = tmp;
10158|      0|	    size *= 2;
10159|      0|	}
10160|     48|	COPY_BUF(buf, len, r);
  ------------------
  |  | 2295|     48|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 48, False: 0]
  |  |  ------------------
  |  | 2296|     48|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
10161|     48|        if (len > maxLength) {
  ------------------
  |  Branch (10161:13): [True: 0, False: 48]
  ------------------
10162|      0|            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10163|      0|                           "CData section too big found\n");
10164|      0|            goto out;
10165|      0|        }
10166|     48|	r = s;
10167|     48|	rl = sl;
10168|     48|	s = cur;
10169|     48|	sl = l;
10170|     48|	NEXTL(l);
  ------------------
  |  | 2284|     48|#define NEXTL(l) do {							\
  |  | 2285|     48|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 48]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     48|    } else ctxt->input->col++;						\
  |  | 2288|     48|    ctxt->input->cur += l;				\
  |  | 2289|     48|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10171|     48|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     48|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
10172|     48|    }
10173|     12|    buf[len] = 0;
10174|     12|    if (ctxt->instate == XML_PARSER_EOF) {
  ------------------
  |  Branch (10174:9): [True: 0, False: 12]
  ------------------
10175|      0|        xmlFree(buf);
10176|      0|        return;
10177|      0|    }
10178|     12|    if (cur != '>') {
  ------------------
  |  Branch (10178:9): [True: 0, False: 12]
  ------------------
10179|      0|	xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,
10180|      0|	                     "CData section not finished\n%.50s\n", buf);
10181|      0|        goto out;
10182|      0|    }
10183|     12|    NEXTL(l);
  ------------------
  |  | 2284|     12|#define NEXTL(l) do {							\
  |  | 2285|     12|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 12]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     12|    } else ctxt->input->col++;						\
  |  | 2288|     12|    ctxt->input->cur += l;				\
  |  | 2289|     12|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10184|       |
10185|       |    /*
10186|       |     * OK the buffer is to be consumed as cdata.
10187|       |     */
10188|     12|    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (10188:9): [True: 12, False: 0]
  |  Branch (10188:32): [True: 12, False: 0]
  ------------------
10189|     12|	if (ctxt->sax->cdataBlock != NULL)
  ------------------
  |  Branch (10189:6): [True: 12, False: 0]
  ------------------
10190|     12|	    ctxt->sax->cdataBlock(ctxt->userData, buf, len);
10191|      0|	else if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (10191:11): [True: 0, False: 0]
  ------------------
10192|      0|	    ctxt->sax->characters(ctxt->userData, buf, len);
10193|     12|    }
10194|       |
10195|     12|out:
10196|     12|    if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (10196:9): [True: 12, False: 0]
  ------------------
10197|     12|        ctxt->instate = XML_PARSER_CONTENT;
10198|     12|    xmlFree(buf);
10199|     12|}
xmlParseElement:
10319|    481|xmlParseElement(xmlParserCtxtPtr ctxt) {
10320|    481|    if (xmlParseElementStart(ctxt) != 0)
  ------------------
  |  Branch (10320:9): [True: 9, False: 472]
  ------------------
10321|      9|        return;
10322|       |
10323|    472|    xmlParseContentInternal(ctxt);
10324|    472|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10324:9): [True: 0, False: 472]
  ------------------
10325|      0|	return;
10326|       |
10327|    472|    if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (10327:9): [True: 9, False: 463]
  ------------------
10328|      9|        if (ctxt->errNo == XML_ERR_OK) {
  ------------------
  |  Branch (10328:13): [True: 1, False: 8]
  ------------------
10329|      1|            const xmlChar *name = ctxt->nameTab[ctxt->nameNr - 1];
10330|      1|            int line = ctxt->pushTab[ctxt->nameNr - 1].line;
10331|      1|            xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NOT_FINISHED,
10332|      1|                    "Premature end of data in tag %s line %d\n",
10333|      1|                    name, line, NULL);
10334|      1|        }
10335|      9|        return;
10336|      9|    }
10337|       |
10338|    463|    xmlParseElementEnd(ctxt);
10339|    463|}
xmlParseVersionNum:
10526|    179|xmlParseVersionNum(xmlParserCtxtPtr ctxt) {
10527|    179|    xmlChar *buf = NULL;
10528|    179|    int len = 0;
10529|    179|    int size = 10;
10530|    179|    xmlChar cur;
10531|       |
10532|    179|    buf = (xmlChar *) xmlMallocAtomic(size);
10533|    179|    if (buf == NULL) {
  ------------------
  |  Branch (10533:9): [True: 0, False: 179]
  ------------------
10534|      0|	xmlErrMemory(ctxt, NULL);
10535|      0|	return(NULL);
10536|      0|    }
10537|    179|    cur = CUR;
  ------------------
  |  | 2222|    179|#define CUR (*ctxt->input->cur)
  ------------------
10538|    179|    if (!((cur >= '0') && (cur <= '9'))) {
  ------------------
  |  Branch (10538:11): [True: 179, False: 0]
  |  Branch (10538:27): [True: 179, False: 0]
  ------------------
10539|      0|	xmlFree(buf);
10540|      0|	return(NULL);
10541|      0|    }
10542|    179|    buf[len++] = cur;
10543|    179|    NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10544|    179|    cur=CUR;
  ------------------
  |  | 2222|    179|#define CUR (*ctxt->input->cur)
  ------------------
10545|    179|    if (cur != '.') {
  ------------------
  |  Branch (10545:9): [True: 0, False: 179]
  ------------------
10546|      0|	xmlFree(buf);
10547|      0|	return(NULL);
10548|      0|    }
10549|    179|    buf[len++] = cur;
10550|    179|    NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10551|    179|    cur=CUR;
  ------------------
  |  | 2222|    179|#define CUR (*ctxt->input->cur)
  ------------------
10552|    358|    while ((cur >= '0') && (cur <= '9')) {
  ------------------
  |  Branch (10552:12): [True: 179, False: 179]
  |  Branch (10552:28): [True: 179, False: 0]
  ------------------
10553|    179|	if (len + 1 >= size) {
  ------------------
  |  Branch (10553:6): [True: 0, False: 179]
  ------------------
10554|      0|	    xmlChar *tmp;
10555|       |
10556|      0|	    size *= 2;
10557|      0|	    tmp = (xmlChar *) xmlRealloc(buf, size);
10558|      0|	    if (tmp == NULL) {
  ------------------
  |  Branch (10558:10): [True: 0, False: 0]
  ------------------
10559|      0|	        xmlFree(buf);
10560|      0|		xmlErrMemory(ctxt, NULL);
10561|      0|		return(NULL);
10562|      0|	    }
10563|      0|	    buf = tmp;
10564|      0|	}
10565|    179|	buf[len++] = cur;
10566|    179|	NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10567|    179|	cur=CUR;
  ------------------
  |  | 2222|    179|#define CUR (*ctxt->input->cur)
  ------------------
10568|    179|    }
10569|    179|    buf[len] = 0;
10570|    179|    return(buf);
10571|    179|}
xmlParseVersionInfo:
10589|    181|xmlParseVersionInfo(xmlParserCtxtPtr ctxt) {
10590|    181|    xmlChar *version = NULL;
10591|       |
10592|    181|    if (CMP7(CUR_PTR, 'v', 'e', 'r', 's', 'i', 'o', 'n')) {
  ------------------
  |  | 2235|    181|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  ------------------
  |  |  |  | 2233|    362|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2231|    362|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2228|    362|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 180, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 180, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2229|    181|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 179, False: 1]
  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 179, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2231:34): [True: 179, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2233:38): [True: 179, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2235:42): [True: 179, False: 0]
  |  |  ------------------
  ------------------
10593|    179|	SKIP(7);
  ------------------
  |  | 2245|    179|#define SKIP(val) do {							\
  |  | 2246|    179|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    179|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 179]
  |  |  ------------------
  |  | 2248|    179|        xmlParserGrow(ctxt);						\
  |  | 2249|    179|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10594|    179|	SKIP_BLANKS;
  ------------------
  |  | 2273|    179|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10595|    179|	if (RAW != '=') {
  ------------------
  |  | 2221|    179|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10595:6): [True: 0, False: 179]
  ------------------
10596|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10597|      0|	    return(NULL);
10598|      0|        }
10599|    179|	NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10600|    179|	SKIP_BLANKS;
  ------------------
  |  | 2273|    179|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10601|    179|	if (RAW == '"') {
  ------------------
  |  | 2221|    179|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10601:6): [True: 179, False: 0]
  ------------------
10602|    179|	    NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10603|    179|	    version = xmlParseVersionNum(ctxt);
10604|    179|	    if (RAW != '"') {
  ------------------
  |  | 2221|    179|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10604:10): [True: 0, False: 179]
  ------------------
10605|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10606|      0|	    } else
10607|    179|	        NEXT;
  ------------------
  |  | 2275|    179|#define NEXT xmlNextChar(ctxt)
  ------------------
10608|    179|	} else if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10608:13): [True: 0, False: 0]
  ------------------
10609|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10610|      0|	    version = xmlParseVersionNum(ctxt);
10611|      0|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10611:10): [True: 0, False: 0]
  ------------------
10612|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10613|      0|	    } else
10614|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10615|      0|	} else {
10616|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10617|      0|	}
10618|    179|    }
10619|    181|    return(version);
10620|    181|}
xmlParseEncodingDecl:
10705|      2|xmlParseEncodingDecl(xmlParserCtxtPtr ctxt) {
10706|      2|    xmlChar *encoding = NULL;
10707|       |
10708|      2|    SKIP_BLANKS;
  ------------------
  |  | 2273|      2|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10709|      2|    if (CMP8(CUR_PTR, 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g') == 0)
  ------------------
  |  | 2237|      2|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  ------------------
  |  |  |  | 2235|      4|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2233|      4|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2231|      4|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2228|      4|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 2]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2229|      2|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10709:9): [True: 2, False: 0]
  ------------------
10710|      2|        return(NULL);
10711|       |
10712|      0|    SKIP(8);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10713|      0|    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10714|      0|    if (RAW != '=') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10714:9): [True: 0, False: 0]
  ------------------
10715|      0|        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10716|      0|        return(NULL);
10717|      0|    }
10718|      0|    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10719|      0|    SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10720|      0|    if (RAW == '"') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10720:9): [True: 0, False: 0]
  ------------------
10721|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10722|      0|        encoding = xmlParseEncName(ctxt);
10723|      0|        if (RAW != '"') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10723:13): [True: 0, False: 0]
  ------------------
10724|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10725|      0|            xmlFree((xmlChar *) encoding);
10726|      0|            return(NULL);
10727|      0|        } else
10728|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10729|      0|    } else if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10729:16): [True: 0, False: 0]
  ------------------
10730|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10731|      0|        encoding = xmlParseEncName(ctxt);
10732|      0|        if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10732:13): [True: 0, False: 0]
  ------------------
10733|      0|            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10734|      0|            xmlFree((xmlChar *) encoding);
10735|      0|            return(NULL);
10736|      0|        } else
10737|      0|            NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10738|      0|    } else {
10739|      0|        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10740|      0|    }
10741|       |
10742|      0|    if (encoding == NULL)
  ------------------
  |  Branch (10742:9): [True: 0, False: 0]
  ------------------
10743|      0|        return(NULL);
10744|       |
10745|      0|    xmlSetDeclaredEncoding(ctxt, encoding);
10746|       |
10747|      0|    return(ctxt->encoding);
10748|      0|}
xmlParseSDDecl:
10784|      2|xmlParseSDDecl(xmlParserCtxtPtr ctxt) {
10785|      2|    int standalone = -2;
10786|       |
10787|      2|    SKIP_BLANKS;
  ------------------
  |  | 2273|      2|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10788|      2|    if (CMP10(CUR_PTR, 's', 't', 'a', 'n', 'd', 'a', 'l', 'o', 'n', 'e')) {
  ------------------
  |  | 2242|      2|  ( CMP9( s, c1, c2, c3, c4, c5, c6, c7, c8, c9 ) && \
  |  |  ------------------
  |  |  |  | 2239|      4|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  |  |  ------------------
  |  |  |  |  |  | 2237|      4|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2235|      4|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2233|      4|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2231|      4|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2228|      4|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 0, False: 2]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  | 2229|      2|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2235:42): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2237:46): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  | 2240|      4|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2240:5): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2243|      2|    ((unsigned char *) s)[ 9 ] == c10 )
  |  |  ------------------
  |  |  |  Branch (2243:5): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10789|      0|	SKIP(10);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10790|      0|        SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10791|      0|	if (RAW != '=') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10791:6): [True: 0, False: 0]
  ------------------
10792|      0|	    xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);
10793|      0|	    return(standalone);
10794|      0|        }
10795|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10796|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10797|      0|        if (RAW == '\''){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10797:13): [True: 0, False: 0]
  ------------------
10798|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10799|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10799:10): [True: 0, False: 0]
  |  Branch (10799:26): [True: 0, False: 0]
  ------------------
10800|      0|	        standalone = 0;
10801|      0|                SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10802|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10802:17): [True: 0, False: 0]
  |  Branch (10802:33): [True: 0, False: 0]
  ------------------
10803|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10803:17): [True: 0, False: 0]
  ------------------
10804|      0|	        standalone = 1;
10805|      0|		SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10806|      0|            } else {
10807|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10808|      0|	    }
10809|      0|	    if (RAW != '\'') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10809:10): [True: 0, False: 0]
  ------------------
10810|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10811|      0|	    } else
10812|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10813|      0|	} else if (RAW == '"'){
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10813:13): [True: 0, False: 0]
  ------------------
10814|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10815|      0|	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    if ((RAW == 'n') && (NXT(1) == 'o')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10815:10): [True: 0, False: 0]
  |  Branch (10815:26): [True: 0, False: 0]
  ------------------
10816|      0|	        standalone = 0;
10817|      0|		SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10818|      0|	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	    } else if ((RAW == 'y') && (NXT(1) == 'e') &&
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10818:17): [True: 0, False: 0]
  |  Branch (10818:33): [True: 0, False: 0]
  ------------------
10819|      0|	               (NXT(2) == 's')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10819:17): [True: 0, False: 0]
  ------------------
10820|      0|	        standalone = 1;
10821|      0|                SKIP(3);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10822|      0|            } else {
10823|      0|		xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);
10824|      0|	    }
10825|      0|	    if (RAW != '"') {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10825:10): [True: 0, False: 0]
  ------------------
10826|      0|		xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
10827|      0|	    } else
10828|      0|	        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10829|      0|	} else {
10830|      0|	    xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);
10831|      0|        }
10832|      0|    }
10833|      2|    return(standalone);
10834|      2|}
xmlParseXMLDecl:
10848|    181|xmlParseXMLDecl(xmlParserCtxtPtr ctxt) {
10849|    181|    xmlChar *version;
10850|       |
10851|       |    /*
10852|       |     * This value for standalone indicates that the document has an
10853|       |     * XML declaration but it does not have a standalone attribute.
10854|       |     * It will be overwritten later if a standalone attribute is found.
10855|       |     */
10856|       |
10857|    181|    ctxt->standalone = -2;
10858|       |
10859|       |    /*
10860|       |     * We know that '<?xml' is here.
10861|       |     */
10862|    181|    SKIP(5);
  ------------------
  |  | 2245|    181|#define SKIP(val) do {							\
  |  | 2246|    181|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    181|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 181]
  |  |  ------------------
  |  | 2248|    181|        xmlParserGrow(ctxt);						\
  |  | 2249|    181|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10863|       |
10864|    181|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    181|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    181|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 181, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    181|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    181|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10865|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
10866|      0|	               "Blank needed after '<?xml'\n");
10867|      0|    }
10868|    181|    SKIP_BLANKS;
  ------------------
  |  | 2273|    181|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10869|       |
10870|       |    /*
10871|       |     * We must have the VersionInfo here.
10872|       |     */
10873|    181|    version = xmlParseVersionInfo(ctxt);
10874|    181|    if (version == NULL) {
  ------------------
  |  Branch (10874:9): [True: 2, False: 179]
  ------------------
10875|      2|	xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);
10876|    179|    } else {
10877|    179|	if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {
  ------------------
  |  |   37|    179|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
  |  Branch (10877:6): [True: 1, False: 178]
  ------------------
10878|       |	    /*
10879|       |	     * Changed here for XML-1.0 5th edition
10880|       |	     */
10881|      1|	    if (ctxt->options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (10881:10): [True: 0, False: 1]
  ------------------
10882|      0|		xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10883|      0|			          "Unsupported version '%s'\n",
10884|      0|			          version);
10885|      1|	    } else {
10886|      1|	        if ((version[0] == '1') && ((version[1] == '.'))) {
  ------------------
  |  Branch (10886:14): [True: 0, False: 1]
  |  Branch (10886:37): [True: 0, False: 0]
  ------------------
10887|      0|		    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,
10888|      0|		                  "Unsupported version '%s'\n",
10889|      0|				  version, NULL);
10890|      1|		} else {
10891|      1|		    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,
10892|      1|				      "Unsupported version '%s'\n",
10893|      1|				      version);
10894|      1|		}
10895|      1|	    }
10896|      1|	}
10897|    179|	if (ctxt->version != NULL)
  ------------------
  |  Branch (10897:6): [True: 0, False: 179]
  ------------------
10898|      0|	    xmlFree((void *) ctxt->version);
10899|    179|	ctxt->version = version;
10900|    179|    }
10901|       |
10902|       |    /*
10903|       |     * We may have the encoding declaration
10904|       |     */
10905|    181|    if (!IS_BLANK_CH(RAW)) {
  ------------------
  |  |  151|    181|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    181|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 181]
  |  |  |  |  ------------------
  |  |  |  |   89|    181|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 181, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 181]
  |  |  |  |  ------------------
  |  |  |  |   90|    181|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 181]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10906|    181|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|    181|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    179|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10906:13): [True: 179, False: 2]
  |  Branch (10906:29): [True: 179, False: 0]
  ------------------
10907|    179|	    SKIP(2);
  ------------------
  |  | 2245|    179|#define SKIP(val) do {							\
  |  | 2246|    179|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    179|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 179]
  |  |  ------------------
  |  | 2248|    179|        xmlParserGrow(ctxt);						\
  |  | 2249|    179|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10908|    179|	    return;
10909|    179|	}
10910|      2|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10911|      2|    }
10912|      2|    xmlParseEncodingDecl(ctxt);
10913|      2|    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (10913:9): [True: 0, False: 2]
  ------------------
10914|      2|         (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (10914:10): [True: 0, False: 2]
  ------------------
10915|       |	/*
10916|       |	 * The XML REC instructs us to stop parsing right here
10917|       |	 */
10918|      0|        return;
10919|      0|    }
10920|       |
10921|       |    /*
10922|       |     * We may have the standalone status.
10923|       |     */
10924|      2|    if ((ctxt->encoding != NULL) && (!IS_BLANK_CH(RAW))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (10924:9): [True: 0, False: 2]
  ------------------
10925|      0|        if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10925:13): [True: 0, False: 0]
  |  Branch (10925:29): [True: 0, False: 0]
  ------------------
10926|      0|	    SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10927|      0|	    return;
10928|      0|	}
10929|      0|	xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, "Blank needed here\n");
10930|      0|    }
10931|       |
10932|       |    /*
10933|       |     * We can grow the input buffer freely at that point
10934|       |     */
10935|      2|    GROW;
  ------------------
  |  | 2270|      2|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      2|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1, False: 1]
  |  |  ------------------
  |  | 2271|      2|	xmlParserGrow(ctxt);
  ------------------
10936|       |
10937|      2|    SKIP_BLANKS;
  ------------------
  |  | 2273|      2|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10938|      2|    ctxt->standalone = xmlParseSDDecl(ctxt);
10939|       |
10940|      2|    SKIP_BLANKS;
  ------------------
  |  | 2273|      2|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10941|      2|    if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '?') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10941:9): [True: 0, False: 2]
  |  Branch (10941:25): [True: 0, False: 0]
  ------------------
10942|      0|        SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10943|      2|    } else if (RAW == '>') {
  ------------------
  |  | 2221|      2|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10943:16): [True: 0, False: 2]
  ------------------
10944|       |        /* Deprecated old WD ... */
10945|      0|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10946|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
10947|      2|    } else {
10948|      2|        int c;
10949|       |
10950|      2|	xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);
10951|     10|        while ((c = CUR) != 0) {
  ------------------
  |  | 2222|     10|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (10951:16): [True: 9, False: 1]
  ------------------
10952|      9|            NEXT;
  ------------------
  |  | 2275|      9|#define NEXT xmlNextChar(ctxt)
  ------------------
10953|      9|            if (c == '>')
  ------------------
  |  Branch (10953:17): [True: 1, False: 8]
  ------------------
10954|      1|                break;
10955|      9|        }
10956|      2|    }
10957|      2|}
xmlParseMisc:
10971|    989|xmlParseMisc(xmlParserCtxtPtr ctxt) {
10972|    990|    while (ctxt->instate != XML_PARSER_EOF) {
  ------------------
  |  Branch (10972:12): [True: 990, False: 0]
  ------------------
10973|    990|        SKIP_BLANKS;
  ------------------
  |  | 2273|    990|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10974|    990|        GROW;
  ------------------
  |  | 2270|    990|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    990|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 810, False: 180]
  |  |  ------------------
  |  | 2271|    990|	xmlParserGrow(ctxt);
  ------------------
10975|    990|        if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2221|    990|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '?')) {
  ------------------
  |  | 2223|    514|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10975:13): [True: 514, False: 476]
  |  Branch (10975:29): [True: 1, False: 513]
  ------------------
10976|      1|	    xmlParsePI(ctxt);
10977|    989|        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {
  ------------------
  |  | 2228|    989|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  ------------------
  |  |  |  Branch (2228:5): [True: 513, False: 476]
  |  |  |  Branch (2228:41): [True: 23, False: 490]
  |  |  ------------------
  |  | 2229|    989|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  ------------------
  |  |  |  Branch (2229:5): [True: 0, False: 23]
  |  |  |  Branch (2229:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10978|      0|	    xmlParseComment(ctxt);
10979|    989|        } else {
10980|    989|            break;
10981|    989|        }
10982|    990|    }
10983|    989|}
xmlParseDocument:
11001|    486|xmlParseDocument(xmlParserCtxtPtr ctxt) {
11002|    486|    xmlInitParser();
11003|       |
11004|    486|    if ((ctxt == NULL) || (ctxt->input == NULL))
  ------------------
  |  Branch (11004:9): [True: 0, False: 486]
  |  Branch (11004:27): [True: 0, False: 486]
  ------------------
11005|      0|        return(-1);
11006|       |
11007|    486|    GROW;
  ------------------
  |  | 2270|    486|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    486|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 486, False: 0]
  |  |  ------------------
  |  | 2271|    486|	xmlParserGrow(ctxt);
  ------------------
11008|       |
11009|       |    /*
11010|       |     * SAX: detecting the level.
11011|       |     */
11012|    486|    xmlDetectSAX2(ctxt);
11013|       |
11014|       |    /*
11015|       |     * SAX: beginning of the document processing.
11016|       |     */
11017|    486|    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
  ------------------
  |  Branch (11017:9): [True: 486, False: 0]
  |  Branch (11017:24): [True: 486, False: 0]
  ------------------
11018|    486|        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
  ------------------
  |  |  861|    486|  #define xmlDefaultSAXLocator XML_GLOBAL_MACRO(xmlDefaultSAXLocator)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11019|    486|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11019:9): [True: 0, False: 486]
  ------------------
11020|      0|	return(-1);
11021|       |
11022|    486|    xmlDetectEncoding(ctxt);
11023|       |
11024|    486|    if (CUR == 0) {
  ------------------
  |  | 2222|    486|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (11024:9): [True: 0, False: 486]
  ------------------
11025|      0|	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
11026|      0|	return(-1);
11027|      0|    }
11028|       |
11029|    486|    GROW;
  ------------------
  |  | 2270|    486|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    486|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 329, False: 157]
  |  |  ------------------
  |  | 2271|    486|	xmlParserGrow(ctxt);
  ------------------
11030|    486|    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  | 2231|    486|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  ------------------
  |  |  |  | 2228|    972|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2228:5): [True: 485, False: 1]
  |  |  |  |  |  Branch (2228:41): [True: 182, False: 303]
  |  |  |  |  ------------------
  |  |  |  | 2229|    486|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2229:5): [True: 181, False: 1]
  |  |  |  |  |  Branch (2229:41): [True: 181, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (2231:34): [True: 181, False: 0]
  |  |  ------------------
  ------------------
                  if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
  ------------------
  |  |  151|    181|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    181|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 181, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|    181|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|    181|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
11031|       |
11032|       |	/*
11033|       |	 * Note that we will switch encoding on the fly.
11034|       |	 */
11035|    181|	xmlParseXMLDecl(ctxt);
11036|    181|	if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||
  ------------------
  |  Branch (11036:6): [True: 0, False: 181]
  ------------------
11037|    181|	    (ctxt->instate == XML_PARSER_EOF)) {
  ------------------
  |  Branch (11037:6): [True: 0, False: 181]
  ------------------
11038|       |	    /*
11039|       |	     * The XML REC instructs us to stop parsing right here
11040|       |	     */
11041|      0|	    return(-1);
11042|      0|	}
11043|    181|	SKIP_BLANKS;
  ------------------
  |  | 2273|    181|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
11044|    305|    } else {
11045|    305|	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
  ------------------
  |  |   37|    305|#define XML_DEFAULT_VERSION	"1.0"
  ------------------
11046|    305|    }
11047|    486|    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
  ------------------
  |  Branch (11047:9): [True: 486, False: 0]
  |  Branch (11047:24): [True: 486, False: 0]
  |  Branch (11047:54): [True: 486, False: 0]
  ------------------
11048|    486|        ctxt->sax->startDocument(ctxt->userData);
11049|    486|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11049:9): [True: 0, False: 486]
  ------------------
11050|      0|	return(-1);
11051|    486|    if ((ctxt->myDoc != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (11051:9): [True: 486, False: 0]
  |  Branch (11051:34): [True: 486, False: 0]
  ------------------
11052|    486|        (ctxt->input->buf != NULL) && (ctxt->input->buf->compressed >= 0)) {
  ------------------
  |  Branch (11052:9): [True: 486, False: 0]
  |  Branch (11052:39): [True: 0, False: 486]
  ------------------
11053|      0|	ctxt->myDoc->compression = ctxt->input->buf->compressed;
11054|      0|    }
11055|       |
11056|       |    /*
11057|       |     * The Misc part of the Prolog
11058|       |     */
11059|    486|    xmlParseMisc(ctxt);
11060|       |
11061|       |    /*
11062|       |     * Then possibly doc type declaration(s) and more Misc
11063|       |     * (doctypedecl Misc*)?
11064|       |     */
11065|    486|    GROW;
  ------------------
  |  | 2270|    486|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    486|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 331, False: 155]
  |  |  ------------------
  |  | 2271|    486|	xmlParserGrow(ctxt);
  ------------------
11066|    486|    if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
  ------------------
  |  | 2239|    486|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|    972|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|    972|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|    972|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|    972|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|    972|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 482, False: 4]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 23, False: 459]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|    486|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 23, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 23, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 23, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 23, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 23, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 23, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|    486|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 23, False: 0]
  |  |  ------------------
  ------------------
11067|       |
11068|     23|	ctxt->inSubset = 1;
11069|     23|	xmlParseDocTypeDecl(ctxt);
11070|     23|	if (RAW == '[') {
  ------------------
  |  | 2221|     23|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11070:6): [True: 23, False: 0]
  ------------------
11071|     23|	    ctxt->instate = XML_PARSER_DTD;
11072|     23|	    xmlParseInternalSubset(ctxt);
11073|     23|	    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11073:10): [True: 1, False: 22]
  ------------------
11074|      1|		return(-1);
11075|     23|	}
11076|       |
11077|       |	/*
11078|       |	 * Create and update the external subset.
11079|       |	 */
11080|     22|	ctxt->inSubset = 2;
11081|     22|	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  ------------------
  |  Branch (11081:6): [True: 22, False: 0]
  |  Branch (11081:29): [True: 22, False: 0]
  ------------------
11082|     22|	    (!ctxt->disableSAX))
  ------------------
  |  Branch (11082:6): [True: 22, False: 0]
  ------------------
11083|     22|	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
11084|     22|	                              ctxt->extSubSystem, ctxt->extSubURI);
11085|     22|	if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (11085:6): [True: 0, False: 22]
  ------------------
11086|      0|	    return(-1);
11087|     22|	ctxt->inSubset = 0;
11088|       |
11089|     22|        xmlCleanSpecialAttr(ctxt);
11090|       |
11091|     22|	ctxt->instate = XML_PARSER_PROLOG;
11092|     22|	xmlParseMisc(ctxt);
11093|     22|    }
11094|       |
11095|       |    /*
11096|       |     * Time to start parsing the tree itself
11097|       |     */
11098|    485|    GROW;
  ------------------
  |  | 2270|    485|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    485|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 331, False: 154]
  |  |  ------------------
  |  | 2271|    485|	xmlParserGrow(ctxt);
  ------------------
11099|    485|    if (RAW != '<') {
  ------------------
  |  | 2221|    485|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (11099:9): [True: 4, False: 481]
  ------------------
11100|      4|	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
11101|      4|		       "Start tag expected, '<' not found\n");
11102|    481|    } else {
11103|    481|	ctxt->instate = XML_PARSER_CONTENT;
11104|    481|	xmlParseElement(ctxt);
11105|    481|	ctxt->instate = XML_PARSER_EPILOG;
11106|       |
11107|       |
11108|       |	/*
11109|       |	 * The Misc part at the end
11110|       |	 */
11111|    481|	xmlParseMisc(ctxt);
11112|       |
11113|    481|        if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (11113:13): [True: 24, False: 457]
  ------------------
11114|     24|            if (ctxt->errNo == XML_ERR_OK)
  ------------------
  |  Branch (11114:17): [True: 5, False: 19]
  ------------------
11115|      5|	        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
11116|    457|        } else if ((ctxt->input->buf != NULL) &&
  ------------------
  |  Branch (11116:20): [True: 457, False: 0]
  ------------------
11117|    457|                   (ctxt->input->buf->encoder != NULL) &&
  ------------------
  |  Branch (11117:20): [True: 0, False: 457]
  ------------------
11118|    457|                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {
  ------------------
  |  Branch (11118:20): [True: 0, False: 0]
  ------------------
11119|      0|            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
11120|      0|                           "Truncated multi-byte sequence at EOF\n");
11121|      0|        }
11122|    481|	ctxt->instate = XML_PARSER_EOF;
11123|    481|    }
11124|       |
11125|       |    /*
11126|       |     * SAX: end of the document processing.
11127|       |     */
11128|    485|    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
  ------------------
  |  Branch (11128:9): [True: 485, False: 0]
  |  Branch (11128:24): [True: 485, False: 0]
  ------------------
11129|    485|        ctxt->sax->endDocument(ctxt->userData);
11130|       |
11131|       |    /*
11132|       |     * Remove locally kept entity definitions if the tree was not built
11133|       |     */
11134|    485|    if ((ctxt->myDoc != NULL) &&
  ------------------
  |  Branch (11134:9): [True: 485, False: 0]
  ------------------
11135|    485|	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
  ------------------
  |  |  168|    485|#define SAX_COMPAT_MODE BAD_CAST "SAX compatibility mode document"
  |  |  ------------------
  |  |  |  |   35|    485|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
  |  Branch (11135:2): [True: 0, False: 485]
  ------------------
11136|      0|	xmlFreeDoc(ctxt->myDoc);
11137|      0|	ctxt->myDoc = NULL;
11138|      0|    }
11139|       |
11140|    485|    if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
  ------------------
  |  Branch (11140:9): [True: 426, False: 59]
  |  Branch (11140:31): [True: 426, False: 0]
  ------------------
11141|    426|        ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
11142|    426|	if (ctxt->valid)
  ------------------
  |  Branch (11142:6): [True: 426, False: 0]
  ------------------
11143|    426|	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
11144|    426|	if (ctxt->nsWellFormed)
  ------------------
  |  Branch (11144:6): [True: 426, False: 0]
  ------------------
11145|    426|	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
11146|    426|	if (ctxt->options & XML_PARSE_OLD10)
  ------------------
  |  Branch (11146:6): [True: 0, False: 426]
  ------------------
11147|      0|	    ctxt->myDoc->properties |= XML_DOC_OLD10;
11148|    426|    }
11149|    485|    if (! ctxt->wellFormed) {
  ------------------
  |  Branch (11149:9): [True: 59, False: 426]
  ------------------
11150|     59|	ctxt->valid = 0;
11151|     59|	return(-1);
11152|     59|    }
11153|    426|    return(0);
11154|    485|}
xmlCreateMemoryParserCtxt:
13985|    488|xmlCreateMemoryParserCtxt(const char *buffer, int size) {
13986|    488|    xmlParserCtxtPtr ctxt;
13987|    488|    xmlParserInputPtr input;
13988|    488|    xmlParserInputBufferPtr buf;
13989|       |
13990|    488|    if (buffer == NULL)
  ------------------
  |  Branch (13990:9): [True: 2, False: 486]
  ------------------
13991|      2|	return(NULL);
13992|    486|    if (size <= 0)
  ------------------
  |  Branch (13992:9): [True: 0, False: 486]
  ------------------
13993|      0|	return(NULL);
13994|       |
13995|    486|    ctxt = xmlNewParserCtxt();
13996|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (13996:9): [True: 0, False: 486]
  ------------------
13997|      0|	return(NULL);
13998|       |
13999|    486|    buf = xmlParserInputBufferCreateMem(buffer, size, XML_CHAR_ENCODING_NONE);
14000|    486|    if (buf == NULL) {
  ------------------
  |  Branch (14000:9): [True: 0, False: 486]
  ------------------
14001|      0|	xmlFreeParserCtxt(ctxt);
14002|      0|	return(NULL);
14003|      0|    }
14004|       |
14005|    486|    input = xmlNewInputStream(ctxt);
14006|    486|    if (input == NULL) {
  ------------------
  |  Branch (14006:9): [True: 0, False: 486]
  ------------------
14007|      0|	xmlFreeParserInputBuffer(buf);
14008|      0|	xmlFreeParserCtxt(ctxt);
14009|      0|	return(NULL);
14010|      0|    }
14011|       |
14012|    486|    input->filename = NULL;
14013|    486|    input->buf = buf;
14014|    486|    xmlBufResetInput(input->buf->buffer, input);
14015|       |
14016|    486|    inputPush(ctxt, input);
14017|    486|    return(ctxt);
14018|    486|}
xmlReadMemory:
14830|    488|{
14831|    488|    xmlParserCtxtPtr ctxt;
14832|       |
14833|    488|    xmlInitParser();
14834|    488|    ctxt = xmlCreateMemoryParserCtxt(buffer, size);
14835|    488|    if (ctxt == NULL)
  ------------------
  |  Branch (14835:9): [True: 2, False: 486]
  ------------------
14836|      2|        return (NULL);
14837|    486|    return (xmlDoRead(ctxt, URL, encoding, options, 0));
14838|    488|}
parser.c:xmlParserNsLookup:
 1485|  2.99k|                  xmlParserNsBucket **bucketPtr) {
 1486|  2.99k|    xmlParserNsBucket *bucket;
 1487|  2.99k|    unsigned index, hashValue;
 1488|       |
 1489|  2.99k|    if (prefix->name == NULL)
  ------------------
  |  Branch (1489:9): [True: 2.96k, False: 37]
  ------------------
 1490|  2.96k|        return(ctxt->nsdb->defaultNsIndex);
 1491|       |
 1492|     37|    if (ctxt->nsdb->hashSize == 0)
  ------------------
  |  Branch (1492:9): [True: 7, False: 30]
  ------------------
 1493|      7|        return(INT_MAX);
 1494|       |
 1495|     30|    hashValue = prefix->hashValue;
 1496|     30|    index = hashValue & (ctxt->nsdb->hashSize - 1);
 1497|     30|    bucket = &ctxt->nsdb->hash[index];
 1498|       |
 1499|     30|    while (bucket->hashValue) {
  ------------------
  |  Branch (1499:12): [True: 24, False: 6]
  ------------------
 1500|     24|        if ((bucket->hashValue == hashValue) &&
  ------------------
  |  Branch (1500:13): [True: 24, False: 0]
  ------------------
 1501|     24|            (bucket->index != INT_MAX)) {
  ------------------
  |  Branch (1501:13): [True: 24, False: 0]
  ------------------
 1502|     24|            if (ctxt->nsTab[bucket->index * 2] == prefix->name) {
  ------------------
  |  Branch (1502:17): [True: 24, False: 0]
  ------------------
 1503|     24|                if (bucketPtr != NULL)
  ------------------
  |  Branch (1503:21): [True: 12, False: 12]
  ------------------
 1504|     12|                    *bucketPtr = bucket;
 1505|     24|                return(bucket->index);
 1506|     24|            }
 1507|     24|        }
 1508|       |
 1509|      0|        index++;
 1510|      0|        bucket++;
 1511|      0|        if (index == ctxt->nsdb->hashSize) {
  ------------------
  |  Branch (1511:13): [True: 0, False: 0]
  ------------------
 1512|      0|            index = 0;
 1513|      0|            bucket = ctxt->nsdb->hash;
 1514|      0|        }
 1515|      0|    }
 1516|       |
 1517|      6|    if (bucketPtr != NULL)
  ------------------
  |  Branch (1517:9): [True: 6, False: 0]
  ------------------
 1518|      6|        *bucketPtr = bucket;
 1519|      6|    return(INT_MAX);
 1520|     30|}
parser.c:xmlFatalErrMsgInt:
  385|     68|{
  386|     68|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (386:9): [True: 68, False: 0]
  |  Branch (386:27): [True: 0, False: 68]
  ------------------
  387|     68|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (387:9): [True: 0, False: 0]
  ------------------
  388|      0|	return;
  389|     68|    if (ctxt != NULL)
  ------------------
  |  Branch (389:9): [True: 68, False: 0]
  ------------------
  390|     68|	ctxt->errNo = error;
  391|     68|    __xmlRaiseError(NULL, NULL, NULL,
  392|     68|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  393|     68|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  394|     68|    if (ctxt != NULL) {
  ------------------
  |  Branch (394:9): [True: 68, False: 0]
  ------------------
  395|     68|	ctxt->wellFormed = 0;
  396|     68|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (396:6): [True: 0, False: 68]
  ------------------
  397|      0|	    ctxt->disableSAX = 1;
  398|     68|    }
  399|     68|}
parser.c:xmlFatalErrMsgStr:
  445|      3|{
  446|      3|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (446:9): [True: 3, False: 0]
  |  Branch (446:27): [True: 0, False: 3]
  ------------------
  447|      3|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (447:9): [True: 0, False: 0]
  ------------------
  448|      0|	return;
  449|      3|    if (ctxt != NULL)
  ------------------
  |  Branch (449:9): [True: 3, False: 0]
  ------------------
  450|      3|	ctxt->errNo = error;
  451|      3|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL,
  452|      3|                    XML_FROM_PARSER, error, XML_ERR_FATAL,
  453|      3|                    NULL, 0, (const char *) val, NULL, NULL, 0, 0, msg,
  454|      3|                    val);
  455|      3|    if (ctxt != NULL) {
  ------------------
  |  Branch (455:9): [True: 3, False: 0]
  ------------------
  456|      3|	ctxt->wellFormed = 0;
  457|      3|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (457:6): [True: 0, False: 3]
  ------------------
  458|      0|	    ctxt->disableSAX = 1;
  459|      3|    }
  460|      3|}
parser.c:xmlParseNameComplex:
 3399|      9|xmlParseNameComplex(xmlParserCtxtPtr ctxt) {
 3400|      9|    int len = 0, l;
 3401|      9|    int c;
 3402|      9|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3402:21): [True: 0, False: 9]
  ------------------
 3403|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3404|      9|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|      9|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3405|       |
 3406|       |    /*
 3407|       |     * Handler for more complex cases
 3408|       |     */
 3409|      9|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      9|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3410|      9|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3410:9): [True: 9, False: 0]
  ------------------
 3411|       |        /*
 3412|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3413|       |	 * Update 5 of XML-1.0
 3414|       |	 */
 3415|      9|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3415:6): [True: 0, False: 9]
  |  Branch (3415:20): [True: 0, False: 9]
  |  Branch (3415:34): [True: 3, False: 6]
  ------------------
 3416|      9|	    (!(((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3416:10): [True: 3, False: 3]
  |  Branch (3416:24): [True: 3, False: 0]
  ------------------
 3417|      6|	       ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3417:10): [True: 0, False: 3]
  |  Branch (3417:24): [True: 0, False: 0]
  ------------------
 3418|      6|	       (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3418:9): [True: 0, False: 3]
  |  Branch (3418:23): [True: 0, False: 3]
  ------------------
 3419|      6|	       ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3419:10): [True: 0, False: 3]
  |  Branch (3419:25): [True: 0, False: 0]
  ------------------
 3420|      6|	       ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3420:10): [True: 0, False: 3]
  |  Branch (3420:25): [True: 0, False: 0]
  ------------------
 3421|      6|	       ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3421:10): [True: 0, False: 3]
  |  Branch (3421:25): [True: 0, False: 0]
  ------------------
 3422|      6|	       ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3422:10): [True: 0, False: 3]
  |  Branch (3422:26): [True: 0, False: 0]
  ------------------
 3423|      6|	       ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3423:10): [True: 0, False: 3]
  |  Branch (3423:26): [True: 0, False: 0]
  ------------------
 3424|      6|	       ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3424:10): [True: 0, False: 3]
  |  Branch (3424:27): [True: 0, False: 0]
  ------------------
 3425|      6|	       ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3425:10): [True: 0, False: 3]
  |  Branch (3425:27): [True: 0, False: 0]
  ------------------
 3426|      6|	       ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3426:10): [True: 0, False: 3]
  |  Branch (3426:27): [True: 0, False: 0]
  ------------------
 3427|      6|	       ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3427:10): [True: 0, False: 3]
  |  Branch (3427:27): [True: 0, False: 0]
  ------------------
 3428|      6|	       ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3428:10): [True: 0, False: 3]
  |  Branch (3428:27): [True: 0, False: 0]
  ------------------
 3429|      6|	       ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3429:10): [True: 0, False: 3]
  |  Branch (3429:27): [True: 0, False: 0]
  ------------------
 3430|      6|	       ((c >= 0x10000) && (c <= 0xEFFFF))))) {
  ------------------
  |  Branch (3430:10): [True: 0, False: 3]
  |  Branch (3430:28): [True: 0, False: 0]
  ------------------
 3431|      6|	    return(NULL);
 3432|      6|	}
 3433|      3|	len += l;
 3434|      3|	NEXTL(l);
  ------------------
  |  | 2284|      3|#define NEXTL(l) do {							\
  |  | 2285|      3|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      3|    } else ctxt->input->col++;						\
  |  | 2288|      3|    ctxt->input->cur += l;				\
  |  | 2289|      3|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3435|      3|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      3|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3436|    116|	while ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3436:9): [True: 116, False: 0]
  |  Branch (3436:23): [True: 116, False: 0]
  |  Branch (3436:37): [True: 116, False: 0]
  ------------------
 3437|    116|	       (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3437:11): [True: 113, False: 3]
  |  Branch (3437:25): [True: 2, False: 111]
  ------------------
 3438|    116|	        ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3438:11): [True: 111, False: 3]
  |  Branch (3438:25): [True: 0, False: 111]
  ------------------
 3439|    116|	        ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3439:11): [True: 112, False: 2]
  |  Branch (3439:25): [True: 0, False: 112]
  ------------------
 3440|    116|	        (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3440:10): [True: 0, False: 114]
  |  Branch (3440:24): [True: 0, False: 114]
  ------------------
 3441|    116|	        (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3441:10): [True: 0, False: 114]
  |  Branch (3441:24): [True: 0, False: 114]
  |  Branch (3441:38): [True: 0, False: 114]
  ------------------
 3442|    116|	        ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3442:11): [True: 111, False: 3]
  |  Branch (3442:26): [True: 0, False: 111]
  ------------------
 3443|    116|	        ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3443:11): [True: 111, False: 3]
  |  Branch (3443:26): [True: 0, False: 111]
  ------------------
 3444|    116|	        ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3444:11): [True: 111, False: 3]
  |  Branch (3444:26): [True: 0, False: 111]
  ------------------
 3445|    116|	        ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3445:11): [True: 111, False: 3]
  |  Branch (3445:27): [True: 0, False: 111]
  ------------------
 3446|    116|	        ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3446:11): [True: 111, False: 3]
  |  Branch (3446:27): [True: 0, False: 111]
  ------------------
 3447|    116|	        ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3447:11): [True: 111, False: 3]
  |  Branch (3447:27): [True: 0, False: 111]
  ------------------
 3448|    116|	        ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3448:11): [True: 111, False: 3]
  |  Branch (3448:28): [True: 0, False: 111]
  ------------------
 3449|    116|	        ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3449:11): [True: 111, False: 3]
  |  Branch (3449:28): [True: 0, False: 111]
  ------------------
 3450|    116|	        ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3450:11): [True: 111, False: 3]
  |  Branch (3450:28): [True: 0, False: 111]
  ------------------
 3451|    116|	        ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3451:11): [True: 111, False: 3]
  |  Branch (3451:28): [True: 0, False: 111]
  ------------------
 3452|    116|	        ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3452:11): [True: 111, False: 3]
  |  Branch (3452:28): [True: 0, False: 111]
  ------------------
 3453|    116|	        ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3453:11): [True: 111, False: 3]
  |  Branch (3453:28): [True: 0, False: 111]
  ------------------
 3454|    116|	        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3454:11): [True: 111, False: 3]
  |  Branch (3454:28): [True: 111, False: 0]
  ------------------
 3455|    116|	        ((c >= 0x10000) && (c <= 0xEFFFF))
  ------------------
  |  Branch (3455:11): [True: 0, False: 3]
  |  Branch (3455:29): [True: 0, False: 0]
  ------------------
 3456|    116|		)) {
 3457|    113|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3457:17): [True: 113, False: 0]
  ------------------
 3458|    113|	        len += l;
 3459|    113|	    NEXTL(l);
  ------------------
  |  | 2284|    113|#define NEXTL(l) do {							\
  |  | 2285|    113|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 113]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    113|    } else ctxt->input->col++;						\
  |  | 2288|    113|    ctxt->input->cur += l;				\
  |  | 2289|    113|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3460|    113|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    113|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3461|    113|	}
 3462|      3|    } else {
 3463|      0|	if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3463:6): [True: 0, False: 0]
  |  Branch (3463:20): [True: 0, False: 0]
  |  Branch (3463:34): [True: 0, False: 0]
  ------------------
 3464|      0|	    (!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3464:24): [True: 0, False: 0]
  ------------------
 3465|      0|	     (c != ':'))) {
  ------------------
  |  Branch (3465:7): [True: 0, False: 0]
  ------------------
 3466|      0|	    return(NULL);
 3467|      0|	}
 3468|      0|	len += l;
 3469|      0|	NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3470|      0|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3471|       |
 3472|      0|	while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3472:9): [True: 0, False: 0]
  |  Branch (3472:23): [True: 0, False: 0]
  |  Branch (3472:37): [True: 0, False: 0]
  ------------------
 3473|      0|	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3473:28): [True: 0, False: 0]
  ------------------
 3474|      0|		(c == '.') || (c == '-') ||
  ------------------
  |  Branch (3474:3): [True: 0, False: 0]
  |  Branch (3474:17): [True: 0, False: 0]
  ------------------
 3475|      0|		(c == '_') || (c == ':') ||
  ------------------
  |  Branch (3475:3): [True: 0, False: 0]
  |  Branch (3475:17): [True: 0, False: 0]
  ------------------
 3476|      0|		(IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3476:3): [True: 0, False: 0]
  ------------------
 3477|      0|		(IS_EXTENDER(c)))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3477:3): [True: 0, False: 0]
  ------------------
 3478|      0|            if (len <= INT_MAX - l)
  ------------------
  |  Branch (3478:17): [True: 0, False: 0]
  ------------------
 3479|      0|	        len += l;
 3480|      0|	    NEXTL(l);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3481|      0|	    c = CUR_CHAR(l);
  ------------------
  |  | 2291|      0|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3482|      0|	}
 3483|      0|    }
 3484|      3|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3484:9): [True: 0, False: 3]
  ------------------
 3485|      0|        return(NULL);
 3486|      3|    if (len > maxLength) {
  ------------------
  |  Branch (3486:9): [True: 0, False: 3]
  ------------------
 3487|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Name");
 3488|      0|        return(NULL);
 3489|      0|    }
 3490|      3|    if (ctxt->input->cur - ctxt->input->base < len) {
  ------------------
  |  Branch (3490:9): [True: 0, False: 3]
  ------------------
 3491|       |        /*
 3492|       |         * There were a couple of bugs where PERefs lead to to a change
 3493|       |         * of the buffer. Check the buffer size to avoid passing an invalid
 3494|       |         * pointer to xmlDictLookup.
 3495|       |         */
 3496|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 3497|      0|                    "unexpected change of input buffer");
 3498|      0|        return (NULL);
 3499|      0|    }
 3500|      3|    if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r'))
  ------------------
  |  Branch (3500:9): [True: 0, False: 3]
  |  Branch (3500:40): [True: 0, False: 0]
  ------------------
 3501|      0|        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len));
 3502|      3|    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
 3503|      3|}
parser.c:xmlIsNameChar:
 3357|     31|xmlIsNameChar(xmlParserCtxtPtr ctxt, int c) {
 3358|     31|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3358:9): [True: 31, False: 0]
  ------------------
 3359|       |        /*
 3360|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3361|       |	 * Update 5 of XML-1.0
 3362|       |	 */
 3363|     31|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3363:6): [True: 31, False: 0]
  |  Branch (3363:20): [True: 31, False: 0]
  |  Branch (3363:34): [True: 31, False: 0]
  ------------------
 3364|     31|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3364:8): [True: 26, False: 5]
  |  Branch (3364:22): [True: 17, False: 9]
  ------------------
 3365|     31|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3365:8): [True: 9, False: 5]
  |  Branch (3365:22): [True: 0, False: 9]
  ------------------
 3366|     31|	     ((c >= '0') && (c <= '9')) || /* !start */
  ------------------
  |  Branch (3366:8): [True: 11, False: 3]
  |  Branch (3366:22): [True: 1, False: 10]
  ------------------
 3367|     31|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3367:7): [True: 0, False: 13]
  |  Branch (3367:21): [True: 0, False: 13]
  ------------------
 3368|     31|	     (c == '-') || (c == '.') || (c == 0xB7) || /* !start */
  ------------------
  |  Branch (3368:7): [True: 0, False: 13]
  |  Branch (3368:21): [True: 0, False: 13]
  |  Branch (3368:35): [True: 0, False: 13]
  ------------------
 3369|     31|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3369:8): [True: 9, False: 4]
  |  Branch (3369:23): [True: 0, False: 9]
  ------------------
 3370|     31|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3370:8): [True: 9, False: 4]
  |  Branch (3370:23): [True: 0, False: 9]
  ------------------
 3371|     31|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3371:8): [True: 9, False: 4]
  |  Branch (3371:23): [True: 0, False: 9]
  ------------------
 3372|     31|	     ((c >= 0x300) && (c <= 0x36F)) || /* !start */
  ------------------
  |  Branch (3372:8): [True: 9, False: 4]
  |  Branch (3372:24): [True: 0, False: 9]
  ------------------
 3373|     31|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3373:8): [True: 9, False: 4]
  |  Branch (3373:24): [True: 0, False: 9]
  ------------------
 3374|     31|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3374:8): [True: 9, False: 4]
  |  Branch (3374:24): [True: 0, False: 9]
  ------------------
 3375|     31|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3375:8): [True: 9, False: 4]
  |  Branch (3375:25): [True: 0, False: 9]
  ------------------
 3376|     31|	     ((c >= 0x203F) && (c <= 0x2040)) || /* !start */
  ------------------
  |  Branch (3376:8): [True: 9, False: 4]
  |  Branch (3376:25): [True: 0, False: 9]
  ------------------
 3377|     31|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3377:8): [True: 9, False: 4]
  |  Branch (3377:25): [True: 0, False: 9]
  ------------------
 3378|     31|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3378:8): [True: 9, False: 4]
  |  Branch (3378:25): [True: 0, False: 9]
  ------------------
 3379|     31|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3379:8): [True: 9, False: 4]
  |  Branch (3379:25): [True: 0, False: 9]
  ------------------
 3380|     31|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3380:8): [True: 9, False: 4]
  |  Branch (3380:25): [True: 0, False: 9]
  ------------------
 3381|     31|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3381:8): [True: 9, False: 4]
  |  Branch (3381:25): [True: 9, False: 0]
  ------------------
 3382|     31|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3382:8): [True: 0, False: 4]
  |  Branch (3382:26): [True: 0, False: 0]
  ------------------
 3383|     27|	     return(1);
 3384|     31|    } else {
 3385|      0|        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                      if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (3385:31): [True: 0, False: 0]
  ------------------
 3386|      0|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (3386:13): [True: 0, False: 0]
  |  Branch (3386:27): [True: 0, False: 0]
  ------------------
 3387|      0|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3387:6): [True: 0, False: 0]
  |  Branch (3387:20): [True: 0, False: 0]
  ------------------
 3388|      0|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (3388:6): [True: 0, False: 0]
  ------------------
 3389|      0|	    (IS_EXTENDER(c)))
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (3389:6): [True: 0, False: 0]
  ------------------
 3390|      0|	    return(1);
 3391|      0|    }
 3392|      4|    return(0);
 3393|     31|}
parser.c:xmlFatalErrMsg:
  279|     30|{
  280|     30|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (280:9): [True: 30, False: 0]
  |  Branch (280:27): [True: 0, False: 30]
  ------------------
  281|     30|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (281:9): [True: 0, False: 0]
  ------------------
  282|      0|	return;
  283|     30|    if (ctxt != NULL)
  ------------------
  |  Branch (283:9): [True: 30, False: 0]
  ------------------
  284|     30|	ctxt->errNo = error;
  285|     30|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  286|     30|                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, "%s", msg);
  287|     30|    if (ctxt != NULL) {
  ------------------
  |  Branch (287:9): [True: 30, False: 0]
  ------------------
  288|     30|	ctxt->wellFormed = 0;
  289|     30|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (289:6): [True: 0, False: 30]
  ------------------
  290|      0|	    ctxt->disableSAX = 1;
  291|     30|    }
  292|     30|}
parser.c:xmlIsNameStartChar:
 3326|     13|xmlIsNameStartChar(xmlParserCtxtPtr ctxt, int c) {
 3327|     13|    if ((ctxt->options & XML_PARSE_OLD10) == 0) {
  ------------------
  |  Branch (3327:9): [True: 13, False: 0]
  ------------------
 3328|       |        /*
 3329|       |	 * Use the new checks of production [4] [4a] amd [5] of the
 3330|       |	 * Update 5 of XML-1.0
 3331|       |	 */
 3332|     13|	if ((c != ' ') && (c != '>') && (c != '/') && /* accelerators */
  ------------------
  |  Branch (3332:6): [True: 13, False: 0]
  |  Branch (3332:20): [True: 13, False: 0]
  |  Branch (3332:34): [True: 13, False: 0]
  ------------------
 3333|     13|	    (((c >= 'a') && (c <= 'z')) ||
  ------------------
  |  Branch (3333:8): [True: 7, False: 6]
  |  Branch (3333:22): [True: 5, False: 2]
  ------------------
 3334|     13|	     ((c >= 'A') && (c <= 'Z')) ||
  ------------------
  |  Branch (3334:8): [True: 2, False: 6]
  |  Branch (3334:22): [True: 0, False: 2]
  ------------------
 3335|     13|	     (c == '_') || (c == ':') ||
  ------------------
  |  Branch (3335:7): [True: 0, False: 8]
  |  Branch (3335:21): [True: 0, False: 8]
  ------------------
 3336|     13|	     ((c >= 0xC0) && (c <= 0xD6)) ||
  ------------------
  |  Branch (3336:8): [True: 2, False: 6]
  |  Branch (3336:23): [True: 0, False: 2]
  ------------------
 3337|     13|	     ((c >= 0xD8) && (c <= 0xF6)) ||
  ------------------
  |  Branch (3337:8): [True: 2, False: 6]
  |  Branch (3337:23): [True: 0, False: 2]
  ------------------
 3338|     13|	     ((c >= 0xF8) && (c <= 0x2FF)) ||
  ------------------
  |  Branch (3338:8): [True: 2, False: 6]
  |  Branch (3338:23): [True: 0, False: 2]
  ------------------
 3339|     13|	     ((c >= 0x370) && (c <= 0x37D)) ||
  ------------------
  |  Branch (3339:8): [True: 2, False: 6]
  |  Branch (3339:24): [True: 0, False: 2]
  ------------------
 3340|     13|	     ((c >= 0x37F) && (c <= 0x1FFF)) ||
  ------------------
  |  Branch (3340:8): [True: 2, False: 6]
  |  Branch (3340:24): [True: 0, False: 2]
  ------------------
 3341|     13|	     ((c >= 0x200C) && (c <= 0x200D)) ||
  ------------------
  |  Branch (3341:8): [True: 2, False: 6]
  |  Branch (3341:25): [True: 0, False: 2]
  ------------------
 3342|     13|	     ((c >= 0x2070) && (c <= 0x218F)) ||
  ------------------
  |  Branch (3342:8): [True: 2, False: 6]
  |  Branch (3342:25): [True: 0, False: 2]
  ------------------
 3343|     13|	     ((c >= 0x2C00) && (c <= 0x2FEF)) ||
  ------------------
  |  Branch (3343:8): [True: 2, False: 6]
  |  Branch (3343:25): [True: 0, False: 2]
  ------------------
 3344|     13|	     ((c >= 0x3001) && (c <= 0xD7FF)) ||
  ------------------
  |  Branch (3344:8): [True: 2, False: 6]
  |  Branch (3344:25): [True: 0, False: 2]
  ------------------
 3345|     13|	     ((c >= 0xF900) && (c <= 0xFDCF)) ||
  ------------------
  |  Branch (3345:8): [True: 2, False: 6]
  |  Branch (3345:25): [True: 0, False: 2]
  ------------------
 3346|     13|	     ((c >= 0xFDF0) && (c <= 0xFFFD)) ||
  ------------------
  |  Branch (3346:8): [True: 2, False: 6]
  |  Branch (3346:25): [True: 2, False: 0]
  ------------------
 3347|     13|	     ((c >= 0x10000) && (c <= 0xEFFFF))))
  ------------------
  |  Branch (3347:8): [True: 0, False: 6]
  |  Branch (3347:26): [True: 0, False: 0]
  ------------------
 3348|      7|	    return(1);
 3349|     13|    } else {
 3350|      0|        if (IS_LETTER(c) || (c == '_') || (c == ':'))
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3350:29): [True: 0, False: 0]
  |  Branch (3350:43): [True: 0, False: 0]
  ------------------
 3351|      0|	    return(1);
 3352|      0|    }
 3353|      6|    return(0);
 3354|     13|}
parser.c:xmlParseCharDataInternal:
 4557|  4.81k|xmlParseCharDataInternal(xmlParserCtxtPtr ctxt, int partial) {
 4558|  4.81k|    const xmlChar *in;
 4559|  4.81k|    int nbchar = 0;
 4560|  4.81k|    int line = ctxt->input->line;
 4561|  4.81k|    int col = ctxt->input->col;
 4562|  4.81k|    int ccol;
 4563|       |
 4564|  4.81k|    GROW;
  ------------------
  |  | 2270|  4.81k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  4.81k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.65k, False: 2.16k]
  |  |  ------------------
  |  | 2271|  4.81k|	xmlParserGrow(ctxt);
  ------------------
 4565|       |    /*
 4566|       |     * Accelerated common case where input don't need to be
 4567|       |     * modified before passing it to the handler.
 4568|       |     */
 4569|  4.81k|    in = ctxt->input->cur;
 4570|  4.81k|    do {
 4571|  7.87k|get_more_space:
 4572|  15.0k|        while (*in == 0x20) { in++; ctxt->input->col++; }
  ------------------
  |  Branch (4572:16): [True: 7.16k, False: 7.87k]
  ------------------
 4573|  7.87k|        if (*in == 0xA) {
  ------------------
  |  Branch (4573:13): [True: 3.05k, False: 4.81k]
  ------------------
 4574|  3.05k|            do {
 4575|  3.05k|                ctxt->input->line++; ctxt->input->col = 1;
 4576|  3.05k|                in++;
 4577|  3.05k|            } while (*in == 0xA);
  ------------------
  |  Branch (4577:22): [True: 0, False: 3.05k]
  ------------------
 4578|  3.05k|            goto get_more_space;
 4579|  3.05k|        }
 4580|  4.81k|        if (*in == '<') {
  ------------------
  |  Branch (4580:13): [True: 3.05k, False: 1.76k]
  ------------------
 4581|  3.05k|            nbchar = in - ctxt->input->cur;
 4582|  3.05k|            if (nbchar > 0) {
  ------------------
  |  Branch (4582:17): [True: 3.05k, False: 0]
  ------------------
 4583|  3.05k|                const xmlChar *tmp = ctxt->input->cur;
 4584|  3.05k|                ctxt->input->cur = in;
 4585|       |
 4586|  3.05k|                if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4586:21): [True: 3.05k, False: 0]
  ------------------
 4587|  3.05k|                    (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4587:21): [True: 3.05k, False: 0]
  ------------------
 4588|  3.05k|                    (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4588:21): [True: 0, False: 3.05k]
  ------------------
 4589|  3.05k|                     ctxt->sax->characters)) {
 4590|      0|                    if (areBlanks(ctxt, tmp, nbchar, 1)) {
  ------------------
  |  Branch (4590:25): [True: 0, False: 0]
  ------------------
 4591|      0|                        if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4591:29): [True: 0, False: 0]
  ------------------
 4592|      0|                            ctxt->sax->ignorableWhitespace(ctxt->userData,
 4593|      0|                                                   tmp, nbchar);
 4594|      0|                    } else {
 4595|      0|                        if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4595:29): [True: 0, False: 0]
  ------------------
 4596|      0|                            ctxt->sax->characters(ctxt->userData,
 4597|      0|                                                  tmp, nbchar);
 4598|      0|                        if (*ctxt->space == -1)
  ------------------
  |  Branch (4598:29): [True: 0, False: 0]
  ------------------
 4599|      0|                            *ctxt->space = -2;
 4600|      0|                    }
 4601|  3.05k|                } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4601:28): [True: 3.05k, False: 0]
  ------------------
 4602|  3.05k|                           (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4602:28): [True: 3.05k, False: 0]
  ------------------
 4603|  3.05k|                           (ctxt->sax->characters != NULL)) {
  ------------------
  |  Branch (4603:28): [True: 3.05k, False: 0]
  ------------------
 4604|  3.05k|                    ctxt->sax->characters(ctxt->userData,
 4605|  3.05k|                                          tmp, nbchar);
 4606|  3.05k|                }
 4607|  3.05k|            }
 4608|  3.05k|            return;
 4609|  3.05k|        }
 4610|       |
 4611|  1.77k|get_more:
 4612|  1.77k|        ccol = ctxt->input->col;
 4613|  22.0k|        while (test_char_data[*in]) {
  ------------------
  |  Branch (4613:16): [True: 20.2k, False: 1.77k]
  ------------------
 4614|  20.2k|            in++;
 4615|  20.2k|            ccol++;
 4616|  20.2k|        }
 4617|  1.77k|        ctxt->input->col = ccol;
 4618|  1.77k|        if (*in == 0xA) {
  ------------------
  |  Branch (4618:13): [True: 7, False: 1.76k]
  ------------------
 4619|      7|            do {
 4620|      7|                ctxt->input->line++; ctxt->input->col = 1;
 4621|      7|                in++;
 4622|      7|            } while (*in == 0xA);
  ------------------
  |  Branch (4622:22): [True: 0, False: 7]
  ------------------
 4623|      7|            goto get_more;
 4624|      7|        }
 4625|  1.76k|        if (*in == ']') {
  ------------------
  |  Branch (4625:13): [True: 2, False: 1.76k]
  ------------------
 4626|      2|            if ((in[1] == ']') && (in[2] == '>')) {
  ------------------
  |  Branch (4626:17): [True: 0, False: 2]
  |  Branch (4626:35): [True: 0, False: 0]
  ------------------
 4627|      0|                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4628|      0|                if (ctxt->instate != XML_PARSER_EOF)
  ------------------
  |  Branch (4628:21): [True: 0, False: 0]
  ------------------
 4629|      0|                    ctxt->input->cur = in + 1;
 4630|      0|                return;
 4631|      0|            }
 4632|      2|            in++;
 4633|      2|            ctxt->input->col++;
 4634|      2|            goto get_more;
 4635|      2|        }
 4636|  1.76k|        nbchar = in - ctxt->input->cur;
 4637|  1.76k|        if (nbchar > 0) {
  ------------------
  |  Branch (4637:13): [True: 1.69k, False: 67]
  ------------------
 4638|  1.69k|            if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4638:17): [True: 1.69k, False: 0]
  ------------------
 4639|  1.69k|                (ctxt->disableSAX == 0) &&
  ------------------
  |  Branch (4639:17): [True: 1.69k, False: 0]
  ------------------
 4640|  1.69k|                (ctxt->sax->ignorableWhitespace !=
  ------------------
  |  Branch (4640:17): [True: 0, False: 1.69k]
  ------------------
 4641|  1.69k|                 ctxt->sax->characters) &&
 4642|  1.69k|                (IS_BLANK_CH(*ctxt->input->cur))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 4643|      0|                const xmlChar *tmp = ctxt->input->cur;
 4644|      0|                ctxt->input->cur = in;
 4645|       |
 4646|      0|                if (areBlanks(ctxt, tmp, nbchar, 0)) {
  ------------------
  |  Branch (4646:21): [True: 0, False: 0]
  ------------------
 4647|      0|                    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4647:25): [True: 0, False: 0]
  ------------------
 4648|      0|                        ctxt->sax->ignorableWhitespace(ctxt->userData,
 4649|      0|                                                       tmp, nbchar);
 4650|      0|                } else {
 4651|      0|                    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4651:25): [True: 0, False: 0]
  ------------------
 4652|      0|                        ctxt->sax->characters(ctxt->userData,
 4653|      0|                                              tmp, nbchar);
 4654|      0|                    if (*ctxt->space == -1)
  ------------------
  |  Branch (4654:25): [True: 0, False: 0]
  ------------------
 4655|      0|                        *ctxt->space = -2;
 4656|      0|                }
 4657|      0|                line = ctxt->input->line;
 4658|      0|                col = ctxt->input->col;
 4659|  1.69k|            } else if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (4659:24): [True: 1.69k, False: 0]
  ------------------
 4660|  1.69k|                       (ctxt->disableSAX == 0)) {
  ------------------
  |  Branch (4660:24): [True: 1.69k, False: 0]
  ------------------
 4661|  1.69k|                if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4661:21): [True: 1.69k, False: 0]
  ------------------
 4662|  1.69k|                    ctxt->sax->characters(ctxt->userData,
 4663|  1.69k|                                          ctxt->input->cur, nbchar);
 4664|  1.69k|                line = ctxt->input->line;
 4665|  1.69k|                col = ctxt->input->col;
 4666|  1.69k|            }
 4667|  1.69k|            if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4667:17): [True: 0, False: 1.69k]
  ------------------
 4668|      0|                return;
 4669|  1.69k|        }
 4670|  1.76k|        ctxt->input->cur = in;
 4671|  1.76k|        if (*in == 0xD) {
  ------------------
  |  Branch (4671:13): [True: 0, False: 1.76k]
  ------------------
 4672|      0|            in++;
 4673|      0|            if (*in == 0xA) {
  ------------------
  |  Branch (4673:17): [True: 0, False: 0]
  ------------------
 4674|      0|                ctxt->input->cur = in;
 4675|      0|                in++;
 4676|      0|                ctxt->input->line++; ctxt->input->col = 1;
 4677|      0|                continue; /* while */
 4678|      0|            }
 4679|      0|            in--;
 4680|      0|        }
 4681|  1.76k|        if (*in == '<') {
  ------------------
  |  Branch (4681:13): [True: 1.68k, False: 81]
  ------------------
 4682|  1.68k|            return;
 4683|  1.68k|        }
 4684|     81|        if (*in == '&') {
  ------------------
  |  Branch (4684:13): [True: 0, False: 81]
  ------------------
 4685|      0|            return;
 4686|      0|        }
 4687|     81|        SHRINK;
  ------------------
  |  | 2265|     81|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 81, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|     81|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|     81|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 81]
  |  |  ------------------
  |  | 2267|     81|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|     81|	xmlParserShrink(ctxt);
  ------------------
 4688|     81|        GROW;
  ------------------
  |  | 2270|     81|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     81|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 72, False: 9]
  |  |  ------------------
  |  | 2271|     81|	xmlParserGrow(ctxt);
  ------------------
 4689|     81|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4689:13): [True: 0, False: 81]
  ------------------
 4690|      0|            return;
 4691|     81|        in = ctxt->input->cur;
 4692|     81|    } while (((*in >= 0x20) && (*in <= 0x7F)) ||
  ------------------
  |  Branch (4692:15): [True: 5, False: 76]
  |  Branch (4692:32): [True: 0, False: 5]
  ------------------
 4693|     81|             (*in == 0x09) || (*in == 0x0a));
  ------------------
  |  Branch (4693:14): [True: 0, False: 81]
  |  Branch (4693:31): [True: 0, False: 81]
  ------------------
 4694|     81|    ctxt->input->line = line;
 4695|     81|    ctxt->input->col = col;
 4696|     81|    xmlParseCharDataComplex(ctxt, partial);
 4697|     81|}
parser.c:areBlanks:
 3071|      5|                     int blank_chars) {
 3072|      5|    int i, ret;
 3073|      5|    xmlNodePtr lastChild;
 3074|       |
 3075|       |    /*
 3076|       |     * Don't spend time trying to differentiate them, the same callback is
 3077|       |     * used !
 3078|       |     */
 3079|      5|    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)
  ------------------
  |  Branch (3079:9): [True: 5, False: 0]
  ------------------
 3080|      5|	return(0);
 3081|       |
 3082|       |    /*
 3083|       |     * Check for xml:space value.
 3084|       |     */
 3085|      0|    if ((ctxt->space == NULL) || (*(ctxt->space) == 1) ||
  ------------------
  |  Branch (3085:9): [True: 0, False: 0]
  |  Branch (3085:34): [True: 0, False: 0]
  ------------------
 3086|      0|        (*(ctxt->space) == -2))
  ------------------
  |  Branch (3086:9): [True: 0, False: 0]
  ------------------
 3087|      0|	return(0);
 3088|       |
 3089|       |    /*
 3090|       |     * Check that the string is made of blanks
 3091|       |     */
 3092|      0|    if (blank_chars == 0) {
  ------------------
  |  Branch (3092:9): [True: 0, False: 0]
  ------------------
 3093|      0|	for (i = 0;i < len;i++)
  ------------------
  |  Branch (3093:13): [True: 0, False: 0]
  ------------------
 3094|      0|	    if (!(IS_BLANK_CH(str[i]))) return(0);
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 3095|      0|    }
 3096|       |
 3097|       |    /*
 3098|       |     * Look if the element is mixed content in the DTD if available
 3099|       |     */
 3100|      0|    if (ctxt->node == NULL) return(0);
  ------------------
  |  Branch (3100:9): [True: 0, False: 0]
  ------------------
 3101|      0|    if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (3101:9): [True: 0, False: 0]
  ------------------
 3102|      0|	ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);
 3103|      0|        if (ret == 0) return(1);
  ------------------
  |  Branch (3103:13): [True: 0, False: 0]
  ------------------
 3104|      0|        if (ret == 1) return(0);
  ------------------
  |  Branch (3104:13): [True: 0, False: 0]
  ------------------
 3105|      0|    }
 3106|       |
 3107|       |    /*
 3108|       |     * Otherwise, heuristic :-\
 3109|       |     */
 3110|      0|    if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') && (RAW != 0xD)) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (3110:9): [True: 0, False: 0]
  |  Branch (3110:25): [True: 0, False: 0]
  ------------------
 3111|      0|    if ((ctxt->node->children == NULL) &&
  ------------------
  |  Branch (3111:9): [True: 0, False: 0]
  ------------------
 3112|      0|	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
              	(RAW == '<') && (NXT(1) == '/')) return(0);
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (3112:2): [True: 0, False: 0]
  |  Branch (3112:18): [True: 0, False: 0]
  ------------------
 3113|       |
 3114|      0|    lastChild = xmlGetLastChild(ctxt->node);
 3115|      0|    if (lastChild == NULL) {
  ------------------
  |  Branch (3115:9): [True: 0, False: 0]
  ------------------
 3116|      0|        if ((ctxt->node->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3116:13): [True: 0, False: 0]
  ------------------
 3117|      0|            (ctxt->node->content != NULL)) return(0);
  ------------------
  |  Branch (3117:13): [True: 0, False: 0]
  ------------------
 3118|      0|    } else if (xmlNodeIsText(lastChild))
  ------------------
  |  Branch (3118:16): [True: 0, False: 0]
  ------------------
 3119|      0|        return(0);
 3120|      0|    else if ((ctxt->node->children != NULL) &&
  ------------------
  |  Branch (3120:14): [True: 0, False: 0]
  ------------------
 3121|      0|             (xmlNodeIsText(ctxt->node->children)))
  ------------------
  |  Branch (3121:14): [True: 0, False: 0]
  ------------------
 3122|      0|        return(0);
 3123|      0|    return(1);
 3124|      0|}
parser.c:xmlParseCharDataComplex:
 4711|     81|xmlParseCharDataComplex(xmlParserCtxtPtr ctxt, int partial) {
 4712|     81|    xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
 4713|     81|    int nbchar = 0;
 4714|     81|    int cur, l;
 4715|       |
 4716|     81|    cur = CUR_CHAR(l);
  ------------------
  |  | 2291|     81|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4717|    195|    while ((cur != '<') && /* checked */
  ------------------
  |  Branch (4717:12): [True: 190, False: 5]
  ------------------
 4718|    195|           (cur != '&') &&
  ------------------
  |  Branch (4718:12): [True: 190, False: 0]
  ------------------
 4719|    195|	   (IS_CHAR(cur))) {
  ------------------
  |  |  125|    190|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|    190|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 112, False: 78]
  |  |  |  |  ------------------
  |  |  |  |  119|    190|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|    112|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 38, False: 74]
  |  |  |  |  |  |  |  Branch (108:44): [True: 2, False: 36]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|    112|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 110]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|    112|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 34, False: 76]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|    190|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 78, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 78]
  |  |  |  |  ------------------
  |  |  |  |  121|     78|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 78, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 78, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|     78|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4719:5): [True: 114, False: 76]
  ------------------
 4720|    114|	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4720:6): [True: 0, False: 114]
  |  Branch (4720:22): [True: 0, False: 0]
  |  Branch (4720:41): [True: 0, False: 0]
  ------------------
 4721|      0|	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 4722|      0|	}
 4723|    114|	COPY_BUF(buf, nbchar, cur);
  ------------------
  |  | 2295|    114|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 36, False: 78]
  |  |  ------------------
  |  | 2296|    114|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4724|       |	/* move current position before possible calling of ctxt->sax->characters */
 4725|    114|	NEXTL(l);
  ------------------
  |  | 2284|    114|#define NEXTL(l) do {							\
  |  | 2285|    114|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 2, False: 112]
  |  |  ------------------
  |  | 2286|      2|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|    112|    } else ctxt->input->col++;						\
  |  | 2288|    114|    ctxt->input->cur += l;				\
  |  | 2289|    114|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4726|    114|	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
  ------------------
  |  |  166|    114|#define XML_PARSER_BIG_BUFFER_SIZE 300
  ------------------
  |  Branch (4726:6): [True: 0, False: 114]
  ------------------
 4727|      0|	    buf[nbchar] = 0;
 4728|       |
 4729|       |	    /*
 4730|       |	     * OK the segment is to be consumed as chars.
 4731|       |	     */
 4732|      0|	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4732:10): [True: 0, False: 0]
  |  Branch (4732:33): [True: 0, False: 0]
  ------------------
 4733|      0|		if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4733:7): [True: 0, False: 0]
  ------------------
 4734|      0|		    if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4734:11): [True: 0, False: 0]
  ------------------
 4735|      0|			ctxt->sax->ignorableWhitespace(ctxt->userData,
 4736|      0|			                               buf, nbchar);
 4737|      0|		} else {
 4738|      0|		    if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4738:11): [True: 0, False: 0]
  ------------------
 4739|      0|			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4740|      0|		    if ((ctxt->sax->characters !=
  ------------------
  |  Branch (4740:11): [True: 0, False: 0]
  ------------------
 4741|      0|		         ctxt->sax->ignorableWhitespace) &&
 4742|      0|			(*ctxt->space == -1))
  ------------------
  |  Branch (4742:4): [True: 0, False: 0]
  ------------------
 4743|      0|			*ctxt->space = -2;
 4744|      0|		}
 4745|      0|	    }
 4746|      0|	    nbchar = 0;
 4747|       |            /* something really bad happened in the SAX callback */
 4748|      0|            if (ctxt->instate != XML_PARSER_CONTENT)
  ------------------
  |  Branch (4748:17): [True: 0, False: 0]
  ------------------
 4749|      0|                return;
 4750|      0|            SHRINK;
  ------------------
  |  | 2265|      0|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 0, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|      0|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2267|      0|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|      0|	xmlParserShrink(ctxt);
  ------------------
 4751|      0|	}
 4752|    114|	cur = CUR_CHAR(l);
  ------------------
  |  | 2291|    114|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4753|    114|    }
 4754|     81|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4754:9): [True: 0, False: 81]
  ------------------
 4755|      0|        return;
 4756|     81|    if (nbchar != 0) {
  ------------------
  |  Branch (4756:9): [True: 5, False: 76]
  ------------------
 4757|      5|        buf[nbchar] = 0;
 4758|       |	/*
 4759|       |	 * OK the segment is to be consumed as chars.
 4760|       |	 */
 4761|      5|	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
  ------------------
  |  Branch (4761:6): [True: 5, False: 0]
  |  Branch (4761:29): [True: 5, False: 0]
  ------------------
 4762|      5|	    if (areBlanks(ctxt, buf, nbchar, 0)) {
  ------------------
  |  Branch (4762:10): [True: 0, False: 5]
  ------------------
 4763|      0|		if (ctxt->sax->ignorableWhitespace != NULL)
  ------------------
  |  Branch (4763:7): [True: 0, False: 0]
  ------------------
 4764|      0|		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 4765|      5|	    } else {
 4766|      5|		if (ctxt->sax->characters != NULL)
  ------------------
  |  Branch (4766:7): [True: 5, False: 0]
  ------------------
 4767|      5|		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 4768|      5|		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
  ------------------
  |  Branch (4768:7): [True: 0, False: 5]
  ------------------
 4769|      5|		    (*ctxt->space == -1))
  ------------------
  |  Branch (4769:7): [True: 0, False: 0]
  ------------------
 4770|      0|		    *ctxt->space = -2;
 4771|      5|	    }
 4772|      5|	}
 4773|      5|    }
 4774|       |    /*
 4775|       |     * cur == 0 can mean
 4776|       |     *
 4777|       |     * - XML_PARSER_EOF or memory error. This is checked above.
 4778|       |     * - An actual 0 character.
 4779|       |     * - End of buffer.
 4780|       |     * - An incomplete UTF-8 sequence. This is allowed if partial is set.
 4781|       |     */
 4782|     81|    if (ctxt->input->cur < ctxt->input->end) {
  ------------------
  |  Branch (4782:9): [True: 73, False: 8]
  ------------------
 4783|     73|        if ((cur == 0) && (CUR != 0)) {
  ------------------
  |  | 2222|     66|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (4783:13): [True: 66, False: 7]
  |  Branch (4783:27): [True: 0, False: 66]
  ------------------
 4784|      0|            if (partial == 0) {
  ------------------
  |  Branch (4784:17): [True: 0, False: 0]
  ------------------
 4785|      0|                xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4786|      0|                        "Incomplete UTF-8 sequence starting with %02X\n", CUR);
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
 4787|      0|                NEXTL(1);
  ------------------
  |  | 2284|      0|#define NEXTL(l) do {							\
  |  | 2285|      0|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|      0|    } else ctxt->input->col++;						\
  |  | 2288|      0|    ctxt->input->cur += l;				\
  |  | 2289|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4788|      0|            }
 4789|     73|        } else if ((cur != '<') && (cur != '&')) {
  ------------------
  |  Branch (4789:20): [True: 68, False: 5]
  |  Branch (4789:36): [True: 68, False: 0]
  ------------------
 4790|       |            /* Generate the error and skip the offending character */
 4791|     68|            xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
 4792|     68|                              "PCDATA invalid Char value %d\n", cur);
 4793|     68|            NEXTL(l);
  ------------------
  |  | 2284|     68|#define NEXTL(l) do {							\
  |  | 2285|     68|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 68]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     68|    } else ctxt->input->col++;						\
  |  | 2288|     68|    ctxt->input->cur += l;				\
  |  | 2289|     68|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4794|     68|        }
 4795|     73|    }
 4796|     81|}
parser.c:xmlNsErr:
  501|      2|{
  502|      2|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (502:9): [True: 2, False: 0]
  |  Branch (502:27): [True: 0, False: 2]
  ------------------
  503|      2|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (503:9): [True: 0, False: 0]
  ------------------
  504|      0|	return;
  505|      2|    if (ctxt != NULL)
  ------------------
  |  Branch (505:9): [True: 2, False: 0]
  ------------------
  506|      2|	ctxt->errNo = error;
  507|      2|    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
  508|      2|                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
  509|      2|                    (const char *) info2, (const char *) info3, 0, 0, msg,
  510|      2|                    info1, info2, info3);
  511|      2|    if (ctxt != NULL)
  ------------------
  |  Branch (511:9): [True: 2, False: 0]
  ------------------
  512|      2|	ctxt->nsWellFormed = 0;
  513|      2|}
parser.c:xmlAddSpecialAttr:
 1136|     88|{
 1137|     88|    if (ctxt->attsSpecial == NULL) {
  ------------------
  |  Branch (1137:9): [True: 22, False: 66]
  ------------------
 1138|     22|        ctxt->attsSpecial = xmlHashCreateDict(10, ctxt->dict);
 1139|     22|	if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1139:6): [True: 0, False: 22]
  ------------------
 1140|      0|	    goto mem_error;
 1141|     22|    }
 1142|       |
 1143|     88|    if (xmlHashLookup2(ctxt->attsSpecial, fullname, fullattr) != NULL)
  ------------------
  |  Branch (1143:9): [True: 0, False: 88]
  ------------------
 1144|      0|        return;
 1145|       |
 1146|     88|    xmlHashAddEntry2(ctxt->attsSpecial, fullname, fullattr,
 1147|     88|                     (void *) (ptrdiff_t) type);
 1148|     88|    return;
 1149|       |
 1150|      0|mem_error:
 1151|      0|    xmlErrMemory(ctxt, NULL);
 1152|      0|    return;
 1153|     88|}
parser.c:xmlParseElementChildrenContentDeclPriv:
 6385|    133|                                       int depth) {
 6386|    133|    xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
 6387|    133|    const xmlChar *elem;
 6388|    133|    xmlChar type = 0;
 6389|       |
 6390|    133|    if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
  ------------------
  |  Branch (6390:10): [True: 0, False: 133]
  |  Branch (6390:27): [True: 0, False: 0]
  ------------------
 6391|    133|        (depth >  2048)) {
  ------------------
  |  Branch (6391:9): [True: 0, False: 133]
  ------------------
 6392|      0|        xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 6393|      0|"xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
 6394|      0|                          depth);
 6395|      0|	return(NULL);
 6396|      0|    }
 6397|    133|    SKIP_BLANKS;
  ------------------
  |  | 2273|    133|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6398|    133|    GROW;
  ------------------
  |  | 2270|    133|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    133|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 133]
  |  |  ------------------
  |  | 2271|    133|	xmlParserGrow(ctxt);
  ------------------
 6399|    133|    if (RAW == '(') {
  ------------------
  |  | 2221|    133|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6399:9): [True: 0, False: 133]
  ------------------
 6400|      0|	int inputid = ctxt->input->id;
 6401|       |
 6402|       |        /* Recurse on first child */
 6403|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6404|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6405|      0|        cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6406|      0|                                                           depth + 1);
 6407|      0|        if (cur == NULL)
  ------------------
  |  Branch (6407:13): [True: 0, False: 0]
  ------------------
 6408|      0|            return(NULL);
 6409|      0|	SKIP_BLANKS;
  ------------------
  |  | 2273|      0|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6410|      0|	GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 6411|    133|    } else {
 6412|    133|	elem = xmlParseName(ctxt);
 6413|    133|	if (elem == NULL) {
  ------------------
  |  Branch (6413:6): [True: 0, False: 133]
  ------------------
 6414|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6415|      0|	    return(NULL);
 6416|      0|	}
 6417|    133|        cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6418|    133|	if (cur == NULL) {
  ------------------
  |  Branch (6418:6): [True: 0, False: 133]
  ------------------
 6419|      0|	    xmlErrMemory(ctxt, NULL);
 6420|      0|	    return(NULL);
 6421|      0|	}
 6422|    133|	GROW;
  ------------------
  |  | 2270|    133|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    133|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 133]
  |  |  ------------------
  |  | 2271|    133|	xmlParserGrow(ctxt);
  ------------------
 6423|    133|	if (RAW == '?') {
  ------------------
  |  | 2221|    133|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6423:6): [True: 67, False: 66]
  ------------------
 6424|     67|	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
 6425|     67|	    NEXT;
  ------------------
  |  | 2275|     67|#define NEXT xmlNextChar(ctxt)
  ------------------
 6426|     67|	} else if (RAW == '*') {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6426:13): [True: 0, False: 66]
  ------------------
 6427|      0|	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
 6428|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6429|     66|	} else if (RAW == '+') {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6429:13): [True: 0, False: 66]
  ------------------
 6430|      0|	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
 6431|      0|	    NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6432|     66|	} else {
 6433|     66|	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;
 6434|     66|	}
 6435|    133|	GROW;
  ------------------
  |  | 2270|    133|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    133|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 133]
  |  |  ------------------
  |  | 2271|    133|	xmlParserGrow(ctxt);
  ------------------
 6436|    133|    }
 6437|    133|    SKIP_BLANKS;
  ------------------
  |  | 2273|    133|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6438|    221|    while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  | 2221|    221|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6438:12): [True: 89, False: 132]
  |  Branch (6438:28): [True: 89, False: 0]
  ------------------
 6439|       |        /*
 6440|       |	 * Each loop we parse one separator and one element.
 6441|       |	 */
 6442|     89|        if (RAW == ',') {
  ------------------
  |  | 2221|     89|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6442:13): [True: 67, False: 22]
  ------------------
 6443|     67|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|     67|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6443:10): [True: 67, False: 0]
  ------------------
 6444|       |
 6445|       |	    /*
 6446|       |	     * Detect "Name | Name , Name" error
 6447|       |	     */
 6448|      0|	    else if (type != CUR) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6448:15): [True: 0, False: 0]
  ------------------
 6449|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6450|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6451|      0|		                  type);
 6452|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6452:7): [True: 0, False: 0]
  |  Branch (6452:25): [True: 0, False: 0]
  ------------------
 6453|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6454|      0|		if (ret != NULL)
  ------------------
  |  Branch (6454:7): [True: 0, False: 0]
  ------------------
 6455|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6456|      0|		return(NULL);
 6457|      0|	    }
 6458|     67|	    NEXT;
  ------------------
  |  | 2275|     67|#define NEXT xmlNextChar(ctxt)
  ------------------
 6459|       |
 6460|     67|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 6461|     67|	    if (op == NULL) {
  ------------------
  |  Branch (6461:10): [True: 0, False: 67]
  ------------------
 6462|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6462:7): [True: 0, False: 0]
  |  Branch (6462:25): [True: 0, False: 0]
  ------------------
 6463|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6464|      0|	        xmlFreeDocElementContent(ctxt->myDoc, ret);
 6465|      0|		return(NULL);
 6466|      0|	    }
 6467|     67|	    if (last == NULL) {
  ------------------
  |  Branch (6467:10): [True: 67, False: 0]
  ------------------
 6468|     67|		op->c1 = ret;
 6469|     67|		if (ret != NULL)
  ------------------
  |  Branch (6469:7): [True: 67, False: 0]
  ------------------
 6470|     67|		    ret->parent = op;
 6471|     67|		ret = cur = op;
 6472|     67|	    } else {
 6473|      0|	        cur->c2 = op;
 6474|      0|		if (op != NULL)
  ------------------
  |  Branch (6474:7): [True: 0, False: 0]
  ------------------
 6475|      0|		    op->parent = cur;
 6476|      0|		op->c1 = last;
 6477|      0|		if (last != NULL)
  ------------------
  |  Branch (6477:7): [True: 0, False: 0]
  ------------------
 6478|      0|		    last->parent = op;
 6479|      0|		cur =op;
 6480|      0|		last = NULL;
 6481|      0|	    }
 6482|     67|	} else if (RAW == '|') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6482:13): [True: 22, False: 0]
  ------------------
 6483|     22|	    if (type == 0) type = CUR;
  ------------------
  |  | 2222|     22|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6483:10): [True: 22, False: 0]
  ------------------
 6484|       |
 6485|       |	    /*
 6486|       |	     * Detect "Name , Name | Name" error
 6487|       |	     */
 6488|      0|	    else if (type != CUR) {
  ------------------
  |  | 2222|      0|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (6488:15): [True: 0, False: 0]
  ------------------
 6489|      0|		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 6490|      0|		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 6491|      0|				  type);
 6492|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6492:7): [True: 0, False: 0]
  |  Branch (6492:25): [True: 0, False: 0]
  ------------------
 6493|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6494|      0|		if (ret != NULL)
  ------------------
  |  Branch (6494:7): [True: 0, False: 0]
  ------------------
 6495|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6496|      0|		return(NULL);
 6497|      0|	    }
 6498|     22|	    NEXT;
  ------------------
  |  | 2275|     22|#define NEXT xmlNextChar(ctxt)
  ------------------
 6499|       |
 6500|     22|	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 6501|     22|	    if (op == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 22]
  ------------------
 6502|      0|		if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  |  Branch (6502:25): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFreeDocElementContent(ctxt->myDoc, last);
 6504|      0|		if (ret != NULL)
  ------------------
  |  Branch (6504:7): [True: 0, False: 0]
  ------------------
 6505|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6506|      0|		return(NULL);
 6507|      0|	    }
 6508|     22|	    if (last == NULL) {
  ------------------
  |  Branch (6508:10): [True: 22, False: 0]
  ------------------
 6509|     22|		op->c1 = ret;
 6510|     22|		if (ret != NULL)
  ------------------
  |  Branch (6510:7): [True: 22, False: 0]
  ------------------
 6511|     22|		    ret->parent = op;
 6512|     22|		ret = cur = op;
 6513|     22|	    } else {
 6514|      0|	        cur->c2 = op;
 6515|      0|		if (op != NULL)
  ------------------
  |  Branch (6515:7): [True: 0, False: 0]
  ------------------
 6516|      0|		    op->parent = cur;
 6517|      0|		op->c1 = last;
 6518|      0|		if (last != NULL)
  ------------------
  |  Branch (6518:7): [True: 0, False: 0]
  ------------------
 6519|      0|		    last->parent = op;
 6520|      0|		cur =op;
 6521|      0|		last = NULL;
 6522|      0|	    }
 6523|     22|	} else {
 6524|      0|	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 6525|      0|	    if ((last != NULL) && (last != ret))
  ------------------
  |  Branch (6525:10): [True: 0, False: 0]
  |  Branch (6525:28): [True: 0, False: 0]
  ------------------
 6526|      0|	        xmlFreeDocElementContent(ctxt->myDoc, last);
 6527|      0|	    if (ret != NULL)
  ------------------
  |  Branch (6527:10): [True: 0, False: 0]
  ------------------
 6528|      0|		xmlFreeDocElementContent(ctxt->myDoc, ret);
 6529|      0|	    return(NULL);
 6530|      0|	}
 6531|     89|	GROW;
  ------------------
  |  | 2270|     89|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     89|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 89]
  |  |  ------------------
  |  | 2271|     89|	xmlParserGrow(ctxt);
  ------------------
 6532|     89|	SKIP_BLANKS;
  ------------------
  |  | 2273|     89|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6533|     89|	GROW;
  ------------------
  |  | 2270|     89|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     89|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 89]
  |  |  ------------------
  |  | 2271|     89|	xmlParserGrow(ctxt);
  ------------------
 6534|     89|	if (RAW == '(') {
  ------------------
  |  | 2221|     89|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6534:6): [True: 66, False: 23]
  ------------------
 6535|     66|	    int inputid = ctxt->input->id;
 6536|       |	    /* Recurse on second child */
 6537|     66|	    NEXT;
  ------------------
  |  | 2275|     66|#define NEXT xmlNextChar(ctxt)
  ------------------
 6538|     66|	    SKIP_BLANKS;
  ------------------
  |  | 2273|     66|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6539|     66|	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
 6540|     66|                                                          depth + 1);
 6541|     66|            if (last == NULL) {
  ------------------
  |  Branch (6541:17): [True: 0, False: 66]
  ------------------
 6542|      0|		if (ret != NULL)
  ------------------
  |  Branch (6542:7): [True: 0, False: 0]
  ------------------
 6543|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6544|      0|		return(NULL);
 6545|      0|            }
 6546|     66|	    SKIP_BLANKS;
  ------------------
  |  | 2273|     66|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6547|     66|	} else {
 6548|     23|	    elem = xmlParseName(ctxt);
 6549|     23|	    if (elem == NULL) {
  ------------------
  |  Branch (6549:10): [True: 1, False: 22]
  ------------------
 6550|      1|		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 6551|      1|		if (ret != NULL)
  ------------------
  |  Branch (6551:7): [True: 1, False: 0]
  ------------------
 6552|      1|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6553|      1|		return(NULL);
 6554|      1|	    }
 6555|     22|	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 6556|     22|	    if (last == NULL) {
  ------------------
  |  Branch (6556:10): [True: 0, False: 22]
  ------------------
 6557|      0|		if (ret != NULL)
  ------------------
  |  Branch (6557:7): [True: 0, False: 0]
  ------------------
 6558|      0|		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 6559|      0|		return(NULL);
 6560|      0|	    }
 6561|     22|	    if (RAW == '?') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6561:10): [True: 0, False: 22]
  ------------------
 6562|      0|		last->ocur = XML_ELEMENT_CONTENT_OPT;
 6563|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6564|     22|	    } else if (RAW == '*') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6564:17): [True: 0, False: 22]
  ------------------
 6565|      0|		last->ocur = XML_ELEMENT_CONTENT_MULT;
 6566|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6567|     22|	    } else if (RAW == '+') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6567:17): [True: 0, False: 22]
  ------------------
 6568|      0|		last->ocur = XML_ELEMENT_CONTENT_PLUS;
 6569|      0|		NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6570|     22|	    } else {
 6571|     22|		last->ocur = XML_ELEMENT_CONTENT_ONCE;
 6572|     22|	    }
 6573|     22|	}
 6574|     88|	SKIP_BLANKS;
  ------------------
  |  | 2273|     88|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 6575|     88|	GROW;
  ------------------
  |  | 2270|     88|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|     88|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 88]
  |  |  ------------------
  |  | 2271|     88|	xmlParserGrow(ctxt);
  ------------------
 6576|     88|    }
 6577|    132|    if ((cur != NULL) && (last != NULL)) {
  ------------------
  |  Branch (6577:9): [True: 132, False: 0]
  |  Branch (6577:26): [True: 88, False: 44]
  ------------------
 6578|     88|        cur->c2 = last;
 6579|     88|	if (last != NULL)
  ------------------
  |  Branch (6579:6): [True: 88, False: 0]
  ------------------
 6580|     88|	    last->parent = cur;
 6581|     88|    }
 6582|    132|    if (ctxt->input->id != inputchk) {
  ------------------
  |  Branch (6582:9): [True: 0, False: 132]
  ------------------
 6583|      0|	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 6584|      0|                       "Element content declaration doesn't start and stop in"
 6585|      0|                       " the same entity\n");
 6586|      0|    }
 6587|    132|    NEXT;
  ------------------
  |  | 2275|    132|#define NEXT xmlNextChar(ctxt)
  ------------------
 6588|    132|    if (RAW == '?') {
  ------------------
  |  | 2221|    132|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6588:9): [True: 0, False: 132]
  ------------------
 6589|      0|	if (ret != NULL) {
  ------------------
  |  Branch (6589:6): [True: 0, False: 0]
  ------------------
 6590|      0|	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||
  ------------------
  |  Branch (6590:10): [True: 0, False: 0]
  ------------------
 6591|      0|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6591:10): [True: 0, False: 0]
  ------------------
 6592|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6593|      0|	    else
 6594|      0|	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
 6595|      0|	}
 6596|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6597|    132|    } else if (RAW == '*') {
  ------------------
  |  | 2221|    132|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6597:16): [True: 66, False: 66]
  ------------------
 6598|     66|	if (ret != NULL) {
  ------------------
  |  Branch (6598:6): [True: 66, False: 0]
  ------------------
 6599|     66|	    ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6600|     66|	    cur = ret;
 6601|       |	    /*
 6602|       |	     * Some normalization:
 6603|       |	     * (a | b* | c?)* == (a | b | c)*
 6604|       |	     */
 6605|     88|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6605:13): [True: 88, False: 0]
  |  Branch (6605:30): [True: 22, False: 66]
  ------------------
 6606|     22|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6606:7): [True: 22, False: 0]
  ------------------
 6607|     22|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6607:15): [True: 0, False: 22]
  ------------------
 6608|     22|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6608:8): [True: 0, False: 22]
  ------------------
 6609|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6610|     22|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6610:7): [True: 22, False: 0]
  ------------------
 6611|     22|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6611:15): [True: 0, False: 22]
  ------------------
 6612|     22|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
  ------------------
  |  Branch (6612:8): [True: 0, False: 22]
  ------------------
 6613|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6614|     22|		cur = cur->c2;
 6615|     22|	    }
 6616|     66|	}
 6617|     66|	NEXT;
  ------------------
  |  | 2275|     66|#define NEXT xmlNextChar(ctxt)
  ------------------
 6618|     66|    } else if (RAW == '+') {
  ------------------
  |  | 2221|     66|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (6618:16): [True: 0, False: 66]
  ------------------
 6619|      0|	if (ret != NULL) {
  ------------------
  |  Branch (6619:6): [True: 0, False: 0]
  ------------------
 6620|      0|	    int found = 0;
 6621|       |
 6622|      0|	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6622:10): [True: 0, False: 0]
  ------------------
 6623|      0|	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
  ------------------
  |  Branch (6623:10): [True: 0, False: 0]
  ------------------
 6624|      0|	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6625|      0|	    else
 6626|      0|	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;
 6627|       |	    /*
 6628|       |	     * Some normalization:
 6629|       |	     * (a | b*)+ == (a | b)*
 6630|       |	     * (a | b?)+ == (a | b)*
 6631|       |	     */
 6632|      0|	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
  ------------------
  |  Branch (6632:13): [True: 0, False: 0]
  |  Branch (6632:30): [True: 0, False: 0]
  ------------------
 6633|      0|		if ((cur->c1 != NULL) &&
  ------------------
  |  Branch (6633:7): [True: 0, False: 0]
  ------------------
 6634|      0|	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6634:15): [True: 0, False: 0]
  ------------------
 6635|      0|		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6635:8): [True: 0, False: 0]
  ------------------
 6636|      0|		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 6637|      0|		    found = 1;
 6638|      0|		}
 6639|      0|		if ((cur->c2 != NULL) &&
  ------------------
  |  Branch (6639:7): [True: 0, False: 0]
  ------------------
 6640|      0|	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
  ------------------
  |  Branch (6640:15): [True: 0, False: 0]
  ------------------
 6641|      0|		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
  ------------------
  |  Branch (6641:8): [True: 0, False: 0]
  ------------------
 6642|      0|		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 6643|      0|		    found = 1;
 6644|      0|		}
 6645|      0|		cur = cur->c2;
 6646|      0|	    }
 6647|      0|	    if (found)
  ------------------
  |  Branch (6647:10): [True: 0, False: 0]
  ------------------
 6648|      0|		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 6649|      0|	}
 6650|      0|	NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 6651|      0|    }
 6652|    132|    return(ret);
 6653|    133|}
parser.c:xmlDetectSAX2:
  857|    486|xmlDetectSAX2(xmlParserCtxtPtr ctxt) {
  858|    486|    xmlSAXHandlerPtr sax;
  859|       |
  860|       |    /* Avoid unused variable warning if features are disabled. */
  861|    486|    (void) sax;
  862|       |
  863|    486|    if (ctxt == NULL) return;
  ------------------
  |  Branch (863:9): [True: 0, False: 486]
  ------------------
  864|    486|    sax = ctxt->sax;
  865|    486|#ifdef LIBXML_SAX1_ENABLED
  866|    486|    if ((sax) && (sax->initialized == XML_SAX2_MAGIC))
  ------------------
  |  |  685|    486|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (866:9): [True: 486, False: 0]
  |  Branch (866:18): [True: 486, False: 0]
  ------------------
  867|    486|        ctxt->sax2 = 1;
  868|       |#else
  869|       |    ctxt->sax2 = 1;
  870|       |#endif /* LIBXML_SAX1_ENABLED */
  871|       |
  872|    486|    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST "xml", 3);
  ------------------
  |  |   35|    486|#define BAD_CAST (xmlChar *)
  ------------------
  873|    486|    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST "xmlns", 5);
  ------------------
  |  |   35|    486|#define BAD_CAST (xmlChar *)
  ------------------
  874|    486|    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);
  ------------------
  |  |  143|    486|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  875|    486|    if ((ctxt->str_xml==NULL) || (ctxt->str_xmlns==NULL) ||
  ------------------
  |  Branch (875:9): [True: 0, False: 486]
  |  Branch (875:34): [True: 0, False: 486]
  ------------------
  876|    486|		(ctxt->str_xml_ns == NULL)) {
  ------------------
  |  Branch (876:3): [True: 0, False: 486]
  ------------------
  877|      0|        xmlErrMemory(ctxt, NULL);
  878|      0|    }
  879|    486|}
parser.c:xmlParseNameAndCompare:
 3682|  2.70k|xmlParseNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *other) {
 3683|  2.70k|    register const xmlChar *cmp = other;
 3684|  2.70k|    register const xmlChar *in;
 3685|  2.70k|    const xmlChar *ret;
 3686|       |
 3687|  2.70k|    GROW;
  ------------------
  |  | 2270|  2.70k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.70k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.77k, False: 935]
  |  |  ------------------
  |  | 2271|  2.70k|	xmlParserGrow(ctxt);
  ------------------
 3688|  2.70k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3688:9): [True: 0, False: 2.70k]
  ------------------
 3689|      0|        return(NULL);
 3690|       |
 3691|  2.70k|    in = ctxt->input->cur;
 3692|  11.8k|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (3692:12): [True: 11.8k, False: 1]
  |  Branch (3692:24): [True: 9.14k, False: 2.70k]
  ------------------
 3693|  9.14k|	++in;
 3694|  9.14k|	++cmp;
 3695|  9.14k|    }
 3696|  2.70k|    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      4|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      4|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  |  |   89|      4|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 3, False: 1]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 3]
  |  |  |  |  ------------------
  |  |  |  |   90|      4|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 4]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (3696:9): [True: 2.67k, False: 31]
  |  Branch (3696:23): [True: 2.67k, False: 4]
  ------------------
 3697|       |	/* success */
 3698|  2.67k|	ctxt->input->col += in - ctxt->input->cur;
 3699|  2.67k|	ctxt->input->cur = in;
 3700|  2.67k|	return (const xmlChar*) 1;
 3701|  2.67k|    }
 3702|       |    /* failure (or end of input buffer), check with full function */
 3703|     35|    ret = xmlParseName (ctxt);
 3704|       |    /* strings coming from the dictionary direct compare possible */
 3705|     35|    if (ret == other) {
  ------------------
  |  Branch (3705:9): [True: 1, False: 34]
  ------------------
 3706|      1|	return (const xmlChar*) 1;
 3707|      1|    }
 3708|     34|    return ret;
 3709|     35|}
parser.c:spacePop:
 2173|  2.95k|static int spacePop(xmlParserCtxtPtr ctxt) {
 2174|  2.95k|    int ret;
 2175|  2.95k|    if (ctxt->spaceNr <= 0) return(0);
  ------------------
  |  Branch (2175:9): [True: 0, False: 2.95k]
  ------------------
 2176|  2.95k|    ctxt->spaceNr--;
 2177|  2.95k|    if (ctxt->spaceNr > 0)
  ------------------
  |  Branch (2177:9): [True: 2.95k, False: 0]
  ------------------
 2178|  2.95k|	ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];
 2179|      0|    else
 2180|      0|        ctxt->space = &ctxt->spaceTab[0];
 2181|  2.95k|    ret = ctxt->spaceTab[ctxt->spaceNr];
 2182|  2.95k|    ctxt->spaceTab[ctxt->spaceNr] = -1;
 2183|  2.95k|    return(ret);
 2184|  2.95k|}
parser.c:xmlParseAttValueInternal:
 9115|    914|{
 9116|    914|    xmlChar limit = 0;
 9117|    914|    const xmlChar *in = NULL, *start, *end, *last;
 9118|    914|    xmlChar *ret = NULL;
 9119|    914|    int line, col;
 9120|    914|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (9120:21): [True: 0, False: 914]
  ------------------
 9121|      0|                    XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 9122|    914|                    XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    914|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 9123|       |
 9124|    914|    GROW;
  ------------------
  |  | 2270|    914|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    914|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 426, False: 488]
  |  |  ------------------
  |  | 2271|    914|	xmlParserGrow(ctxt);
  ------------------
 9125|    914|    in = (xmlChar *) CUR_PTR;
  ------------------
  |  | 2224|    914|#define CUR_PTR ctxt->input->cur
  ------------------
 9126|    914|    line = ctxt->input->line;
 9127|    914|    col = ctxt->input->col;
 9128|    914|    if (*in != '"' && *in != '\'') {
  ------------------
  |  Branch (9128:9): [True: 0, False: 914]
  |  Branch (9128:23): [True: 0, False: 0]
  ------------------
 9129|      0|        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 9130|      0|        return (NULL);
 9131|      0|    }
 9132|    914|    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 9133|       |
 9134|       |    /*
 9135|       |     * try to handle in this routine the most common case where no
 9136|       |     * allocation of a new string is required and where content is
 9137|       |     * pure ASCII.
 9138|       |     */
 9139|    914|    limit = *in++;
 9140|    914|    col++;
 9141|    914|    end = ctxt->input->end;
 9142|    914|    start = in;
 9143|    914|    if (in >= end) {
  ------------------
  |  Branch (9143:9): [True: 0, False: 914]
  ------------------
 9144|      0|        GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9145|      0|    }
 9146|    914|    if (normalize) {
  ------------------
  |  Branch (9146:9): [True: 110, False: 804]
  ------------------
 9147|       |        /*
 9148|       |	 * Skip any leading spaces
 9149|       |	 */
 9150|    110|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9150:9): [True: 110, False: 0]
  |  Branch (9150:23): [True: 110, False: 0]
  ------------------
 9151|    110|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9151:10): [True: 0, False: 110]
  |  Branch (9151:27): [True: 0, False: 110]
  ------------------
 9152|    110|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9152:10): [True: 0, False: 110]
  |  Branch (9152:26): [True: 0, False: 110]
  ------------------
 9153|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9153:10): [True: 0, False: 0]
  ------------------
 9154|      0|	        line++; col = 1;
 9155|      0|	    } else {
 9156|      0|	        col++;
 9157|      0|	    }
 9158|      0|	    in++;
 9159|      0|	    start = in;
 9160|      0|	    if (in >= end) {
  ------------------
  |  Branch (9160:10): [True: 0, False: 0]
  ------------------
 9161|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9162|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9162:21): [True: 0, False: 0]
  ------------------
 9163|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9164|      0|                                   "AttValue length too long\n");
 9165|      0|                    return(NULL);
 9166|      0|                }
 9167|      0|	    }
 9168|      0|	}
 9169|    990|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9169:9): [True: 990, False: 0]
  |  Branch (9169:23): [True: 880, False: 110]
  |  Branch (9169:41): [True: 880, False: 0]
  ------------------
 9170|    990|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9170:9): [True: 880, False: 0]
  |  Branch (9170:26): [True: 880, False: 0]
  |  Branch (9170:42): [True: 880, False: 0]
  ------------------
 9171|    880|	    col++;
 9172|    880|	    if ((*in++ == 0x20) && (*in == 0x20)) break;
  ------------------
  |  Branch (9172:10): [True: 0, False: 880]
  |  Branch (9172:29): [True: 0, False: 0]
  ------------------
 9173|    880|	    if (in >= end) {
  ------------------
  |  Branch (9173:10): [True: 0, False: 880]
  ------------------
 9174|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9175|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9175:21): [True: 0, False: 0]
  ------------------
 9176|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9177|      0|                                   "AttValue length too long\n");
 9178|      0|                    return(NULL);
 9179|      0|                }
 9180|      0|	    }
 9181|    880|	}
 9182|    110|	last = in;
 9183|       |	/*
 9184|       |	 * skip the trailing blanks
 9185|       |	 */
 9186|    110|	while ((last[-1] == 0x20) && (last > start)) last--;
  ------------------
  |  Branch (9186:9): [True: 0, False: 110]
  |  Branch (9186:31): [True: 0, False: 0]
  ------------------
 9187|    110|	while ((in < end) && (*in != limit) &&
  ------------------
  |  Branch (9187:9): [True: 110, False: 0]
  |  Branch (9187:23): [True: 0, False: 110]
  ------------------
 9188|    110|	       ((*in == 0x20) || (*in == 0x9) ||
  ------------------
  |  Branch (9188:10): [True: 0, False: 0]
  |  Branch (9188:27): [True: 0, False: 0]
  ------------------
 9189|      0|	        (*in == 0xA) || (*in == 0xD))) {
  ------------------
  |  Branch (9189:10): [True: 0, False: 0]
  |  Branch (9189:26): [True: 0, False: 0]
  ------------------
 9190|      0|	    if (*in == 0xA) {
  ------------------
  |  Branch (9190:10): [True: 0, False: 0]
  ------------------
 9191|      0|	        line++, col = 1;
 9192|      0|	    } else {
 9193|      0|	        col++;
 9194|      0|	    }
 9195|      0|	    in++;
 9196|      0|	    if (in >= end) {
  ------------------
  |  Branch (9196:10): [True: 0, False: 0]
  ------------------
 9197|      0|		const xmlChar *oldbase = ctxt->input->base;
 9198|      0|		GROW;
  ------------------
  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  ------------------
  |  | 2271|      0|	xmlParserGrow(ctxt);
  ------------------
 9199|      0|                if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9199:21): [True: 0, False: 0]
  ------------------
 9200|      0|                    return(NULL);
 9201|      0|		if (oldbase != ctxt->input->base) {
  ------------------
  |  Branch (9201:7): [True: 0, False: 0]
  ------------------
 9202|      0|		    ptrdiff_t delta = ctxt->input->base - oldbase;
 9203|      0|		    start = start + delta;
 9204|      0|		    in = in + delta;
 9205|      0|		    last = last + delta;
 9206|      0|		}
 9207|      0|		end = ctxt->input->end;
 9208|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9208:21): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9210|      0|                                   "AttValue length too long\n");
 9211|      0|                    return(NULL);
 9212|      0|                }
 9213|      0|	    }
 9214|      0|	}
 9215|    110|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9215:13): [True: 0, False: 110]
  ------------------
 9216|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9217|      0|                           "AttValue length too long\n");
 9218|      0|            return(NULL);
 9219|      0|        }
 9220|    110|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9220:6): [True: 0, False: 110]
  ------------------
 9221|    804|    } else {
 9222|  6.39k|	while ((in < end) && (*in != limit) && (*in >= 0x20) &&
  ------------------
  |  Branch (9222:9): [True: 6.39k, False: 0]
  |  Branch (9222:23): [True: 5.70k, False: 694]
  |  Branch (9222:41): [True: 5.70k, False: 1]
  ------------------
 9223|  6.39k|	       (*in <= 0x7f) && (*in != '&') && (*in != '<')) {
  ------------------
  |  Branch (9223:9): [True: 5.69k, False: 3]
  |  Branch (9223:26): [True: 5.59k, False: 105]
  |  Branch (9223:42): [True: 5.59k, False: 1]
  ------------------
 9224|  5.59k|	    in++;
 9225|  5.59k|	    col++;
 9226|  5.59k|	    if (in >= end) {
  ------------------
  |  Branch (9226:10): [True: 0, False: 5.59k]
  ------------------
 9227|      0|                GROW_PARSE_ATT_VALUE_INTERNAL(ctxt, in, start, end)
  ------------------
  |  | 9101|      0|    const xmlChar *oldbase = ctxt->input->base;\
  |  | 9102|      0|    GROW;\
  |  |  ------------------
  |  |  |  | 2270|      0|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  |  |  ------------------
  |  |  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2270:18): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  | 2271|      0|	xmlParserGrow(ctxt);
  |  |  ------------------
  |  | 9103|      0|    if (ctxt->instate == XML_PARSER_EOF)\
  |  |  ------------------
  |  |  |  Branch (9103:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9104|      0|        return(NULL);\
  |  | 9105|      0|    if (oldbase != ctxt->input->base) {\
  |  |  ------------------
  |  |  |  Branch (9105:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 9106|      0|        ptrdiff_t delta = ctxt->input->base - oldbase;\
  |  | 9107|      0|        start = start + delta;\
  |  | 9108|      0|        in = in + delta;\
  |  | 9109|      0|    }\
  |  | 9110|      0|    end = ctxt->input->end;
  ------------------
 9228|      0|                if ((in - start) > maxLength) {
  ------------------
  |  Branch (9228:21): [True: 0, False: 0]
  ------------------
 9229|      0|                    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9230|      0|                                   "AttValue length too long\n");
 9231|      0|                    return(NULL);
 9232|      0|                }
 9233|      0|	    }
 9234|  5.59k|	}
 9235|    804|	last = in;
 9236|    804|        if ((in - start) > maxLength) {
  ------------------
  |  Branch (9236:13): [True: 0, False: 804]
  ------------------
 9237|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 9238|      0|                           "AttValue length too long\n");
 9239|      0|            return(NULL);
 9240|      0|        }
 9241|    804|	if (*in != limit) goto need_complex;
  ------------------
  |  Branch (9241:6): [True: 110, False: 694]
  ------------------
 9242|    804|    }
 9243|    804|    in++;
 9244|    804|    col++;
 9245|    804|    if (len != NULL) {
  ------------------
  |  Branch (9245:9): [True: 804, False: 0]
  ------------------
 9246|    804|        if (alloc) *alloc = 0;
  ------------------
  |  Branch (9246:13): [True: 804, False: 0]
  ------------------
 9247|    804|        *len = last - start;
 9248|    804|        ret = (xmlChar *) start;
 9249|    804|    } else {
 9250|      0|        if (alloc) *alloc = 1;
  ------------------
  |  Branch (9250:13): [True: 0, False: 0]
  ------------------
 9251|      0|        ret = xmlStrndup(start, last - start);
 9252|      0|    }
 9253|    804|    CUR_PTR = in;
  ------------------
  |  | 2224|    804|#define CUR_PTR ctxt->input->cur
  ------------------
 9254|    804|    ctxt->input->line = line;
 9255|    804|    ctxt->input->col = col;
 9256|    804|    return ret;
 9257|    110|need_complex:
 9258|    110|    if (alloc) *alloc = 1;
  ------------------
  |  Branch (9258:9): [True: 110, False: 0]
  ------------------
 9259|    110|    return xmlParseAttValueComplex(ctxt, len, normalize);
 9260|    914|}
parser.c:xmlParseAttValueComplex:
 4056|    110|xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
 4057|    110|    xmlChar limit = 0;
 4058|    110|    xmlChar *buf = NULL;
 4059|    110|    xmlChar *rep = NULL;
 4060|    110|    size_t len = 0;
 4061|    110|    size_t buf_size = 0;
 4062|    110|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (4062:24): [True: 0, False: 110]
  ------------------
 4063|      0|                       XML_MAX_HUGE_LENGTH :
  ------------------
  |  |   49|      0|#define XML_MAX_HUGE_LENGTH 1000000000
  ------------------
 4064|    110|                       XML_MAX_TEXT_LENGTH;
  ------------------
  |  |   42|    220|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 4065|    110|    int c, l, in_space = 0;
 4066|    110|    xmlChar *current = NULL;
 4067|    110|    xmlEntityPtr ent;
 4068|       |
 4069|    110|    if (NXT(0) == '"') {
  ------------------
  |  | 2223|    110|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4069:9): [True: 110, False: 0]
  ------------------
 4070|    110|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4071|    110|	limit = '"';
 4072|    110|        NEXT;
  ------------------
  |  | 2275|    110|#define NEXT xmlNextChar(ctxt)
  ------------------
 4073|    110|    } else if (NXT(0) == '\'') {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4073:16): [True: 0, False: 0]
  ------------------
 4074|      0|	limit = '\'';
 4075|      0|	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 4076|      0|        NEXT;
  ------------------
  |  | 2275|      0|#define NEXT xmlNextChar(ctxt)
  ------------------
 4077|      0|    } else {
 4078|      0|	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 4079|      0|	return(NULL);
 4080|      0|    }
 4081|       |
 4082|       |    /*
 4083|       |     * allocate a translation buffer.
 4084|       |     */
 4085|    110|    buf_size = XML_PARSER_BUFFER_SIZE;
  ------------------
  |  |  167|    110|#define XML_PARSER_BUFFER_SIZE 100
  ------------------
 4086|    110|    buf = (xmlChar *) xmlMallocAtomic(buf_size);
 4087|    110|    if (buf == NULL) goto mem_error;
  ------------------
  |  Branch (4087:9): [True: 0, False: 110]
  ------------------
 4088|       |
 4089|       |    /*
 4090|       |     * OK loop until we reach one of the ending char or a size limit.
 4091|       |     */
 4092|    110|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|    110|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4093|  1.50k|    while (((NXT(0) != limit) && /* checked */
  ------------------
  |  | 2223|  1.50k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4093:13): [True: 1.39k, False: 104]
  ------------------
 4094|  1.50k|            (IS_CHAR(c)) && (c != '<')) &&
  ------------------
  |  |  125|  1.39k|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|  1.39k|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 1.21k, False: 182]
  |  |  |  |  ------------------
  |  |  |  |  119|  1.39k|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|  1.21k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 1.21k, False: 4]
  |  |  |  |  |  |  |  Branch (108:44): [True: 1, False: 1.21k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|  1.21k|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 1.21k]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|  1.21k|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 1.21k, False: 4]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|  1.39k|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 182, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 182]
  |  |  |  |  ------------------
  |  |  |  |  121|    182|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 182, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 182, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|    182|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4094:13): [True: 1.39k, False: 4]
  |  Branch (4094:29): [True: 1.39k, False: 2]
  ------------------
 4095|  1.50k|            (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (4095:13): [True: 1.39k, False: 0]
  ------------------
 4096|  1.39k|	if (c == '&') {
  ------------------
  |  Branch (4096:6): [True: 105, False: 1.28k]
  ------------------
 4097|    105|	    in_space = 0;
 4098|    105|	    if (NXT(1) == '#') {
  ------------------
  |  | 2223|    105|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (4098:10): [True: 0, False: 105]
  ------------------
 4099|      0|		int val = xmlParseCharRef(ctxt);
 4100|       |
 4101|      0|		if (val == '&') {
  ------------------
  |  Branch (4101:7): [True: 0, False: 0]
  ------------------
 4102|      0|		    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (4102:11): [True: 0, False: 0]
  ------------------
 4103|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4103:8): [True: 0, False: 0]
  ------------------
 4104|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4105|      0|			}
 4106|      0|			buf[len++] = '&';
 4107|      0|		    } else {
 4108|       |			/*
 4109|       |			 * The reparsing will be done in xmlStringGetNodeList()
 4110|       |			 * called by the attribute() function in SAX.c
 4111|       |			 */
 4112|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4112:8): [True: 0, False: 0]
  ------------------
 4113|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4114|      0|			}
 4115|      0|			buf[len++] = '&';
 4116|      0|			buf[len++] = '#';
 4117|      0|			buf[len++] = '3';
 4118|      0|			buf[len++] = '8';
 4119|      0|			buf[len++] = ';';
 4120|      0|		    }
 4121|      0|		} else if (val != 0) {
  ------------------
  |  Branch (4121:14): [True: 0, False: 0]
  ------------------
 4122|      0|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4122:11): [True: 0, False: 0]
  ------------------
 4123|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4124|      0|		    }
 4125|      0|		    len += xmlCopyChar(0, &buf[len], val);
 4126|      0|		}
 4127|    105|	    } else {
 4128|    105|		ent = xmlParseEntityRef(ctxt);
 4129|    105|		if ((ent != NULL) &&
  ------------------
  |  Branch (4129:7): [True: 102, False: 3]
  ------------------
 4130|    105|		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (4130:7): [True: 102, False: 0]
  ------------------
 4131|    102|		    if (len + 10 > buf_size) {
  ------------------
  |  Branch (4131:11): [True: 0, False: 102]
  ------------------
 4132|      0|			growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4133|      0|		    }
 4134|    102|		    if ((ctxt->replaceEntities == 0) &&
  ------------------
  |  Branch (4134:11): [True: 102, False: 0]
  ------------------
 4135|    102|		        (ent->content[0] == '&')) {
  ------------------
  |  Branch (4135:11): [True: 102, False: 0]
  ------------------
 4136|    102|			buf[len++] = '&';
 4137|    102|			buf[len++] = '#';
 4138|    102|			buf[len++] = '3';
 4139|    102|			buf[len++] = '8';
 4140|    102|			buf[len++] = ';';
 4141|    102|		    } else {
 4142|      0|			buf[len++] = ent->content[0];
 4143|      0|		    }
 4144|    102|		} else if ((ent != NULL) &&
  ------------------
  |  Branch (4144:14): [True: 0, False: 3]
  ------------------
 4145|      3|		           (ctxt->replaceEntities != 0)) {
  ------------------
  |  Branch (4145:14): [True: 0, False: 0]
  ------------------
 4146|      0|		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
  ------------------
  |  Branch (4146:11): [True: 0, False: 0]
  ------------------
 4147|      0|                        if (xmlParserEntityCheck(ctxt, ent->length))
  ------------------
  |  Branch (4147:29): [True: 0, False: 0]
  ------------------
 4148|      0|                            goto error;
 4149|       |
 4150|      0|			++ctxt->depth;
 4151|      0|			rep = xmlStringDecodeEntitiesInt(ctxt, ent->content,
 4152|      0|                                ent->length, XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4153|      0|                                /* check */ 1);
 4154|      0|			--ctxt->depth;
 4155|      0|			if (rep != NULL) {
  ------------------
  |  Branch (4155:8): [True: 0, False: 0]
  ------------------
 4156|      0|			    current = rep;
 4157|      0|			    while (*current != 0) { /* non input consuming */
  ------------------
  |  Branch (4157:15): [True: 0, False: 0]
  ------------------
 4158|      0|                                if ((*current == 0xD) || (*current == 0xA) ||
  ------------------
  |  Branch (4158:37): [True: 0, False: 0]
  |  Branch (4158:58): [True: 0, False: 0]
  ------------------
 4159|      0|                                    (*current == 0x9)) {
  ------------------
  |  Branch (4159:37): [True: 0, False: 0]
  ------------------
 4160|      0|                                    buf[len++] = 0x20;
 4161|      0|                                    current++;
 4162|      0|                                } else
 4163|      0|                                    buf[len++] = *current++;
 4164|      0|				if (len + 10 > buf_size) {
  ------------------
  |  Branch (4164:9): [True: 0, False: 0]
  ------------------
 4165|      0|				    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4166|      0|				}
 4167|      0|			    }
 4168|      0|			    xmlFree(rep);
 4169|      0|			    rep = NULL;
 4170|      0|			}
 4171|      0|		    } else {
 4172|      0|			if (len + 10 > buf_size) {
  ------------------
  |  Branch (4172:8): [True: 0, False: 0]
  ------------------
 4173|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4174|      0|			}
 4175|      0|			if (ent->content != NULL)
  ------------------
  |  Branch (4175:8): [True: 0, False: 0]
  ------------------
 4176|      0|			    buf[len++] = ent->content[0];
 4177|      0|		    }
 4178|      3|		} else if (ent != NULL) {
  ------------------
  |  Branch (4178:14): [True: 0, False: 3]
  ------------------
 4179|      0|		    int i = xmlStrlen(ent->name);
 4180|      0|		    const xmlChar *cur = ent->name;
 4181|       |
 4182|       |		    /*
 4183|       |                     * We also check for recursion and amplification
 4184|       |                     * when entities are not substituted. They're
 4185|       |                     * often expanded later.
 4186|       |		     */
 4187|      0|		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
  ------------------
  |  Branch (4187:11): [True: 0, False: 0]
  ------------------
 4188|      0|			(ent->content != NULL)) {
  ------------------
  |  Branch (4188:4): [True: 0, False: 0]
  ------------------
 4189|      0|                        if ((ent->flags & XML_ENT_CHECKED) == 0) {
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
  |  Branch (4189:29): [True: 0, False: 0]
  ------------------
 4190|      0|                            unsigned long oldCopy = ctxt->sizeentcopy;
 4191|       |
 4192|      0|                            ctxt->sizeentcopy = ent->length;
 4193|       |
 4194|      0|                            ++ctxt->depth;
 4195|      0|                            rep = xmlStringDecodeEntitiesInt(ctxt,
 4196|      0|                                    ent->content, ent->length,
 4197|      0|                                    XML_SUBSTITUTE_REF, 0, 0, 0,
  ------------------
  |  |  521|      0|#define XML_SUBSTITUTE_REF	1
  ------------------
 4198|      0|                                    /* check */ 1);
 4199|      0|                            --ctxt->depth;
 4200|       |
 4201|       |                            /*
 4202|       |                             * If we're parsing DTD content, the entity
 4203|       |                             * might reference other entities which
 4204|       |                             * weren't defined yet, so the check isn't
 4205|       |                             * reliable.
 4206|       |                             */
 4207|      0|                            if (ctxt->inSubset == 0) {
  ------------------
  |  Branch (4207:33): [True: 0, False: 0]
  ------------------
 4208|      0|                                ent->flags |= XML_ENT_CHECKED;
  ------------------
  |  |   15|      0|#define XML_ENT_CHECKED     (1<<1)
  ------------------
 4209|      0|                                ent->expandedSize = ctxt->sizeentcopy;
 4210|      0|                            }
 4211|       |
 4212|      0|                            if (rep != NULL) {
  ------------------
  |  Branch (4212:33): [True: 0, False: 0]
  ------------------
 4213|      0|                                xmlFree(rep);
 4214|      0|                                rep = NULL;
 4215|      0|                            } else {
 4216|      0|                                ent->content[0] = 0;
 4217|      0|                            }
 4218|       |
 4219|      0|                            if (xmlParserEntityCheck(ctxt, oldCopy))
  ------------------
  |  Branch (4219:33): [True: 0, False: 0]
  ------------------
 4220|      0|                                goto error;
 4221|      0|                        } else {
 4222|      0|                            if (xmlParserEntityCheck(ctxt, ent->expandedSize))
  ------------------
  |  Branch (4222:33): [True: 0, False: 0]
  ------------------
 4223|      0|                                goto error;
 4224|      0|                        }
 4225|      0|		    }
 4226|       |
 4227|       |		    /*
 4228|       |		     * Just output the reference
 4229|       |		     */
 4230|      0|		    buf[len++] = '&';
 4231|      0|		    while (len + i + 10 > buf_size) {
  ------------------
  |  Branch (4231:14): [True: 0, False: 0]
  ------------------
 4232|      0|			growBuffer(buf, i + 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4233|      0|		    }
 4234|      0|		    for (;i > 0;i--)
  ------------------
  |  Branch (4234:13): [True: 0, False: 0]
  ------------------
 4235|      0|			buf[len++] = *cur++;
 4236|      0|		    buf[len++] = ';';
 4237|      0|		}
 4238|    105|	    }
 4239|  1.28k|	} else {
 4240|  1.28k|	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
  ------------------
  |  Branch (4240:10): [True: 214, False: 1.07k]
  |  Branch (4240:25): [True: 0, False: 1.07k]
  |  Branch (4240:39): [True: 1, False: 1.07k]
  |  Branch (4240:53): [True: 0, False: 1.07k]
  ------------------
 4241|    215|	        if ((len != 0) || (!normalize)) {
  ------------------
  |  Branch (4241:14): [True: 214, False: 1]
  |  Branch (4241:28): [True: 1, False: 0]
  ------------------
 4242|    215|		    if ((!normalize) || (!in_space)) {
  ------------------
  |  Branch (4242:11): [True: 215, False: 0]
  |  Branch (4242:27): [True: 0, False: 0]
  ------------------
 4243|    215|			COPY_BUF(buf, len, 0x20);
  ------------------
  |  | 2295|    215|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [Folded - Ignored]
  |  |  ------------------
  |  | 2296|    215|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4244|    215|			while (len + 10 > buf_size) {
  ------------------
  |  Branch (4244:11): [True: 0, False: 215]
  ------------------
 4245|      0|			    growBuffer(buf, 10);
  ------------------
  |  | 2774|      0|#define growBuffer(buffer, n) {						\
  |  | 2775|      0|    xmlChar *tmp;							\
  |  | 2776|      0|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      0|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2778|      0|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      0|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2780|      0|    buffer = tmp;							\
  |  | 2781|      0|    buffer##_size = new_size;                                           \
  |  | 2782|      0|}
  ------------------
 4246|      0|			}
 4247|    215|		    }
 4248|    215|		    in_space = 1;
 4249|    215|		}
 4250|  1.07k|	    } else {
 4251|  1.07k|	        in_space = 0;
 4252|  1.07k|		COPY_BUF(buf, len, c);
  ------------------
  |  | 2295|  1.07k|    if (v < 0x80) b[i++] = v;						\
  |  |  ------------------
  |  |  |  Branch (2295:9): [True: 890, False: 182]
  |  |  ------------------
  |  | 2296|  1.07k|    else i += xmlCopyCharMultiByte(&b[i],v)
  ------------------
 4253|  1.07k|		if (len + 10 > buf_size) {
  ------------------
  |  Branch (4253:7): [True: 3, False: 1.06k]
  ------------------
 4254|      6|		    growBuffer(buf, 10);
  ------------------
  |  | 2774|      3|#define growBuffer(buffer, n) {						\
  |  | 2775|      3|    xmlChar *tmp;							\
  |  | 2776|      3|    size_t new_size = buffer##_size * 2 + n;                            \
  |  | 2777|      3|    if (new_size < buffer##_size) goto mem_error;                       \
  |  |  ------------------
  |  |  |  Branch (2777:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2778|      3|    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \
  |  | 2779|      3|    if (tmp == NULL) goto mem_error;					\
  |  |  ------------------
  |  |  |  Branch (2779:9): [True: 0, False: 3]
  |  |  ------------------
  |  | 2780|      3|    buffer = tmp;							\
  |  | 2781|      3|    buffer##_size = new_size;                                           \
  |  | 2782|      3|}
  ------------------
 4255|      6|		}
 4256|  1.07k|	    }
 4257|  1.28k|	    NEXTL(l);
  ------------------
  |  | 2284|  1.28k|#define NEXTL(l) do {							\
  |  | 2285|  1.28k|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 1, False: 1.28k]
  |  |  ------------------
  |  | 2286|      1|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|  1.28k|    } else ctxt->input->col++;						\
  |  | 2288|  1.28k|    ctxt->input->cur += l;				\
  |  | 2289|  1.28k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 4258|  1.28k|	}
 4259|  1.39k|	GROW;
  ------------------
  |  | 2270|  1.39k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  1.39k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 653, False: 739]
  |  |  ------------------
  |  | 2271|  1.39k|	xmlParserGrow(ctxt);
  ------------------
 4260|  1.39k|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|  1.39k|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 4261|  1.39k|        if (len > maxLength) {
  ------------------
  |  Branch (4261:13): [True: 0, False: 1.39k]
  ------------------
 4262|      0|            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4263|      0|                           "AttValue length too long\n");
 4264|      0|            goto mem_error;
 4265|      0|        }
 4266|  1.39k|    }
 4267|    110|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (4267:9): [True: 0, False: 110]
  ------------------
 4268|      0|        goto error;
 4269|       |
 4270|    110|    if ((in_space) && (normalize)) {
  ------------------
  |  Branch (4270:9): [True: 2, False: 108]
  |  Branch (4270:23): [True: 0, False: 2]
  ------------------
 4271|      0|        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
  ------------------
  |  Branch (4271:16): [True: 0, False: 0]
  |  Branch (4271:29): [True: 0, False: 0]
  ------------------
 4272|      0|    }
 4273|    110|    buf[len] = 0;
 4274|    110|    if (RAW == '<') {
  ------------------
  |  | 2221|    110|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4274:9): [True: 2, False: 108]
  ------------------
 4275|      2|	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
 4276|    108|    } else if (RAW != limit) {
  ------------------
  |  | 2221|    108|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (4276:16): [True: 4, False: 104]
  ------------------
 4277|      4|	if ((c != 0) && (!IS_CHAR(c))) {
  ------------------
  |  |  125|      1|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|      1|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 1, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  119|      1|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      1|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      1|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      1|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|      1|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|      0|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|      0|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (4277:6): [True: 1, False: 3]
  |  Branch (4277:18): [True: 1, False: 0]
  ------------------
 4278|      1|	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 4279|      1|			   "invalid character in attribute value\n");
 4280|      3|	} else {
 4281|      3|	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 4282|      3|			   "AttValue: ' expected\n");
 4283|      3|        }
 4284|      4|    } else
 4285|    104|	NEXT;
  ------------------
  |  | 2275|    104|#define NEXT xmlNextChar(ctxt)
  ------------------
 4286|       |
 4287|    110|    if (attlen != NULL) *attlen = len;
  ------------------
  |  Branch (4287:9): [True: 110, False: 0]
  ------------------
 4288|    110|    return(buf);
 4289|       |
 4290|      0|mem_error:
 4291|      0|    xmlErrMemory(ctxt, NULL);
 4292|      0|error:
 4293|      0|    if (buf != NULL)
  ------------------
  |  Branch (4293:9): [True: 0, False: 0]
  ------------------
 4294|      0|        xmlFree(buf);
 4295|      0|    if (rep != NULL)
  ------------------
  |  Branch (4295:9): [True: 0, False: 0]
  ------------------
 4296|      0|        xmlFree(rep);
 4297|      0|    return(NULL);
 4298|      0|}
parser.c:xmlParseContentInternal:
10210|    472|xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
10211|    472|    int nameNr = ctxt->nameNr;
10212|       |
10213|    472|    GROW;
  ------------------
  |  | 2270|    472|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    472|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 358, False: 114]
  |  |  ------------------
  |  | 2271|    472|	xmlParserGrow(ctxt);
  ------------------
10214|  10.0k|    while ((ctxt->input->cur < ctxt->input->end) &&
  ------------------
  |  Branch (10214:12): [True: 10.0k, False: 9]
  ------------------
10215|  10.0k|	   (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (10215:5): [True: 10.0k, False: 0]
  ------------------
10216|  10.0k|	const xmlChar *cur = ctxt->input->cur;
10217|       |
10218|       |	/*
10219|       |	 * First case : a Processing Instruction.
10220|       |	 */
10221|  10.0k|	if ((*cur == '<') && (cur[1] == '?')) {
  ------------------
  |  Branch (10221:6): [True: 5.25k, False: 4.81k]
  |  Branch (10221:23): [True: 12, False: 5.23k]
  ------------------
10222|     12|	    xmlParsePI(ctxt);
10223|     12|	}
10224|       |
10225|       |	/*
10226|       |	 * Second case : a CDSection
10227|       |	 */
10228|       |	/* 2.6.0 test was *cur not RAW */
10229|  10.0k|	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
  ------------------
  |  | 2239|  10.0k|  ( CMP8( s, c1, c2, c3, c4, c5, c6, c7, c8 ) && \
  |  |  ------------------
  |  |  |  | 2237|  20.1k|  ( CMP7( s, c1, c2, c3, c4, c5, c6, c7 ) && ((unsigned char *) s)[ 7 ] == c8 )
  |  |  |  |  ------------------
  |  |  |  |  |  | 2235|  20.1k|  ( CMP6( s, c1, c2, c3, c4, c5, c6 ) && ((unsigned char *) s)[ 6 ] == c7 )
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  | 2233|  20.1k|  ( CMP5( s, c1, c2, c3, c4, c5 ) && ((unsigned char *) s)[ 5 ] == c6 )
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  | 2231|  20.1k|  ( CMP4( s, c1, c2, c3, c4 ) && ((unsigned char *) s)[ 4 ] == c5 )
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2228|  20.1k|  ( ((unsigned char *) s)[ 0 ] == c1 && ((unsigned char *) s)[ 1 ] == c2 && \
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:5): [True: 5.23k, False: 4.81k]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2228:41): [True: 49, False: 5.19k]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  | 2229|  10.0k|    ((unsigned char *) s)[ 2 ] == c3 && ((unsigned char *) s)[ 3 ] == c4 )
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:5): [True: 12, False: 37]
  |  |  |  |  |  |  |  |  |  |  |  |  |  Branch (2229:41): [True: 12, False: 0]
  |  |  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  |  |  Branch (2231:34): [True: 12, False: 0]
  |  |  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (2233:38): [True: 12, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (2235:42): [True: 12, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2237:46): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 2240|  10.0k|    ((unsigned char *) s)[ 8 ] == c9 )
  |  |  ------------------
  |  |  |  Branch (2240:5): [True: 12, False: 0]
  |  |  ------------------
  ------------------
10230|     12|	    xmlParseCDSect(ctxt);
10231|     12|	}
10232|       |
10233|       |	/*
10234|       |	 * Third case :  a comment
10235|       |	 */
10236|  10.0k|	else if ((*cur == '<') && (NXT(1) == '!') &&
  ------------------
  |  | 2223|  5.22k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10236:11): [True: 5.22k, False: 4.81k]
  |  Branch (10236:28): [True: 37, False: 5.19k]
  ------------------
10237|  10.0k|		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
              		 (NXT(2) == '-') && (NXT(3) == '-')) {
  ------------------
  |  | 2223|     37|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10237:4): [True: 37, False: 0]
  |  Branch (10237:23): [True: 37, False: 0]
  ------------------
10238|     37|	    xmlParseComment(ctxt);
10239|     37|	    ctxt->instate = XML_PARSER_CONTENT;
10240|     37|	}
10241|       |
10242|       |	/*
10243|       |	 * Fourth case :  a sub-element.
10244|       |	 */
10245|  10.0k|	else if (*cur == '<') {
  ------------------
  |  Branch (10245:11): [True: 5.19k, False: 4.81k]
  ------------------
10246|  5.19k|            if (NXT(1) == '/') {
  ------------------
  |  | 2223|  5.19k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10246:17): [True: 2.70k, False: 2.48k]
  ------------------
10247|  2.70k|                if (ctxt->nameNr <= nameNr)
  ------------------
  |  Branch (10247:21): [True: 463, False: 2.24k]
  ------------------
10248|    463|                    break;
10249|  2.24k|	        xmlParseElementEnd(ctxt);
10250|  2.48k|            } else {
10251|  2.48k|	        xmlParseElementStart(ctxt);
10252|  2.48k|            }
10253|  5.19k|	}
10254|       |
10255|       |	/*
10256|       |	 * Fifth case : a reference. If if has not been resolved,
10257|       |	 *    parsing returns it's Name, create the node
10258|       |	 */
10259|       |
10260|  4.81k|	else if (*cur == '&') {
  ------------------
  |  Branch (10260:11): [True: 1, False: 4.81k]
  ------------------
10261|      1|	    xmlParseReference(ctxt);
10262|      1|	}
10263|       |
10264|       |	/*
10265|       |	 * Last case, text. Note that References are handled directly.
10266|       |	 */
10267|  4.81k|	else {
10268|  4.81k|	    xmlParseCharDataInternal(ctxt, 0);
10269|  4.81k|	}
10270|       |
10271|  9.60k|	SHRINK;
  ------------------
  |  | 2265|  9.60k|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 9.60k, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|  9.60k|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|  9.60k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 152, False: 9.45k]
  |  |  ------------------
  |  | 2267|  9.60k|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|    152|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 107, False: 45]
  |  |  ------------------
  |  | 2268|  9.60k|	xmlParserShrink(ctxt);
  ------------------
10272|  9.60k|	GROW;
  ------------------
  |  | 2270|  9.60k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  9.60k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 5.42k, False: 4.18k]
  |  |  ------------------
  |  | 2271|  9.60k|	xmlParserGrow(ctxt);
  ------------------
10273|  9.60k|    }
10274|    472|}
parser.c:xmlFatalErrMsgStrIntStr:
  416|     49|{
  417|     49|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (417:9): [True: 49, False: 0]
  |  Branch (417:27): [True: 0, False: 49]
  ------------------
  418|     49|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (418:9): [True: 0, False: 0]
  ------------------
  419|      0|	return;
  420|     49|    if (ctxt != NULL)
  ------------------
  |  Branch (420:9): [True: 49, False: 0]
  ------------------
  421|     49|	ctxt->errNo = error;
  422|     49|    __xmlRaiseError(NULL, NULL, NULL,
  423|     49|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  424|     49|                    NULL, 0, (const char *) str1, (const char *) str2,
  425|     49|		    NULL, val, 0, msg, str1, val, str2);
  426|     49|    if (ctxt != NULL) {
  ------------------
  |  Branch (426:9): [True: 49, False: 0]
  ------------------
  427|     49|	ctxt->wellFormed = 0;
  428|     49|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (428:6): [True: 0, False: 49]
  ------------------
  429|      0|	    ctxt->disableSAX = 1;
  430|     49|    }
  431|     49|}
parser.c:xmlParseElementStart:
10351|  2.96k|xmlParseElementStart(xmlParserCtxtPtr ctxt) {
10352|  2.96k|    const xmlChar *name;
10353|  2.96k|    const xmlChar *prefix = NULL;
10354|  2.96k|    const xmlChar *URI = NULL;
10355|  2.96k|    xmlParserNodeInfo node_info;
10356|  2.96k|    int line;
10357|  2.96k|    xmlNodePtr cur;
10358|  2.96k|    int nbNs = 0;
10359|       |
10360|  2.96k|    if (((unsigned int) ctxt->nameNr > xmlParserMaxDepth) &&
  ------------------
  |  Branch (10360:9): [True: 0, False: 2.96k]
  ------------------
10361|  2.96k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (10361:9): [True: 0, False: 0]
  ------------------
10362|      0|	xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,
10363|      0|		 "Excessive depth in document: %d use XML_PARSE_HUGE option\n",
10364|      0|			  xmlParserMaxDepth);
10365|      0|	xmlHaltParser(ctxt);
10366|      0|	return(-1);
10367|      0|    }
10368|       |
10369|       |    /* Capture start position */
10370|  2.96k|    if (ctxt->record_info) {
  ------------------
  |  Branch (10370:9): [True: 0, False: 2.96k]
  ------------------
10371|      0|        node_info.begin_pos = ctxt->input->consumed +
10372|      0|                          (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10373|      0|	node_info.begin_line = ctxt->input->line;
10374|      0|    }
10375|       |
10376|  2.96k|    if (ctxt->spaceNr == 0)
  ------------------
  |  Branch (10376:9): [True: 0, False: 2.96k]
  ------------------
10377|      0|	spacePush(ctxt, -1);
10378|  2.96k|    else if (*ctxt->space == -2)
  ------------------
  |  Branch (10378:14): [True: 0, False: 2.96k]
  ------------------
10379|      0|	spacePush(ctxt, -1);
10380|  2.96k|    else
10381|  2.96k|	spacePush(ctxt, *ctxt->space);
10382|       |
10383|  2.96k|    line = ctxt->input->line;
10384|  2.96k|#ifdef LIBXML_SAX1_ENABLED
10385|  2.96k|    if (ctxt->sax2)
  ------------------
  |  Branch (10385:9): [True: 2.96k, False: 0]
  ------------------
10386|  2.96k|#endif /* LIBXML_SAX1_ENABLED */
10387|  2.96k|        name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);
10388|      0|#ifdef LIBXML_SAX1_ENABLED
10389|      0|    else
10390|      0|	name = xmlParseStartTag(ctxt);
10391|  2.96k|#endif /* LIBXML_SAX1_ENABLED */
10392|  2.96k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10392:9): [True: 0, False: 2.96k]
  ------------------
10393|      0|	return(-1);
10394|  2.96k|    if (name == NULL) {
  ------------------
  |  Branch (10394:9): [True: 7, False: 2.95k]
  ------------------
10395|      7|	spacePop(ctxt);
10396|      7|        return(-1);
10397|      7|    }
10398|  2.95k|    nameNsPush(ctxt, name, prefix, URI, line, nbNs);
10399|  2.95k|    cur = ctxt->node;
10400|       |
10401|  2.95k|#ifdef LIBXML_VALID_ENABLED
10402|       |    /*
10403|       |     * [ VC: Root Element Type ]
10404|       |     * The Name in the document type declaration must match the element
10405|       |     * type of the root element.
10406|       |     */
10407|  2.95k|    if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&
  ------------------
  |  Branch (10407:9): [True: 0, False: 2.95k]
  |  Branch (10407:27): [True: 0, False: 0]
  |  Branch (10407:47): [True: 0, False: 0]
  ------------------
10408|  2.95k|        ctxt->node && (ctxt->node == ctxt->myDoc->children))
  ------------------
  |  Branch (10408:9): [True: 0, False: 0]
  |  Branch (10408:23): [True: 0, False: 0]
  ------------------
10409|      0|        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);
10410|  2.95k|#endif /* LIBXML_VALID_ENABLED */
10411|       |
10412|       |    /*
10413|       |     * Check for an Empty Element.
10414|       |     */
10415|  2.95k|    if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2221|  2.95k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW == '/') && (NXT(1) == '>')) {
  ------------------
  |  | 2223|    227|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10415:9): [True: 227, False: 2.72k]
  |  Branch (10415:25): [True: 225, False: 2]
  ------------------
10416|    225|        SKIP(2);
  ------------------
  |  | 2245|    225|#define SKIP(val) do {							\
  |  | 2246|    225|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|    225|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 225]
  |  |  ------------------
  |  | 2248|    225|        xmlParserGrow(ctxt);						\
  |  | 2249|    225|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10417|    225|	if (ctxt->sax2) {
  ------------------
  |  Branch (10417:6): [True: 225, False: 0]
  ------------------
10418|    225|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10418:10): [True: 225, False: 0]
  |  Branch (10418:33): [True: 225, False: 0]
  ------------------
10419|    225|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10419:3): [True: 225, False: 0]
  ------------------
10420|    225|		ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);
10421|    225|#ifdef LIBXML_SAX1_ENABLED
10422|    225|	} else {
10423|      0|	    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&
  ------------------
  |  Branch (10423:10): [True: 0, False: 0]
  |  Branch (10423:33): [True: 0, False: 0]
  ------------------
10424|      0|		(!ctxt->disableSAX))
  ------------------
  |  Branch (10424:3): [True: 0, False: 0]
  ------------------
10425|      0|		ctxt->sax->endElement(ctxt->userData, name);
10426|      0|#endif /* LIBXML_SAX1_ENABLED */
10427|      0|	}
10428|    225|	namePop(ctxt);
10429|    225|	spacePop(ctxt);
10430|    225|	if (nbNs > 0)
  ------------------
  |  Branch (10430:6): [True: 6, False: 219]
  ------------------
10431|      6|	    xmlParserNsPop(ctxt, nbNs);
10432|    225|	if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10432:6): [True: 225, False: 0]
  |  Branch (10432:21): [True: 0, False: 225]
  ------------------
10433|      0|            node_info.node = cur;
10434|      0|            node_info.end_pos = ctxt->input->consumed +
10435|      0|                                (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10436|      0|            node_info.end_line = ctxt->input->line;
10437|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10438|      0|	}
10439|    225|	return(1);
10440|    225|    }
10441|  2.73k|    if (RAW == '>') {
  ------------------
  |  | 2221|  2.73k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10441:9): [True: 2.71k, False: 13]
  ------------------
10442|  2.71k|        NEXT1;
  ------------------
  |  | 2277|  2.71k|#define NEXT1 {								\
  |  | 2278|  2.71k|	ctxt->input->col++;						\
  |  | 2279|  2.71k|	ctxt->input->cur++;						\
  |  | 2280|  2.71k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 2, False: 2.71k]
  |  |  ------------------
  |  | 2281|  2.71k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.71k|    }
  ------------------
10443|  2.71k|        if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10443:13): [True: 2.71k, False: 0]
  |  Branch (10443:28): [True: 0, False: 2.71k]
  ------------------
10444|      0|            node_info.node = cur;
10445|      0|            node_info.end_pos = 0;
10446|      0|            node_info.end_line = 0;
10447|      0|            xmlParserAddNodeInfo(ctxt, &node_info);
10448|      0|        }
10449|  2.71k|    } else {
10450|     13|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_GT_REQUIRED,
10451|     13|		     "Couldn't find end of Start Tag %s line %d\n",
10452|     13|		                name, line, NULL);
10453|       |
10454|       |	/*
10455|       |	 * end of parsing of this node.
10456|       |	 */
10457|     13|	nodePop(ctxt);
10458|     13|	namePop(ctxt);
10459|     13|	spacePop(ctxt);
10460|     13|	if (nbNs > 0)
  ------------------
  |  Branch (10460:6): [True: 1, False: 12]
  ------------------
10461|      1|	    xmlParserNsPop(ctxt, nbNs);
10462|     13|	return(-1);
10463|     13|    }
10464|       |
10465|  2.71k|    return(0);
10466|  2.73k|}
parser.c:spacePush:
 2154|  2.96k|static int spacePush(xmlParserCtxtPtr ctxt, int val) {
 2155|  2.96k|    if (ctxt->spaceNr >= ctxt->spaceMax) {
  ------------------
  |  Branch (2155:9): [True: 0, False: 2.96k]
  ------------------
 2156|      0|        int *tmp;
 2157|       |
 2158|      0|	ctxt->spaceMax *= 2;
 2159|      0|        tmp = (int *) xmlRealloc(ctxt->spaceTab,
 2160|      0|	                         ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));
 2161|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (2161:13): [True: 0, False: 0]
  ------------------
 2162|      0|	    xmlErrMemory(ctxt, NULL);
 2163|      0|	    ctxt->spaceMax /=2;
 2164|      0|	    return(-1);
 2165|      0|	}
 2166|      0|	ctxt->spaceTab = tmp;
 2167|      0|    }
 2168|  2.96k|    ctxt->spaceTab[ctxt->spaceNr] = val;
 2169|  2.96k|    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr];
 2170|  2.96k|    return(ctxt->spaceNr++);
 2171|  2.96k|}
parser.c:xmlParseStartTag2:
 9471|  2.96k|                  const xmlChar **URI, int *nbNsPtr) {
 9472|  2.96k|    xmlHashedString hlocalname;
 9473|  2.96k|    xmlHashedString hprefix;
 9474|  2.96k|    xmlHashedString hattname;
 9475|  2.96k|    xmlHashedString haprefix;
 9476|  2.96k|    const xmlChar *localname;
 9477|  2.96k|    const xmlChar *prefix;
 9478|  2.96k|    const xmlChar *attname;
 9479|  2.96k|    const xmlChar *aprefix;
 9480|  2.96k|    const xmlChar *uri;
 9481|  2.96k|    xmlChar *attvalue = NULL;
 9482|  2.96k|    const xmlChar **atts = ctxt->atts;
 9483|  2.96k|    unsigned attrHashSize = 0;
 9484|  2.96k|    int maxatts = ctxt->maxatts;
 9485|  2.96k|    int nratts, nbatts, nbdef, inputid;
 9486|  2.96k|    int i, j, nbNs, nbTotalDef, attval, nsIndex, maxAtts;
 9487|  2.96k|    int alloc = 0;
 9488|       |
 9489|  2.96k|    if (RAW != '<') return(NULL);
  ------------------
  |  | 2221|  2.96k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9489:9): [True: 0, False: 2.96k]
  ------------------
 9490|  2.96k|    NEXT1;
  ------------------
  |  | 2277|  2.96k|#define NEXT1 {								\
  |  | 2278|  2.96k|	ctxt->input->col++;						\
  |  | 2279|  2.96k|	ctxt->input->cur++;						\
  |  | 2280|  2.96k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 2, False: 2.96k]
  |  |  ------------------
  |  | 2281|  2.96k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.96k|    }
  ------------------
 9491|       |
 9492|  2.96k|    inputid = ctxt->input->id;
 9493|  2.96k|    nbatts = 0;
 9494|  2.96k|    nratts = 0;
 9495|  2.96k|    nbdef = 0;
 9496|  2.96k|    nbNs = 0;
 9497|  2.96k|    nbTotalDef = 0;
 9498|  2.96k|    attval = 0;
 9499|       |
 9500|  2.96k|    if (xmlParserNsStartElement(ctxt->nsdb) < 0) {
  ------------------
  |  Branch (9500:9): [True: 0, False: 2.96k]
  ------------------
 9501|      0|        xmlErrMemory(ctxt, NULL);
 9502|      0|        return(NULL);
 9503|      0|    }
 9504|       |
 9505|  2.96k|    hlocalname = xmlParseQNameHashed(ctxt, &hprefix);
 9506|  2.96k|    if (hlocalname.name == NULL) {
  ------------------
  |  Branch (9506:9): [True: 7, False: 2.95k]
  ------------------
 9507|      7|	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9508|      7|		       "StartTag: invalid element name\n");
 9509|      7|        return(NULL);
 9510|      7|    }
 9511|  2.95k|    localname = hlocalname.name;
 9512|  2.95k|    prefix = hprefix.name;
 9513|       |
 9514|       |    /*
 9515|       |     * Now parse the attributes, it ends up with the ending
 9516|       |     *
 9517|       |     * (S Attribute)* S?
 9518|       |     */
 9519|  2.95k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.95k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9520|  2.95k|    GROW;
  ------------------
  |  | 2270|  2.95k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.95k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.73k, False: 1.22k]
  |  |  ------------------
  |  | 2271|  2.95k|	xmlParserGrow(ctxt);
  ------------------
 9521|       |
 9522|       |    /*
 9523|       |     * The ctxt->atts array will be ultimately passed to the SAX callback
 9524|       |     * containing five xmlChar pointers for each attribute:
 9525|       |     *
 9526|       |     * [0] attribute name
 9527|       |     * [1] attribute prefix
 9528|       |     * [2] namespace URI
 9529|       |     * [3] attribute value
 9530|       |     * [4] end of attribute value
 9531|       |     *
 9532|       |     * To save memory, we reuse this array temporarily and store integers
 9533|       |     * in these pointer variables.
 9534|       |     *
 9535|       |     * [0] attribute name
 9536|       |     * [1] attribute prefix
 9537|       |     * [2] hash value of attribute prefix, and later namespace index
 9538|       |     * [3] for non-allocated values: ptrdiff_t offset into input buffer
 9539|       |     * [4] for non-allocated values: ptrdiff_t offset into input buffer
 9540|       |     *
 9541|       |     * The ctxt->attallocs array contains an additional unsigned int for
 9542|       |     * each attribute, containing the hash value of the attribute name
 9543|       |     * and the alloc flag in bit 31.
 9544|       |     */
 9545|       |
 9546|  3.07k|    while (((RAW != '>') &&
  ------------------
  |  | 2221|  3.07k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9546:13): [True: 964, False: 2.10k]
  ------------------
 9547|  3.07k|	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2221|    964|#define RAW (*ctxt->input->cur)
  ------------------
              	   ((RAW != '/') || (NXT(1) != '>')) &&
  ------------------
  |  | 2223|     45|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9547:6): [True: 919, False: 45]
  |  Branch (9547:22): [True: 1, False: 44]
  ------------------
 9548|  3.07k|	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  |  113|    920|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|    920|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 917, False: 3]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 917]
  |  |  |  |  ------------------
  |  |  |  |  109|    920|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 920]
  |  |  |  |  ------------------
  |  |  |  |  110|    920|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 917, False: 3]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9548:29): [True: 917, False: 0]
  ------------------
 9549|    917|	int len = -1;
 9550|       |
 9551|    917|	hattname = xmlParseAttribute2(ctxt, prefix, localname,
 9552|    917|                                          &haprefix, &attvalue, &len,
 9553|    917|                                          &alloc);
 9554|    917|        if (hattname.name == NULL) {
  ------------------
  |  Branch (9554:13): [True: 2, False: 915]
  ------------------
 9555|      2|	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9556|      2|	         "xmlParseStartTag: problem parsing attributes\n");
 9557|      2|	    break;
 9558|      2|	}
 9559|    915|        if (attvalue == NULL)
  ------------------
  |  Branch (9559:13): [True: 1, False: 914]
  ------------------
 9560|      1|            goto next_attr;
 9561|    914|        attname = hattname.name;
 9562|    914|        aprefix = haprefix.name;
 9563|    914|	if (len < 0) len = xmlStrlen(attvalue);
  ------------------
  |  Branch (9563:6): [True: 0, False: 914]
  ------------------
 9564|       |
 9565|    914|        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9565:13): [True: 6, False: 908]
  |  Branch (9565:45): [True: 6, False: 0]
  ------------------
 9566|      6|            xmlHashedString huri;
 9567|      6|            xmlURIPtr parsedUri;
 9568|       |
 9569|      6|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9570|      6|            uri = huri.name;
 9571|      6|            if (uri == NULL) {
  ------------------
  |  Branch (9571:17): [True: 0, False: 6]
  ------------------
 9572|      0|                xmlErrMemory(ctxt, NULL);
 9573|      0|                goto next_attr;
 9574|      0|            }
 9575|      6|            if (*uri != 0) {
  ------------------
  |  Branch (9575:17): [True: 6, False: 0]
  ------------------
 9576|      6|                parsedUri = xmlParseURI((const char *) uri);
 9577|      6|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9577:21): [True: 1, False: 5]
  ------------------
 9578|      1|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9579|      1|                             "xmlns: '%s' is not a valid URI\n",
 9580|      1|                                       uri, NULL, NULL);
 9581|      5|                } else {
 9582|      5|                    if (parsedUri->scheme == NULL) {
  ------------------
  |  Branch (9582:25): [True: 0, False: 5]
  ------------------
 9583|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9584|      0|                                  "xmlns: URI %s is not absolute\n",
 9585|      0|                                  uri, NULL, NULL);
 9586|      0|                    }
 9587|      5|                    xmlFreeURI(parsedUri);
 9588|      5|                }
 9589|      6|                if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9589:21): [True: 0, False: 6]
  ------------------
 9590|      0|                    if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9590:25): [True: 0, False: 0]
  ------------------
 9591|      0|                        xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9592|      0|                     "xml namespace URI cannot be the default namespace\n",
 9593|      0|                                 NULL, NULL, NULL);
 9594|      0|                    }
 9595|      0|                    goto next_attr;
 9596|      0|                }
 9597|      6|                if ((len == 29) &&
  ------------------
  |  Branch (9597:21): [True: 0, False: 6]
  ------------------
 9598|      6|                    (xmlStrEqual(uri,
  ------------------
  |  Branch (9598:21): [True: 0, False: 0]
  ------------------
 9599|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9600|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9601|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9602|      0|                             NULL, NULL, NULL);
 9603|      0|                    goto next_attr;
 9604|      0|                }
 9605|      6|            }
 9606|       |
 9607|      6|            if (xmlParserNsPush(ctxt, NULL, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9607:17): [True: 6, False: 0]
  ------------------
 9608|      6|                nbNs++;
 9609|    908|        } else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9609:20): [True: 12, False: 896]
  ------------------
 9610|     12|            xmlHashedString huri;
 9611|     12|            xmlURIPtr parsedUri;
 9612|       |
 9613|     12|            huri = xmlDictLookupHashed(ctxt->dict, attvalue, len);
 9614|     12|            uri = huri.name;
 9615|     12|            if (uri == NULL) {
  ------------------
  |  Branch (9615:17): [True: 0, False: 12]
  ------------------
 9616|      0|                xmlErrMemory(ctxt, NULL);
 9617|      0|                goto next_attr;
 9618|      0|            }
 9619|       |
 9620|     12|            if (attname == ctxt->str_xml) {
  ------------------
  |  Branch (9620:17): [True: 0, False: 12]
  ------------------
 9621|      0|                if (uri != ctxt->str_xml_ns) {
  ------------------
  |  Branch (9621:21): [True: 0, False: 0]
  ------------------
 9622|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9623|      0|                             "xml namespace prefix mapped to wrong URI\n",
 9624|      0|                             NULL, NULL, NULL);
 9625|      0|                }
 9626|       |                /*
 9627|       |                 * Do not keep a namespace definition node
 9628|       |                 */
 9629|      0|                goto next_attr;
 9630|      0|            }
 9631|     12|            if (uri == ctxt->str_xml_ns) {
  ------------------
  |  Branch (9631:17): [True: 0, False: 12]
  ------------------
 9632|      0|                if (attname != ctxt->str_xml) {
  ------------------
  |  Branch (9632:21): [True: 0, False: 0]
  ------------------
 9633|      0|                    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9634|      0|                             "xml namespace URI mapped to wrong prefix\n",
 9635|      0|                             NULL, NULL, NULL);
 9636|      0|                }
 9637|      0|                goto next_attr;
 9638|      0|            }
 9639|     12|            if (attname == ctxt->str_xmlns) {
  ------------------
  |  Branch (9639:17): [True: 0, False: 12]
  ------------------
 9640|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9641|      0|                         "redefinition of the xmlns prefix is forbidden\n",
 9642|      0|                         NULL, NULL, NULL);
 9643|      0|                goto next_attr;
 9644|      0|            }
 9645|     12|            if ((len == 29) &&
  ------------------
  |  Branch (9645:17): [True: 0, False: 12]
  ------------------
 9646|     12|                (xmlStrEqual(uri,
  ------------------
  |  Branch (9646:17): [True: 0, False: 0]
  ------------------
 9647|      0|                             BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 9648|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9649|      0|                         "reuse of the xmlns namespace name is forbidden\n",
 9650|      0|                         NULL, NULL, NULL);
 9651|      0|                goto next_attr;
 9652|      0|            }
 9653|     12|            if ((uri == NULL) || (uri[0] == 0)) {
  ------------------
  |  Branch (9653:17): [True: 0, False: 12]
  |  Branch (9653:34): [True: 0, False: 12]
  ------------------
 9654|      0|                xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
 9655|      0|                         "xmlns:%s: Empty XML namespace is not allowed\n",
 9656|      0|                              attname, NULL, NULL);
 9657|      0|                goto next_attr;
 9658|     12|            } else {
 9659|     12|                parsedUri = xmlParseURI((const char *) uri);
 9660|     12|                if (parsedUri == NULL) {
  ------------------
  |  Branch (9660:21): [True: 0, False: 12]
  ------------------
 9661|      0|                    xmlNsErr(ctxt, XML_WAR_NS_URI,
 9662|      0|                         "xmlns:%s: '%s' is not a valid URI\n",
 9663|      0|                                       attname, uri, NULL);
 9664|     12|                } else {
 9665|     12|                    if ((ctxt->pedantic) && (parsedUri->scheme == NULL)) {
  ------------------
  |  Branch (9665:25): [True: 0, False: 12]
  |  Branch (9665:45): [True: 0, False: 0]
  ------------------
 9666|      0|                        xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
 9667|      0|                                  "xmlns:%s: URI %s is not absolute\n",
 9668|      0|                                  attname, uri, NULL);
 9669|      0|                    }
 9670|     12|                    xmlFreeURI(parsedUri);
 9671|     12|                }
 9672|     12|            }
 9673|       |
 9674|     12|            if (xmlParserNsPush(ctxt, &hattname, &huri, NULL, 0) > 0)
  ------------------
  |  Branch (9674:17): [True: 12, False: 0]
  ------------------
 9675|     12|                nbNs++;
 9676|    896|        } else {
 9677|       |            /*
 9678|       |             * Populate attributes array, see above for repurposing
 9679|       |             * of xmlChar pointers.
 9680|       |             */
 9681|    896|            if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9681:17): [True: 170, False: 726]
  |  Branch (9681:35): [True: 0, False: 726]
  ------------------
 9682|    170|                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9682:21): [True: 0, False: 170]
  ------------------
 9683|      0|                    goto next_attr;
 9684|      0|                }
 9685|    170|                maxatts = ctxt->maxatts;
 9686|    170|                atts = ctxt->atts;
 9687|    170|            }
 9688|    896|            ctxt->attallocs[nratts++] = (hattname.hashValue & 0x7FFFFFFF) |
 9689|    896|                                        ((unsigned) alloc << 31);
 9690|    896|            atts[nbatts++] = attname;
 9691|    896|            atts[nbatts++] = aprefix;
 9692|    896|            atts[nbatts++] = (const xmlChar *) (size_t) haprefix.hashValue;
 9693|    896|            if (alloc) {
  ------------------
  |  Branch (9693:17): [True: 109, False: 787]
  ------------------
 9694|    109|                atts[nbatts++] = attvalue;
 9695|    109|                attvalue += len;
 9696|    109|                atts[nbatts++] = attvalue;
 9697|    787|            } else {
 9698|       |                /*
 9699|       |                 * attvalue points into the input buffer which can be
 9700|       |                 * reallocated. Store differences to input->base instead.
 9701|       |                 * The pointers will be reconstructed later.
 9702|       |                 */
 9703|    787|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|    787|#define BASE_PTR ctxt->input->base
  ------------------
 9704|    787|                attvalue += len;
 9705|    787|                atts[nbatts++] = (void *) (attvalue - BASE_PTR);
  ------------------
  |  | 2225|    787|#define BASE_PTR ctxt->input->base
  ------------------
 9706|    787|            }
 9707|       |            /*
 9708|       |             * tag if some deallocation is needed
 9709|       |             */
 9710|    896|            if (alloc != 0) attval = 1;
  ------------------
  |  Branch (9710:17): [True: 109, False: 787]
  ------------------
 9711|    896|            attvalue = NULL; /* moved into atts */
 9712|    896|        }
 9713|       |
 9714|    915|next_attr:
 9715|    915|        if ((attvalue != NULL) && (alloc != 0)) {
  ------------------
  |  Branch (9715:13): [True: 18, False: 897]
  |  Branch (9715:35): [True: 1, False: 17]
  ------------------
 9716|      1|            xmlFree(attvalue);
 9717|      1|            attvalue = NULL;
 9718|      1|        }
 9719|       |
 9720|    915|	GROW
  ------------------
  |  | 2270|    915|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    915|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 426, False: 489]
  |  |  ------------------
  |  | 2271|    915|	xmlParserGrow(ctxt);
  ------------------
 9721|    915|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (9721:13): [True: 0, False: 915]
  ------------------
 9722|      0|            break;
 9723|    915|	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|    915|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2221|    304|#define RAW (*ctxt->input->cur)
  ------------------
              	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
  ------------------
  |  | 2223|    182|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (9723:6): [True: 611, False: 304]
  |  Branch (9723:24): [True: 182, False: 122]
  |  Branch (9723:40): [True: 181, False: 1]
  ------------------
 9724|    792|	    break;
 9725|    123|	if (SKIP_BLANKS == 0) {
  ------------------
  |  | 2273|    123|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
  |  Branch (9725:6): [True: 8, False: 115]
  ------------------
 9726|      8|	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 9727|      8|			   "attributes construct error\n");
 9728|      8|	    break;
 9729|      8|	}
 9730|    115|        GROW;
  ------------------
  |  | 2270|    115|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    115|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 44, False: 71]
  |  |  ------------------
  |  | 2271|    115|	xmlParserGrow(ctxt);
  ------------------
 9731|    115|    }
 9732|       |
 9733|  2.95k|    if (ctxt->input->id != inputid) {
  ------------------
  |  Branch (9733:9): [True: 0, False: 2.95k]
  ------------------
 9734|      0|        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 9735|      0|                    "Unexpected change of input\n");
 9736|      0|        localname = NULL;
 9737|      0|        goto done;
 9738|      0|    }
 9739|       |
 9740|       |    /*
 9741|       |     * Namespaces from default attributes
 9742|       |     */
 9743|  2.95k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9743:9): [True: 0, False: 2.95k]
  ------------------
 9744|      0|        xmlDefAttrsPtr defaults;
 9745|       |
 9746|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9747|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9747:6): [True: 0, False: 0]
  ------------------
 9748|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9748:18): [True: 0, False: 0]
  ------------------
 9749|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9750|       |
 9751|      0|	        attname = attr->name.name;
 9752|      0|		aprefix = attr->prefix.name;
 9753|       |
 9754|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
  ------------------
  |  Branch (9754:7): [True: 0, False: 0]
  |  Branch (9754:39): [True: 0, False: 0]
  ------------------
 9755|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9756|       |
 9757|      0|                    if (xmlParserNsPush(ctxt, NULL, &attr->value, NULL, 1) > 0)
  ------------------
  |  Branch (9757:25): [True: 0, False: 0]
  ------------------
 9758|      0|                        nbNs++;
 9759|      0|		} else if (aprefix == ctxt->str_xmlns) {
  ------------------
  |  Branch (9759:14): [True: 0, False: 0]
  ------------------
 9760|      0|                    xmlParserEntityCheck(ctxt, attr->expandedSize);
 9761|       |
 9762|      0|                    if (xmlParserNsPush(ctxt, &attr->name, &attr->value,
  ------------------
  |  Branch (9762:25): [True: 0, False: 0]
  ------------------
 9763|      0|                                      NULL, 1) > 0)
 9764|      0|                        nbNs++;
 9765|      0|		} else {
 9766|      0|                    nbTotalDef += 1;
 9767|      0|                }
 9768|      0|	    }
 9769|      0|	}
 9770|      0|    }
 9771|       |
 9772|       |    /*
 9773|       |     * Resolve attribute namespaces
 9774|       |     */
 9775|  3.85k|    for (i = 0; i < nbatts; i += 5) {
  ------------------
  |  Branch (9775:17): [True: 896, False: 2.95k]
  ------------------
 9776|    896|        attname = atts[i];
 9777|    896|        aprefix = atts[i+1];
 9778|       |
 9779|       |        /*
 9780|       |	* The default namespace does not apply to attribute names.
 9781|       |	*/
 9782|    896|	if (aprefix == NULL) {
  ------------------
  |  Branch (9782:6): [True: 860, False: 36]
  ------------------
 9783|    860|            nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|    860|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9784|    860|        } else if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9784:20): [True: 36, False: 0]
  ------------------
 9785|     36|            nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|     36|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9786|     36|        } else {
 9787|      0|            haprefix.name = aprefix;
 9788|      0|            haprefix.hashValue = (size_t) atts[i+2];
 9789|      0|            nsIndex = xmlParserNsLookup(ctxt, &haprefix, NULL);
 9790|      0|	    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9790:10): [True: 0, False: 0]
  ------------------
 9791|      0|                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9792|      0|		    "Namespace prefix %s for %s on %s is not defined\n",
 9793|      0|		    aprefix, attname, localname);
 9794|      0|                nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9795|      0|            }
 9796|      0|        }
 9797|       |
 9798|    896|        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9799|    896|    }
 9800|       |
 9801|       |    /*
 9802|       |     * Maximum number of attributes including default attributes.
 9803|       |     */
 9804|  2.95k|    maxAtts = nratts + nbTotalDef;
 9805|       |
 9806|       |    /*
 9807|       |     * Verify that attribute names are unique.
 9808|       |     */
 9809|  2.95k|    if (maxAtts > 1) {
  ------------------
  |  Branch (9809:9): [True: 109, False: 2.84k]
  ------------------
 9810|    109|        attrHashSize = 4;
 9811|    115|        while (attrHashSize / 2 < (unsigned) maxAtts)
  ------------------
  |  Branch (9811:16): [True: 6, False: 109]
  ------------------
 9812|      6|            attrHashSize *= 2;
 9813|       |
 9814|    109|        if (attrHashSize > ctxt->attrHashMax) {
  ------------------
  |  Branch (9814:13): [True: 106, False: 3]
  ------------------
 9815|    106|            xmlAttrHashBucket *tmp;
 9816|       |
 9817|    106|            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));
 9818|    106|            if (tmp == NULL) {
  ------------------
  |  Branch (9818:17): [True: 0, False: 106]
  ------------------
 9819|      0|                xmlErrMemory(ctxt, NULL);
 9820|      0|                goto done;
 9821|      0|            }
 9822|       |
 9823|    106|            ctxt->attrHash = tmp;
 9824|    106|            ctxt->attrHashMax = attrHashSize;
 9825|    106|        }
 9826|       |
 9827|    109|        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));
 9828|       |
 9829|    333|        for (i = 0, j = 0; j < nratts; i += 5, j++) {
  ------------------
  |  Branch (9829:28): [True: 224, False: 109]
  ------------------
 9830|    224|            const xmlChar *nsuri;
 9831|    224|            unsigned hashValue, nameHashValue, uriHashValue;
 9832|    224|            int res;
 9833|       |
 9834|    224|            attname = atts[i];
 9835|    224|            aprefix = atts[i+1];
 9836|    224|            nsIndex = (ptrdiff_t) atts[i+2];
 9837|       |            /* Hash values always have bit 31 set, see dict.c */
 9838|    224|            nameHashValue = ctxt->attallocs[j] | 0x80000000;
 9839|       |
 9840|    224|            if (nsIndex == NS_INDEX_EMPTY) {
  ------------------
  |  |   77|    224|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9840:17): [True: 224, False: 0]
  ------------------
 9841|    224|                nsuri = NULL;
 9842|    224|                uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|    224|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9843|    224|            } else if (nsIndex == NS_INDEX_XML) {
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9843:24): [True: 0, False: 0]
  ------------------
 9844|      0|                nsuri = ctxt->str_xml_ns;
 9845|      0|                uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|      0|#define URI_HASH_XML    0xF0451F02
  ------------------
 9846|      0|            } else {
 9847|      0|                nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9848|      0|                uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9849|      0|            }
 9850|       |
 9851|    224|            hashValue = xmlDictCombineHash(nameHashValue, uriHashValue);
 9852|    224|            res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9853|    224|                                    hashValue, i);
 9854|    224|            if (res < 0)
  ------------------
  |  Branch (9854:17): [True: 0, False: 224]
  ------------------
 9855|      0|                continue;
 9856|       |
 9857|       |            /*
 9858|       |             * [ WFC: Unique Att Spec ]
 9859|       |             * No attribute name may appear more than once in the same
 9860|       |             * start-tag or empty-element tag.
 9861|       |             * As extended by the Namespace in XML REC.
 9862|       |             */
 9863|    224|            if (res < INT_MAX) {
  ------------------
  |  Branch (9863:17): [True: 0, False: 224]
  ------------------
 9864|      0|                if (aprefix == atts[res+1]) {
  ------------------
  |  Branch (9864:21): [True: 0, False: 0]
  ------------------
 9865|      0|                    xmlErrAttributeDup(ctxt, aprefix, attname);
 9866|      0|                } else {
 9867|      0|                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9868|      0|                             "Namespaced Attribute %s in '%s' redefined\n",
 9869|      0|                             attname, nsuri, NULL);
 9870|      0|                }
 9871|      0|            }
 9872|    224|        }
 9873|    109|    }
 9874|       |
 9875|       |    /*
 9876|       |     * Default attributes
 9877|       |     */
 9878|  2.95k|    if (ctxt->attsDefault != NULL) {
  ------------------
  |  Branch (9878:9): [True: 0, False: 2.95k]
  ------------------
 9879|      0|        xmlDefAttrsPtr defaults;
 9880|       |
 9881|      0|	defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);
 9882|      0|	if (defaults != NULL) {
  ------------------
  |  Branch (9882:6): [True: 0, False: 0]
  ------------------
 9883|      0|	    for (i = 0; i < defaults->nbAttrs; i++) {
  ------------------
  |  Branch (9883:18): [True: 0, False: 0]
  ------------------
 9884|      0|                xmlDefAttr *attr = &defaults->attrs[i];
 9885|      0|                const xmlChar *nsuri;
 9886|      0|                unsigned hashValue, uriHashValue;
 9887|      0|                int res;
 9888|       |
 9889|      0|	        attname = attr->name.name;
 9890|      0|		aprefix = attr->prefix.name;
 9891|       |
 9892|      0|		if ((attname == ctxt->str_xmlns) && (aprefix == NULL))
  ------------------
  |  Branch (9892:7): [True: 0, False: 0]
  |  Branch (9892:39): [True: 0, False: 0]
  ------------------
 9893|      0|                    continue;
 9894|      0|		if (aprefix == ctxt->str_xmlns)
  ------------------
  |  Branch (9894:7): [True: 0, False: 0]
  ------------------
 9895|      0|                    continue;
 9896|       |
 9897|      0|                if (aprefix == NULL) {
  ------------------
  |  Branch (9897:21): [True: 0, False: 0]
  ------------------
 9898|      0|                    nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9899|      0|                    nsuri = NULL;
 9900|      0|                    uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9901|      0|                } if (aprefix == ctxt->str_xml) {
  ------------------
  |  Branch (9901:23): [True: 0, False: 0]
  ------------------
 9902|      0|                    nsIndex = NS_INDEX_XML;
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
 9903|      0|                    nsuri = ctxt->str_xml_ns;
 9904|      0|                    uriHashValue = URI_HASH_XML;
  ------------------
  |  |   80|      0|#define URI_HASH_XML    0xF0451F02
  ------------------
 9905|      0|                } else if (aprefix != NULL) {
  ------------------
  |  Branch (9905:28): [True: 0, False: 0]
  ------------------
 9906|      0|                    nsIndex = xmlParserNsLookup(ctxt, &attr->prefix, NULL);
 9907|      0|                    if (nsIndex == INT_MAX) {
  ------------------
  |  Branch (9907:25): [True: 0, False: 0]
  ------------------
 9908|      0|                        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9909|      0|                                 "Namespace prefix %s for %s on %s is not "
 9910|      0|                                 "defined\n",
 9911|      0|                                 aprefix, attname, localname);
 9912|      0|                        nsIndex = NS_INDEX_EMPTY;
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
 9913|      0|                        nsuri = NULL;
 9914|      0|                        uriHashValue = URI_HASH_EMPTY;
  ------------------
  |  |   79|      0|#define URI_HASH_EMPTY  0xD943A04E
  ------------------
 9915|      0|                    } else {
 9916|      0|                        nsuri = ctxt->nsTab[nsIndex * 2 + 1];
 9917|      0|                        uriHashValue = ctxt->nsdb->extra[nsIndex].uriHashValue;
 9918|      0|                    }
 9919|      0|                }
 9920|       |
 9921|       |                /*
 9922|       |                 * Check whether the attribute exists
 9923|       |                 */
 9924|      0|                if (maxAtts > 1) {
  ------------------
  |  Branch (9924:21): [True: 0, False: 0]
  ------------------
 9925|      0|                    hashValue = xmlDictCombineHash(attr->name.hashValue,
 9926|      0|                                                   uriHashValue);
 9927|      0|                    res = xmlAttrHashInsert(ctxt, attrHashSize, attname, nsuri,
 9928|      0|                                            hashValue, nbatts);
 9929|      0|                    if (res < 0)
  ------------------
  |  Branch (9929:25): [True: 0, False: 0]
  ------------------
 9930|      0|                        continue;
 9931|      0|                    if (res < INT_MAX) {
  ------------------
  |  Branch (9931:25): [True: 0, False: 0]
  ------------------
 9932|      0|                        if (aprefix == atts[res+1])
  ------------------
  |  Branch (9932:29): [True: 0, False: 0]
  ------------------
 9933|      0|                            continue;
 9934|      0|                        xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,
 9935|      0|                                 "Namespaced Attribute %s in '%s' redefined\n",
 9936|      0|                                 attname, nsuri, NULL);
 9937|      0|                    }
 9938|      0|                }
 9939|       |
 9940|      0|                xmlParserEntityCheck(ctxt, attr->expandedSize);
 9941|       |
 9942|      0|                if ((atts == NULL) || (nbatts + 5 > maxatts)) {
  ------------------
  |  Branch (9942:21): [True: 0, False: 0]
  |  Branch (9942:39): [True: 0, False: 0]
  ------------------
 9943|      0|                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
  ------------------
  |  Branch (9943:25): [True: 0, False: 0]
  ------------------
 9944|      0|                        localname = NULL;
 9945|      0|                        goto done;
 9946|      0|                    }
 9947|      0|                    maxatts = ctxt->maxatts;
 9948|      0|                    atts = ctxt->atts;
 9949|      0|                }
 9950|       |
 9951|      0|                atts[nbatts++] = attname;
 9952|      0|                atts[nbatts++] = aprefix;
 9953|      0|                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;
 9954|      0|                atts[nbatts++] = attr->value.name;
 9955|      0|                atts[nbatts++] = attr->valueEnd;
 9956|      0|                if ((ctxt->standalone == 1) && (attr->external != 0)) {
  ------------------
  |  Branch (9956:21): [True: 0, False: 0]
  |  Branch (9956:48): [True: 0, False: 0]
  ------------------
 9957|      0|                    xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,
 9958|      0|                            "standalone: attribute %s on %s defaulted "
 9959|      0|                            "from external subset\n",
 9960|      0|                            attname, localname);
 9961|      0|                }
 9962|      0|                nbdef++;
 9963|      0|	    }
 9964|      0|	}
 9965|      0|    }
 9966|       |
 9967|       |    /*
 9968|       |     * Reconstruct attribute pointers
 9969|       |     */
 9970|  3.85k|    for (i = 0, j = 0; i < nbatts; i += 5, j++) {
  ------------------
  |  Branch (9970:24): [True: 896, False: 2.95k]
  ------------------
 9971|       |        /* namespace URI */
 9972|    896|        nsIndex = (ptrdiff_t) atts[i+2];
 9973|    896|        if (nsIndex == INT_MAX)
  ------------------
  |  Branch (9973:13): [True: 860, False: 36]
  ------------------
 9974|    860|            atts[i+2] = NULL;
 9975|     36|        else if (nsIndex == INT_MAX - 1)
  ------------------
  |  Branch (9975:18): [True: 36, False: 0]
  ------------------
 9976|     36|            atts[i+2] = ctxt->str_xml_ns;
 9977|      0|        else
 9978|      0|            atts[i+2] = ctxt->nsTab[nsIndex * 2 + 1];
 9979|       |
 9980|    896|        if ((j < nratts) && (ctxt->attallocs[j] & 0x80000000) == 0) {
  ------------------
  |  Branch (9980:13): [True: 896, False: 0]
  |  Branch (9980:29): [True: 787, False: 109]
  ------------------
 9981|    787|            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  /* value */
  ------------------
  |  | 2225|    787|#define BASE_PTR ctxt->input->base
  ------------------
 9982|    787|            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  /* valuend */
  ------------------
  |  | 2225|    787|#define BASE_PTR ctxt->input->base
  ------------------
 9983|    787|        }
 9984|    896|    }
 9985|       |
 9986|  2.95k|    uri = xmlParserNsLookupUri(ctxt, &hprefix);
 9987|  2.95k|    if ((prefix != NULL) && (uri == NULL)) {
  ------------------
  |  Branch (9987:9): [True: 1, False: 2.95k]
  |  Branch (9987:29): [True: 1, False: 0]
  ------------------
 9988|      1|	xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,
 9989|      1|	         "Namespace prefix %s on %s is not defined\n",
 9990|      1|		 prefix, localname, NULL);
 9991|      1|    }
 9992|  2.95k|    *pref = prefix;
 9993|  2.95k|    *URI = uri;
 9994|       |
 9995|       |    /*
 9996|       |     * SAX callback
 9997|       |     */
 9998|  2.95k|    if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) &&
  ------------------
  |  Branch (9998:9): [True: 2.95k, False: 0]
  |  Branch (9998:32): [True: 2.95k, False: 0]
  ------------------
 9999|  2.95k|	(!ctxt->disableSAX)) {
  ------------------
  |  Branch (9999:2): [True: 2.95k, False: 0]
  ------------------
10000|  2.95k|	if (nbNs > 0)
  ------------------
  |  Branch (10000:6): [True: 18, False: 2.93k]
  ------------------
10001|     18|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10002|     18|                          nbNs, ctxt->nsTab + 2 * (ctxt->nsNr - nbNs),
10003|     18|			  nbatts / 5, nbdef, atts);
10004|  2.93k|	else
10005|  2.93k|	    ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,
10006|  2.93k|                          0, NULL, nbatts / 5, nbdef, atts);
10007|  2.95k|    }
10008|       |
10009|  2.95k|done:
10010|       |    /*
10011|       |     * Free allocated attribute values
10012|       |     */
10013|  2.95k|    if (attval != 0) {
  ------------------
  |  Branch (10013:9): [True: 108, False: 2.84k]
  ------------------
10014|    326|	for (i = 0, j = 0; j < nratts; i += 5, j++)
  ------------------
  |  Branch (10014:21): [True: 218, False: 108]
  ------------------
10015|    218|	    if (ctxt->attallocs[j] & 0x80000000)
  ------------------
  |  Branch (10015:10): [True: 109, False: 109]
  ------------------
10016|    109|	        xmlFree((xmlChar *) atts[i+3]);
10017|    108|    }
10018|       |
10019|  2.95k|    *nbNsPtr = nbNs;
10020|  2.95k|    return(localname);
10021|  2.95k|}
parser.c:xmlParserNsStartElement:
 1462|  2.96k|xmlParserNsStartElement(xmlParserNsData *nsdb) {
 1463|  2.96k|    if (nsdb->elementId == UINT_MAX)
  ------------------
  |  Branch (1463:9): [True: 0, False: 2.96k]
  ------------------
 1464|      0|        return(-1);
 1465|  2.96k|    nsdb->elementId++;
 1466|       |
 1467|  2.96k|    return(0);
 1468|  2.96k|}
parser.c:xmlParseQNameHashed:
 8943|  3.88k|xmlParseQNameHashed(xmlParserCtxtPtr ctxt, xmlHashedString *prefix) {
 8944|  3.88k|    xmlHashedString l, p;
 8945|  3.88k|    int start;
 8946|       |
 8947|  3.88k|    l.name = NULL;
 8948|  3.88k|    p.name = NULL;
 8949|       |
 8950|  3.88k|    GROW;
  ------------------
  |  | 2270|  3.88k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  3.88k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 2.06k, False: 1.81k]
  |  |  ------------------
  |  | 2271|  3.88k|	xmlParserGrow(ctxt);
  ------------------
 8951|  3.88k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8951:9): [True: 0, False: 3.88k]
  ------------------
 8952|      0|        return(l);
 8953|  3.88k|    start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|  3.88k|#define CUR_PTR ctxt->input->cur
  ------------------
                  start = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|  3.88k|#define BASE_PTR ctxt->input->base
  ------------------
 8954|       |
 8955|  3.88k|    l = xmlParseNCName(ctxt);
 8956|  3.88k|    if ((l.name != NULL) && (CUR == ':')) {
  ------------------
  |  | 2222|  3.87k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8956:9): [True: 3.87k, False: 9]
  |  Branch (8956:29): [True: 49, False: 3.82k]
  ------------------
 8957|     49|        NEXT;
  ------------------
  |  | 2275|     49|#define NEXT xmlNextChar(ctxt)
  ------------------
 8958|     49|	p = l;
 8959|     49|	l = xmlParseNCName(ctxt);
 8960|     49|    }
 8961|  3.88k|    if ((l.name == NULL) || (CUR == ':')) {
  ------------------
  |  | 2222|  3.87k|#define CUR (*ctxt->input->cur)
  ------------------
  |  Branch (8961:9): [True: 9, False: 3.87k]
  |  Branch (8961:29): [True: 0, False: 3.87k]
  ------------------
 8962|      9|        xmlChar *tmp;
 8963|       |
 8964|      9|        l.name = NULL;
 8965|      9|        p.name = NULL;
 8966|      9|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8966:13): [True: 0, False: 9]
  ------------------
 8967|      0|            return(l);
 8968|      9|        if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2222|      9|#define CUR (*ctxt->input->cur)
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2224|      9|#define CUR_PTR ctxt->input->cur
  ------------------
                      if ((CUR != ':') && (CUR_PTR <= BASE_PTR + start))
  ------------------
  |  | 2225|      9|#define BASE_PTR ctxt->input->base
  ------------------
  |  Branch (8968:13): [True: 9, False: 0]
  |  Branch (8968:29): [True: 9, False: 0]
  ------------------
 8969|      9|            return(l);
 8970|      0|        tmp = xmlParseNmtoken(ctxt);
 8971|      0|        if (tmp != NULL)
  ------------------
  |  Branch (8971:13): [True: 0, False: 0]
  ------------------
 8972|      0|            xmlFree(tmp);
 8973|      0|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (8973:13): [True: 0, False: 0]
  ------------------
 8974|      0|            return(l);
 8975|      0|        l = xmlDictLookupHashed(ctxt->dict, BASE_PTR + start,
  ------------------
  |  | 2225|      0|#define BASE_PTR ctxt->input->base
  ------------------
 8976|      0|                                CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
                                              CUR_PTR - (BASE_PTR + start));
  ------------------
  |  | 2225|      0|#define BASE_PTR ctxt->input->base
  ------------------
 8977|      0|        xmlNsErr(ctxt, XML_NS_ERR_QNAME,
 8978|      0|                 "Failed to parse QName '%s'\n", l.name, NULL, NULL);
 8979|      0|    }
 8980|       |
 8981|  3.87k|    *prefix = p;
 8982|  3.87k|    return(l);
 8983|  3.88k|}
parser.c:xmlParseNCName:
 3624|  3.93k|xmlParseNCName(xmlParserCtxtPtr ctxt) {
 3625|  3.93k|    const xmlChar *in, *e;
 3626|  3.93k|    xmlHashedString ret;
 3627|  3.93k|    size_t count = 0;
 3628|  3.93k|    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3628:24): [True: 0, False: 3.93k]
  ------------------
 3629|      0|                       XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3630|  3.93k|                       XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|  7.86k|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3631|       |
 3632|  3.93k|    ret.name = NULL;
 3633|       |
 3634|       |    /*
 3635|       |     * Accelerator for simple ASCII names
 3636|       |     */
 3637|  3.93k|    in = ctxt->input->cur;
 3638|  3.93k|    e = ctxt->input->end;
 3639|  3.93k|    if ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3639:11): [True: 3.80k, False: 121]
  |  Branch (3639:28): [True: 3.80k, False: 2]
  ------------------
 3640|  3.93k|	 ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3640:4): [True: 114, False: 9]
  |  Branch (3640:21): [True: 112, False: 2]
  ------------------
 3641|  3.93k|	 (*in == '_')) && (in < e)) {
  ------------------
  |  Branch (3641:3): [True: 0, False: 11]
  |  Branch (3641:20): [True: 3.91k, False: 0]
  ------------------
 3642|  3.91k|	in++;
 3643|  13.4k|	while ((((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (3643:11): [True: 8.60k, False: 4.84k]
  |  Branch (3643:28): [True: 8.60k, False: 3]
  ------------------
 3644|  13.4k|	        ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (3644:11): [True: 694, False: 4.15k]
  |  Branch (3644:28): [True: 690, False: 4]
  ------------------
 3645|  13.4k|	        ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (3645:11): [True: 3.31k, False: 846]
  |  Branch (3645:28): [True: 240, False: 3.07k]
  ------------------
 3646|  13.4k|	        (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (3646:10): [True: 1, False: 3.91k]
  |  Branch (3646:26): [True: 0, False: 3.91k]
  ------------------
 3647|  13.4k|	        (*in == '.')) && (in < e))
  ------------------
  |  Branch (3647:10): [True: 0, False: 3.91k]
  |  Branch (3647:27): [True: 9.53k, False: 0]
  ------------------
 3648|  9.53k|	    in++;
 3649|  3.91k|	if (in >= e)
  ------------------
  |  Branch (3649:6): [True: 0, False: 3.91k]
  ------------------
 3650|      0|	    goto complex;
 3651|  3.91k|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (3651:6): [True: 3.91k, False: 2]
  |  Branch (3651:19): [True: 3.91k, False: 3]
  ------------------
 3652|  3.91k|	    count = in - ctxt->input->cur;
 3653|  3.91k|            if (count > maxLength) {
  ------------------
  |  Branch (3653:17): [True: 0, False: 3.91k]
  ------------------
 3654|      0|                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3655|      0|                return(ret);
 3656|      0|            }
 3657|  3.91k|	    ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);
 3658|  3.91k|	    ctxt->input->cur = in;
 3659|  3.91k|	    ctxt->input->col += count;
 3660|  3.91k|	    if (ret.name == NULL) {
  ------------------
  |  Branch (3660:10): [True: 0, False: 3.91k]
  ------------------
 3661|      0|	        xmlErrMemory(ctxt, NULL);
 3662|      0|	    }
 3663|  3.91k|	    return(ret);
 3664|  3.91k|	}
 3665|  3.91k|    }
 3666|     16|complex:
 3667|     16|    return(xmlParseNCNameComplex(ctxt));
 3668|  3.93k|}
parser.c:xmlParseNCNameComplex:
 3569|     16|xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {
 3570|     16|    xmlHashedString ret;
 3571|     16|    int len = 0, l;
 3572|     16|    int c;
 3573|     16|    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
  ------------------
  |  Branch (3573:21): [True: 0, False: 16]
  ------------------
 3574|      0|                    XML_MAX_TEXT_LENGTH :
  ------------------
  |  |   42|      0|#define XML_MAX_TEXT_LENGTH 10000000
  ------------------
 3575|     16|                    XML_MAX_NAME_LENGTH;
  ------------------
  |  |   61|     16|#define XML_MAX_NAME_LENGTH 50000
  ------------------
 3576|     16|    size_t startPosition = 0;
 3577|       |
 3578|     16|    ret.name = NULL;
 3579|     16|    ret.hashValue = 0;
 3580|       |
 3581|       |    /*
 3582|       |     * Handler for more complex cases
 3583|       |     */
 3584|     16|    startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2224|     16|#define CUR_PTR ctxt->input->cur
  ------------------
                  startPosition = CUR_PTR - BASE_PTR;
  ------------------
  |  | 2225|     16|#define BASE_PTR ctxt->input->base
  ------------------
 3585|     16|    c = CUR_CHAR(l);
  ------------------
  |  | 2291|     16|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3586|     16|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (3586:9): [True: 0, False: 16]
  |  Branch (3586:23): [True: 2, False: 14]
  |  Branch (3586:37): [True: 1, False: 13]
  ------------------
 3587|     16|	(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {
  ------------------
  |  Branch (3587:3): [True: 6, False: 7]
  |  Branch (3587:35): [True: 0, False: 7]
  ------------------
 3588|      9|	return(ret);
 3589|      9|    }
 3590|       |
 3591|     34|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (3591:12): [True: 32, False: 2]
  |  Branch (3591:26): [True: 31, False: 1]
  |  Branch (3591:40): [True: 31, False: 0]
  ------------------
 3592|     34|	   (xmlIsNameChar(ctxt, c) && (c != ':'))) {
  ------------------
  |  Branch (3592:6): [True: 27, False: 4]
  |  Branch (3592:32): [True: 27, False: 0]
  ------------------
 3593|     27|        if (len <= INT_MAX - l)
  ------------------
  |  Branch (3593:13): [True: 27, False: 0]
  ------------------
 3594|     27|	    len += l;
 3595|     27|	NEXTL(l);
  ------------------
  |  | 2284|     27|#define NEXTL(l) do {							\
  |  | 2285|     27|    if (*(ctxt->input->cur) == '\n') {					\
  |  |  ------------------
  |  |  |  Branch (2285:9): [True: 0, False: 27]
  |  |  ------------------
  |  | 2286|      0|	ctxt->input->line++; ctxt->input->col = 1;			\
  |  | 2287|     27|    } else ctxt->input->col++;						\
  |  | 2288|     27|    ctxt->input->cur += l;				\
  |  | 2289|     27|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2289:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
 3596|     27|	c = CUR_CHAR(l);
  ------------------
  |  | 2291|     27|#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)
  ------------------
 3597|     27|    }
 3598|      7|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (3598:9): [True: 0, False: 7]
  ------------------
 3599|      0|        return(ret);
 3600|      7|    if (len > maxLength) {
  ------------------
  |  Branch (3600:9): [True: 0, False: 7]
  ------------------
 3601|      0|        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "NCName");
 3602|      0|        return(ret);
 3603|      0|    }
 3604|      7|    ret = xmlDictLookupHashed(ctxt->dict, (BASE_PTR + startPosition), len);
  ------------------
  |  | 2225|      7|#define BASE_PTR ctxt->input->base
  ------------------
 3605|      7|    return(ret);
 3606|      7|}
parser.c:xmlParseAttribute2:
 9282|    917|{
 9283|    917|    xmlHashedString hname;
 9284|    917|    const xmlChar *prefix, *name;
 9285|    917|    xmlChar *val, *internal_val = NULL;
 9286|    917|    int normalize = 0;
 9287|       |
 9288|    917|    *value = NULL;
 9289|    917|    GROW;
  ------------------
  |  | 2270|    917|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    917|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 427, False: 490]
  |  |  ------------------
  |  | 2271|    917|	xmlParserGrow(ctxt);
  ------------------
 9290|    917|    hname = xmlParseQNameHashed(ctxt, hprefix);
 9291|    917|    if (hname.name == NULL) {
  ------------------
  |  Branch (9291:9): [True: 2, False: 915]
  ------------------
 9292|      2|        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 9293|      2|                       "error parsing attribute name\n");
 9294|      2|        return(hname);
 9295|      2|    }
 9296|    915|    name = hname.name;
 9297|    915|    if (hprefix->name != NULL)
  ------------------
  |  Branch (9297:9): [True: 48, False: 867]
  ------------------
 9298|     48|        prefix = hprefix->name;
 9299|    867|    else
 9300|    867|        prefix = NULL;
 9301|       |
 9302|       |    /*
 9303|       |     * get the type if needed
 9304|       |     */
 9305|    915|    if (ctxt->attsSpecial != NULL) {
  ------------------
  |  Branch (9305:9): [True: 132, False: 783]
  ------------------
 9306|    132|        int type;
 9307|       |
 9308|    132|        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,
 9309|    132|                                                 pref, elem,
 9310|    132|                                                 prefix, name);
 9311|    132|        if (type != 0)
  ------------------
  |  Branch (9311:13): [True: 110, False: 22]
  ------------------
 9312|    110|            normalize = 1;
 9313|    132|    }
 9314|       |
 9315|       |    /*
 9316|       |     * read the value
 9317|       |     */
 9318|    915|    SKIP_BLANKS;
  ------------------
  |  | 2273|    915|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9319|    915|    if (RAW == '=') {
  ------------------
  |  | 2221|    915|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (9319:9): [True: 914, False: 1]
  ------------------
 9320|    914|        NEXT;
  ------------------
  |  | 2275|    914|#define NEXT xmlNextChar(ctxt)
  ------------------
 9321|    914|        SKIP_BLANKS;
  ------------------
  |  | 2273|    914|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 9322|    914|        val = xmlParseAttValueInternal(ctxt, len, alloc, normalize);
 9323|    914|        if (val == NULL) {
  ------------------
  |  Branch (9323:13): [True: 0, False: 914]
  ------------------
 9324|      0|            hname.name = NULL;
 9325|      0|            return(hname);
 9326|      0|        }
 9327|    914|	if (normalize) {
  ------------------
  |  Branch (9327:6): [True: 110, False: 804]
  ------------------
 9328|       |	    /*
 9329|       |	     * Sometimes a second normalisation pass for spaces is needed
 9330|       |	     * but that only happens if charrefs or entities references
 9331|       |	     * have been used in the attribute value, i.e. the attribute
 9332|       |	     * value have been extracted in an allocated string already.
 9333|       |	     */
 9334|    110|	    if (*alloc) {
  ------------------
  |  Branch (9334:10): [True: 0, False: 110]
  ------------------
 9335|      0|	        const xmlChar *val2;
 9336|       |
 9337|      0|	        val2 = xmlAttrNormalizeSpace2(ctxt, val, len);
 9338|      0|		if ((val2 != NULL) && (val2 != val)) {
  ------------------
  |  Branch (9338:7): [True: 0, False: 0]
  |  Branch (9338:25): [True: 0, False: 0]
  ------------------
 9339|      0|		    xmlFree(val);
 9340|      0|		    val = (xmlChar *) val2;
 9341|      0|		}
 9342|      0|	    }
 9343|    110|	}
 9344|    914|        ctxt->instate = XML_PARSER_CONTENT;
 9345|    914|    } else {
 9346|      1|        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,
 9347|      1|                          "Specification mandates value for attribute %s\n",
 9348|      1|                          name);
 9349|      1|        return(hname);
 9350|      1|    }
 9351|       |
 9352|    914|    if (prefix == ctxt->str_xml) {
  ------------------
  |  Branch (9352:9): [True: 36, False: 878]
  ------------------
 9353|       |        /*
 9354|       |         * Check that xml:lang conforms to the specification
 9355|       |         * No more registered as an error, just generate a warning now
 9356|       |         * since this was deprecated in XML second edition
 9357|       |         */
 9358|     36|        if ((ctxt->pedantic) && (xmlStrEqual(name, BAD_CAST "lang"))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9358:13): [True: 0, False: 36]
  |  Branch (9358:33): [True: 0, False: 0]
  ------------------
 9359|      0|            internal_val = xmlStrndup(val, *len);
 9360|      0|            if (!xmlCheckLanguageID(internal_val)) {
  ------------------
  |  Branch (9360:17): [True: 0, False: 0]
  ------------------
 9361|      0|                xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,
 9362|      0|                              "Malformed value for xml:lang : %s\n",
 9363|      0|                              internal_val, NULL);
 9364|      0|            }
 9365|      0|        }
 9366|       |
 9367|       |        /*
 9368|       |         * Check that xml:space conforms to the specification
 9369|       |         */
 9370|     36|        if (xmlStrEqual(name, BAD_CAST "space")) {
  ------------------
  |  |   35|     36|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9370:13): [True: 0, False: 36]
  ------------------
 9371|      0|            internal_val = xmlStrndup(val, *len);
 9372|      0|            if (xmlStrEqual(internal_val, BAD_CAST "default"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9372:17): [True: 0, False: 0]
  ------------------
 9373|      0|                *(ctxt->space) = 0;
 9374|      0|            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9374:22): [True: 0, False: 0]
  ------------------
 9375|      0|                *(ctxt->space) = 1;
 9376|      0|            else {
 9377|      0|                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,
 9378|      0|                              "Invalid value \"%s\" for xml:space : \"default\" or \"preserve\" expected\n",
 9379|      0|                              internal_val, NULL);
 9380|      0|            }
 9381|      0|        }
 9382|     36|        if (internal_val) {
  ------------------
  |  Branch (9382:13): [True: 0, False: 36]
  ------------------
 9383|      0|            xmlFree(internal_val);
 9384|      0|        }
 9385|     36|    }
 9386|       |
 9387|    914|    *value = val;
 9388|    914|    return (hname);
 9389|    915|}
parser.c:xmlCtxtGrowAttrs:
 1853|    170|xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {
 1854|    170|    const xmlChar **atts;
 1855|    170|    unsigned *attallocs;
 1856|    170|    int maxatts;
 1857|       |
 1858|    170|    if (nr + 5 > ctxt->maxatts) {
  ------------------
  |  Branch (1858:9): [True: 170, False: 0]
  ------------------
 1859|    170|	maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;
  ------------------
  |  Branch (1859:12): [True: 170, False: 0]
  ------------------
 1860|    170|	atts = (const xmlChar **) xmlMalloc(
 1861|    170|				     maxatts * sizeof(const xmlChar *));
 1862|    170|	if (atts == NULL) goto mem_error;
  ------------------
  |  Branch (1862:6): [True: 0, False: 170]
  ------------------
 1863|    170|	attallocs = xmlRealloc(ctxt->attallocs,
 1864|    170|                               (maxatts / 5) * sizeof(attallocs[0]));
 1865|    170|	if (attallocs == NULL) {
  ------------------
  |  Branch (1865:6): [True: 0, False: 170]
  ------------------
 1866|      0|            xmlFree(atts);
 1867|      0|            goto mem_error;
 1868|      0|        }
 1869|    170|        if (ctxt->maxatts > 0)
  ------------------
  |  Branch (1869:13): [True: 0, False: 170]
  ------------------
 1870|      0|            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));
 1871|    170|        xmlFree(ctxt->atts);
 1872|    170|	ctxt->atts = atts;
 1873|    170|	ctxt->attallocs = attallocs;
 1874|    170|	ctxt->maxatts = maxatts;
 1875|    170|    }
 1876|    170|    return(ctxt->maxatts);
 1877|      0|mem_error:
 1878|      0|    xmlErrMemory(ctxt, NULL);
 1879|      0|    return(-1);
 1880|    170|}
parser.c:xmlAttrHashInsert:
 9407|    224|                  const xmlChar *uri, unsigned hashValue, int aindex) {
 9408|    224|    xmlAttrHashBucket *table = ctxt->attrHash;
 9409|    224|    xmlAttrHashBucket *bucket;
 9410|    224|    unsigned hindex;
 9411|       |
 9412|    224|    hindex = hashValue & (size - 1);
 9413|    224|    bucket = &table[hindex];
 9414|       |
 9415|    224|    while (bucket->index >= 0) {
  ------------------
  |  Branch (9415:12): [True: 0, False: 224]
  ------------------
 9416|      0|        const xmlChar **atts = &ctxt->atts[bucket->index];
 9417|       |
 9418|      0|        if (name == atts[0]) {
  ------------------
  |  Branch (9418:13): [True: 0, False: 0]
  ------------------
 9419|      0|            int nsIndex = (int) (ptrdiff_t) atts[2];
 9420|       |
 9421|      0|            if ((nsIndex == NS_INDEX_EMPTY) ? (uri == NULL) :
  ------------------
  |  |   77|      0|#define NS_INDEX_EMPTY  INT_MAX
  ------------------
  |  Branch (9421:17): [True: 0, False: 0]
  |  Branch (9421:17): [True: 0, False: 0]
  ------------------
 9422|      0|                (nsIndex == NS_INDEX_XML) ? (uri == ctxt->str_xml) :
  ------------------
  |  |   78|      0|#define NS_INDEX_XML    (INT_MAX - 1)
  ------------------
  |  Branch (9422:17): [True: 0, False: 0]
  ------------------
 9423|      0|                (uri == ctxt->nsTab[nsIndex * 2 + 1]))
 9424|      0|                return(bucket->index);
 9425|      0|        }
 9426|       |
 9427|      0|        hindex++;
 9428|      0|        bucket++;
 9429|      0|        if (hindex >= size) {
  ------------------
  |  Branch (9429:13): [True: 0, False: 0]
  ------------------
 9430|      0|            hindex = 0;
 9431|      0|            bucket = table;
 9432|      0|        }
 9433|      0|    }
 9434|       |
 9435|    224|    bucket->index = aindex;
 9436|       |
 9437|    224|    return(INT_MAX);
 9438|    224|}
parser.c:xmlParserNsLookupUri:
 1532|  2.95k|xmlParserNsLookupUri(xmlParserCtxtPtr ctxt, const xmlHashedString *prefix) {
 1533|  2.95k|    const xmlChar *ret;
 1534|  2.95k|    int nsIndex;
 1535|       |
 1536|  2.95k|    if (prefix->name == ctxt->str_xml)
  ------------------
  |  Branch (1536:9): [True: 0, False: 2.95k]
  ------------------
 1537|      0|        return(ctxt->str_xml_ns);
 1538|       |
 1539|  2.95k|    nsIndex = xmlParserNsLookup(ctxt, prefix, NULL);
 1540|  2.95k|    if (nsIndex == INT_MAX)
  ------------------
  |  Branch (1540:9): [True: 2.95k, False: 6]
  ------------------
 1541|  2.95k|        return(NULL);
 1542|       |
 1543|      6|    ret = ctxt->nsTab[nsIndex * 2 + 1];
 1544|      6|    if (ret[0] == 0)
  ------------------
  |  Branch (1544:9): [True: 0, False: 6]
  ------------------
 1545|      0|        ret = NULL;
 1546|      6|    return(ret);
 1547|  2.95k|}
parser.c:nameNsPush:
 2024|  2.95k|{
 2025|  2.95k|    xmlStartTag *tag;
 2026|       |
 2027|  2.95k|    if (ctxt->nameNr >= ctxt->nameMax) {
  ------------------
  |  Branch (2027:9): [True: 0, False: 2.95k]
  ------------------
 2028|      0|        const xmlChar * *tmp;
 2029|      0|        xmlStartTag *tmp2;
 2030|      0|        ctxt->nameMax *= 2;
 2031|      0|        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,
 2032|      0|                                    ctxt->nameMax *
 2033|      0|                                    sizeof(ctxt->nameTab[0]));
 2034|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (2034:13): [True: 0, False: 0]
  ------------------
 2035|      0|	    ctxt->nameMax /= 2;
 2036|      0|	    goto mem_error;
 2037|      0|        }
 2038|      0|	ctxt->nameTab = tmp;
 2039|      0|        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,
 2040|      0|                                    ctxt->nameMax *
 2041|      0|                                    sizeof(ctxt->pushTab[0]));
 2042|      0|        if (tmp2 == NULL) {
  ------------------
  |  Branch (2042:13): [True: 0, False: 0]
  ------------------
 2043|      0|	    ctxt->nameMax /= 2;
 2044|      0|	    goto mem_error;
 2045|      0|        }
 2046|      0|	ctxt->pushTab = tmp2;
 2047|  2.95k|    } else if (ctxt->pushTab == NULL) {
  ------------------
  |  Branch (2047:16): [True: 480, False: 2.47k]
  ------------------
 2048|    480|        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *
 2049|    480|                                            sizeof(ctxt->pushTab[0]));
 2050|    480|        if (ctxt->pushTab == NULL)
  ------------------
  |  Branch (2050:13): [True: 0, False: 480]
  ------------------
 2051|      0|            goto mem_error;
 2052|    480|    }
 2053|  2.95k|    ctxt->nameTab[ctxt->nameNr] = value;
 2054|  2.95k|    ctxt->name = value;
 2055|  2.95k|    tag = &ctxt->pushTab[ctxt->nameNr];
 2056|  2.95k|    tag->prefix = prefix;
 2057|  2.95k|    tag->URI = URI;
 2058|  2.95k|    tag->line = line;
 2059|  2.95k|    tag->nsNr = nsNr;
 2060|  2.95k|    return (ctxt->nameNr++);
 2061|      0|mem_error:
 2062|      0|    xmlErrMemory(ctxt, NULL);
 2063|      0|    return (-1);
 2064|  2.95k|}
parser.c:xmlParseElementEnd:
10475|  2.70k|xmlParseElementEnd(xmlParserCtxtPtr ctxt) {
10476|  2.70k|    xmlNodePtr cur = ctxt->node;
10477|       |
10478|  2.70k|    if (ctxt->nameNr <= 0) {
  ------------------
  |  Branch (10478:9): [True: 0, False: 2.70k]
  ------------------
10479|      0|        if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                      if ((RAW == '<') && (NXT(1) == '/'))
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10479:13): [True: 0, False: 0]
  |  Branch (10479:29): [True: 0, False: 0]
  ------------------
10480|      0|            SKIP(2);
  ------------------
  |  | 2245|      0|#define SKIP(val) do {							\
  |  | 2246|      0|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|      0|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2248|      0|        xmlParserGrow(ctxt);						\
  |  | 2249|      0|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10481|      0|        return;
10482|      0|    }
10483|       |
10484|       |    /*
10485|       |     * parse the end of tag: '</' should be here.
10486|       |     */
10487|  2.70k|    if (ctxt->sax2) {
  ------------------
  |  Branch (10487:9): [True: 2.70k, False: 0]
  ------------------
10488|  2.70k|	xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);
10489|  2.70k|	namePop(ctxt);
10490|  2.70k|    }
10491|      0|#ifdef LIBXML_SAX1_ENABLED
10492|      0|    else
10493|      0|	xmlParseEndTag1(ctxt, 0);
10494|  2.70k|#endif /* LIBXML_SAX1_ENABLED */
10495|       |
10496|       |    /*
10497|       |     * Capture end position
10498|       |     */
10499|  2.70k|    if (cur != NULL && ctxt->record_info) {
  ------------------
  |  Branch (10499:9): [True: 2.70k, False: 0]
  |  Branch (10499:24): [True: 0, False: 2.70k]
  ------------------
10500|      0|        xmlParserNodeInfoPtr node_info;
10501|       |
10502|      0|        node_info = (xmlParserNodeInfoPtr) xmlParserFindNodeInfo(ctxt, cur);
10503|      0|        if (node_info != NULL) {
  ------------------
  |  Branch (10503:13): [True: 0, False: 0]
  ------------------
10504|      0|            node_info->end_pos = ctxt->input->consumed +
10505|      0|                                 (CUR_PTR - ctxt->input->base);
  ------------------
  |  | 2224|      0|#define CUR_PTR ctxt->input->cur
  ------------------
10506|      0|            node_info->end_line = ctxt->input->line;
10507|      0|        }
10508|      0|    }
10509|  2.70k|}
parser.c:xmlParseEndTag2:
10039|  2.70k|xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlStartTag *tag) {
10040|  2.70k|    const xmlChar *name;
10041|       |
10042|  2.70k|    GROW;
  ------------------
  |  | 2270|  2.70k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.70k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.77k, False: 935]
  |  |  ------------------
  |  | 2271|  2.70k|	xmlParserGrow(ctxt);
  ------------------
10043|  2.70k|    if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2221|  2.70k|#define RAW (*ctxt->input->cur)
  ------------------
                  if ((RAW != '<') || (NXT(1) != '/')) {
  ------------------
  |  | 2223|  2.70k|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (10043:9): [True: 0, False: 2.70k]
  |  Branch (10043:25): [True: 0, False: 2.70k]
  ------------------
10044|      0|	xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);
10045|      0|	return;
10046|      0|    }
10047|  2.70k|    SKIP(2);
  ------------------
  |  | 2245|  2.70k|#define SKIP(val) do {							\
  |  | 2246|  2.70k|    ctxt->input->cur += (val),ctxt->input->col+=(val);			\
  |  | 2247|  2.70k|    if (*ctxt->input->cur == 0)						\
  |  |  ------------------
  |  |  |  Branch (2247:9): [True: 0, False: 2.70k]
  |  |  ------------------
  |  | 2248|  2.70k|        xmlParserGrow(ctxt);						\
  |  | 2249|  2.70k|  } while (0)
  |  |  ------------------
  |  |  |  Branch (2249:12): [Folded - Ignored]
  |  |  ------------------
  ------------------
10048|       |
10049|  2.70k|    if (tag->prefix == NULL)
  ------------------
  |  Branch (10049:9): [True: 2.70k, False: 1]
  ------------------
10050|  2.70k|        name = xmlParseNameAndCompare(ctxt, ctxt->name);
10051|      1|    else
10052|      1|        name = xmlParseQNameAndCompare(ctxt, ctxt->name, tag->prefix);
10053|       |
10054|       |    /*
10055|       |     * We should definitely be at the ending "S? '>'" part
10056|       |     */
10057|  2.70k|    GROW;
  ------------------
  |  | 2270|  2.70k|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|  2.70k|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1.77k, False: 935]
  |  |  ------------------
  |  | 2271|  2.70k|	xmlParserGrow(ctxt);
  ------------------
10058|  2.70k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (10058:9): [True: 0, False: 2.70k]
  ------------------
10059|      0|        return;
10060|  2.70k|    SKIP_BLANKS;
  ------------------
  |  | 2273|  2.70k|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
10061|  2.70k|    if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  |  113|  2.70k|#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|  2.70k|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 2.70k, False: 2]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 2.70k]
  |  |  |  |  ------------------
  |  |  |  |  109|  2.70k|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 2.70k]
  |  |  |  |  ------------------
  |  |  |  |  110|  2.70k|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 2.70k, False: 2]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) {
  ------------------
  |  | 2221|  2.70k|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (10061:33): [True: 7, False: 2.69k]
  ------------------
10062|      9|	xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);
10063|      9|    } else
10064|  2.69k|	NEXT1;
  ------------------
  |  | 2277|  2.69k|#define NEXT1 {								\
  |  | 2278|  2.69k|	ctxt->input->col++;						\
  |  | 2279|  2.69k|	ctxt->input->cur++;						\
  |  | 2280|  2.69k|	if (*ctxt->input->cur == 0)					\
  |  |  ------------------
  |  |  |  Branch (2280:6): [True: 281, False: 2.41k]
  |  |  ------------------
  |  | 2281|  2.69k|	    xmlParserGrow(ctxt);						\
  |  | 2282|  2.69k|    }
  ------------------
10065|       |
10066|       |    /*
10067|       |     * [ WFC: Element Type Match ]
10068|       |     * The Name in an element's end-tag must match the element type in the
10069|       |     * start-tag.
10070|       |     *
10071|       |     */
10072|  2.70k|    if (name != (xmlChar*)1) {
  ------------------
  |  Branch (10072:9): [True: 35, False: 2.67k]
  ------------------
10073|     35|        if (name == NULL) name = BAD_CAST "unparsable";
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10073:13): [True: 1, False: 34]
  ------------------
10074|     35|        xmlFatalErrMsgStrIntStr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
10075|     35|		     "Opening and ending tag mismatch: %s line %d and %s\n",
10076|     35|		                ctxt->name, tag->line, name);
10077|     35|    }
10078|       |
10079|       |    /*
10080|       |     * SAX: End of Tag
10081|       |     */
10082|  2.70k|    if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&
  ------------------
  |  Branch (10082:9): [True: 2.70k, False: 0]
  |  Branch (10082:32): [True: 2.70k, False: 0]
  ------------------
10083|  2.70k|	(!ctxt->disableSAX))
  ------------------
  |  Branch (10083:2): [True: 2.70k, False: 0]
  ------------------
10084|  2.70k|	ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,
10085|  2.70k|                                tag->URI);
10086|       |
10087|  2.70k|    spacePop(ctxt);
10088|  2.70k|    if (tag->nsNr != 0)
  ------------------
  |  Branch (10088:9): [True: 11, False: 2.69k]
  ------------------
10089|     11|	xmlParserNsPop(ctxt, tag->nsNr);
10090|  2.70k|}
parser.c:xmlParseQNameAndCompare:
 9025|      1|                        xmlChar const *prefix) {
 9026|      1|    const xmlChar *cmp;
 9027|      1|    const xmlChar *in;
 9028|      1|    const xmlChar *ret;
 9029|      1|    const xmlChar *prefix2;
 9030|       |
 9031|      1|    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));
  ------------------
  |  Branch (9031:9): [True: 0, False: 1]
  ------------------
 9032|       |
 9033|      1|    GROW;
  ------------------
  |  | 2270|      1|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|      1|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 1, False: 0]
  |  |  ------------------
  |  | 2271|      1|	xmlParserGrow(ctxt);
  ------------------
 9034|      1|    in = ctxt->input->cur;
 9035|       |
 9036|      1|    cmp = prefix;
 9037|      1|    while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9037:12): [True: 1, False: 0]
  |  Branch (9037:24): [True: 0, False: 1]
  ------------------
 9038|      0|	++in;
 9039|      0|	++cmp;
 9040|      0|    }
 9041|      1|    if ((*cmp == 0) && (*in == ':')) {
  ------------------
  |  Branch (9041:9): [True: 0, False: 1]
  |  Branch (9041:24): [True: 0, False: 0]
  ------------------
 9042|      0|        in++;
 9043|      0|	cmp = name;
 9044|      0|	while (*in != 0 && *in == *cmp) {
  ------------------
  |  Branch (9044:9): [True: 0, False: 0]
  |  Branch (9044:21): [True: 0, False: 0]
  ------------------
 9045|      0|	    ++in;
 9046|      0|	    ++cmp;
 9047|      0|	}
 9048|      0|	if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9048:6): [True: 0, False: 0]
  |  Branch (9048:20): [True: 0, False: 0]
  ------------------
 9049|       |	    /* success */
 9050|      0|            ctxt->input->col += in - ctxt->input->cur;
 9051|      0|	    ctxt->input->cur = in;
 9052|      0|	    return((const xmlChar*) 1);
 9053|      0|	}
 9054|      0|    }
 9055|       |    /*
 9056|       |     * all strings coms from the dictionary, equality can be done directly
 9057|       |     */
 9058|      1|    ret = xmlParseQName (ctxt, &prefix2);
 9059|      1|    if (ret == NULL)
  ------------------
  |  Branch (9059:9): [True: 0, False: 1]
  ------------------
 9060|      0|        return(NULL);
 9061|      1|    if ((ret == name) && (prefix == prefix2))
  ------------------
  |  Branch (9061:9): [True: 0, False: 1]
  |  Branch (9061:26): [True: 0, False: 0]
  ------------------
 9062|      0|	return((const xmlChar*) 1);
 9063|      1|    return ret;
 9064|      1|}
parser.c:xmlParseQName:
 9000|      1|xmlParseQName(xmlParserCtxtPtr ctxt, const xmlChar **prefix) {
 9001|      1|    xmlHashedString n, p;
 9002|       |
 9003|      1|    n = xmlParseQNameHashed(ctxt, &p);
 9004|      1|    if (n.name == NULL)
  ------------------
  |  Branch (9004:9): [True: 0, False: 1]
  ------------------
 9005|      0|        return(NULL);
 9006|      1|    *prefix = p.name;
 9007|      1|    return(n.name);
 9008|      1|}
parser.c:xmlParseInternalSubset:
 8533|     23|xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
 8534|       |    /*
 8535|       |     * Is there any DTD definition ?
 8536|       |     */
 8537|     23|    if (RAW == '[') {
  ------------------
  |  | 2221|     23|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8537:9): [True: 23, False: 0]
  ------------------
 8538|     23|        int baseInputNr = ctxt->inputNr;
 8539|     23|        ctxt->instate = XML_PARSER_DTD;
 8540|     23|        NEXT;
  ------------------
  |  | 2275|     23|#define NEXT xmlNextChar(ctxt)
  ------------------
 8541|       |	/*
 8542|       |	 * Parse the succession of Markup declarations and
 8543|       |	 * PEReferences.
 8544|       |	 * Subsequence (markupdecl | PEReference | S)*
 8545|       |	 */
 8546|     23|	SKIP_BLANKS;
  ------------------
  |  | 2273|     23|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8547|    244|	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&
  ------------------
  |  | 2221|    244|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8547:10): [True: 222, False: 22]
  |  Branch (8547:26): [True: 0, False: 22]
  ------------------
 8548|    244|               (ctxt->instate != XML_PARSER_EOF)) {
  ------------------
  |  Branch (8548:16): [True: 222, False: 0]
  ------------------
 8549|       |
 8550|       |            /*
 8551|       |             * Conditional sections are allowed from external entities included
 8552|       |             * by PE References in the internal subset.
 8553|       |             */
 8554|    222|            if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
  ------------------
  |  Branch (8554:17): [True: 0, False: 222]
  |  Branch (8554:40): [True: 0, False: 0]
  ------------------
 8555|    222|                (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2221|      0|#define RAW (*ctxt->input->cur)
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                              (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8555:17): [True: 0, False: 0]
  |  Branch (8555:33): [True: 0, False: 0]
  |  Branch (8555:52): [True: 0, False: 0]
  ------------------
 8556|      0|                xmlParseConditionalSections(ctxt);
 8557|    222|            } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2221|    222|#define RAW (*ctxt->input->cur)
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|    221|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
                          } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
  ------------------
  |  | 2223|      0|#define NXT(val) ctxt->input->cur[(val)]
  ------------------
  |  Branch (8557:24): [True: 221, False: 1]
  |  Branch (8557:41): [True: 221, False: 0]
  |  Branch (8557:60): [True: 0, False: 0]
  ------------------
 8558|    221|	        xmlParseMarkupDecl(ctxt);
 8559|    221|            } else if (RAW == '%') {
  ------------------
  |  | 2221|      1|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8559:24): [True: 0, False: 1]
  ------------------
 8560|      0|	        xmlParsePEReference(ctxt);
 8561|      1|            } else {
 8562|      1|		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 8563|      1|                        "xmlParseInternalSubset: error detected in"
 8564|      1|                        " Markup declaration\n");
 8565|      1|                xmlHaltParser(ctxt);
 8566|      1|                return;
 8567|      1|            }
 8568|    221|	    SKIP_BLANKS;
  ------------------
  |  | 2273|    221|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8569|    221|            SHRINK;
  ------------------
  |  | 2265|    221|    if (((ctxt->progressive == 0) || (ctxt->inputNr > 1)) && \
  |  |  ------------------
  |  |  |  Branch (2265:10): [True: 221, False: 0]
  |  |  |  Branch (2265:38): [True: 0, False: 0]
  |  |  ------------------
  |  | 2266|    221|        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \
  |  |  ------------------
  |  |  |  |   97|    221|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2266:9): [True: 0, False: 221]
  |  |  ------------------
  |  | 2267|    221|	(ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \
  |  |  ------------------
  |  |  |  |   97|      0|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2267:2): [True: 0, False: 0]
  |  |  ------------------
  |  | 2268|    221|	xmlParserShrink(ctxt);
  ------------------
 8570|    221|            GROW;
  ------------------
  |  | 2270|    221|#define GROW if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)	\
  |  |  ------------------
  |  |  |  |   97|    221|#define INPUT_CHUNK	250
  |  |  ------------------
  |  |  |  Branch (2270:18): [True: 0, False: 221]
  |  |  ------------------
  |  | 2271|    221|	xmlParserGrow(ctxt);
  ------------------
 8571|    221|	}
 8572|     22|	if (RAW == ']') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8572:6): [True: 22, False: 0]
  ------------------
 8573|     22|	    NEXT;
  ------------------
  |  | 2275|     22|#define NEXT xmlNextChar(ctxt)
  ------------------
 8574|     22|	    SKIP_BLANKS;
  ------------------
  |  | 2273|     22|#define SKIP_BLANKS xmlSkipBlankChars(ctxt)
  ------------------
 8575|     22|	}
 8576|     22|    }
 8577|       |
 8578|       |    /*
 8579|       |     * We should be at the end of the DOCTYPE declaration.
 8580|       |     */
 8581|     22|    if (RAW != '>') {
  ------------------
  |  | 2221|     22|#define RAW (*ctxt->input->cur)
  ------------------
  |  Branch (8581:9): [True: 0, False: 22]
  ------------------
 8582|      0|	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 8583|      0|	return;
 8584|      0|    }
 8585|     22|    NEXT;
  ------------------
  |  | 2275|     22|#define NEXT xmlNextChar(ctxt)
  ------------------
 8586|     22|}
parser.c:xmlCleanSpecialAttr:
 1181|     22|{
 1182|     22|    if (ctxt->attsSpecial == NULL)
  ------------------
  |  Branch (1182:9): [True: 0, False: 22]
  ------------------
 1183|      0|        return;
 1184|       |
 1185|     22|    xmlHashScanFull(ctxt->attsSpecial, xmlCleanSpecialAttrCallback, ctxt);
 1186|       |
 1187|     22|    if (xmlHashSize(ctxt->attsSpecial) == 0) {
  ------------------
  |  Branch (1187:9): [True: 0, False: 22]
  ------------------
 1188|      0|        xmlHashFree(ctxt->attsSpecial, NULL);
 1189|      0|        ctxt->attsSpecial = NULL;
 1190|      0|    }
 1191|     22|    return;
 1192|     22|}
parser.c:xmlCleanSpecialAttrCallback:
 1163|     88|                            const xmlChar *unused ATTRIBUTE_UNUSED) {
 1164|     88|    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) data;
 1165|       |
 1166|     88|    if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {
  ------------------
  |  Branch (1166:9): [True: 22, False: 66]
  ------------------
 1167|     22|        xmlHashRemoveEntry2(ctxt->attsSpecial, fullname, fullattr, NULL);
 1168|     22|    }
 1169|     88|}
parser.c:xmlParserNsPush:
 1664|     18|                const xmlHashedString *uri, void *saxData, int defAttr) {
 1665|     18|    xmlParserNsBucket *bucket = NULL;
 1666|     18|    xmlParserNsExtra *extra;
 1667|     18|    const xmlChar **ns;
 1668|     18|    unsigned hashValue, nsIndex, oldIndex;
 1669|       |
 1670|     18|    if ((prefix != NULL) && (prefix->name == ctxt->str_xml))
  ------------------
  |  Branch (1670:9): [True: 12, False: 6]
  |  Branch (1670:29): [True: 0, False: 12]
  ------------------
 1671|      0|        return(0);
 1672|       |
 1673|     18|    if ((ctxt->nsNr >= ctxt->nsMax) && (xmlParserNsGrow(ctxt) < 0)) {
  ------------------
  |  Branch (1673:9): [True: 12, False: 6]
  |  Branch (1673:40): [True: 0, False: 12]
  ------------------
 1674|      0|        xmlErrMemory(ctxt, NULL);
 1675|      0|        return(-1);
 1676|      0|    }
 1677|       |
 1678|       |    /*
 1679|       |     * Default namespace and 'xml' namespace
 1680|       |     */
 1681|     18|    if ((prefix == NULL) || (prefix->name == NULL)) {
  ------------------
  |  Branch (1681:9): [True: 6, False: 12]
  |  Branch (1681:29): [True: 0, False: 12]
  ------------------
 1682|      6|        oldIndex = ctxt->nsdb->defaultNsIndex;
 1683|       |
 1684|      6|        if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1684:13): [True: 0, False: 6]
  ------------------
 1685|      0|            if (defAttr != 0)
  ------------------
  |  Branch (1685:17): [True: 0, False: 0]
  ------------------
 1686|      0|                return(0);
 1687|       |
 1688|      0|            extra = &ctxt->nsdb->extra[oldIndex];
 1689|       |
 1690|      0|            if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1690:17): [True: 0, False: 0]
  ------------------
 1691|      0|                xmlErrAttributeDup(ctxt, NULL, BAD_CAST "xmlns");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1692|      0|                return(0);
 1693|      0|            }
 1694|       |
 1695|      0|            if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1695:17): [True: 0, False: 0]
  ------------------
 1696|      0|                (uri->name == ctxt->nsTab[oldIndex * 2 + 1]))
  ------------------
  |  Branch (1696:17): [True: 0, False: 0]
  ------------------
 1697|      0|                return(0);
 1698|      0|        }
 1699|       |
 1700|      6|        ctxt->nsdb->defaultNsIndex = ctxt->nsNr;
 1701|      6|        goto populate_entry;
 1702|      6|    }
 1703|       |
 1704|       |    /*
 1705|       |     * Hash table lookup
 1706|       |     */
 1707|     12|    oldIndex = xmlParserNsLookup(ctxt, prefix, &bucket);
 1708|     12|    if (oldIndex != INT_MAX) {
  ------------------
  |  Branch (1708:9): [True: 0, False: 12]
  ------------------
 1709|      0|        extra = &ctxt->nsdb->extra[oldIndex];
 1710|       |
 1711|      0|        if (defAttr != 0)
  ------------------
  |  Branch (1711:13): [True: 0, False: 0]
  ------------------
 1712|      0|            return(0);
 1713|       |
 1714|       |        /*
 1715|       |         * Check for duplicate definitions on the same element.
 1716|       |         */
 1717|      0|        if (extra->elementId == ctxt->nsdb->elementId) {
  ------------------
  |  Branch (1717:13): [True: 0, False: 0]
  ------------------
 1718|      0|            xmlErrAttributeDup(ctxt, BAD_CAST "xmlns", prefix->name);
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1719|      0|            return(0);
 1720|      0|        }
 1721|       |
 1722|      0|        if ((ctxt->options & XML_PARSE_NSCLEAN) &&
  ------------------
  |  Branch (1722:13): [True: 0, False: 0]
  ------------------
 1723|      0|            (uri->name == ctxt->nsTab[bucket->index * 2 + 1]))
  ------------------
  |  Branch (1723:13): [True: 0, False: 0]
  ------------------
 1724|      0|            return(0);
 1725|       |
 1726|      0|        bucket->index = ctxt->nsNr;
 1727|      0|        goto populate_entry;
 1728|      0|    }
 1729|       |
 1730|       |    /*
 1731|       |     * Insert new bucket
 1732|       |     */
 1733|       |
 1734|     12|    hashValue = prefix->hashValue;
 1735|       |
 1736|       |    /*
 1737|       |     * Grow hash table, 50% fill factor
 1738|       |     */
 1739|     12|    if (ctxt->nsdb->hashElems + 1 > ctxt->nsdb->hashSize / 2) {
  ------------------
  |  Branch (1739:9): [True: 6, False: 6]
  ------------------
 1740|      6|        xmlParserNsBucket *newHash;
 1741|      6|        unsigned newSize, i, index;
 1742|       |
 1743|      6|        if (ctxt->nsdb->hashSize > UINT_MAX / 2) {
  ------------------
  |  Branch (1743:13): [True: 0, False: 6]
  ------------------
 1744|      0|            xmlErrMemory(ctxt, NULL);
 1745|      0|            return(-1);
 1746|      0|        }
 1747|      6|        newSize = ctxt->nsdb->hashSize ? ctxt->nsdb->hashSize * 2 : 16;
  ------------------
  |  Branch (1747:19): [True: 0, False: 6]
  ------------------
 1748|      6|        newHash = xmlMalloc(newSize * sizeof(newHash[0]));
 1749|      6|        if (newHash == NULL) {
  ------------------
  |  Branch (1749:13): [True: 0, False: 6]
  ------------------
 1750|      0|            xmlErrMemory(ctxt, NULL);
 1751|      0|            return(-1);
 1752|      0|        }
 1753|      6|        memset(newHash, 0, newSize * sizeof(newHash[0]));
 1754|       |
 1755|      6|        for (i = 0; i < ctxt->nsdb->hashSize; i++) {
  ------------------
  |  Branch (1755:21): [True: 0, False: 6]
  ------------------
 1756|      0|            unsigned hv = ctxt->nsdb->hash[i].hashValue;
 1757|      0|            unsigned newIndex;
 1758|       |
 1759|      0|            if (hv == 0)
  ------------------
  |  Branch (1759:17): [True: 0, False: 0]
  ------------------
 1760|      0|                continue;
 1761|      0|            newIndex = hv & (newSize - 1);
 1762|       |
 1763|      0|            while (newHash[newIndex].hashValue != 0) {
  ------------------
  |  Branch (1763:20): [True: 0, False: 0]
  ------------------
 1764|      0|                newIndex++;
 1765|      0|                if (newIndex == newSize)
  ------------------
  |  Branch (1765:21): [True: 0, False: 0]
  ------------------
 1766|      0|                    newIndex = 0;
 1767|      0|            }
 1768|       |
 1769|      0|            newHash[newIndex] = ctxt->nsdb->hash[i];
 1770|      0|        }
 1771|       |
 1772|      6|        xmlFree(ctxt->nsdb->hash);
 1773|      6|        ctxt->nsdb->hash = newHash;
 1774|      6|        ctxt->nsdb->hashSize = newSize;
 1775|       |
 1776|       |        /*
 1777|       |         * Relookup
 1778|       |         */
 1779|      6|        index = hashValue & (newSize - 1);
 1780|       |
 1781|      6|        while (newHash[index].hashValue != 0) {
  ------------------
  |  Branch (1781:16): [True: 0, False: 6]
  ------------------
 1782|      0|            index++;
 1783|      0|            if (index == newSize)
  ------------------
  |  Branch (1783:17): [True: 0, False: 0]
  ------------------
 1784|      0|                index = 0;
 1785|      0|        }
 1786|       |
 1787|      6|        bucket = &newHash[index];
 1788|      6|    }
 1789|       |
 1790|     12|    bucket->hashValue = hashValue;
 1791|     12|    bucket->index = ctxt->nsNr;
 1792|     12|    ctxt->nsdb->hashElems++;
 1793|     12|    oldIndex = INT_MAX;
 1794|       |
 1795|     18|populate_entry:
 1796|     18|    nsIndex = ctxt->nsNr;
 1797|       |
 1798|     18|    ns = &ctxt->nsTab[nsIndex * 2];
 1799|     18|    ns[0] = prefix ? prefix->name : NULL;
  ------------------
  |  Branch (1799:13): [True: 12, False: 6]
  ------------------
 1800|     18|    ns[1] = uri->name;
 1801|       |
 1802|     18|    extra = &ctxt->nsdb->extra[nsIndex];
 1803|     18|    extra->saxData = saxData;
 1804|     18|    extra->prefixHashValue = prefix ? prefix->hashValue : 0;
  ------------------
  |  Branch (1804:30): [True: 12, False: 6]
  ------------------
 1805|     18|    extra->uriHashValue = uri->hashValue;
 1806|     18|    extra->elementId = ctxt->nsdb->elementId;
 1807|     18|    extra->oldIndex = oldIndex;
 1808|       |
 1809|     18|    ctxt->nsNr++;
 1810|       |
 1811|     18|    return(1);
 1812|     12|}
parser.c:xmlParserNsGrow:
 1622|     12|xmlParserNsGrow(xmlParserCtxtPtr ctxt) {
 1623|     12|    const xmlChar **table;
 1624|     12|    xmlParserNsExtra *extra;
 1625|     12|    int newSize;
 1626|       |
 1627|     12|    if (ctxt->nsMax > INT_MAX / 2)
  ------------------
  |  Branch (1627:9): [True: 0, False: 12]
  ------------------
 1628|      0|        goto error;
 1629|     12|    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;
  ------------------
  |  Branch (1629:15): [True: 0, False: 12]
  ------------------
 1630|       |
 1631|     12|    table = xmlRealloc(ctxt->nsTab, 2 * newSize * sizeof(table[0]));
 1632|     12|    if (table == NULL)
  ------------------
  |  Branch (1632:9): [True: 0, False: 12]
  ------------------
 1633|      0|        goto error;
 1634|     12|    ctxt->nsTab = table;
 1635|       |
 1636|     12|    extra = xmlRealloc(ctxt->nsdb->extra, newSize * sizeof(extra[0]));
 1637|     12|    if (extra == NULL)
  ------------------
  |  Branch (1637:9): [True: 0, False: 12]
  ------------------
 1638|      0|        goto error;
 1639|     12|    ctxt->nsdb->extra = extra;
 1640|       |
 1641|     12|    ctxt->nsMax = newSize;
 1642|     12|    return(0);
 1643|       |
 1644|      0|error:
 1645|      0|    xmlErrMemory(ctxt, NULL);
 1646|      0|    return(-1);
 1647|     12|}
parser.c:xmlParserNsPop:
 1825|     18|{
 1826|     18|    int i;
 1827|       |
 1828|       |    /* assert(nr <= ctxt->nsNr); */
 1829|       |
 1830|     36|    for (i = ctxt->nsNr - 1; i >= ctxt->nsNr - nr; i--) {
  ------------------
  |  Branch (1830:30): [True: 18, False: 18]
  ------------------
 1831|     18|        const xmlChar *prefix = ctxt->nsTab[i * 2];
 1832|     18|        xmlParserNsExtra *extra = &ctxt->nsdb->extra[i];
 1833|       |
 1834|     18|        if (prefix == NULL) {
  ------------------
  |  Branch (1834:13): [True: 6, False: 12]
  ------------------
 1835|      6|            ctxt->nsdb->defaultNsIndex = extra->oldIndex;
 1836|     12|        } else {
 1837|     12|            xmlHashedString hprefix;
 1838|     12|            xmlParserNsBucket *bucket = NULL;
 1839|       |
 1840|     12|            hprefix.name = prefix;
 1841|     12|            hprefix.hashValue = extra->prefixHashValue;
 1842|     12|            xmlParserNsLookup(ctxt, &hprefix, &bucket);
 1843|       |            /* assert(bucket && bucket->hashValue); */
 1844|     12|            bucket->index = extra->oldIndex;
 1845|     12|        }
 1846|     18|    }
 1847|       |
 1848|     18|    ctxt->nsNr -= nr;
 1849|     18|    return(nr);
 1850|     18|}
parser.c:xmlCtxtUseOptionsInternal:
14554|    486|{
14555|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (14555:9): [True: 0, False: 486]
  ------------------
14556|      0|        return(-1);
14557|    486|    if (encoding != NULL) {
  ------------------
  |  Branch (14557:9): [True: 0, False: 486]
  ------------------
14558|      0|        if (ctxt->encoding != NULL)
  ------------------
  |  Branch (14558:13): [True: 0, False: 0]
  ------------------
14559|      0|	    xmlFree((xmlChar *) ctxt->encoding);
14560|      0|        ctxt->encoding = xmlStrdup((const xmlChar *) encoding);
14561|      0|    }
14562|    486|    if (options & XML_PARSE_RECOVER) {
  ------------------
  |  Branch (14562:9): [True: 486, False: 0]
  ------------------
14563|    486|        ctxt->recovery = 1;
14564|    486|        options -= XML_PARSE_RECOVER;
14565|    486|	ctxt->options |= XML_PARSE_RECOVER;
14566|    486|    } else
14567|      0|        ctxt->recovery = 0;
14568|    486|    if (options & XML_PARSE_DTDLOAD) {
  ------------------
  |  Branch (14568:9): [True: 0, False: 486]
  ------------------
14569|      0|        ctxt->loadsubset = XML_DETECT_IDS;
  ------------------
  |  |  141|      0|#define XML_DETECT_IDS		2
  ------------------
14570|      0|        options -= XML_PARSE_DTDLOAD;
14571|      0|	ctxt->options |= XML_PARSE_DTDLOAD;
14572|      0|    } else
14573|    486|        ctxt->loadsubset = 0;
14574|    486|    if (options & XML_PARSE_DTDATTR) {
  ------------------
  |  Branch (14574:9): [True: 0, False: 486]
  ------------------
14575|      0|        ctxt->loadsubset |= XML_COMPLETE_ATTRS;
  ------------------
  |  |  150|      0|#define XML_COMPLETE_ATTRS	4
  ------------------
14576|      0|        options -= XML_PARSE_DTDATTR;
14577|      0|	ctxt->options |= XML_PARSE_DTDATTR;
14578|      0|    }
14579|    486|    if (options & XML_PARSE_NOENT) {
  ------------------
  |  Branch (14579:9): [True: 0, False: 486]
  ------------------
14580|      0|        ctxt->replaceEntities = 1;
14581|       |        /* ctxt->loadsubset |= XML_DETECT_IDS; */
14582|      0|        options -= XML_PARSE_NOENT;
14583|      0|	ctxt->options |= XML_PARSE_NOENT;
14584|      0|    } else
14585|    486|        ctxt->replaceEntities = 0;
14586|    486|    if (options & XML_PARSE_PEDANTIC) {
  ------------------
  |  Branch (14586:9): [True: 0, False: 486]
  ------------------
14587|      0|        ctxt->pedantic = 1;
14588|      0|        options -= XML_PARSE_PEDANTIC;
14589|      0|	ctxt->options |= XML_PARSE_PEDANTIC;
14590|      0|    } else
14591|    486|        ctxt->pedantic = 0;
14592|    486|    if (options & XML_PARSE_NOBLANKS) {
  ------------------
  |  Branch (14592:9): [True: 0, False: 486]
  ------------------
14593|      0|        ctxt->keepBlanks = 0;
14594|      0|        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
14595|      0|        options -= XML_PARSE_NOBLANKS;
14596|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
14597|      0|    } else
14598|    486|        ctxt->keepBlanks = 1;
14599|    486|    if (options & XML_PARSE_DTDVALID) {
  ------------------
  |  Branch (14599:9): [True: 0, False: 486]
  ------------------
14600|      0|        ctxt->validate = 1;
14601|      0|        if (options & XML_PARSE_NOWARNING)
  ------------------
  |  Branch (14601:13): [True: 0, False: 0]
  ------------------
14602|      0|            ctxt->vctxt.warning = NULL;
14603|      0|        if (options & XML_PARSE_NOERROR)
  ------------------
  |  Branch (14603:13): [True: 0, False: 0]
  ------------------
14604|      0|            ctxt->vctxt.error = NULL;
14605|      0|        options -= XML_PARSE_DTDVALID;
14606|      0|	ctxt->options |= XML_PARSE_DTDVALID;
14607|      0|    } else
14608|    486|        ctxt->validate = 0;
14609|    486|    if (options & XML_PARSE_NOWARNING) {
  ------------------
  |  Branch (14609:9): [True: 0, False: 486]
  ------------------
14610|      0|        ctxt->sax->warning = NULL;
14611|      0|        options -= XML_PARSE_NOWARNING;
14612|      0|    }
14613|    486|    if (options & XML_PARSE_NOERROR) {
  ------------------
  |  Branch (14613:9): [True: 0, False: 486]
  ------------------
14614|      0|        ctxt->sax->error = NULL;
14615|      0|        ctxt->sax->fatalError = NULL;
14616|      0|        options -= XML_PARSE_NOERROR;
14617|      0|    }
14618|    486|#ifdef LIBXML_SAX1_ENABLED
14619|    486|    if (options & XML_PARSE_SAX1) {
  ------------------
  |  Branch (14619:9): [True: 0, False: 486]
  ------------------
14620|      0|        ctxt->sax->startElementNs = NULL;
14621|      0|        ctxt->sax->endElementNs = NULL;
14622|      0|        ctxt->sax->initialized = 1;
14623|      0|        options -= XML_PARSE_SAX1;
14624|      0|	ctxt->options |= XML_PARSE_SAX1;
14625|      0|    }
14626|    486|#endif /* LIBXML_SAX1_ENABLED */
14627|    486|    if (options & XML_PARSE_NODICT) {
  ------------------
  |  Branch (14627:9): [True: 0, False: 486]
  ------------------
14628|      0|        ctxt->dictNames = 0;
14629|      0|        options -= XML_PARSE_NODICT;
14630|      0|	ctxt->options |= XML_PARSE_NODICT;
14631|    486|    } else {
14632|    486|        ctxt->dictNames = 1;
14633|    486|    }
14634|    486|    if (options & XML_PARSE_NOCDATA) {
  ------------------
  |  Branch (14634:9): [True: 0, False: 486]
  ------------------
14635|      0|        ctxt->sax->cdataBlock = NULL;
14636|      0|        options -= XML_PARSE_NOCDATA;
14637|      0|	ctxt->options |= XML_PARSE_NOCDATA;
14638|      0|    }
14639|    486|    if (options & XML_PARSE_NSCLEAN) {
  ------------------
  |  Branch (14639:9): [True: 0, False: 486]
  ------------------
14640|      0|	ctxt->options |= XML_PARSE_NSCLEAN;
14641|      0|        options -= XML_PARSE_NSCLEAN;
14642|      0|    }
14643|    486|    if (options & XML_PARSE_NONET) {
  ------------------
  |  Branch (14643:9): [True: 0, False: 486]
  ------------------
14644|      0|	ctxt->options |= XML_PARSE_NONET;
14645|      0|        options -= XML_PARSE_NONET;
14646|      0|    }
14647|    486|    if (options & XML_PARSE_COMPACT) {
  ------------------
  |  Branch (14647:9): [True: 0, False: 486]
  ------------------
14648|      0|	ctxt->options |= XML_PARSE_COMPACT;
14649|      0|        options -= XML_PARSE_COMPACT;
14650|      0|    }
14651|    486|    if (options & XML_PARSE_OLD10) {
  ------------------
  |  Branch (14651:9): [True: 0, False: 486]
  ------------------
14652|      0|	ctxt->options |= XML_PARSE_OLD10;
14653|      0|        options -= XML_PARSE_OLD10;
14654|      0|    }
14655|    486|    if (options & XML_PARSE_NOBASEFIX) {
  ------------------
  |  Branch (14655:9): [True: 0, False: 486]
  ------------------
14656|      0|	ctxt->options |= XML_PARSE_NOBASEFIX;
14657|      0|        options -= XML_PARSE_NOBASEFIX;
14658|      0|    }
14659|    486|    if (options & XML_PARSE_HUGE) {
  ------------------
  |  Branch (14659:9): [True: 0, False: 486]
  ------------------
14660|      0|	ctxt->options |= XML_PARSE_HUGE;
14661|      0|        options -= XML_PARSE_HUGE;
14662|      0|        if (ctxt->dict != NULL)
  ------------------
  |  Branch (14662:13): [True: 0, False: 0]
  ------------------
14663|      0|            xmlDictSetLimit(ctxt->dict, 0);
14664|      0|    }
14665|    486|    if (options & XML_PARSE_OLDSAX) {
  ------------------
  |  Branch (14665:9): [True: 0, False: 486]
  ------------------
14666|      0|	ctxt->options |= XML_PARSE_OLDSAX;
14667|      0|        options -= XML_PARSE_OLDSAX;
14668|      0|    }
14669|    486|    if (options & XML_PARSE_IGNORE_ENC) {
  ------------------
  |  Branch (14669:9): [True: 0, False: 486]
  ------------------
14670|      0|	ctxt->options |= XML_PARSE_IGNORE_ENC;
14671|      0|        options -= XML_PARSE_IGNORE_ENC;
14672|      0|    }
14673|    486|    if (options & XML_PARSE_BIG_LINES) {
  ------------------
  |  Branch (14673:9): [True: 0, False: 486]
  ------------------
14674|      0|	ctxt->options |= XML_PARSE_BIG_LINES;
14675|      0|        options -= XML_PARSE_BIG_LINES;
14676|      0|    }
14677|    486|    ctxt->linenumbers = 1;
14678|    486|    return (options);
14679|    486|}
parser.c:xmlDoRead:
14731|    486|{
14732|    486|    xmlDocPtr ret;
14733|       |
14734|    486|    xmlCtxtUseOptionsInternal(ctxt, options, encoding);
14735|    486|    if (encoding != NULL) {
  ------------------
  |  Branch (14735:9): [True: 0, False: 486]
  ------------------
14736|      0|        xmlCharEncodingHandlerPtr hdlr;
14737|       |
14738|       |        /*
14739|       |         * TODO: We should consider to set XML_PARSE_IGNORE_ENC if the
14740|       |         * caller provided an encoding. Otherwise, we might switch to
14741|       |         * the encoding from the XML declaration which is likely to
14742|       |         * break things. Also see xmlSwitchInputEncoding.
14743|       |         */
14744|      0|	hdlr = xmlFindCharEncodingHandler(encoding);
14745|      0|	if (hdlr != NULL)
  ------------------
  |  Branch (14745:6): [True: 0, False: 0]
  ------------------
14746|      0|	    xmlSwitchToEncoding(ctxt, hdlr);
14747|      0|    }
14748|    486|    if ((URL != NULL) && (ctxt->input != NULL) &&
  ------------------
  |  Branch (14748:9): [True: 0, False: 486]
  |  Branch (14748:26): [True: 0, False: 0]
  ------------------
14749|    486|        (ctxt->input->filename == NULL))
  ------------------
  |  Branch (14749:9): [True: 0, False: 0]
  ------------------
14750|      0|        ctxt->input->filename = (char *) xmlStrdup((const xmlChar *) URL);
14751|    486|    xmlParseDocument(ctxt);
14752|    486|    if ((ctxt->wellFormed) || ctxt->recovery)
  ------------------
  |  Branch (14752:9): [True: 426, False: 60]
  |  Branch (14752:31): [True: 60, False: 0]
  ------------------
14753|    486|        ret = ctxt->myDoc;
14754|      0|    else {
14755|      0|        ret = NULL;
14756|      0|	if (ctxt->myDoc != NULL) {
  ------------------
  |  Branch (14756:6): [True: 0, False: 0]
  ------------------
14757|      0|	    xmlFreeDoc(ctxt->myDoc);
14758|      0|	}
14759|      0|    }
14760|    486|    ctxt->myDoc = NULL;
14761|    486|    if (!reuse) {
  ------------------
  |  Branch (14761:9): [True: 486, False: 0]
  ------------------
14762|    486|	xmlFreeParserCtxt(ctxt);
14763|    486|    }
14764|       |
14765|    486|    return (ret);
14766|    486|}

__xmlErrEncoding:
  136|     16|{
  137|     16|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (137:9): [True: 16, False: 0]
  |  Branch (137:27): [True: 0, False: 16]
  ------------------
  138|     16|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (138:9): [True: 0, False: 0]
  ------------------
  139|      0|	return;
  140|     16|    if (ctxt != NULL)
  ------------------
  |  Branch (140:9): [True: 16, False: 0]
  ------------------
  141|     16|        ctxt->errNo = xmlerr;
  142|     16|    __xmlRaiseError(NULL, NULL, NULL,
  143|     16|                    ctxt, NULL, XML_FROM_PARSER, xmlerr, XML_ERR_FATAL,
  144|     16|                    NULL, 0, (const char *) str1, (const char *) str2,
  145|     16|                    NULL, 0, 0, msg, str1, str2);
  146|     16|    if (ctxt != NULL) {
  ------------------
  |  Branch (146:9): [True: 16, False: 0]
  ------------------
  147|     16|        ctxt->wellFormed = 0;
  148|     16|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (148:13): [True: 0, False: 16]
  ------------------
  149|      0|            ctxt->disableSAX = 1;
  150|     16|    }
  151|     16|}
xmlFatalErr:
  190|     26|{
  191|     26|    const char *errmsg;
  192|       |
  193|     26|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (193:9): [True: 26, False: 0]
  |  Branch (193:27): [True: 0, False: 26]
  ------------------
  194|     26|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (194:9): [True: 0, False: 0]
  ------------------
  195|      0|	return;
  196|     26|    switch (error) {
  197|      0|        case XML_ERR_INVALID_HEX_CHARREF:
  ------------------
  |  Branch (197:9): [True: 0, False: 26]
  ------------------
  198|      0|            errmsg = "CharRef: invalid hexadecimal value";
  199|      0|            break;
  200|      0|        case XML_ERR_INVALID_DEC_CHARREF:
  ------------------
  |  Branch (200:9): [True: 0, False: 26]
  ------------------
  201|      0|            errmsg = "CharRef: invalid decimal value";
  202|      0|            break;
  203|      0|        case XML_ERR_INVALID_CHARREF:
  ------------------
  |  Branch (203:9): [True: 0, False: 26]
  ------------------
  204|      0|            errmsg = "CharRef: invalid value";
  205|      0|            break;
  206|      3|        case XML_ERR_INTERNAL_ERROR:
  ------------------
  |  Branch (206:9): [True: 3, False: 23]
  ------------------
  207|      3|            errmsg = "internal error";
  208|      3|            break;
  209|      0|        case XML_ERR_PEREF_AT_EOF:
  ------------------
  |  Branch (209:9): [True: 0, False: 26]
  ------------------
  210|      0|            errmsg = "PEReference at end of document";
  211|      0|            break;
  212|      0|        case XML_ERR_PEREF_IN_PROLOG:
  ------------------
  |  Branch (212:9): [True: 0, False: 26]
  ------------------
  213|      0|            errmsg = "PEReference in prolog";
  214|      0|            break;
  215|      0|        case XML_ERR_PEREF_IN_EPILOG:
  ------------------
  |  Branch (215:9): [True: 0, False: 26]
  ------------------
  216|      0|            errmsg = "PEReference in epilog";
  217|      0|            break;
  218|      0|        case XML_ERR_PEREF_NO_NAME:
  ------------------
  |  Branch (218:9): [True: 0, False: 26]
  ------------------
  219|      0|            errmsg = "PEReference: no name";
  220|      0|            break;
  221|      0|        case XML_ERR_PEREF_SEMICOL_MISSING:
  ------------------
  |  Branch (221:9): [True: 0, False: 26]
  ------------------
  222|      0|            errmsg = "PEReference: expecting ';'";
  223|      0|            break;
  224|      0|        case XML_ERR_ENTITY_LOOP:
  ------------------
  |  Branch (224:9): [True: 0, False: 26]
  ------------------
  225|      0|            errmsg = "Detected an entity reference loop";
  226|      0|            break;
  227|      0|        case XML_ERR_ENTITY_NOT_STARTED:
  ------------------
  |  Branch (227:9): [True: 0, False: 26]
  ------------------
  228|      0|            errmsg = "EntityValue: \" or ' expected";
  229|      0|            break;
  230|      0|        case XML_ERR_ENTITY_PE_INTERNAL:
  ------------------
  |  Branch (230:9): [True: 0, False: 26]
  ------------------
  231|      0|            errmsg = "PEReferences forbidden in internal subset";
  232|      0|            break;
  233|      0|        case XML_ERR_ENTITY_NOT_FINISHED:
  ------------------
  |  Branch (233:9): [True: 0, False: 26]
  ------------------
  234|      0|            errmsg = "EntityValue: \" or ' expected";
  235|      0|            break;
  236|      0|        case XML_ERR_ATTRIBUTE_NOT_STARTED:
  ------------------
  |  Branch (236:9): [True: 0, False: 26]
  ------------------
  237|      0|            errmsg = "AttValue: \" or ' expected";
  238|      0|            break;
  239|      2|        case XML_ERR_LT_IN_ATTRIBUTE:
  ------------------
  |  Branch (239:9): [True: 2, False: 24]
  ------------------
  240|      2|            errmsg = "Unescaped '<' not allowed in attributes values";
  241|      2|            break;
  242|      0|        case XML_ERR_LITERAL_NOT_STARTED:
  ------------------
  |  Branch (242:9): [True: 0, False: 26]
  ------------------
  243|      0|            errmsg = "SystemLiteral \" or ' expected";
  244|      0|            break;
  245|      0|        case XML_ERR_LITERAL_NOT_FINISHED:
  ------------------
  |  Branch (245:9): [True: 0, False: 26]
  ------------------
  246|      0|            errmsg = "Unfinished System or Public ID \" or ' expected";
  247|      0|            break;
  248|      0|        case XML_ERR_MISPLACED_CDATA_END:
  ------------------
  |  Branch (248:9): [True: 0, False: 26]
  ------------------
  249|      0|            errmsg = "Sequence ']]>' not allowed in content";
  250|      0|            break;
  251|      0|        case XML_ERR_URI_REQUIRED:
  ------------------
  |  Branch (251:9): [True: 0, False: 26]
  ------------------
  252|      0|            errmsg = "SYSTEM or PUBLIC, the URI is missing";
  253|      0|            break;
  254|      0|        case XML_ERR_PUBID_REQUIRED:
  ------------------
  |  Branch (254:9): [True: 0, False: 26]
  ------------------
  255|      0|            errmsg = "PUBLIC, the Public Identifier is missing";
  256|      0|            break;
  257|      0|        case XML_ERR_HYPHEN_IN_COMMENT:
  ------------------
  |  Branch (257:9): [True: 0, False: 26]
  ------------------
  258|      0|            errmsg = "Comment must not contain '--' (double-hyphen)";
  259|      0|            break;
  260|      1|        case XML_ERR_PI_NOT_STARTED:
  ------------------
  |  Branch (260:9): [True: 1, False: 25]
  ------------------
  261|      1|            errmsg = "xmlParsePI : no target name";
  262|      1|            break;
  263|      0|        case XML_ERR_RESERVED_XML_NAME:
  ------------------
  |  Branch (263:9): [True: 0, False: 26]
  ------------------
  264|      0|            errmsg = "Invalid PI name";
  265|      0|            break;
  266|      0|        case XML_ERR_NOTATION_NOT_STARTED:
  ------------------
  |  Branch (266:9): [True: 0, False: 26]
  ------------------
  267|      0|            errmsg = "NOTATION: Name expected here";
  268|      0|            break;
  269|      0|        case XML_ERR_NOTATION_NOT_FINISHED:
  ------------------
  |  Branch (269:9): [True: 0, False: 26]
  ------------------
  270|      0|            errmsg = "'>' required to close NOTATION declaration";
  271|      0|            break;
  272|      0|        case XML_ERR_VALUE_REQUIRED:
  ------------------
  |  Branch (272:9): [True: 0, False: 26]
  ------------------
  273|      0|            errmsg = "Entity value required";
  274|      0|            break;
  275|      0|        case XML_ERR_URI_FRAGMENT:
  ------------------
  |  Branch (275:9): [True: 0, False: 26]
  ------------------
  276|      0|            errmsg = "Fragment not allowed";
  277|      0|            break;
  278|      0|        case XML_ERR_ATTLIST_NOT_STARTED:
  ------------------
  |  Branch (278:9): [True: 0, False: 26]
  ------------------
  279|      0|            errmsg = "'(' required to start ATTLIST enumeration";
  280|      0|            break;
  281|      0|        case XML_ERR_NMTOKEN_REQUIRED:
  ------------------
  |  Branch (281:9): [True: 0, False: 26]
  ------------------
  282|      0|            errmsg = "NmToken expected in ATTLIST enumeration";
  283|      0|            break;
  284|      0|        case XML_ERR_ATTLIST_NOT_FINISHED:
  ------------------
  |  Branch (284:9): [True: 0, False: 26]
  ------------------
  285|      0|            errmsg = "')' required to finish ATTLIST enumeration";
  286|      0|            break;
  287|      0|        case XML_ERR_MIXED_NOT_STARTED:
  ------------------
  |  Branch (287:9): [True: 0, False: 26]
  ------------------
  288|      0|            errmsg = "MixedContentDecl : '|' or ')*' expected";
  289|      0|            break;
  290|      0|        case XML_ERR_PCDATA_REQUIRED:
  ------------------
  |  Branch (290:9): [True: 0, False: 26]
  ------------------
  291|      0|            errmsg = "MixedContentDecl : '#PCDATA' expected";
  292|      0|            break;
  293|      1|        case XML_ERR_ELEMCONTENT_NOT_STARTED:
  ------------------
  |  Branch (293:9): [True: 1, False: 25]
  ------------------
  294|      1|            errmsg = "ContentDecl : Name or '(' expected";
  295|      1|            break;
  296|      0|        case XML_ERR_ELEMCONTENT_NOT_FINISHED:
  ------------------
  |  Branch (296:9): [True: 0, False: 26]
  ------------------
  297|      0|            errmsg = "ContentDecl : ',' '|' or ')' expected";
  298|      0|            break;
  299|      0|        case XML_ERR_PEREF_IN_INT_SUBSET:
  ------------------
  |  Branch (299:9): [True: 0, False: 26]
  ------------------
  300|      0|            errmsg =
  301|      0|                "PEReference: forbidden within markup decl in internal subset";
  302|      0|            break;
  303|     10|        case XML_ERR_GT_REQUIRED:
  ------------------
  |  Branch (303:9): [True: 10, False: 16]
  ------------------
  304|     10|            errmsg = "expected '>'";
  305|     10|            break;
  306|      0|        case XML_ERR_CONDSEC_INVALID:
  ------------------
  |  Branch (306:9): [True: 0, False: 26]
  ------------------
  307|      0|            errmsg = "XML conditional section '[' expected";
  308|      0|            break;
  309|      0|        case XML_ERR_EXT_SUBSET_NOT_FINISHED:
  ------------------
  |  Branch (309:9): [True: 0, False: 26]
  ------------------
  310|      0|            errmsg = "Content error in the external subset";
  311|      0|            break;
  312|      0|        case XML_ERR_CONDSEC_INVALID_KEYWORD:
  ------------------
  |  Branch (312:9): [True: 0, False: 26]
  ------------------
  313|      0|            errmsg =
  314|      0|                "conditional section INCLUDE or IGNORE keyword expected";
  315|      0|            break;
  316|      0|        case XML_ERR_CONDSEC_NOT_FINISHED:
  ------------------
  |  Branch (316:9): [True: 0, False: 26]
  ------------------
  317|      0|            errmsg = "XML conditional section not closed";
  318|      0|            break;
  319|      0|        case XML_ERR_XMLDECL_NOT_STARTED:
  ------------------
  |  Branch (319:9): [True: 0, False: 26]
  ------------------
  320|      0|            errmsg = "Text declaration '<?xml' required";
  321|      0|            break;
  322|      2|        case XML_ERR_XMLDECL_NOT_FINISHED:
  ------------------
  |  Branch (322:9): [True: 2, False: 24]
  ------------------
  323|      2|            errmsg = "parsing XML declaration: '?>' expected";
  324|      2|            break;
  325|      0|        case XML_ERR_EXT_ENTITY_STANDALONE:
  ------------------
  |  Branch (325:9): [True: 0, False: 26]
  ------------------
  326|      0|            errmsg = "external parsed entities cannot be standalone";
  327|      0|            break;
  328|      0|        case XML_ERR_ENTITYREF_SEMICOL_MISSING:
  ------------------
  |  Branch (328:9): [True: 0, False: 26]
  ------------------
  329|      0|            errmsg = "EntityRef: expecting ';'";
  330|      0|            break;
  331|      0|        case XML_ERR_DOCTYPE_NOT_FINISHED:
  ------------------
  |  Branch (331:9): [True: 0, False: 26]
  ------------------
  332|      0|            errmsg = "DOCTYPE improperly terminated";
  333|      0|            break;
  334|      0|        case XML_ERR_LTSLASH_REQUIRED:
  ------------------
  |  Branch (334:9): [True: 0, False: 26]
  ------------------
  335|      0|            errmsg = "EndTag: '</' not found";
  336|      0|            break;
  337|      0|        case XML_ERR_EQUAL_REQUIRED:
  ------------------
  |  Branch (337:9): [True: 0, False: 26]
  ------------------
  338|      0|            errmsg = "expected '='";
  339|      0|            break;
  340|      0|        case XML_ERR_STRING_NOT_CLOSED:
  ------------------
  |  Branch (340:9): [True: 0, False: 26]
  ------------------
  341|      0|            errmsg = "String not closed expecting \" or '";
  342|      0|            break;
  343|      0|        case XML_ERR_STRING_NOT_STARTED:
  ------------------
  |  Branch (343:9): [True: 0, False: 26]
  ------------------
  344|      0|            errmsg = "String not started expecting ' or \"";
  345|      0|            break;
  346|      0|        case XML_ERR_ENCODING_NAME:
  ------------------
  |  Branch (346:9): [True: 0, False: 26]
  ------------------
  347|      0|            errmsg = "Invalid XML encoding name";
  348|      0|            break;
  349|      0|        case XML_ERR_STANDALONE_VALUE:
  ------------------
  |  Branch (349:9): [True: 0, False: 26]
  ------------------
  350|      0|            errmsg = "standalone accepts only 'yes' or 'no'";
  351|      0|            break;
  352|      0|        case XML_ERR_DOCUMENT_EMPTY:
  ------------------
  |  Branch (352:9): [True: 0, False: 26]
  ------------------
  353|      0|            errmsg = "Document is empty";
  354|      0|            break;
  355|      5|        case XML_ERR_DOCUMENT_END:
  ------------------
  |  Branch (355:9): [True: 5, False: 21]
  ------------------
  356|      5|            errmsg = "Extra content at the end of the document";
  357|      5|            break;
  358|      0|        case XML_ERR_NOT_WELL_BALANCED:
  ------------------
  |  Branch (358:9): [True: 0, False: 26]
  ------------------
  359|      0|            errmsg = "chunk is not well balanced";
  360|      0|            break;
  361|      0|        case XML_ERR_EXTRA_CONTENT:
  ------------------
  |  Branch (361:9): [True: 0, False: 26]
  ------------------
  362|      0|            errmsg = "extra content at the end of well balanced chunk";
  363|      0|            break;
  364|      2|        case XML_ERR_VERSION_MISSING:
  ------------------
  |  Branch (364:9): [True: 2, False: 24]
  ------------------
  365|      2|            errmsg = "Malformed declaration expecting version";
  366|      2|            break;
  367|      0|        case XML_ERR_NAME_TOO_LONG:
  ------------------
  |  Branch (367:9): [True: 0, False: 26]
  ------------------
  368|      0|            errmsg = "Name too long";
  369|      0|            break;
  370|      0|        case XML_ERR_INVALID_ENCODING:
  ------------------
  |  Branch (370:9): [True: 0, False: 26]
  ------------------
  371|      0|            errmsg = "Invalid bytes in character encoding";
  372|      0|            break;
  373|      0|        case XML_IO_UNKNOWN:
  ------------------
  |  Branch (373:9): [True: 0, False: 26]
  ------------------
  374|      0|            errmsg = "I/O error";
  375|      0|            break;
  376|       |#if 0
  377|       |        case:
  378|       |            errmsg = "";
  379|       |            break;
  380|       |#endif
  381|      0|        default:
  ------------------
  |  Branch (381:9): [True: 0, False: 26]
  ------------------
  382|      0|            errmsg = "Unregistered error message";
  383|     26|    }
  384|     26|    if (ctxt != NULL)
  ------------------
  |  Branch (384:9): [True: 26, False: 0]
  ------------------
  385|     26|	ctxt->errNo = error;
  386|     26|    if (info == NULL) {
  ------------------
  |  Branch (386:9): [True: 23, False: 3]
  ------------------
  387|     23|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  388|     23|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s\n",
  389|     23|                        errmsg);
  390|     23|    } else {
  391|      3|        __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
  392|      3|                        XML_ERR_FATAL, NULL, 0, info, NULL, NULL, 0, 0, "%s: %s\n",
  393|      3|                        errmsg, info);
  394|      3|    }
  395|     26|    if (ctxt != NULL) {
  ------------------
  |  Branch (395:9): [True: 26, False: 0]
  ------------------
  396|     26|	ctxt->wellFormed = 0;
  397|     26|	if (ctxt->recovery == 0)
  ------------------
  |  Branch (397:6): [True: 0, False: 26]
  ------------------
  398|      0|	    ctxt->disableSAX = 1;
  399|     26|    }
  400|     26|}
xmlHaltParser:
  461|      1|xmlHaltParser(xmlParserCtxtPtr ctxt) {
  462|      1|    if (ctxt == NULL)
  ------------------
  |  Branch (462:9): [True: 0, False: 1]
  ------------------
  463|      0|        return;
  464|      1|    ctxt->instate = XML_PARSER_EOF;
  465|      1|    ctxt->disableSAX = 1;
  466|      1|    while (ctxt->inputNr > 1)
  ------------------
  |  Branch (466:12): [True: 0, False: 1]
  ------------------
  467|      0|        xmlFreeInputStream(inputPop(ctxt));
  468|      1|    if (ctxt->input != NULL) {
  ------------------
  |  Branch (468:9): [True: 1, False: 0]
  ------------------
  469|       |        /*
  470|       |	 * in case there was a specific allocation deallocate before
  471|       |	 * overriding base
  472|       |	 */
  473|      1|        if (ctxt->input->free != NULL) {
  ------------------
  |  Branch (473:13): [True: 0, False: 1]
  ------------------
  474|      0|	    ctxt->input->free((xmlChar *) ctxt->input->base);
  475|      0|	    ctxt->input->free = NULL;
  476|      0|	}
  477|      1|        if (ctxt->input->buf != NULL) {
  ------------------
  |  Branch (477:13): [True: 1, False: 0]
  ------------------
  478|      1|            xmlFreeParserInputBuffer(ctxt->input->buf);
  479|      1|            ctxt->input->buf = NULL;
  480|      1|        }
  481|      1|	ctxt->input->cur = BAD_CAST"";
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  482|      1|        ctxt->input->length = 0;
  483|      1|	ctxt->input->base = ctxt->input->cur;
  484|      1|        ctxt->input->end = ctxt->input->cur;
  485|      1|    }
  486|      1|}
xmlParserGrow:
  511|  24.8k|xmlParserGrow(xmlParserCtxtPtr ctxt) {
  512|  24.8k|    xmlParserInputPtr in = ctxt->input;
  513|  24.8k|    xmlParserInputBufferPtr buf = in->buf;
  514|  24.8k|    ptrdiff_t curEnd = in->end - in->cur;
  515|  24.8k|    ptrdiff_t curBase = in->cur - in->base;
  516|  24.8k|    int ret;
  517|       |
  518|  24.8k|    if (buf == NULL)
  ------------------
  |  Branch (518:9): [True: 0, False: 24.8k]
  ------------------
  519|      0|        return(0);
  520|       |    /* Don't grow push parser buffer. */
  521|  24.8k|    if ((ctxt->progressive) && (ctxt->inputNr <= 1))
  ------------------
  |  Branch (521:9): [True: 0, False: 24.8k]
  |  Branch (521:32): [True: 0, False: 0]
  ------------------
  522|      0|        return(0);
  523|  24.8k|    if (buf->error != 0)
  ------------------
  |  Branch (523:9): [True: 0, False: 24.8k]
  ------------------
  524|      0|        return(-1);
  525|       |
  526|  24.8k|    if (((curEnd > XML_MAX_LOOKUP_LIMIT) ||
  ------------------
  |  |   81|  24.8k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (526:10): [True: 0, False: 24.8k]
  ------------------
  527|  24.8k|         (curBase > XML_MAX_LOOKUP_LIMIT)) &&
  ------------------
  |  |   81|  24.8k|#define XML_MAX_LOOKUP_LIMIT 10000000
  ------------------
  |  Branch (527:10): [True: 0, False: 24.8k]
  ------------------
  528|  24.8k|        ((ctxt->options & XML_PARSE_HUGE) == 0)) {
  ------------------
  |  Branch (528:9): [True: 0, False: 0]
  ------------------
  529|      0|        xmlErrMemory(ctxt, "Huge input lookup");
  530|      0|        xmlHaltParser(ctxt);
  531|      0|	return(-1);
  532|      0|    }
  533|       |
  534|  24.8k|    if (curEnd >= INPUT_CHUNK)
  ------------------
  |  |   97|  24.8k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (534:9): [True: 158, False: 24.6k]
  ------------------
  535|    158|        return(0);
  536|       |
  537|  24.6k|    ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
  ------------------
  |  |   97|  24.6k|#define INPUT_CHUNK	250
  ------------------
  538|  24.6k|    xmlBufUpdateInput(buf->buffer, in, curBase);
  539|       |
  540|  24.6k|    if (ret < 0) {
  ------------------
  |  Branch (540:9): [True: 0, False: 24.6k]
  ------------------
  541|      0|        xmlFatalErr(ctxt, buf->error, NULL);
  542|       |        /* Buffer contents may be lost in case of memory errors. */
  543|      0|        if (buf->error == XML_ERR_NO_MEMORY)
  ------------------
  |  Branch (543:13): [True: 0, False: 0]
  ------------------
  544|      0|            xmlHaltParser(ctxt);
  545|      0|    }
  546|       |
  547|  24.6k|    return(ret);
  548|  24.8k|}
xmlParserShrink:
  600|    107|xmlParserShrink(xmlParserCtxtPtr ctxt) {
  601|    107|    xmlParserInputPtr in = ctxt->input;
  602|    107|    xmlParserInputBufferPtr buf = in->buf;
  603|    107|    size_t used;
  604|       |
  605|    107|    if (buf == NULL)
  ------------------
  |  Branch (605:9): [True: 0, False: 107]
  ------------------
  606|      0|        return;
  607|       |
  608|    107|    used = in->cur - in->base;
  609|       |    /*
  610|       |     * Do not shrink on large buffers whose only a tiny fraction
  611|       |     * was consumed
  612|       |     */
  613|    107|    if (used > INPUT_CHUNK) {
  ------------------
  |  |   97|    107|#define INPUT_CHUNK	250
  ------------------
  |  Branch (613:9): [True: 107, False: 0]
  ------------------
  614|    107|	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
  ------------------
  |  |  451|    107|#define LINE_LEN        80
  ------------------
  615|       |
  616|    107|	if (res > 0) {
  ------------------
  |  Branch (616:6): [True: 107, False: 0]
  ------------------
  617|    107|            used -= res;
  618|    107|            if ((res > ULONG_MAX) ||
  ------------------
  |  Branch (618:17): [True: 0, False: 107]
  ------------------
  619|    107|                (in->consumed > ULONG_MAX - (unsigned long)res))
  ------------------
  |  Branch (619:17): [True: 0, False: 107]
  ------------------
  620|      0|                in->consumed = ULONG_MAX;
  621|    107|            else
  622|    107|                in->consumed += res;
  623|    107|	}
  624|    107|    }
  625|       |
  626|    107|    xmlBufUpdateInput(buf->buffer, in, used);
  627|    107|}
xmlNextChar:
  698|  4.30k|{
  699|  4.30k|    const unsigned char *cur;
  700|  4.30k|    size_t avail;
  701|  4.30k|    int c;
  702|       |
  703|  4.30k|    if ((ctxt == NULL) || (ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (703:9): [True: 0, False: 4.30k]
  |  Branch (703:27): [True: 0, False: 4.30k]
  ------------------
  704|  4.30k|        (ctxt->input == NULL))
  ------------------
  |  Branch (704:9): [True: 0, False: 4.30k]
  ------------------
  705|      0|        return;
  706|       |
  707|  4.30k|    avail = ctxt->input->end - ctxt->input->cur;
  708|       |
  709|  4.30k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  4.30k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (709:9): [True: 789, False: 3.51k]
  ------------------
  710|    789|        xmlParserGrow(ctxt);
  711|    789|        if ((ctxt->instate == XML_PARSER_EOF) ||
  ------------------
  |  Branch (711:13): [True: 0, False: 789]
  ------------------
  712|    789|            (ctxt->input->cur >= ctxt->input->end))
  ------------------
  |  Branch (712:13): [True: 0, False: 789]
  ------------------
  713|      0|            return;
  714|    789|        avail = ctxt->input->end - ctxt->input->cur;
  715|    789|    }
  716|       |
  717|  4.30k|    cur = ctxt->input->cur;
  718|  4.30k|    c = *cur;
  719|       |
  720|  4.30k|    if (c < 0x80) {
  ------------------
  |  Branch (720:9): [True: 4.30k, False: 3]
  ------------------
  721|  4.30k|        if (c == '\n') {
  ------------------
  |  Branch (721:13): [True: 243, False: 4.05k]
  ------------------
  722|    243|            ctxt->input->cur++;
  723|    243|            ctxt->input->line++;
  724|    243|            ctxt->input->col = 1;
  725|  4.05k|        } else if (c == '\r') {
  ------------------
  |  Branch (725:20): [True: 0, False: 4.05k]
  ------------------
  726|       |            /*
  727|       |             *   2.11 End-of-Line Handling
  728|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  729|       |             *   literal #xD, an XML processor must pass to the application
  730|       |             *   the single character #xA.
  731|       |             */
  732|      0|            ctxt->input->cur += ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (732:34): [True: 0, False: 0]
  ------------------
  733|      0|            ctxt->input->line++;
  734|      0|            ctxt->input->col = 1;
  735|      0|            return;
  736|  4.05k|        } else {
  737|  4.05k|            ctxt->input->cur++;
  738|  4.05k|            ctxt->input->col++;
  739|  4.05k|        }
  740|  4.30k|    } else {
  741|      3|        ctxt->input->col++;
  742|       |
  743|      3|        if ((avail < 2) || (cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (743:13): [True: 0, False: 3]
  |  Branch (743:28): [True: 3, False: 0]
  ------------------
  744|      3|            goto encoding_error;
  745|       |
  746|      0|        if (c < 0xe0) {
  ------------------
  |  Branch (746:13): [True: 0, False: 0]
  ------------------
  747|       |            /* 2-byte code */
  748|      0|            if (c < 0xc2)
  ------------------
  |  Branch (748:17): [True: 0, False: 0]
  ------------------
  749|      0|                goto encoding_error;
  750|      0|            ctxt->input->cur += 2;
  751|      0|        } else {
  752|      0|            unsigned int val = (c << 8) | cur[1];
  753|       |
  754|      0|            if ((avail < 3) || (cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (754:17): [True: 0, False: 0]
  |  Branch (754:32): [True: 0, False: 0]
  ------------------
  755|      0|                goto encoding_error;
  756|       |
  757|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (757:17): [True: 0, False: 0]
  ------------------
  758|       |                /* 3-byte code */
  759|      0|                if ((val < 0xe0a0) || ((val >= 0xeda0) && (val < 0xee00)))
  ------------------
  |  Branch (759:21): [True: 0, False: 0]
  |  Branch (759:40): [True: 0, False: 0]
  |  Branch (759:59): [True: 0, False: 0]
  ------------------
  760|      0|                    goto encoding_error;
  761|      0|                ctxt->input->cur += 3;
  762|      0|            } else {
  763|      0|                if ((avail < 4) || ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (763:21): [True: 0, False: 0]
  |  Branch (763:36): [True: 0, False: 0]
  ------------------
  764|      0|                    goto encoding_error;
  765|       |
  766|       |                /* 4-byte code */
  767|      0|                if ((val < 0xf090) || (val >= 0xf490))
  ------------------
  |  Branch (767:21): [True: 0, False: 0]
  |  Branch (767:39): [True: 0, False: 0]
  ------------------
  768|      0|                    goto encoding_error;
  769|      0|                ctxt->input->cur += 4;
  770|      0|            }
  771|      0|        }
  772|      0|    }
  773|       |
  774|  4.30k|    return;
  775|       |
  776|  4.30k|encoding_error:
  777|       |    /* Only report the first error */
  778|      3|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|      3|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (778:9): [True: 1, False: 2]
  ------------------
  779|      1|        if ((ctxt == NULL) || (ctxt->input == NULL) ||
  ------------------
  |  Branch (779:13): [True: 0, False: 1]
  |  Branch (779:31): [True: 0, False: 1]
  ------------------
  780|      1|            (ctxt->input->end - ctxt->input->cur < 4)) {
  ------------------
  |  Branch (780:13): [True: 0, False: 1]
  ------------------
  781|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  782|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  783|      0|                         NULL, NULL);
  784|      1|        } else {
  785|      1|            char buffer[150];
  786|       |
  787|      1|            snprintf(buffer, 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  788|      1|                            ctxt->input->cur[0], ctxt->input->cur[1],
  789|      1|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  790|      1|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  791|      1|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  792|      1|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
  793|      1|        }
  794|      1|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|      1|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  795|      1|    }
  796|      3|    ctxt->input->cur++;
  797|      3|    return;
  798|  4.30k|}
xmlCurrentChar:
  821|  2.00k|xmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {
  822|  2.00k|    const unsigned char *cur;
  823|  2.00k|    size_t avail;
  824|  2.00k|    int c;
  825|       |
  826|  2.00k|    if ((ctxt == NULL) || (len == NULL) || (ctxt->input == NULL)) return(0);
  ------------------
  |  Branch (826:9): [True: 0, False: 2.00k]
  |  Branch (826:27): [True: 0, False: 2.00k]
  |  Branch (826:44): [True: 0, False: 2.00k]
  ------------------
  827|  2.00k|    if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (827:9): [True: 0, False: 2.00k]
  ------------------
  828|      0|	return(0);
  829|       |
  830|  2.00k|    avail = ctxt->input->end - ctxt->input->cur;
  831|       |
  832|  2.00k|    if (avail < INPUT_CHUNK) {
  ------------------
  |  |   97|  2.00k|#define INPUT_CHUNK	250
  ------------------
  |  Branch (832:9): [True: 1.03k, False: 970]
  ------------------
  833|  1.03k|        xmlParserGrow(ctxt);
  834|  1.03k|        if (ctxt->instate == XML_PARSER_EOF)
  ------------------
  |  Branch (834:13): [True: 0, False: 1.03k]
  ------------------
  835|      0|            return(0);
  836|  1.03k|        avail = ctxt->input->end - ctxt->input->cur;
  837|  1.03k|    }
  838|       |
  839|  2.00k|    cur = ctxt->input->cur;
  840|  2.00k|    c = *cur;
  841|       |
  842|  2.00k|    if (c < 0x80) {
  ------------------
  |  Branch (842:9): [True: 1.62k, False: 380]
  ------------------
  843|       |	/* 1-byte code */
  844|  1.62k|        if (c < 0x20) {
  ------------------
  |  Branch (844:13): [True: 92, False: 1.53k]
  ------------------
  845|       |            /*
  846|       |             *   2.11 End-of-Line Handling
  847|       |             *   the literal two-character sequence "#xD#xA" or a standalone
  848|       |             *   literal #xD, an XML processor must pass to the application
  849|       |             *   the single character #xA.
  850|       |             */
  851|     92|            if (c == '\r') {
  ------------------
  |  Branch (851:17): [True: 0, False: 92]
  ------------------
  852|      0|                *len = ((cur[1] == '\n') ? 2 : 1);
  ------------------
  |  Branch (852:25): [True: 0, False: 0]
  ------------------
  853|      0|                c = '\n';
  854|     92|            } else if (c == 0) {
  ------------------
  |  Branch (854:24): [True: 84, False: 8]
  ------------------
  855|     84|                if (ctxt->input->cur >= ctxt->input->end) {
  ------------------
  |  Branch (855:21): [True: 11, False: 73]
  ------------------
  856|     11|                    *len = 0;
  857|     73|                } else {
  858|     73|                    *len = 1;
  859|       |                    /*
  860|       |                     * TODO: Null bytes should be handled by callers,
  861|       |                     * but this can be tricky.
  862|       |                     */
  863|     73|                    xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,
  864|     73|                            "Char 0x0 out of allowed range\n", c);
  865|     73|                }
  866|     84|            } else {
  867|      8|                *len = 1;
  868|      8|            }
  869|  1.53k|        } else {
  870|  1.53k|            *len = 1;
  871|  1.53k|        }
  872|       |
  873|  1.62k|        return(c);
  874|  1.62k|    } else {
  875|    380|        int val;
  876|       |
  877|    380|        if (avail < 2)
  ------------------
  |  Branch (877:13): [True: 0, False: 380]
  ------------------
  878|      0|            goto incomplete_sequence;
  879|    380|        if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (879:13): [True: 179, False: 201]
  ------------------
  880|    179|            goto encoding_error;
  881|       |
  882|    201|        if (c < 0xe0) {
  ------------------
  |  Branch (882:13): [True: 201, False: 0]
  ------------------
  883|       |            /* 2-byte code */
  884|    201|            if (c < 0xc2)
  ------------------
  |  Branch (884:17): [True: 201, False: 0]
  ------------------
  885|    201|                goto encoding_error;
  886|      0|            val = (c & 0x1f) << 6;
  887|      0|            val |= cur[1] & 0x3f;
  888|      0|            *len = 2;
  889|      0|        } else {
  890|      0|            if (avail < 3)
  ------------------
  |  Branch (890:17): [True: 0, False: 0]
  ------------------
  891|      0|                goto incomplete_sequence;
  892|      0|            if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (892:17): [True: 0, False: 0]
  ------------------
  893|      0|                goto encoding_error;
  894|       |
  895|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (895:17): [True: 0, False: 0]
  ------------------
  896|       |                /* 3-byte code */
  897|      0|                val = (c & 0xf) << 12;
  898|      0|                val |= (cur[1] & 0x3f) << 6;
  899|      0|                val |= cur[2] & 0x3f;
  900|      0|                if ((val < 0x800) || ((val >= 0xd800) && (val < 0xe000)))
  ------------------
  |  Branch (900:21): [True: 0, False: 0]
  |  Branch (900:39): [True: 0, False: 0]
  |  Branch (900:58): [True: 0, False: 0]
  ------------------
  901|      0|                    goto encoding_error;
  902|      0|                *len = 3;
  903|      0|            } else {
  904|      0|                if (avail < 4)
  ------------------
  |  Branch (904:21): [True: 0, False: 0]
  ------------------
  905|      0|                    goto incomplete_sequence;
  906|      0|                if ((cur[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (906:21): [True: 0, False: 0]
  ------------------
  907|      0|                    goto encoding_error;
  908|       |
  909|       |                /* 4-byte code */
  910|      0|                val = (c & 0x0f) << 18;
  911|      0|                val |= (cur[1] & 0x3f) << 12;
  912|      0|                val |= (cur[2] & 0x3f) << 6;
  913|      0|                val |= cur[3] & 0x3f;
  914|      0|                if ((val < 0x10000) || (val >= 0x110000))
  ------------------
  |  Branch (914:21): [True: 0, False: 0]
  |  Branch (914:40): [True: 0, False: 0]
  ------------------
  915|      0|                    goto encoding_error;
  916|      0|                *len = 4;
  917|      0|            }
  918|      0|        }
  919|       |
  920|      0|        return(val);
  921|    201|    }
  922|       |
  923|    380|encoding_error:
  924|       |    /* Only report the first error */
  925|    380|    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {
  ------------------
  |  |   27|    380|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  |  Branch (925:9): [True: 15, False: 365]
  ------------------
  926|     15|        if (ctxt->input->end - ctxt->input->cur < 4) {
  ------------------
  |  Branch (926:13): [True: 0, False: 15]
  ------------------
  927|      0|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  928|      0|                         "Input is not proper UTF-8, indicate encoding !\n",
  929|      0|                         NULL, NULL);
  930|     15|        } else {
  931|     15|            char buffer[150];
  932|       |
  933|     15|            snprintf(&buffer[0], 149, "Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\n",
  934|     15|                            ctxt->input->cur[0], ctxt->input->cur[1],
  935|     15|                            ctxt->input->cur[2], ctxt->input->cur[3]);
  936|     15|            __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,
  937|     15|                         "Input is not proper UTF-8, indicate encoding !\n%s",
  938|     15|                         BAD_CAST buffer, NULL);
  ------------------
  |  |   35|     15|#define BAD_CAST (xmlChar *)
  ------------------
  939|     15|        }
  940|     15|        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;
  ------------------
  |  |   27|     15|#define XML_INPUT_ENCODING_ERROR    (1u << 5)
  ------------------
  941|     15|    }
  942|    380|    *len = 1;
  943|    380|    return(0xFFFD); /* U+FFFD Replacement Character */
  944|       |
  945|      0|incomplete_sequence:
  946|       |    /*
  947|       |     * An encoding problem may arise from a truncated input buffer
  948|       |     * splitting a character in the middle. In that case do not raise
  949|       |     * an error but return 0. This should only happen when push parsing
  950|       |     * char data.
  951|       |     */
  952|      0|    *len = 0;
  953|      0|    return(0);
  954|  2.00k|}
xmlStringCurrentChar:
  972|    234|                     const xmlChar *cur, int *len) {
  973|    234|    int c;
  974|       |
  975|    234|    if ((cur == NULL) || (len == NULL))
  ------------------
  |  Branch (975:9): [True: 0, False: 234]
  |  Branch (975:26): [True: 0, False: 234]
  ------------------
  976|      0|        return(0);
  977|       |
  978|       |    /* cur is zero-terminated, so we can lie about its length. */
  979|    234|    *len = 4;
  980|    234|    c = xmlGetUTF8Char(cur, len);
  981|       |
  982|    234|    return((c < 0) ? 0 : c);
  ------------------
  |  Branch (982:12): [True: 0, False: 234]
  ------------------
  983|    234|}
xmlCopyCharMultiByte:
  995|    387|xmlCopyCharMultiByte(xmlChar *out, int val) {
  996|    387|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (996:9): [True: 0, False: 387]
  |  Branch (996:26): [True: 0, False: 387]
  ------------------
  997|       |    /*
  998|       |     * We are supposed to handle UTF8, check it's valid
  999|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 1000|       |     *
 1001|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 1002|       |     * 0000 0000-0000 007F   0xxxxxxx
 1003|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 1004|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 1005|       |     */
 1006|    387|    if  (val >= 0x80) {
  ------------------
  |  Branch (1006:10): [True: 285, False: 102]
  ------------------
 1007|    285|	xmlChar *savedout = out;
 1008|    285|	int bits;
 1009|    285|	if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }
  ------------------
  |  Branch (1009:6): [True: 25, False: 260]
  ------------------
 1010|    260|	else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}
  ------------------
  |  Branch (1010:11): [True: 260, False: 0]
  ------------------
 1011|      0|	else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }
  ------------------
  |  Branch (1011:11): [True: 0, False: 0]
  ------------------
 1012|      0|	else {
 1013|      0|	    xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,
 1014|      0|		    "Internal error, xmlCopyCharMultiByte 0x%X out of bound\n",
 1015|      0|			      val);
 1016|      0|	    return(0);
 1017|      0|	}
 1018|    830|	for ( ; bits >= 0; bits-= 6)
  ------------------
  |  Branch (1018:10): [True: 545, False: 285]
  ------------------
 1019|    545|	    *out++= ((val >> bits) & 0x3F) | 0x80 ;
 1020|    285|	return (out - savedout);
 1021|    285|    }
 1022|    102|    *out = val;
 1023|    102|    return 1;
 1024|    387|}
xmlCopyChar:
 1038|     25|xmlCopyChar(int len ATTRIBUTE_UNUSED, xmlChar *out, int val) {
 1039|     25|    if ((out == NULL) || (val < 0)) return(0);
  ------------------
  |  Branch (1039:9): [True: 0, False: 25]
  |  Branch (1039:26): [True: 0, False: 25]
  ------------------
 1040|       |    /* the len parameter is ignored */
 1041|     25|    if  (val >= 0x80) {
  ------------------
  |  Branch (1041:10): [True: 25, False: 0]
  ------------------
 1042|     25|	return(xmlCopyCharMultiByte (out, val));
 1043|     25|    }
 1044|      0|    *out = val;
 1045|      0|    return 1;
 1046|     25|}
xmlDetectEncoding:
 1290|    486|xmlDetectEncoding(xmlParserCtxtPtr ctxt) {
 1291|    486|    const xmlChar *in;
 1292|    486|    xmlCharEncoding enc;
 1293|    486|    int bomSize;
 1294|    486|    int autoFlag = 0;
 1295|       |
 1296|    486|    if (xmlParserGrow(ctxt) < 0)
  ------------------
  |  Branch (1296:9): [True: 0, False: 486]
  ------------------
 1297|      0|        return;
 1298|    486|    in = ctxt->input->cur;
 1299|    486|    if (ctxt->input->end - in < 4)
  ------------------
  |  Branch (1299:9): [True: 0, False: 486]
  ------------------
 1300|      0|        return;
 1301|       |
 1302|    486|    if (ctxt->input->flags & XML_INPUT_HAS_ENCODING) {
  ------------------
  |  |   20|    486|#define XML_INPUT_HAS_ENCODING      (1u << 0)
  ------------------
  |  Branch (1302:9): [True: 0, False: 486]
  ------------------
 1303|       |        /*
 1304|       |         * If the encoding was already set, only skip the BOM which was
 1305|       |         * possibly decoded to UTF-8.
 1306|       |         */
 1307|      0|        if ((in[0] == 0xEF) && (in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1307:13): [True: 0, False: 0]
  |  Branch (1307:32): [True: 0, False: 0]
  |  Branch (1307:51): [True: 0, False: 0]
  ------------------
 1308|      0|            ctxt->input->cur += 3;
 1309|      0|        }
 1310|       |
 1311|      0|        return;
 1312|      0|    }
 1313|       |
 1314|    486|    enc = XML_CHAR_ENCODING_NONE;
 1315|    486|    bomSize = 0;
 1316|       |
 1317|    486|    switch (in[0]) {
  ------------------
  |  Branch (1317:13): [True: 1, False: 485]
  ------------------
 1318|      0|        case 0x00:
  ------------------
  |  Branch (1318:9): [True: 0, False: 486]
  ------------------
 1319|      0|            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {
  ------------------
  |  Branch (1319:17): [True: 0, False: 0]
  |  Branch (1319:36): [True: 0, False: 0]
  |  Branch (1319:55): [True: 0, False: 0]
  ------------------
 1320|      0|                enc = XML_CHAR_ENCODING_UCS4BE;
 1321|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1322|      0|            } else if ((in[1] == 0x3C) && (in[2] == 0x00) && (in[3] == 0x3F)) {
  ------------------
  |  Branch (1322:24): [True: 0, False: 0]
  |  Branch (1322:43): [True: 0, False: 0]
  |  Branch (1322:62): [True: 0, False: 0]
  ------------------
 1323|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1324|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1325|      0|            }
 1326|      0|            break;
 1327|       |
 1328|    485|        case 0x3C:
  ------------------
  |  Branch (1328:9): [True: 485, False: 1]
  ------------------
 1329|    485|            if (in[1] == 0x00) {
  ------------------
  |  Branch (1329:17): [True: 0, False: 485]
  ------------------
 1330|      0|                if ((in[2] == 0x00) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1330:21): [True: 0, False: 0]
  |  Branch (1330:40): [True: 0, False: 0]
  ------------------
 1331|      0|                    enc = XML_CHAR_ENCODING_UCS4LE;
 1332|      0|                    autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1333|      0|                } else if ((in[2] == 0x3F) && (in[3] == 0x00)) {
  ------------------
  |  Branch (1333:28): [True: 0, False: 0]
  |  Branch (1333:47): [True: 0, False: 0]
  ------------------
 1334|      0|                    enc = XML_CHAR_ENCODING_UTF16LE;
 1335|      0|                    autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1336|      0|                }
 1337|      0|            }
 1338|    485|            break;
 1339|       |
 1340|      0|        case 0x4C:
  ------------------
  |  Branch (1340:9): [True: 0, False: 486]
  ------------------
 1341|      0|	    if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {
  ------------------
  |  Branch (1341:10): [True: 0, False: 0]
  |  Branch (1341:29): [True: 0, False: 0]
  |  Branch (1341:48): [True: 0, False: 0]
  ------------------
 1342|      0|	        enc = XML_CHAR_ENCODING_EBCDIC;
 1343|      0|                autoFlag = XML_INPUT_AUTO_OTHER;
  ------------------
  |  |   25|      0|#define XML_INPUT_AUTO_OTHER        (4u << 1)
  ------------------
 1344|      0|            }
 1345|      0|            break;
 1346|       |
 1347|      0|        case 0xEF:
  ------------------
  |  Branch (1347:9): [True: 0, False: 486]
  ------------------
 1348|      0|            if ((in[1] == 0xBB) && (in[2] == 0xBF)) {
  ------------------
  |  Branch (1348:17): [True: 0, False: 0]
  |  Branch (1348:36): [True: 0, False: 0]
  ------------------
 1349|      0|                enc = XML_CHAR_ENCODING_UTF8;
 1350|      0|                autoFlag = XML_INPUT_AUTO_UTF8;
  ------------------
  |  |   22|      0|#define XML_INPUT_AUTO_UTF8         (1u << 1)
  ------------------
 1351|      0|                bomSize = 3;
 1352|      0|            }
 1353|      0|            break;
 1354|       |
 1355|      0|        case 0xFE:
  ------------------
  |  Branch (1355:9): [True: 0, False: 486]
  ------------------
 1356|      0|            if (in[1] == 0xFF) {
  ------------------
  |  Branch (1356:17): [True: 0, False: 0]
  ------------------
 1357|      0|                enc = XML_CHAR_ENCODING_UTF16BE;
 1358|      0|                autoFlag = XML_INPUT_AUTO_UTF16BE;
  ------------------
  |  |   24|      0|#define XML_INPUT_AUTO_UTF16BE      (3u << 1)
  ------------------
 1359|      0|                bomSize = 2;
 1360|      0|            }
 1361|      0|            break;
 1362|       |
 1363|      0|        case 0xFF:
  ------------------
  |  Branch (1363:9): [True: 0, False: 486]
  ------------------
 1364|      0|            if (in[1] == 0xFE) {
  ------------------
  |  Branch (1364:17): [True: 0, False: 0]
  ------------------
 1365|      0|                enc = XML_CHAR_ENCODING_UTF16LE;
 1366|      0|                autoFlag = XML_INPUT_AUTO_UTF16LE;
  ------------------
  |  |   23|      0|#define XML_INPUT_AUTO_UTF16LE      (2u << 1)
  ------------------
 1367|      0|                bomSize = 2;
 1368|      0|            }
 1369|      0|            break;
 1370|    486|    }
 1371|       |
 1372|    486|    if (bomSize > 0) {
  ------------------
  |  Branch (1372:9): [True: 0, False: 486]
  ------------------
 1373|      0|        ctxt->input->cur += bomSize;
 1374|      0|    }
 1375|       |
 1376|    486|    if (enc != XML_CHAR_ENCODING_NONE) {
  ------------------
  |  Branch (1376:9): [True: 0, False: 486]
  ------------------
 1377|      0|        ctxt->input->flags |= autoFlag;
 1378|      0|        xmlSwitchEncoding(ctxt, enc);
 1379|      0|    }
 1380|    486|}
xmlFreeInputStream:
 1476|    486|xmlFreeInputStream(xmlParserInputPtr input) {
 1477|    486|    if (input == NULL) return;
  ------------------
  |  Branch (1477:9): [True: 0, False: 486]
  ------------------
 1478|       |
 1479|    486|    if (input->filename != NULL) xmlFree((char *) input->filename);
  ------------------
  |  Branch (1479:9): [True: 0, False: 486]
  ------------------
 1480|    486|    if (input->directory != NULL) xmlFree((char *) input->directory);
  ------------------
  |  Branch (1480:9): [True: 0, False: 486]
  ------------------
 1481|    486|    if (input->version != NULL) xmlFree((char *) input->version);
  ------------------
  |  Branch (1481:9): [True: 0, False: 486]
  ------------------
 1482|    486|    if ((input->free != NULL) && (input->base != NULL))
  ------------------
  |  Branch (1482:9): [True: 0, False: 486]
  |  Branch (1482:34): [True: 0, False: 0]
  ------------------
 1483|      0|        input->free((xmlChar *) input->base);
 1484|    486|    if (input->buf != NULL)
  ------------------
  |  Branch (1484:9): [True: 485, False: 1]
  ------------------
 1485|    485|        xmlFreeParserInputBuffer(input->buf);
 1486|    486|    xmlFree(input);
 1487|    486|}
xmlNewInputStream:
 1498|    486|xmlNewInputStream(xmlParserCtxtPtr ctxt) {
 1499|    486|    xmlParserInputPtr input;
 1500|       |
 1501|    486|    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));
 1502|    486|    if (input == NULL) {
  ------------------
  |  Branch (1502:9): [True: 0, False: 486]
  ------------------
 1503|      0|        xmlErrMemory(ctxt,  "couldn't allocate a new input stream\n");
 1504|      0|	return(NULL);
 1505|      0|    }
 1506|    486|    memset(input, 0, sizeof(xmlParserInput));
 1507|    486|    input->line = 1;
 1508|    486|    input->col = 1;
 1509|       |
 1510|       |    /*
 1511|       |     * If the context is NULL the id cannot be initialized, but that
 1512|       |     * should not happen while parsing which is the situation where
 1513|       |     * the id is actually needed.
 1514|       |     */
 1515|    486|    if (ctxt != NULL) {
  ------------------
  |  Branch (1515:9): [True: 486, False: 0]
  ------------------
 1516|    486|        if (input->id >= INT_MAX) {
  ------------------
  |  Branch (1516:13): [True: 0, False: 486]
  ------------------
 1517|      0|            xmlErrMemory(ctxt, "Input ID overflow\n");
 1518|      0|            return(NULL);
 1519|      0|        }
 1520|    486|        input->id = ctxt->input_id++;
 1521|    486|    }
 1522|       |
 1523|    486|    return(input);
 1524|    486|}
xmlFreeParserCtxt:
 1967|    486|{
 1968|    486|    xmlParserInputPtr input;
 1969|       |
 1970|    486|    if (ctxt == NULL) return;
  ------------------
  |  Branch (1970:9): [True: 0, False: 486]
  ------------------
 1971|       |
 1972|    972|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1972:12): [True: 486, False: 486]
  ------------------
 1973|    486|        xmlFreeInputStream(input);
 1974|    486|    }
 1975|    486|    if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
  ------------------
  |  Branch (1975:9): [True: 486, False: 0]
  ------------------
 1976|    486|    if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
  ------------------
  |  Branch (1976:9): [True: 486, False: 0]
  ------------------
 1977|    486|    if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
  ------------------
  |  Branch (1977:9): [True: 486, False: 0]
  ------------------
 1978|    486|    if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
  ------------------
  |  Branch (1978:9): [True: 0, False: 486]
  ------------------
 1979|    486|    if (ctxt->inputTab != NULL) xmlFree(ctxt->inputTab);
  ------------------
  |  Branch (1979:9): [True: 486, False: 0]
  ------------------
 1980|    486|    if (ctxt->version != NULL) xmlFree((char *) ctxt->version);
  ------------------
  |  Branch (1980:9): [True: 484, False: 2]
  ------------------
 1981|    486|    if (ctxt->encoding != NULL) xmlFree((char *) ctxt->encoding);
  ------------------
  |  Branch (1981:9): [True: 0, False: 486]
  ------------------
 1982|    486|    if (ctxt->extSubURI != NULL) xmlFree((char *) ctxt->extSubURI);
  ------------------
  |  Branch (1982:9): [True: 0, False: 486]
  ------------------
 1983|    486|    if (ctxt->extSubSystem != NULL) xmlFree((char *) ctxt->extSubSystem);
  ------------------
  |  Branch (1983:9): [True: 0, False: 486]
  ------------------
 1984|    486|#ifdef LIBXML_SAX1_ENABLED
 1985|    486|    if ((ctxt->sax != NULL) &&
  ------------------
  |  Branch (1985:9): [True: 486, False: 0]
  ------------------
 1986|    486|        (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler))
  ------------------
  |  |  860|    486|  #define xmlDefaultSAXHandler XML_GLOBAL_MACRO(xmlDefaultSAXHandler)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1986:9): [True: 486, False: 0]
  ------------------
 1987|       |#else
 1988|       |    if (ctxt->sax != NULL)
 1989|       |#endif /* LIBXML_SAX1_ENABLED */
 1990|    486|        xmlFree(ctxt->sax);
 1991|    486|    if (ctxt->directory != NULL) xmlFree((char *) ctxt->directory);
  ------------------
  |  Branch (1991:9): [True: 0, False: 486]
  ------------------
 1992|    486|    if (ctxt->vctxt.nodeTab != NULL) xmlFree(ctxt->vctxt.nodeTab);
  ------------------
  |  Branch (1992:9): [True: 0, False: 486]
  ------------------
 1993|    486|    if (ctxt->atts != NULL) xmlFree((xmlChar * *)ctxt->atts);
  ------------------
  |  Branch (1993:9): [True: 170, False: 316]
  ------------------
 1994|    486|    if (ctxt->dict != NULL) xmlDictFree(ctxt->dict);
  ------------------
  |  Branch (1994:9): [True: 486, False: 0]
  ------------------
 1995|    486|    if (ctxt->nsTab != NULL) xmlFree(ctxt->nsTab);
  ------------------
  |  Branch (1995:9): [True: 12, False: 474]
  ------------------
 1996|    486|    if (ctxt->nsdb != NULL) xmlParserNsFree(ctxt->nsdb);
  ------------------
  |  Branch (1996:9): [True: 486, False: 0]
  ------------------
 1997|    486|    if (ctxt->attrHash != NULL) xmlFree(ctxt->attrHash);
  ------------------
  |  Branch (1997:9): [True: 106, False: 380]
  ------------------
 1998|    486|    if (ctxt->pushTab != NULL) xmlFree(ctxt->pushTab);
  ------------------
  |  Branch (1998:9): [True: 480, False: 6]
  ------------------
 1999|    486|    if (ctxt->attallocs != NULL) xmlFree(ctxt->attallocs);
  ------------------
  |  Branch (1999:9): [True: 170, False: 316]
  ------------------
 2000|    486|    if (ctxt->attsDefault != NULL)
  ------------------
  |  Branch (2000:9): [True: 0, False: 486]
  ------------------
 2001|      0|        xmlHashFree(ctxt->attsDefault, xmlHashDefaultDeallocator);
 2002|    486|    if (ctxt->attsSpecial != NULL)
  ------------------
  |  Branch (2002:9): [True: 22, False: 464]
  ------------------
 2003|     22|        xmlHashFree(ctxt->attsSpecial, NULL);
 2004|    486|    if (ctxt->freeElems != NULL) {
  ------------------
  |  Branch (2004:9): [True: 0, False: 486]
  ------------------
 2005|      0|        xmlNodePtr cur, next;
 2006|       |
 2007|      0|	cur = ctxt->freeElems;
 2008|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2008:9): [True: 0, False: 0]
  ------------------
 2009|      0|	    next = cur->next;
 2010|      0|	    xmlFree(cur);
 2011|      0|	    cur = next;
 2012|      0|	}
 2013|      0|    }
 2014|    486|    if (ctxt->freeAttrs != NULL) {
  ------------------
  |  Branch (2014:9): [True: 0, False: 486]
  ------------------
 2015|      0|        xmlAttrPtr cur, next;
 2016|       |
 2017|      0|	cur = ctxt->freeAttrs;
 2018|      0|	while (cur != NULL) {
  ------------------
  |  Branch (2018:9): [True: 0, False: 0]
  ------------------
 2019|      0|	    next = cur->next;
 2020|      0|	    xmlFree(cur);
 2021|      0|	    cur = next;
 2022|      0|	}
 2023|      0|    }
 2024|       |    /*
 2025|       |     * cleanup the error strings
 2026|       |     */
 2027|    486|    if (ctxt->lastError.message != NULL)
  ------------------
  |  Branch (2027:9): [True: 60, False: 426]
  ------------------
 2028|     60|        xmlFree(ctxt->lastError.message);
 2029|    486|    if (ctxt->lastError.file != NULL)
  ------------------
  |  Branch (2029:9): [True: 0, False: 486]
  ------------------
 2030|      0|        xmlFree(ctxt->lastError.file);
 2031|    486|    if (ctxt->lastError.str1 != NULL)
  ------------------
  |  Branch (2031:9): [True: 40, False: 446]
  ------------------
 2032|     40|        xmlFree(ctxt->lastError.str1);
 2033|    486|    if (ctxt->lastError.str2 != NULL)
  ------------------
  |  Branch (2033:9): [True: 25, False: 461]
  ------------------
 2034|     25|        xmlFree(ctxt->lastError.str2);
 2035|    486|    if (ctxt->lastError.str3 != NULL)
  ------------------
  |  Branch (2035:9): [True: 0, False: 486]
  ------------------
 2036|      0|        xmlFree(ctxt->lastError.str3);
 2037|       |
 2038|    486|#ifdef LIBXML_CATALOG_ENABLED
 2039|    486|    if (ctxt->catalogs != NULL)
  ------------------
  |  Branch (2039:9): [True: 0, False: 486]
  ------------------
 2040|      0|	xmlCatalogFreeLocal(ctxt->catalogs);
 2041|    486|#endif
 2042|    486|    xmlFree(ctxt);
 2043|    486|}
xmlNewParserCtxt:
 2055|    486|{
 2056|    486|    return(xmlNewSAXParserCtxt(NULL, NULL));
 2057|    486|}
xmlNewSAXParserCtxt:
 2072|    486|{
 2073|    486|    xmlParserCtxtPtr ctxt;
 2074|       |
 2075|    486|    ctxt = (xmlParserCtxtPtr) xmlMalloc(sizeof(xmlParserCtxt));
 2076|    486|    if (ctxt == NULL) {
  ------------------
  |  Branch (2076:9): [True: 0, False: 486]
  ------------------
 2077|      0|	xmlErrMemory(NULL, "cannot allocate parser context\n");
 2078|      0|	return(NULL);
 2079|      0|    }
 2080|    486|    memset(ctxt, 0, sizeof(xmlParserCtxt));
 2081|    486|    if (xmlInitSAXParserCtxt(ctxt, sax, userData) < 0) {
  ------------------
  |  Branch (2081:9): [True: 0, False: 486]
  ------------------
 2082|      0|        xmlFreeParserCtxt(ctxt);
 2083|      0|	return(NULL);
 2084|      0|    }
 2085|    486|    return(ctxt);
 2086|    486|}
xmlInitNodeInfoSeq:
 2149|    486|{
 2150|    486|    if (seq == NULL)
  ------------------
  |  Branch (2150:9): [True: 0, False: 486]
  ------------------
 2151|      0|        return;
 2152|    486|    seq->length = 0;
 2153|    486|    seq->maximum = 0;
 2154|    486|    seq->buffer = NULL;
 2155|    486|}
parserInternals.c:xmlErrEncodingInt:
  414|     73|{
  415|     73|    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
  ------------------
  |  Branch (415:9): [True: 73, False: 0]
  |  Branch (415:27): [True: 0, False: 73]
  ------------------
  416|     73|        (ctxt->instate == XML_PARSER_EOF))
  ------------------
  |  Branch (416:9): [True: 0, False: 0]
  ------------------
  417|      0|	return;
  418|     73|    if (ctxt != NULL)
  ------------------
  |  Branch (418:9): [True: 73, False: 0]
  ------------------
  419|     73|        ctxt->errNo = error;
  420|     73|    __xmlRaiseError(NULL, NULL, NULL,
  421|     73|                    ctxt, NULL, XML_FROM_PARSER, error, XML_ERR_FATAL,
  422|     73|                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);
  423|     73|    if (ctxt != NULL) {
  ------------------
  |  Branch (423:9): [True: 73, False: 0]
  ------------------
  424|     73|        ctxt->wellFormed = 0;
  425|     73|        if (ctxt->recovery == 0)
  ------------------
  |  Branch (425:13): [True: 0, False: 73]
  ------------------
  426|      0|            ctxt->disableSAX = 1;
  427|     73|    }
  428|     73|}
parserInternals.c:xmlInitSAXParserCtxt:
 1746|    486|{
 1747|    486|    xmlParserInputPtr input;
 1748|       |
 1749|    486|    if(ctxt==NULL) {
  ------------------
  |  Branch (1749:8): [True: 0, False: 486]
  ------------------
 1750|      0|        xmlErrInternal(NULL, "Got NULL parser context\n", NULL);
 1751|      0|        return(-1);
 1752|      0|    }
 1753|       |
 1754|    486|    xmlInitParser();
 1755|       |
 1756|    486|    if (ctxt->dict == NULL)
  ------------------
  |  Branch (1756:9): [True: 486, False: 0]
  ------------------
 1757|    486|	ctxt->dict = xmlDictCreate();
 1758|    486|    if (ctxt->dict == NULL) {
  ------------------
  |  Branch (1758:9): [True: 0, False: 486]
  ------------------
 1759|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1760|      0|	return(-1);
 1761|      0|    }
 1762|    486|    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);
  ------------------
  |  |   71|    486|#define XML_MAX_DICTIONARY_LIMIT 10000000
  ------------------
 1763|       |
 1764|    486|    if (ctxt->sax == NULL)
  ------------------
  |  Branch (1764:9): [True: 486, False: 0]
  ------------------
 1765|    486|	ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));
 1766|    486|    if (ctxt->sax == NULL) {
  ------------------
  |  Branch (1766:9): [True: 0, False: 486]
  ------------------
 1767|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1768|      0|	return(-1);
 1769|      0|    }
 1770|    486|    if (sax == NULL) {
  ------------------
  |  Branch (1770:9): [True: 486, False: 0]
  ------------------
 1771|    486|	memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1772|    486|        xmlSAXVersion(ctxt->sax, 2);
 1773|    486|        ctxt->userData = ctxt;
 1774|    486|    } else {
 1775|      0|	if (sax->initialized == XML_SAX2_MAGIC) {
  ------------------
  |  |  685|      0|#define XML_SAX2_MAGIC 0xDEEDBEAF
  ------------------
  |  Branch (1775:6): [True: 0, False: 0]
  ------------------
 1776|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));
 1777|      0|        } else {
 1778|      0|	    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));
 1779|      0|	    memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));
 1780|      0|        }
 1781|      0|        ctxt->userData = userData ? userData : ctxt;
  ------------------
  |  Branch (1781:26): [True: 0, False: 0]
  ------------------
 1782|      0|    }
 1783|       |
 1784|    486|    ctxt->maxatts = 0;
 1785|    486|    ctxt->atts = NULL;
 1786|       |    /* Allocate the Input stack */
 1787|    486|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1787:9): [True: 486, False: 0]
  ------------------
 1788|    486|	ctxt->inputTab = (xmlParserInputPtr *)
 1789|    486|		    xmlMalloc(5 * sizeof(xmlParserInputPtr));
 1790|    486|	ctxt->inputMax = 5;
 1791|    486|    }
 1792|    486|    if (ctxt->inputTab == NULL) {
  ------------------
  |  Branch (1792:9): [True: 0, False: 486]
  ------------------
 1793|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1794|      0|	ctxt->inputNr = 0;
 1795|      0|	ctxt->inputMax = 0;
 1796|      0|	ctxt->input = NULL;
 1797|      0|	return(-1);
 1798|      0|    }
 1799|    486|    while ((input = inputPop(ctxt)) != NULL) { /* Non consuming */
  ------------------
  |  Branch (1799:12): [True: 0, False: 486]
  ------------------
 1800|      0|        xmlFreeInputStream(input);
 1801|      0|    }
 1802|    486|    ctxt->inputNr = 0;
 1803|    486|    ctxt->input = NULL;
 1804|       |
 1805|    486|    ctxt->version = NULL;
 1806|    486|    ctxt->encoding = NULL;
 1807|    486|    ctxt->standalone = -1;
 1808|    486|    ctxt->hasExternalSubset = 0;
 1809|    486|    ctxt->hasPErefs = 0;
 1810|    486|    ctxt->html = 0;
 1811|    486|    ctxt->external = 0;
 1812|    486|    ctxt->instate = XML_PARSER_START;
 1813|    486|    ctxt->token = 0;
 1814|    486|    ctxt->directory = NULL;
 1815|       |
 1816|       |    /* Allocate the Node stack */
 1817|    486|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1817:9): [True: 486, False: 0]
  ------------------
 1818|    486|	ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));
 1819|    486|	ctxt->nodeMax = 10;
 1820|    486|    }
 1821|    486|    if (ctxt->nodeTab == NULL) {
  ------------------
  |  Branch (1821:9): [True: 0, False: 486]
  ------------------
 1822|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1823|      0|	ctxt->nodeNr = 0;
 1824|      0|	ctxt->nodeMax = 0;
 1825|      0|	ctxt->node = NULL;
 1826|      0|	ctxt->inputNr = 0;
 1827|      0|	ctxt->inputMax = 0;
 1828|      0|	ctxt->input = NULL;
 1829|      0|	return(-1);
 1830|      0|    }
 1831|    486|    ctxt->nodeNr = 0;
 1832|    486|    ctxt->node = NULL;
 1833|       |
 1834|       |    /* Allocate the Name stack */
 1835|    486|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1835:9): [True: 486, False: 0]
  ------------------
 1836|    486|	ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));
 1837|    486|	ctxt->nameMax = 10;
 1838|    486|    }
 1839|    486|    if (ctxt->nameTab == NULL) {
  ------------------
  |  Branch (1839:9): [True: 0, False: 486]
  ------------------
 1840|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1841|      0|	ctxt->nodeNr = 0;
 1842|      0|	ctxt->nodeMax = 0;
 1843|      0|	ctxt->node = NULL;
 1844|      0|	ctxt->inputNr = 0;
 1845|      0|	ctxt->inputMax = 0;
 1846|      0|	ctxt->input = NULL;
 1847|      0|	ctxt->nameNr = 0;
 1848|      0|	ctxt->nameMax = 0;
 1849|      0|	ctxt->name = NULL;
 1850|      0|	return(-1);
 1851|      0|    }
 1852|    486|    ctxt->nameNr = 0;
 1853|    486|    ctxt->name = NULL;
 1854|       |
 1855|       |    /* Allocate the space stack */
 1856|    486|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1856:9): [True: 486, False: 0]
  ------------------
 1857|    486|	ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));
 1858|    486|	ctxt->spaceMax = 10;
 1859|    486|    }
 1860|    486|    if (ctxt->spaceTab == NULL) {
  ------------------
  |  Branch (1860:9): [True: 0, False: 486]
  ------------------
 1861|      0|        xmlErrMemory(NULL, "cannot initialize parser context\n");
 1862|      0|	ctxt->nodeNr = 0;
 1863|      0|	ctxt->nodeMax = 0;
 1864|      0|	ctxt->node = NULL;
 1865|      0|	ctxt->inputNr = 0;
 1866|      0|	ctxt->inputMax = 0;
 1867|      0|	ctxt->input = NULL;
 1868|      0|	ctxt->nameNr = 0;
 1869|      0|	ctxt->nameMax = 0;
 1870|      0|	ctxt->name = NULL;
 1871|      0|	ctxt->spaceNr = 0;
 1872|      0|	ctxt->spaceMax = 0;
 1873|      0|	ctxt->space = NULL;
 1874|      0|	return(-1);
 1875|      0|    }
 1876|    486|    ctxt->spaceNr = 1;
 1877|    486|    ctxt->spaceMax = 10;
 1878|    486|    ctxt->spaceTab[0] = -1;
 1879|    486|    ctxt->space = &ctxt->spaceTab[0];
 1880|    486|    ctxt->myDoc = NULL;
 1881|    486|    ctxt->wellFormed = 1;
 1882|    486|    ctxt->nsWellFormed = 1;
 1883|    486|    ctxt->valid = 1;
 1884|    486|    ctxt->loadsubset = xmlLoadExtDtdDefaultValue;
  ------------------
  |  |  869|    486|  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1885|    486|    if (ctxt->loadsubset) {
  ------------------
  |  Branch (1885:9): [True: 0, False: 486]
  ------------------
 1886|      0|        ctxt->options |= XML_PARSE_DTDLOAD;
 1887|      0|    }
 1888|    486|    ctxt->validate = xmlDoValidityCheckingDefaultValue;
  ------------------
  |  |  863|    486|    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1889|    486|    ctxt->pedantic = xmlPedanticParserDefaultValue;
  ------------------
  |  |  872|    486|    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1890|    486|    if (ctxt->pedantic) {
  ------------------
  |  Branch (1890:9): [True: 0, False: 486]
  ------------------
 1891|      0|        ctxt->options |= XML_PARSE_PEDANTIC;
 1892|      0|    }
 1893|    486|    ctxt->linenumbers = xmlLineNumbersDefaultValue;
  ------------------
  |  |  868|    486|    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1894|    486|    ctxt->keepBlanks = xmlKeepBlanksDefaultValue;
  ------------------
  |  |  866|    486|  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1895|    486|    if (ctxt->keepBlanks == 0) {
  ------------------
  |  Branch (1895:9): [True: 0, False: 486]
  ------------------
 1896|      0|	ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;
 1897|      0|	ctxt->options |= XML_PARSE_NOBLANKS;
 1898|      0|    }
 1899|       |
 1900|    486|    ctxt->vctxt.flags = XML_VCTXT_USE_PCTXT;
  ------------------
  |  |   18|    486|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
 1901|    486|    ctxt->vctxt.userData = ctxt;
 1902|    486|    ctxt->vctxt.error = xmlParserValidityError;
 1903|    486|    ctxt->vctxt.warning = xmlParserValidityWarning;
 1904|    486|    if (ctxt->validate) {
  ------------------
  |  Branch (1904:9): [True: 0, False: 486]
  ------------------
 1905|      0|	if (xmlGetWarningsDefaultValue == 0)
  ------------------
  |  |  865|      0|    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1905:6): [True: 0, False: 0]
  ------------------
 1906|      0|	    ctxt->vctxt.warning = NULL;
 1907|      0|	else
 1908|      0|	    ctxt->vctxt.warning = xmlParserValidityWarning;
 1909|      0|	ctxt->vctxt.nodeMax = 0;
 1910|      0|        ctxt->options |= XML_PARSE_DTDVALID;
 1911|      0|    }
 1912|    486|    ctxt->replaceEntities = xmlSubstituteEntitiesDefaultValue;
  ------------------
  |  |  874|    486|    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1913|    486|    if (ctxt->replaceEntities) {
  ------------------
  |  Branch (1913:9): [True: 0, False: 486]
  ------------------
 1914|      0|        ctxt->options |= XML_PARSE_NOENT;
 1915|      0|    }
 1916|    486|    ctxt->record_info = 0;
 1917|    486|    ctxt->checkIndex = 0;
 1918|    486|    ctxt->inSubset = 0;
 1919|    486|    ctxt->errNo = XML_ERR_OK;
 1920|    486|    ctxt->depth = 0;
 1921|    486|    ctxt->catalogs = NULL;
 1922|    486|    ctxt->sizeentities = 0;
 1923|    486|    ctxt->sizeentcopy = 0;
 1924|    486|    ctxt->input_id = 1;
 1925|    486|    ctxt->maxAmpl = XML_MAX_AMPLIFICATION_DEFAULT;
  ------------------
  |  |   52|    486|#define XML_MAX_AMPLIFICATION_DEFAULT 5
  ------------------
 1926|    486|    xmlInitNodeInfoSeq(&ctxt->node_seq);
 1927|       |
 1928|    486|    if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1928:9): [True: 486, False: 0]
  ------------------
 1929|    486|        ctxt->nsdb = xmlParserNsCreate();
 1930|    486|        if (ctxt->nsdb == NULL) {
  ------------------
  |  Branch (1930:13): [True: 0, False: 486]
  ------------------
 1931|      0|            xmlErrMemory(ctxt, NULL);
 1932|      0|            return(-1);
 1933|      0|        }
 1934|    486|    }
 1935|       |
 1936|    486|    return(0);
 1937|    486|}

xmlFreePattern:
  228|    237|xmlFreePattern(xmlPatternPtr comp) {
  229|    237|    xmlFreePatternList(comp);
  230|    237|}
xmlFreePatternList:
  269|    252|xmlFreePatternList(xmlPatternPtr comp) {
  270|    252|    xmlPatternPtr cur;
  271|       |
  272|    392|    while (comp != NULL) {
  ------------------
  |  Branch (272:12): [True: 140, False: 252]
  ------------------
  273|    140|	cur = comp;
  274|    140|	comp = comp->next;
  275|    140|	cur->next = NULL;
  276|    140|	xmlFreePatternInternal(cur);
  277|    140|    }
  278|    252|}
xmlFreeStreamCtxt:
 1722|     15|xmlFreeStreamCtxt(xmlStreamCtxtPtr stream) {
 1723|     15|    xmlStreamCtxtPtr next;
 1724|       |
 1725|     31|    while (stream != NULL) {
  ------------------
  |  Branch (1725:12): [True: 16, False: 15]
  ------------------
 1726|     16|        next = stream->next;
 1727|     16|        if (stream->states != NULL)
  ------------------
  |  Branch (1727:13): [True: 16, False: 0]
  ------------------
 1728|     16|	    xmlFree(stream->states);
 1729|     16|        xmlFree(stream);
 1730|     16|	stream = next;
 1731|     16|    }
 1732|     15|}
xmlStreamPush:
 2132|     69|              const xmlChar *name, const xmlChar *ns) {
 2133|     69|    return (xmlStreamPushInternal(stream, name, ns, XML_ELEMENT_NODE));
 2134|     69|}
xmlStreamPushNode:
 2159|     40|{
 2160|     40|    return (xmlStreamPushInternal(stream, name, ns,
 2161|     40|	nodeType));
 2162|     40|}
xmlStreamPop:
 2195|     96|xmlStreamPop(xmlStreamCtxtPtr stream) {
 2196|     96|    int i, lev;
 2197|       |
 2198|     96|    if (stream == NULL)
  ------------------
  |  Branch (2198:9): [True: 0, False: 96]
  ------------------
 2199|      0|        return(-1);
 2200|    196|    while (stream != NULL) {
  ------------------
  |  Branch (2200:12): [True: 100, False: 96]
  ------------------
 2201|       |	/*
 2202|       |	* Reset block-level.
 2203|       |	*/
 2204|    100|	if (stream->blockLevel == stream->level)
  ------------------
  |  Branch (2204:6): [True: 9, False: 91]
  ------------------
 2205|      9|	    stream->blockLevel = -1;
 2206|       |
 2207|       |	/*
 2208|       |	 *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set
 2209|       |	 *  (see the thread at
 2210|       |	 *  http://mail.gnome.org/archives/xslt/2008-July/msg00027.html)
 2211|       |	 */
 2212|    100|	if (stream->level)
  ------------------
  |  Branch (2212:6): [True: 100, False: 0]
  ------------------
 2213|    100|	    stream->level--;
 2214|       |	/*
 2215|       |	 * Check evolution of existing states
 2216|       |	 */
 2217|    106|	for (i = stream->nbState -1; i >= 0; i--) {
  ------------------
  |  Branch (2217:31): [True: 40, False: 66]
  ------------------
 2218|       |	    /* discard obsoleted states */
 2219|     40|	    lev = stream->states[(2 * i) + 1];
 2220|     40|	    if (lev > stream->level)
  ------------------
  |  Branch (2220:10): [True: 6, False: 34]
  ------------------
 2221|      6|		stream->nbState--;
 2222|     40|	    if (lev <= stream->level)
  ------------------
  |  Branch (2222:10): [True: 34, False: 6]
  ------------------
 2223|     34|		break;
 2224|     40|	}
 2225|    100|	stream = stream->next;
 2226|    100|    }
 2227|     96|    return(0);
 2228|     96|}
xmlStreamWantsAnyNode:
 2244|     15|{
 2245|     15|    if (streamCtxt == NULL)
  ------------------
  |  Branch (2245:9): [True: 0, False: 15]
  ------------------
 2246|      0|	return(-1);
 2247|     26|    while (streamCtxt != NULL) {
  ------------------
  |  Branch (2247:12): [True: 16, False: 10]
  ------------------
 2248|     16|	if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)
  ------------------
  |  |   58|     16|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
  |  Branch (2248:6): [True: 5, False: 11]
  ------------------
 2249|      5|	    return(1);
 2250|     11|	streamCtxt = streamCtxt->next;
 2251|     11|    }
 2252|     10|    return(0);
 2253|     15|}
xmlPatterncompile:
 2274|    137|                  const xmlChar **namespaces) {
 2275|    137|    xmlPatternPtr ret = NULL, cur;
 2276|    137|    xmlPatParserContextPtr ctxt = NULL;
 2277|    137|    const xmlChar *or, *start;
 2278|    137|    xmlChar *tmp = NULL;
 2279|    137|    int type = 0;
 2280|    137|    int streamable = 1;
 2281|       |
 2282|    137|    if (pattern == NULL)
  ------------------
  |  Branch (2282:9): [True: 0, False: 137]
  ------------------
 2283|      0|        return(NULL);
 2284|       |
 2285|    137|    start = pattern;
 2286|    137|    or = start;
 2287|    162|    while (*or != 0) {
  ------------------
  |  Branch (2287:12): [True: 140, False: 22]
  ------------------
 2288|    140|	tmp = NULL;
 2289|  1.60k|	while ((*or != 0) && (*or != '|')) or++;
  ------------------
  |  Branch (2289:9): [True: 1.47k, False: 133]
  |  Branch (2289:23): [True: 1.46k, False: 7]
  ------------------
 2290|    140|        if (*or == 0)
  ------------------
  |  Branch (2290:13): [True: 133, False: 7]
  ------------------
 2291|    133|	    ctxt = xmlNewPatParserContext(start, dict, namespaces);
 2292|      7|	else {
 2293|      7|	    tmp = xmlStrndup(start, or - start);
 2294|      7|	    if (tmp != NULL) {
  ------------------
  |  Branch (2294:10): [True: 7, False: 0]
  ------------------
 2295|      7|		ctxt = xmlNewPatParserContext(tmp, dict, namespaces);
 2296|      7|	    }
 2297|      7|	    or++;
 2298|      7|	}
 2299|    140|	if (ctxt == NULL) goto error;
  ------------------
  |  Branch (2299:6): [True: 0, False: 140]
  ------------------
 2300|    140|	cur = xmlNewPattern();
 2301|    140|	if (cur == NULL) goto error;
  ------------------
  |  Branch (2301:6): [True: 0, False: 140]
  ------------------
 2302|       |	/*
 2303|       |	* Assign string dict.
 2304|       |	*/
 2305|    140|	if (dict) {
  ------------------
  |  Branch (2305:6): [True: 0, False: 140]
  ------------------
 2306|      0|	    cur->dict = dict;
 2307|      0|	    xmlDictReference(dict);
 2308|      0|	}
 2309|    140|	if (ret == NULL)
  ------------------
  |  Branch (2309:6): [True: 135, False: 5]
  ------------------
 2310|    135|	    ret = cur;
 2311|      5|	else {
 2312|      5|	    cur->next = ret->next;
 2313|      5|	    ret->next = cur;
 2314|      5|	}
 2315|    140|	cur->flags = flags;
 2316|    140|	ctxt->comp = cur;
 2317|       |
 2318|    140|	if (XML_STREAM_XS_IDC(cur))
  ------------------
  |  |   72|    140|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 140]
  |  |  ------------------
  |  |   73|    140|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
 2319|      0|	    xmlCompileIDCXPathPath(ctxt);
 2320|    140|	else
 2321|    140|	    xmlCompilePathPattern(ctxt);
 2322|    140|	if (ctxt->error != 0)
  ------------------
  |  Branch (2322:6): [True: 115, False: 25]
  ------------------
 2323|    115|	    goto error;
 2324|     25|	xmlFreePatParserContext(ctxt);
 2325|     25|	ctxt = NULL;
 2326|       |
 2327|       |
 2328|     25|        if (streamable) {
  ------------------
  |  Branch (2328:13): [True: 25, False: 0]
  ------------------
 2329|     25|	    if (type == 0) {
  ------------------
  |  Branch (2329:10): [True: 20, False: 5]
  ------------------
 2330|     20|	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  158|     20|#define PAT_FROM_ROOT	(1<<8)
  ------------------
              	        type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);
  ------------------
  |  |  159|     20|#define PAT_FROM_CUR	(1<<9)
  ------------------
 2331|     20|	    } else if (type == PAT_FROM_ROOT) {
  ------------------
  |  |  158|      5|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2331:17): [True: 2, False: 3]
  ------------------
 2332|      2|	        if (cur->flags & PAT_FROM_CUR)
  ------------------
  |  |  159|      2|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2332:14): [True: 2, False: 0]
  ------------------
 2333|      2|		    streamable = 0;
 2334|      3|	    } else if (type == PAT_FROM_CUR) {
  ------------------
  |  |  159|      3|#define PAT_FROM_CUR	(1<<9)
  ------------------
  |  Branch (2334:17): [True: 3, False: 0]
  ------------------
 2335|      3|	        if (cur->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|      3|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2335:14): [True: 2, False: 1]
  ------------------
 2336|      2|		    streamable = 0;
 2337|      3|	    }
 2338|     25|	}
 2339|     25|	if (streamable)
  ------------------
  |  Branch (2339:6): [True: 21, False: 4]
  ------------------
 2340|     21|	    xmlStreamCompile(cur);
 2341|     25|	if (xmlReversePattern(cur) < 0)
  ------------------
  |  Branch (2341:6): [True: 0, False: 25]
  ------------------
 2342|      0|	    goto error;
 2343|     25|	if (tmp != NULL) {
  ------------------
  |  Branch (2343:6): [True: 5, False: 20]
  ------------------
 2344|      5|	    xmlFree(tmp);
 2345|      5|	    tmp = NULL;
 2346|      5|	}
 2347|     25|	start = or;
 2348|     25|    }
 2349|     22|    if (streamable == 0) {
  ------------------
  |  Branch (2349:9): [True: 4, False: 18]
  ------------------
 2350|      4|        cur = ret;
 2351|     12|	while (cur != NULL) {
  ------------------
  |  Branch (2351:9): [True: 8, False: 4]
  ------------------
 2352|      8|	    if (cur->stream != NULL) {
  ------------------
  |  Branch (2352:10): [True: 4, False: 4]
  ------------------
 2353|      4|		xmlFreeStreamComp(cur->stream);
 2354|      4|		cur->stream = NULL;
 2355|      4|	    }
 2356|      8|	    cur = cur->next;
 2357|      8|	}
 2358|      4|    }
 2359|       |
 2360|     22|    return(ret);
 2361|    115|error:
 2362|    115|    if (ctxt != NULL) xmlFreePatParserContext(ctxt);
  ------------------
  |  Branch (2362:9): [True: 115, False: 0]
  ------------------
 2363|    115|    if (ret != NULL) xmlFreePattern(ret);
  ------------------
  |  Branch (2363:9): [True: 115, False: 0]
  ------------------
 2364|    115|    if (tmp != NULL) xmlFree(tmp);
  ------------------
  |  Branch (2364:9): [True: 2, False: 113]
  ------------------
 2365|    115|    return(NULL);
 2366|    137|}
xmlPatternGetStreamCtxt:
 2405|     15|{
 2406|     15|    xmlStreamCtxtPtr ret = NULL, cur;
 2407|       |
 2408|     15|    if ((comp == NULL) || (comp->stream == NULL))
  ------------------
  |  Branch (2408:9): [True: 0, False: 15]
  |  Branch (2408:27): [True: 0, False: 15]
  ------------------
 2409|      0|        return(NULL);
 2410|       |
 2411|     31|    while (comp != NULL) {
  ------------------
  |  Branch (2411:12): [True: 16, False: 15]
  ------------------
 2412|     16|        if (comp->stream == NULL)
  ------------------
  |  Branch (2412:13): [True: 0, False: 16]
  ------------------
 2413|      0|	    goto failed;
 2414|     16|	cur = xmlNewStreamCtxt(comp->stream);
 2415|     16|	if (cur == NULL)
  ------------------
  |  Branch (2415:6): [True: 0, False: 16]
  ------------------
 2416|      0|	    goto failed;
 2417|     16|	if (ret == NULL)
  ------------------
  |  Branch (2417:6): [True: 15, False: 1]
  ------------------
 2418|     15|	    ret = cur;
 2419|      1|	else {
 2420|      1|	    cur->next = ret->next;
 2421|      1|	    ret->next = cur;
 2422|      1|	}
 2423|     16|	cur->flags = comp->flags;
 2424|     16|	comp = comp->next;
 2425|     16|    }
 2426|     15|    return(ret);
 2427|      0|failed:
 2428|      0|    xmlFreeStreamCtxt(ret);
 2429|      0|    return(NULL);
 2430|     15|}
xmlPatternStreamable:
 2442|     20|xmlPatternStreamable(xmlPatternPtr comp) {
 2443|     20|    if (comp == NULL)
  ------------------
  |  Branch (2443:9): [True: 0, False: 20]
  ------------------
 2444|      0|        return(-1);
 2445|     36|    while (comp != NULL) {
  ------------------
  |  Branch (2445:12): [True: 21, False: 15]
  ------------------
 2446|     21|        if (comp->stream == NULL)
  ------------------
  |  Branch (2446:13): [True: 5, False: 16]
  ------------------
 2447|      5|	    return(0);
 2448|     16|	comp = comp->next;
 2449|     16|    }
 2450|     15|    return(1);
 2451|     20|}
xmlPatternMaxDepth:
 2463|     15|xmlPatternMaxDepth(xmlPatternPtr comp) {
 2464|     15|    int ret = 0, i;
 2465|     15|    if (comp == NULL)
  ------------------
  |  Branch (2465:9): [True: 0, False: 15]
  ------------------
 2466|      0|        return(-1);
 2467|     22|    while (comp != NULL) {
  ------------------
  |  Branch (2467:12): [True: 16, False: 6]
  ------------------
 2468|     16|        if (comp->stream == NULL)
  ------------------
  |  Branch (2468:13): [True: 0, False: 16]
  ------------------
 2469|      0|	    return(-1);
 2470|     28|	for (i = 0;i < comp->stream->nbStep;i++)
  ------------------
  |  Branch (2470:13): [True: 21, False: 7]
  ------------------
 2471|     21|	    if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)
  ------------------
  |  |   45|     21|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (2471:10): [True: 9, False: 12]
  ------------------
 2472|      9|	        return(-2);
 2473|      7|	if (comp->stream->nbStep > ret)
  ------------------
  |  Branch (2473:6): [True: 7, False: 0]
  ------------------
 2474|      7|	    ret = comp->stream->nbStep;
 2475|      7|	comp = comp->next;
 2476|      7|    }
 2477|      6|    return(ret);
 2478|     15|}
xmlPatternMinDepth:
 2491|     15|xmlPatternMinDepth(xmlPatternPtr comp) {
 2492|     15|    int ret = 12345678;
 2493|     15|    if (comp == NULL)
  ------------------
  |  Branch (2493:9): [True: 0, False: 15]
  ------------------
 2494|      0|        return(-1);
 2495|     31|    while (comp != NULL) {
  ------------------
  |  Branch (2495:12): [True: 16, False: 15]
  ------------------
 2496|     16|        if (comp->stream == NULL)
  ------------------
  |  Branch (2496:13): [True: 0, False: 16]
  ------------------
 2497|      0|	    return(-1);
 2498|     16|	if (comp->stream->nbStep < ret)
  ------------------
  |  Branch (2498:6): [True: 15, False: 1]
  ------------------
 2499|     15|	    ret = comp->stream->nbStep;
 2500|     16|	if (ret == 0)
  ------------------
  |  Branch (2500:6): [True: 0, False: 16]
  ------------------
 2501|      0|	    return(0);
 2502|     16|	comp = comp->next;
 2503|     16|    }
 2504|     15|    return(ret);
 2505|     15|}
xmlPatternFromRoot:
 2516|     15|xmlPatternFromRoot(xmlPatternPtr comp) {
 2517|     15|    if (comp == NULL)
  ------------------
  |  Branch (2517:9): [True: 0, False: 15]
  ------------------
 2518|      0|        return(-1);
 2519|     18|    while (comp != NULL) {
  ------------------
  |  Branch (2519:12): [True: 16, False: 2]
  ------------------
 2520|     16|        if (comp->stream == NULL)
  ------------------
  |  Branch (2520:13): [True: 0, False: 16]
  ------------------
 2521|      0|	    return(-1);
 2522|     16|	if (comp->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|     16|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (2522:6): [True: 13, False: 3]
  ------------------
 2523|     13|	    return(1);
 2524|      3|	comp = comp->next;
 2525|      3|    }
 2526|      2|    return(0);
 2527|       |
 2528|     15|}
pattern.c:xmlFreePatternInternal:
  233|    140|xmlFreePatternInternal(xmlPatternPtr comp) {
  234|    140|    xmlStepOpPtr op;
  235|    140|    int i;
  236|       |
  237|    140|    if (comp == NULL)
  ------------------
  |  Branch (237:9): [True: 0, False: 140]
  ------------------
  238|      0|	return;
  239|    140|    if (comp->stream != NULL)
  ------------------
  |  Branch (239:9): [True: 16, False: 124]
  ------------------
  240|     16|        xmlFreeStreamComp(comp->stream);
  241|    140|    if (comp->pattern != NULL)
  ------------------
  |  Branch (241:9): [True: 0, False: 140]
  ------------------
  242|      0|	xmlFree((xmlChar *)comp->pattern);
  243|    140|    if (comp->steps != NULL) {
  ------------------
  |  Branch (243:9): [True: 140, False: 0]
  ------------------
  244|    140|        if (comp->dict == NULL) {
  ------------------
  |  Branch (244:13): [True: 140, False: 0]
  ------------------
  245|    236|	    for (i = 0;i < comp->nbStep;i++) {
  ------------------
  |  Branch (245:17): [True: 96, False: 140]
  ------------------
  246|     96|		op = &comp->steps[i];
  247|     96|		if (op->value != NULL)
  ------------------
  |  Branch (247:7): [True: 31, False: 65]
  ------------------
  248|     31|		    xmlFree((xmlChar *) op->value);
  249|     96|		if (op->value2 != NULL)
  ------------------
  |  Branch (249:7): [True: 0, False: 96]
  ------------------
  250|      0|		    xmlFree((xmlChar *) op->value2);
  251|     96|	    }
  252|    140|	}
  253|    140|	xmlFree(comp->steps);
  254|    140|    }
  255|    140|    if (comp->dict != NULL)
  ------------------
  |  Branch (255:9): [True: 0, False: 140]
  ------------------
  256|      0|        xmlDictFree(comp->dict);
  257|       |
  258|    140|    memset(comp, -1, sizeof(xmlPattern));
  259|    140|    xmlFree(comp);
  260|    140|}
pattern.c:xmlStreamPushInternal:
 1790|    109|		      int nodeType) {
 1791|    109|    int ret = 0, err = 0, final = 0, tmp, i, m, match, stepNr, desc;
 1792|    109|    xmlStreamCompPtr comp;
 1793|    109|    xmlStreamStep step;
 1794|       |
 1795|    109|    if ((stream == NULL) || (stream->nbState < 0))
  ------------------
  |  Branch (1795:9): [True: 0, False: 109]
  |  Branch (1795:29): [True: 0, False: 109]
  ------------------
 1796|      0|        return(-1);
 1797|       |
 1798|    222|    while (stream != NULL) {
  ------------------
  |  Branch (1798:12): [True: 113, False: 109]
  ------------------
 1799|    113|	comp = stream->comp;
 1800|       |
 1801|    113|	if ((nodeType == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1801:6): [True: 73, False: 40]
  ------------------
 1802|    113|	    (name == NULL) && (ns == NULL)) {
  ------------------
  |  Branch (1802:6): [True: 13, False: 60]
  |  Branch (1802:24): [True: 13, False: 0]
  ------------------
 1803|       |	    /* We have a document node here (or a reset). */
 1804|     13|	    stream->nbState = 0;
 1805|     13|	    stream->level = 0;
 1806|     13|	    stream->blockLevel = -1;
 1807|     13|	    if (comp->flags & XML_STREAM_FROM_ROOT) {
  ------------------
  |  |   59|     13|#define XML_STREAM_FROM_ROOT 1<<15
  ------------------
  |  Branch (1807:10): [True: 13, False: 0]
  ------------------
 1808|     13|		if (comp->nbStep == 0) {
  ------------------
  |  Branch (1808:7): [True: 0, False: 13]
  ------------------
 1809|       |		    /* TODO: We have a "/." here? */
 1810|      0|		    ret = 1;
 1811|     13|		} else {
 1812|     13|		    if ((comp->nbStep == 1) &&
  ------------------
  |  Branch (1812:11): [True: 8, False: 5]
  ------------------
 1813|     13|			(comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&
  ------------------
  |  |   66|      8|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1813:4): [True: 3, False: 5]
  ------------------
 1814|     13|			(comp->steps[0].flags & XML_STREAM_STEP_DESC))
  ------------------
  |  |   45|      3|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1814:4): [True: 3, False: 0]
  ------------------
 1815|      3|		    {
 1816|       |			/*
 1817|       |			* In the case of "//." the document node will match
 1818|       |			* as well.
 1819|       |			*/
 1820|      3|			ret = 1;
 1821|     10|		    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {
  ------------------
  |  |   47|     10|#define XML_STREAM_STEP_ROOT	4
  ------------------
  |  Branch (1821:18): [True: 6, False: 4]
  ------------------
 1822|       |			/* TODO: Do we need this ? */
 1823|      6|			tmp = xmlStreamCtxtAddState(stream, 0, 0);
 1824|      6|			if (tmp < 0)
  ------------------
  |  Branch (1824:8): [True: 0, False: 6]
  ------------------
 1825|      0|			    err++;
 1826|      6|		    }
 1827|     13|		}
 1828|     13|	    }
 1829|     13|	    stream = stream->next;
 1830|     13|	    continue; /* while */
 1831|     13|	}
 1832|       |
 1833|       |	/*
 1834|       |	* Fast check for ".".
 1835|       |	*/
 1836|    100|	if (comp->nbStep == 0) {
  ------------------
  |  Branch (1836:6): [True: 0, False: 100]
  ------------------
 1837|       |	    /*
 1838|       |	     * / and . are handled at the XPath node set creation
 1839|       |	     * level by checking min depth
 1840|       |	     */
 1841|      0|	    if (stream->flags & XML_PATTERN_XPATH) {
  ------------------
  |  Branch (1841:10): [True: 0, False: 0]
  ------------------
 1842|      0|		stream = stream->next;
 1843|      0|		continue; /* while */
 1844|      0|	    }
 1845|       |	    /*
 1846|       |	    * For non-pattern like evaluation like XML Schema IDCs
 1847|       |	    * or traditional XPath expressions, this will match if
 1848|       |	    * we are at the first level only, otherwise on every level.
 1849|       |	    */
 1850|      0|	    if ((nodeType != XML_ATTRIBUTE_NODE) &&
  ------------------
  |  Branch (1850:10): [True: 0, False: 0]
  ------------------
 1851|      0|		(((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||
  ------------------
  |  |   68|      0|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|      0|				 XML_PATTERN_XSSEL | \
  |  |   70|      0|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1851:4): [True: 0, False: 0]
  ------------------
 1852|      0|		(stream->level == 0))) {
  ------------------
  |  Branch (1852:3): [True: 0, False: 0]
  ------------------
 1853|      0|		    ret = 1;
 1854|      0|	    }
 1855|      0|	    stream->level++;
 1856|      0|	    goto stream_next;
 1857|      0|	}
 1858|    100|	if (stream->blockLevel != -1) {
  ------------------
  |  Branch (1858:6): [True: 6, False: 94]
  ------------------
 1859|       |	    /*
 1860|       |	    * Skip blocked expressions.
 1861|       |	    */
 1862|      6|	    stream->level++;
 1863|      6|	    goto stream_next;
 1864|      6|	}
 1865|       |
 1866|     94|	if ((nodeType != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (1866:6): [True: 40, False: 54]
  ------------------
 1867|     94|	    (nodeType != XML_ATTRIBUTE_NODE) &&
  ------------------
  |  Branch (1867:6): [True: 40, False: 0]
  ------------------
 1868|     94|	    ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {
  ------------------
  |  |   58|     40|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
  |  Branch (1868:6): [True: 0, False: 40]
  ------------------
 1869|       |	    /*
 1870|       |	    * No need to process nodes of other types if we don't
 1871|       |	    * resolve to those types.
 1872|       |	    * TODO: Do we need to block the context here?
 1873|       |	    */
 1874|      0|	    stream->level++;
 1875|      0|	    goto stream_next;
 1876|      0|	}
 1877|       |
 1878|       |	/*
 1879|       |	 * Check evolution of existing states
 1880|       |	 */
 1881|     94|	i = 0;
 1882|     94|	m = stream->nbState;
 1883|    152|	while (i < m) {
  ------------------
  |  Branch (1883:9): [True: 58, False: 94]
  ------------------
 1884|     58|	    if ((comp->flags & XML_STREAM_DESC) == 0) {
  ------------------
  |  |   60|     58|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1884:10): [True: 8, False: 50]
  ------------------
 1885|       |		/*
 1886|       |		* If there is no "//", then only the last
 1887|       |		* added state is of interest.
 1888|       |		*/
 1889|      8|		stepNr = stream->states[2 * (stream->nbState -1)];
 1890|       |		/*
 1891|       |		* TODO: Security check, should not happen, remove it.
 1892|       |		*/
 1893|      8|		if (stream->states[(2 * (stream->nbState -1)) + 1] <
  ------------------
  |  Branch (1893:7): [True: 0, False: 8]
  ------------------
 1894|      8|		    stream->level) {
 1895|      0|		    return (-1);
 1896|      0|		}
 1897|      8|		desc = 0;
 1898|       |		/* loop-stopper */
 1899|      8|		i = m;
 1900|     50|	    } else {
 1901|       |		/*
 1902|       |		* If there are "//", then we need to process every "//"
 1903|       |		* occurring in the states, plus any other state for this
 1904|       |		* level.
 1905|       |		*/
 1906|     50|		stepNr = stream->states[2 * i];
 1907|       |
 1908|       |		/* TODO: should not happen anymore: dead states */
 1909|     50|		if (stepNr < 0)
  ------------------
  |  Branch (1909:7): [True: 0, False: 50]
  ------------------
 1910|      0|		    goto next_state;
 1911|       |
 1912|     50|		tmp = stream->states[(2 * i) + 1];
 1913|       |
 1914|       |		/* skip new states just added */
 1915|     50|		if (tmp > stream->level)
  ------------------
  |  Branch (1915:7): [True: 0, False: 50]
  ------------------
 1916|      0|		    goto next_state;
 1917|       |
 1918|       |		/* skip states at ancestor levels, except if "//" */
 1919|     50|		desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|     50|#define XML_STREAM_STEP_DESC	1
  ------------------
 1920|     50|		if ((tmp < stream->level) && (!desc))
  ------------------
  |  Branch (1920:7): [True: 38, False: 12]
  |  Branch (1920:32): [True: 20, False: 18]
  ------------------
 1921|     20|		    goto next_state;
 1922|     50|	    }
 1923|       |	    /*
 1924|       |	    * Check for correct node-type.
 1925|       |	    */
 1926|     38|	    step = comp->steps[stepNr];
 1927|     38|	    if (step.nodeType != nodeType) {
  ------------------
  |  Branch (1927:10): [True: 22, False: 16]
  ------------------
 1928|     22|		if (step.nodeType == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (1928:7): [True: 0, False: 22]
  ------------------
 1929|       |		    /*
 1930|       |		    * Block this expression for deeper evaluation.
 1931|       |		    */
 1932|      0|		    if ((comp->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1932:11): [True: 0, False: 0]
  ------------------
 1933|      0|			stream->blockLevel = stream->level +1;
 1934|      0|		    goto next_state;
 1935|     22|		} else if (step.nodeType != XML_STREAM_ANY_NODE)
  ------------------
  |  |   66|     22|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1935:14): [True: 8, False: 14]
  ------------------
 1936|      8|		    goto next_state;
 1937|     22|	    }
 1938|       |	    /*
 1939|       |	    * Compare local/namespace-name.
 1940|       |	    */
 1941|     30|	    match = 0;
 1942|     30|	    if (step.nodeType == XML_STREAM_ANY_NODE) {
  ------------------
  |  |   66|     30|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (1942:10): [True: 14, False: 16]
  ------------------
 1943|     14|		match = 1;
 1944|     16|	    } else if (step.name == NULL) {
  ------------------
  |  Branch (1944:17): [True: 0, False: 16]
  ------------------
 1945|      0|		if (step.ns == NULL) {
  ------------------
  |  Branch (1945:7): [True: 0, False: 0]
  ------------------
 1946|       |		    /*
 1947|       |		    * This lets through all elements/attributes.
 1948|       |		    */
 1949|      0|		    match = 1;
 1950|      0|		} else if (ns != NULL)
  ------------------
  |  Branch (1950:14): [True: 0, False: 0]
  ------------------
 1951|      0|		    match = xmlStrEqual(step.ns, ns);
 1952|     16|	    } else if (((step.ns != NULL) == (ns != NULL)) &&
  ------------------
  |  Branch (1952:17): [True: 16, False: 0]
  ------------------
 1953|     16|		(name != NULL) &&
  ------------------
  |  Branch (1953:3): [True: 16, False: 0]
  ------------------
 1954|     16|		(step.name[0] == name[0]) &&
  ------------------
  |  Branch (1954:3): [True: 10, False: 6]
  ------------------
 1955|     16|		xmlStrEqual(step.name, name) &&
  ------------------
  |  Branch (1955:3): [True: 9, False: 1]
  ------------------
 1956|     16|		((step.ns == ns) || xmlStrEqual(step.ns, ns)))
  ------------------
  |  Branch (1956:4): [True: 9, False: 0]
  |  Branch (1956:23): [True: 0, False: 0]
  ------------------
 1957|      9|	    {
 1958|      9|		match = 1;
 1959|      9|	    }
 1960|       |#if 0
 1961|       |/*
 1962|       |* TODO: Pointer comparison won't work, since not guaranteed that the given
 1963|       |*  values are in the same dict; especially if it's the namespace name,
 1964|       |*  normally coming from ns->href. We need a namespace dict mechanism !
 1965|       |*/
 1966|       |	    } else if (comp->dict) {
 1967|       |		if (step.name == NULL) {
 1968|       |		    if (step.ns == NULL)
 1969|       |			match = 1;
 1970|       |		    else
 1971|       |			match = (step.ns == ns);
 1972|       |		} else {
 1973|       |		    match = ((step.name == name) && (step.ns == ns));
 1974|       |		}
 1975|       |#endif /* if 0 ------------------------------------------------------- */
 1976|     30|	    if (match) {
  ------------------
  |  Branch (1976:10): [True: 23, False: 7]
  ------------------
 1977|     23|		final = step.flags & XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|     23|#define XML_STREAM_STEP_FINAL	2
  ------------------
 1978|     23|                if (final) {
  ------------------
  |  Branch (1978:21): [True: 18, False: 5]
  ------------------
 1979|     18|                    ret = 1;
 1980|     18|                } else {
 1981|      5|                    xmlStreamCtxtAddState(stream, stepNr + 1,
 1982|      5|                                          stream->level + 1);
 1983|      5|                }
 1984|     23|		if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {
  ------------------
  |  |   50|      5|#define XML_STREAM_STEP_IN_SET	32
  ------------------
  |  Branch (1984:7): [True: 5, False: 18]
  |  Branch (1984:21): [True: 2, False: 3]
  ------------------
 1985|       |		    /*
 1986|       |		    * Check if we have a special case like "foo/bar//.", where
 1987|       |		    * "foo" is selected as well.
 1988|       |		    */
 1989|      2|		    ret = 1;
 1990|      2|		}
 1991|     23|	    }
 1992|     30|	    if (((comp->flags & XML_STREAM_DESC) == 0) &&
  ------------------
  |  |   60|     30|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1992:10): [True: 8, False: 22]
  ------------------
 1993|     30|		((! match) || final))  {
  ------------------
  |  Branch (1993:4): [True: 3, False: 5]
  |  Branch (1993:17): [True: 3, False: 2]
  ------------------
 1994|       |		/*
 1995|       |		* Mark this expression as blocked for any evaluation at
 1996|       |		* deeper levels. Note that this includes "/foo"
 1997|       |		* expressions if the *pattern* behaviour is used.
 1998|       |		*/
 1999|      6|		stream->blockLevel = stream->level +1;
 2000|      6|	    }
 2001|     58|next_state:
 2002|     58|	    i++;
 2003|     58|	}
 2004|       |
 2005|     94|	stream->level++;
 2006|       |
 2007|       |	/*
 2008|       |	* Re/enter the expression.
 2009|       |	* Don't reenter if it's an absolute expression like "/foo",
 2010|       |	*   except "//foo".
 2011|       |	*/
 2012|     94|	step = comp->steps[0];
 2013|     94|	if (step.flags & XML_STREAM_STEP_ROOT)
  ------------------
  |  |   47|     94|#define XML_STREAM_STEP_ROOT	4
  ------------------
  |  Branch (2013:6): [True: 30, False: 64]
  ------------------
 2014|     30|	    goto stream_next;
 2015|       |
 2016|     64|	desc = step.flags & XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|     64|#define XML_STREAM_STEP_DESC	1
  ------------------
 2017|     64|	if (stream->flags & XML_PATTERN_NOTPATTERN) {
  ------------------
  |  |   68|     64|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|     64|				 XML_PATTERN_XSSEL | \
  |  |   70|     64|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (2017:6): [True: 64, False: 0]
  ------------------
 2018|       |	    /*
 2019|       |	    * Re/enter the expression if it is a "descendant" one,
 2020|       |	    * or if we are at the 1st level of evaluation.
 2021|       |	    */
 2022|       |
 2023|     64|	    if (stream->level == 1) {
  ------------------
  |  Branch (2023:10): [True: 10, False: 54]
  ------------------
 2024|     10|		if (XML_STREAM_XS_IDC(stream)) {
  ------------------
  |  |   72|     10|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 10]
  |  |  ------------------
  |  |   73|     10|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
 2025|       |		    /*
 2026|       |		    * XS-IDC: The missing "self::node()" will always
 2027|       |		    * match the first given node.
 2028|       |		    */
 2029|      0|		    goto stream_next;
 2030|      0|		} else
 2031|     10|		    goto compare;
 2032|     10|	    }
 2033|       |	    /*
 2034|       |	    * A "//" is always reentrant.
 2035|       |	    */
 2036|     54|	    if (desc)
  ------------------
  |  Branch (2036:10): [True: 54, False: 0]
  ------------------
 2037|     54|		goto compare;
 2038|       |
 2039|       |	    /*
 2040|       |	    * XS-IDC: Process the 2nd level, since the missing
 2041|       |	    * "self::node()" is responsible for the 2nd level being
 2042|       |	    * the real start level.
 2043|       |	    */
 2044|      0|	    if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))
  ------------------
  |  |   72|      0|#define XML_STREAM_XS_IDC(c) ((c)->flags & \
  |  |  ------------------
  |  |  |  Branch (72:30): [True: 0, False: 0]
  |  |  ------------------
  |  |   73|      0|    (XML_PATTERN_XSSEL | XML_PATTERN_XSFIELD))
  ------------------
  |  Branch (2044:10): [True: 0, False: 0]
  ------------------
 2045|      0|		goto compare;
 2046|       |
 2047|      0|	    goto stream_next;
 2048|      0|	}
 2049|       |
 2050|     64|compare:
 2051|       |	/*
 2052|       |	* Check expected node-type.
 2053|       |	*/
 2054|     64|	if (step.nodeType != nodeType) {
  ------------------
  |  Branch (2054:6): [True: 33, False: 31]
  ------------------
 2055|     33|	    if (nodeType == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (2055:10): [True: 0, False: 33]
  ------------------
 2056|      0|		goto stream_next;
 2057|     33|	    else if (step.nodeType != XML_STREAM_ANY_NODE)
  ------------------
  |  |   66|     33|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (2057:15): [True: 0, False: 33]
  ------------------
 2058|      0|		goto stream_next;
 2059|     33|	}
 2060|       |	/*
 2061|       |	* Compare local/namespace-name.
 2062|       |	*/
 2063|     64|	match = 0;
 2064|     64|	if (step.nodeType == XML_STREAM_ANY_NODE) {
  ------------------
  |  |   66|     64|#define XML_STREAM_ANY_NODE 100
  ------------------
  |  Branch (2064:6): [True: 33, False: 31]
  ------------------
 2065|     33|	    match = 1;
 2066|     33|	} else if (step.name == NULL) {
  ------------------
  |  Branch (2066:13): [True: 0, False: 31]
  ------------------
 2067|      0|	    if (step.ns == NULL) {
  ------------------
  |  Branch (2067:10): [True: 0, False: 0]
  ------------------
 2068|       |		/*
 2069|       |		* This lets through all elements/attributes.
 2070|       |		*/
 2071|      0|		match = 1;
 2072|      0|	    } else if (ns != NULL)
  ------------------
  |  Branch (2072:17): [True: 0, False: 0]
  ------------------
 2073|      0|		match = xmlStrEqual(step.ns, ns);
 2074|     31|	} else if (((step.ns != NULL) == (ns != NULL)) &&
  ------------------
  |  Branch (2074:13): [True: 31, False: 0]
  ------------------
 2075|     31|	    (name != NULL) &&
  ------------------
  |  Branch (2075:6): [True: 31, False: 0]
  ------------------
 2076|     31|	    (step.name[0] == name[0]) &&
  ------------------
  |  Branch (2076:6): [True: 9, False: 22]
  ------------------
 2077|     31|	    xmlStrEqual(step.name, name) &&
  ------------------
  |  Branch (2077:6): [True: 9, False: 0]
  ------------------
 2078|     31|	    ((step.ns == ns) || xmlStrEqual(step.ns, ns)))
  ------------------
  |  Branch (2078:7): [True: 9, False: 0]
  |  Branch (2078:26): [True: 0, False: 0]
  ------------------
 2079|      9|	{
 2080|      9|	    match = 1;
 2081|      9|	}
 2082|     64|	final = step.flags & XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|     64|#define XML_STREAM_STEP_FINAL	2
  ------------------
 2083|     64|	if (match) {
  ------------------
  |  Branch (2083:6): [True: 42, False: 22]
  ------------------
 2084|     42|	    if (final)
  ------------------
  |  Branch (2084:10): [True: 41, False: 1]
  ------------------
 2085|     41|		ret = 1;
 2086|      1|	    else
 2087|      1|		xmlStreamCtxtAddState(stream, 1, stream->level);
 2088|     42|	    if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {
  ------------------
  |  |   50|      1|#define XML_STREAM_STEP_IN_SET	32
  ------------------
  |  Branch (2088:10): [True: 1, False: 41]
  |  Branch (2088:24): [True: 0, False: 1]
  ------------------
 2089|       |		/*
 2090|       |		* Check if we have a special case like "foo//.", where
 2091|       |		* "foo" is selected as well.
 2092|       |		*/
 2093|      0|		ret = 1;
 2094|      0|	    }
 2095|     42|	}
 2096|     64|	if (((comp->flags & XML_STREAM_DESC) == 0) &&
  ------------------
  |  |   60|     64|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (2096:6): [True: 3, False: 61]
  ------------------
 2097|     64|	    ((! match) || final))  {
  ------------------
  |  Branch (2097:7): [True: 3, False: 0]
  |  Branch (2097:20): [True: 0, False: 0]
  ------------------
 2098|       |	    /*
 2099|       |	    * Mark this expression as blocked for any evaluation at
 2100|       |	    * deeper levels.
 2101|       |	    */
 2102|      3|	    stream->blockLevel = stream->level;
 2103|      3|	}
 2104|       |
 2105|    100|stream_next:
 2106|    100|        stream = stream->next;
 2107|    100|    } /* while stream != NULL */
 2108|       |
 2109|    109|    if (err > 0)
  ------------------
  |  Branch (2109:9): [True: 0, False: 109]
  ------------------
 2110|      0|        ret = -1;
 2111|    109|    return(ret);
 2112|    109|}
pattern.c:xmlStreamCtxtAddState:
 1744|     12|xmlStreamCtxtAddState(xmlStreamCtxtPtr comp, int idx, int level) {
 1745|     12|    int i;
 1746|     18|    for (i = 0;i < comp->nbState;i++) {
  ------------------
  |  Branch (1746:16): [True: 6, False: 12]
  ------------------
 1747|      6|        if (comp->states[2 * i] < 0) {
  ------------------
  |  Branch (1747:13): [True: 0, False: 6]
  ------------------
 1748|      0|	    comp->states[2 * i] = idx;
 1749|      0|	    comp->states[2 * i + 1] = level;
 1750|      0|	    return(i);
 1751|      0|	}
 1752|      6|    }
 1753|     12|    if (comp->nbState >= comp->maxState) {
  ------------------
  |  Branch (1753:9): [True: 0, False: 12]
  ------------------
 1754|      0|        int *cur;
 1755|       |
 1756|      0|	cur = (int *) xmlRealloc(comp->states,
 1757|      0|				 comp->maxState * 4 * sizeof(int));
 1758|      0|	if (cur == NULL) {
  ------------------
  |  Branch (1758:6): [True: 0, False: 0]
  ------------------
 1759|      0|	    ERROR(NULL, NULL, NULL,
 1760|      0|		  "xmlNewStreamCtxt: malloc failed\n");
 1761|      0|	    return(-1);
 1762|      0|	}
 1763|      0|	comp->states = cur;
 1764|      0|        comp->maxState *= 2;
 1765|      0|    }
 1766|     12|    comp->states[2 * comp->nbState] = idx;
 1767|     12|    comp->states[2 * comp->nbState++ + 1] = level;
 1768|     12|    return(comp->nbState - 1);
 1769|     12|}
pattern.c:xmlNewPatParserContext:
  293|    140|                       const xmlChar **namespaces) {
  294|    140|    xmlPatParserContextPtr cur;
  295|       |
  296|    140|    if (pattern == NULL)
  ------------------
  |  Branch (296:9): [True: 0, False: 140]
  ------------------
  297|      0|        return(NULL);
  298|       |
  299|    140|    cur = (xmlPatParserContextPtr) xmlMalloc(sizeof(xmlPatParserContext));
  300|    140|    if (cur == NULL) {
  ------------------
  |  Branch (300:9): [True: 0, False: 140]
  ------------------
  301|      0|	ERROR(NULL, NULL, NULL,
  302|      0|		"xmlNewPatParserContext : malloc failed\n");
  303|      0|	return(NULL);
  304|      0|    }
  305|    140|    memset(cur, 0, sizeof(xmlPatParserContext));
  306|    140|    cur->dict = dict;
  307|    140|    cur->cur = pattern;
  308|    140|    cur->base = pattern;
  309|    140|    if (namespaces != NULL) {
  ------------------
  |  Branch (309:9): [True: 0, False: 140]
  ------------------
  310|      0|        int i;
  311|      0|        for (i = 0;namespaces[2 * i] != NULL;i++)
  ------------------
  |  Branch (311:20): [True: 0, False: 0]
  ------------------
  312|      0|            ;
  313|      0|        cur->nb_namespaces = i;
  314|    140|    } else {
  315|    140|        cur->nb_namespaces = 0;
  316|    140|    }
  317|    140|    cur->namespaces = namespaces;
  318|    140|    return(cur);
  319|    140|}
pattern.c:xmlNewPattern:
  200|    140|xmlNewPattern(void) {
  201|    140|    xmlPatternPtr cur;
  202|       |
  203|    140|    cur = (xmlPatternPtr) xmlMalloc(sizeof(xmlPattern));
  204|    140|    if (cur == NULL) {
  ------------------
  |  Branch (204:9): [True: 0, False: 140]
  ------------------
  205|      0|	ERROR(NULL, NULL, NULL,
  206|      0|		"xmlNewPattern : malloc failed\n");
  207|      0|	return(NULL);
  208|      0|    }
  209|    140|    memset(cur, 0, sizeof(xmlPattern));
  210|    140|    cur->maxStep = 10;
  211|    140|    cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));
  212|    140|    if (cur->steps == NULL) {
  ------------------
  |  Branch (212:9): [True: 0, False: 140]
  ------------------
  213|      0|        xmlFree(cur);
  214|      0|	ERROR(NULL, NULL, NULL,
  215|      0|		"xmlNewPattern : malloc failed\n");
  216|      0|	return(NULL);
  217|      0|    }
  218|    140|    return(cur);
  219|    140|}
pattern.c:xmlPatternAdd:
  350|     80|{
  351|     80|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (351:9): [True: 0, False: 80]
  ------------------
  352|      0|        xmlStepOpPtr temp;
  353|      0|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  354|      0|	                                 sizeof(xmlStepOp));
  355|      0|        if (temp == NULL) {
  ------------------
  |  Branch (355:13): [True: 0, False: 0]
  ------------------
  356|      0|	    ERROR(ctxt, NULL, NULL,
  357|      0|			     "xmlPatternAdd: realloc failed\n");
  358|      0|	    return (-1);
  359|      0|	}
  360|      0|	comp->steps = temp;
  361|      0|	comp->maxStep *= 2;
  362|      0|    }
  363|     80|    comp->steps[comp->nbStep].op = op;
  364|     80|    comp->steps[comp->nbStep].value = value;
  365|     80|    comp->steps[comp->nbStep].value2 = value2;
  366|     80|    comp->nbStep++;
  367|     80|    return (0);
  368|     80|}
pattern.c:xmlCompileStepPattern:
 1003|    157|xmlCompileStepPattern(xmlPatParserContextPtr ctxt) {
 1004|    157|    xmlChar *token = NULL;
 1005|    157|    xmlChar *name = NULL;
 1006|    157|    xmlChar *URL = NULL;
 1007|    157|    int hasBlanks = 0;
 1008|       |
 1009|    157|    SKIP_BLANKS;
  ------------------
  |  |  711|    157|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1010|    157|    if (CUR == '.') {
  ------------------
  |  |  704|    157|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1010:9): [True: 14, False: 143]
  ------------------
 1011|       |	/*
 1012|       |	* Context node.
 1013|       |	*/
 1014|     14|	NEXT;
  ------------------
  |  |  714|     14|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 14, False: 0]
  |  |  ------------------
  ------------------
 1015|     14|	PUSH(XML_OP_ELEM, NULL, NULL);
  ------------------
  |  |  718|     14|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 14]
  |  |  ------------------
  ------------------
 1016|     14|	return;
 1017|     14|    }
 1018|    143|    if (CUR == '@') {
  ------------------
  |  |  704|    143|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1018:9): [True: 0, False: 143]
  ------------------
 1019|       |	/*
 1020|       |	* Attribute test.
 1021|       |	*/
 1022|      0|	if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|      0|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1023|      0|	    ERROR5(NULL, NULL, NULL,
 1024|      0|		"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1025|      0|	    ctxt->error = 1;
 1026|      0|	    return;
 1027|      0|	}
 1028|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1029|      0|	xmlCompileAttributeTest(ctxt);
 1030|      0|	if (ctxt->error != 0)
  ------------------
  |  Branch (1030:6): [True: 0, False: 0]
  ------------------
 1031|      0|	    goto error;
 1032|      0|	return;
 1033|      0|    }
 1034|    143|    name = xmlPatScanNCName(ctxt);
 1035|    143|    if (name == NULL) {
  ------------------
  |  Branch (1035:9): [True: 112, False: 31]
  ------------------
 1036|    112|	if (CUR == '*') {
  ------------------
  |  |  704|    112|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1036:6): [True: 0, False: 112]
  ------------------
 1037|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1038|      0|	    PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1039|      0|	    return;
 1040|    112|	} else {
 1041|    112|	    ERROR(NULL, NULL, NULL,
 1042|    112|		    "xmlCompileStepPattern : Name expected\n");
 1043|    112|	    ctxt->error = 1;
 1044|    112|	    return;
 1045|    112|	}
 1046|    112|    }
 1047|     31|    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|     31|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     31|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 31]
  |  |  |  |  ------------------
  |  |  |  |   89|     31|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 12, False: 19]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 12]
  |  |  |  |  ------------------
  |  |  |  |   90|     31|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 31]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1048|      0|	hasBlanks = 1;
 1049|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1050|      0|    }
 1051|     31|    if (CUR == ':') {
  ------------------
  |  |  704|     31|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1051:9): [True: 0, False: 31]
  ------------------
 1052|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1053|      0|	if (CUR != ':') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1053:6): [True: 0, False: 0]
  ------------------
 1054|      0|	    xmlChar *prefix = name;
 1055|      0|	    int i;
 1056|       |
 1057|      0|	    if (hasBlanks || IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (1057:10): [True: 0, False: 0]
  ------------------
 1058|      0|		ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1059|      0|		ctxt->error = 1;
 1060|      0|		goto error;
 1061|      0|	    }
 1062|       |	    /*
 1063|       |	     * This is a namespace match
 1064|       |	     */
 1065|      0|	    token = xmlPatScanName(ctxt);
 1066|      0|	    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1066:10): [True: 0, False: 0]
  ------------------
 1067|      0|		(prefix[1] == 'm') &&
  ------------------
  |  Branch (1067:3): [True: 0, False: 0]
  ------------------
 1068|      0|		(prefix[2] == 'l') &&
  ------------------
  |  Branch (1068:3): [True: 0, False: 0]
  ------------------
 1069|      0|		(prefix[3] == 0))
  ------------------
  |  Branch (1069:3): [True: 0, False: 0]
  ------------------
 1070|      0|	    {
 1071|      0|		XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1072|      0|	    } else {
 1073|      0|		for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1073:14): [True: 0, False: 0]
  ------------------
 1074|      0|		    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1074:11): [True: 0, False: 0]
  ------------------
 1075|      0|			XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1076|      0|			break;
 1077|      0|		    }
 1078|      0|		}
 1079|      0|		if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1079:7): [True: 0, False: 0]
  ------------------
 1080|      0|		    ERROR5(NULL, NULL, NULL,
 1081|      0|			"xmlCompileStepPattern : no namespace bound to prefix %s\n",
 1082|      0|			prefix);
 1083|      0|		    ctxt->error = 1;
 1084|      0|		    goto error;
 1085|      0|		}
 1086|      0|	    }
 1087|      0|	    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1088|      0|	    name = NULL;
 1089|      0|	    if (token == NULL) {
  ------------------
  |  Branch (1089:10): [True: 0, False: 0]
  ------------------
 1090|      0|		if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1090:7): [True: 0, False: 0]
  ------------------
 1091|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1092|      0|		    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1093|      0|		} else {
 1094|      0|		    ERROR(NULL, NULL, NULL,
 1095|      0|			    "xmlCompileStepPattern : Name expected\n");
 1096|      0|		    ctxt->error = 1;
 1097|      0|		    goto error;
 1098|      0|		}
 1099|      0|	    } else {
 1100|      0|		PUSH(XML_OP_ELEM, token, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1101|      0|	    }
 1102|      0|	} else {
 1103|      0|	    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1104|      0|	    if (xmlStrEqual(name, (const xmlChar *) "child")) {
  ------------------
  |  Branch (1104:10): [True: 0, False: 0]
  ------------------
 1105|      0|		XML_PAT_FREE_STRING(ctxt, name);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1106|      0|		name = xmlPatScanName(ctxt);
 1107|      0|		if (name == NULL) {
  ------------------
  |  Branch (1107:7): [True: 0, False: 0]
  ------------------
 1108|      0|		    if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1108:11): [True: 0, False: 0]
  ------------------
 1109|      0|			NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1110|      0|			PUSH(XML_OP_ALL, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1111|      0|			return;
 1112|      0|		    } else {
 1113|      0|			ERROR(NULL, NULL, NULL,
 1114|      0|			    "xmlCompileStepPattern : QName expected\n");
 1115|      0|			ctxt->error = 1;
 1116|      0|			goto error;
 1117|      0|		    }
 1118|      0|		}
 1119|      0|		if (CUR == ':') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1119:7): [True: 0, False: 0]
  ------------------
 1120|      0|		    xmlChar *prefix = name;
 1121|      0|		    int i;
 1122|       |
 1123|      0|		    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1124|      0|		    if (IS_BLANK_CH(CUR)) {
  ------------------
  |  |  151|      0|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|      0|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   89|      0|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |   90|      0|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1125|      0|			ERROR5(NULL, NULL, NULL, "Invalid QName.\n", NULL);
 1126|      0|			ctxt->error = 1;
 1127|      0|			goto error;
 1128|      0|		    }
 1129|       |		    /*
 1130|       |		    * This is a namespace match
 1131|       |		    */
 1132|      0|		    token = xmlPatScanName(ctxt);
 1133|      0|		    if ((prefix[0] == 'x') &&
  ------------------
  |  Branch (1133:11): [True: 0, False: 0]
  ------------------
 1134|      0|			(prefix[1] == 'm') &&
  ------------------
  |  Branch (1134:4): [True: 0, False: 0]
  ------------------
 1135|      0|			(prefix[2] == 'l') &&
  ------------------
  |  Branch (1135:4): [True: 0, False: 0]
  ------------------
 1136|      0|			(prefix[3] == 0))
  ------------------
  |  Branch (1136:4): [True: 0, False: 0]
  ------------------
 1137|      0|		    {
 1138|      0|			XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1139|      0|		    } else {
 1140|      0|			for (i = 0;i < ctxt->nb_namespaces;i++) {
  ------------------
  |  Branch (1140:15): [True: 0, False: 0]
  ------------------
 1141|      0|			    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {
  ------------------
  |  Branch (1141:12): [True: 0, False: 0]
  ------------------
 1142|      0|				XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])
  ------------------
  |  |   80|      0|    if ((c)->comp->dict) \
  |  |  ------------------
  |  |  |  Branch (80:9): [True: 0, False: 0]
  |  |  ------------------
  |  |   81|      0|	r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  |  |   82|      0|    else r = xmlStrdup(BAD_CAST nsname);
  |  |  ------------------
  |  |  |  |   35|      0|#define BAD_CAST (xmlChar *)
  |  |  ------------------
  ------------------
 1143|      0|				break;
 1144|      0|			    }
 1145|      0|			}
 1146|      0|			if (i >= ctxt->nb_namespaces) {
  ------------------
  |  Branch (1146:8): [True: 0, False: 0]
  ------------------
 1147|      0|			    ERROR5(NULL, NULL, NULL,
 1148|      0|				"xmlCompileStepPattern : no namespace bound "
 1149|      0|				"to prefix %s\n", prefix);
 1150|      0|			    ctxt->error = 1;
 1151|      0|			    goto error;
 1152|      0|			}
 1153|      0|		    }
 1154|      0|		    XML_PAT_FREE_STRING(ctxt, prefix);
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1155|      0|		    name = NULL;
 1156|      0|		    if (token == NULL) {
  ------------------
  |  Branch (1156:11): [True: 0, False: 0]
  ------------------
 1157|      0|			if (CUR == '*') {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1157:8): [True: 0, False: 0]
  ------------------
 1158|      0|			    NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1159|      0|			    PUSH(XML_OP_NS, URL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1160|      0|			} else {
 1161|      0|			    ERROR(NULL, NULL, NULL,
 1162|      0|				"xmlCompileStepPattern : Name expected\n");
 1163|      0|			    ctxt->error = 1;
 1164|      0|			    goto error;
 1165|      0|			}
 1166|      0|		    } else {
 1167|      0|			PUSH(XML_OP_CHILD, token, URL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1168|      0|		    }
 1169|      0|		} else
 1170|      0|		    PUSH(XML_OP_CHILD, name, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1171|      0|		return;
 1172|      0|	    } else if (xmlStrEqual(name, (const xmlChar *) "attribute")) {
  ------------------
  |  Branch (1172:17): [True: 0, False: 0]
  ------------------
 1173|      0|		XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1174|      0|		name = NULL;
 1175|      0|		if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {
  ------------------
  |  |   75|      0|#define XML_STREAM_XS_IDC_SEL(c) ((c)->flags & XML_PATTERN_XSSEL)
  |  |  ------------------
  |  |  |  Branch (75:34): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1176|      0|		    ERROR5(NULL, NULL, NULL,
 1177|      0|			"Unexpected attribute axis in '%s'.\n", ctxt->base);
 1178|      0|		    ctxt->error = 1;
 1179|      0|		    goto error;
 1180|      0|		}
 1181|      0|		xmlCompileAttributeTest(ctxt);
 1182|      0|		if (ctxt->error != 0)
  ------------------
  |  Branch (1182:7): [True: 0, False: 0]
  ------------------
 1183|      0|		    goto error;
 1184|      0|		return;
 1185|      0|	    } else {
 1186|      0|		ERROR5(NULL, NULL, NULL,
 1187|      0|		    "The 'element' or 'attribute' axis is expected.\n", NULL);
 1188|      0|		ctxt->error = 1;
 1189|      0|		goto error;
 1190|      0|	    }
 1191|      0|	}
 1192|     31|    } else if (CUR == '*') {
  ------------------
  |  |  704|     31|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1192:16): [True: 0, False: 31]
  ------------------
 1193|      0|        if (name != NULL) {
  ------------------
  |  Branch (1193:13): [True: 0, False: 0]
  ------------------
 1194|      0|	    ctxt->error = 1;
 1195|      0|	    goto error;
 1196|      0|	}
 1197|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1198|      0|	PUSH(XML_OP_ALL, token, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1199|     31|    } else {
 1200|     31|	PUSH(XML_OP_ELEM, name, NULL);
  ------------------
  |  |  718|     31|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 31]
  |  |  ------------------
  ------------------
 1201|     31|    }
 1202|     31|    return;
 1203|     31|error:
 1204|      0|    if (URL != NULL)
  ------------------
  |  Branch (1204:9): [True: 0, False: 0]
  ------------------
 1205|      0|	XML_PAT_FREE_STRING(ctxt, URL)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1206|      0|    if (token != NULL)
  ------------------
  |  Branch (1206:9): [True: 0, False: 0]
  ------------------
 1207|      0|	XML_PAT_FREE_STRING(ctxt, token)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1208|      0|    if (name != NULL)
  ------------------
  |  Branch (1208:9): [True: 0, False: 0]
  ------------------
 1209|      0|	XML_PAT_FREE_STRING(ctxt, name)
  ------------------
  |  |   84|      0|#define XML_PAT_FREE_STRING(c, r) if ((c)->comp->dict == NULL) xmlFree(r);
  |  |  ------------------
  |  |  |  Branch (84:39): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1210|      0|}
pattern.c:xmlPatScanNCName:
  848|    143|xmlPatScanNCName(xmlPatParserContextPtr ctxt) {
  849|    143|    const xmlChar *q, *cur;
  850|    143|    xmlChar *ret = NULL;
  851|    143|    int val, len;
  852|       |
  853|    143|    SKIP_BLANKS;
  ------------------
  |  |  711|    143|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  854|       |
  855|    143|    cur = q = CUR_PTR;
  ------------------
  |  |  708|    143|#define CUR_PTR ctxt->cur
  ------------------
  856|    143|    val = xmlStringCurrentChar(NULL, cur, &len);
  857|    143|    if (!IS_LETTER(val) && (val != '_'))
  ------------------
  |  |  240|    286|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    143|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    286|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 31, False: 112]
  |  |  |  |  |  |  |  Branch (76:28): [True: 143, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    286|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    143|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 31, False: 112]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 4, False: 27]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    143|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 27, False: 112]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 27, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    143|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 112]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    143|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 112]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    143|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 112]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    286|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    112|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    112|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 112]
  |  |  |  |  |  |  |  Branch (184:31): [True: 112, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    112|				 0 :\
  |  |  |  |  |  |  186|    112|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (857:28): [True: 112, False: 0]
  ------------------
  858|    112|	return(NULL);
  859|       |
  860|    122|    while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  240|    122|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    122|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    244|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 86, False: 36]
  |  |  |  |  |  |  |  Branch (76:28): [True: 122, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    244|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    122|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 87, False: 35]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 28, False: 59]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    122|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 59, False: 35]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 58, False: 1]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    122|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 36]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    122|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 36]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    122|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 36]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    244|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|     36|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|     36|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 36]
  |  |  |  |  |  |  |  Branch (184:31): [True: 36, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|     36|				 0 :\
  |  |  |  |  |  |  186|     36|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
                  while ((IS_LETTER(val)) || (IS_DIGIT(val)) ||
  ------------------
  |  |  171|     36|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|     36|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 36, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|     36|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|     36|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 6, False: 30]
  |  |  |  |  |  |  |  Branch (144:45): [True: 5, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|     36|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (860:32): [True: 5, False: 31]
  ------------------
  861|    122|           (val == '.') || (val == '-') ||
  ------------------
  |  Branch (861:12): [True: 0, False: 31]
  |  Branch (861:28): [True: 0, False: 31]
  ------------------
  862|    122|	   (val == '_') ||
  ------------------
  |  Branch (862:5): [True: 0, False: 31]
  ------------------
  863|    122|	   (IS_COMBINING(val)) ||
  ------------------
  |  |  189|     31|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|     31|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 31, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|     31|				 0 : \
  |  |  |  |  134|     31|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (863:5): [True: 0, False: 31]
  ------------------
  864|    122|	   (IS_EXTENDER(val))) {
  ------------------
  |  |  210|     31|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|     31|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 31, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|     31|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|     31|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|     31|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (864:5): [True: 0, False: 31]
  ------------------
  865|     91|	cur += len;
  866|     91|	val = xmlStringCurrentChar(NULL, cur, &len);
  867|     91|    }
  868|     31|    if (ctxt->dict)
  ------------------
  |  Branch (868:9): [True: 0, False: 31]
  ------------------
  869|      0|	ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);
  870|     31|    else
  871|     31|	ret = xmlStrndup(q, cur - q);
  872|     31|    CUR_PTR = cur;
  ------------------
  |  |  708|     31|#define CUR_PTR ctxt->cur
  ------------------
  873|     31|    return(ret);
  874|    143|}
pattern.c:xmlCompilePathPattern:
 1222|    140|xmlCompilePathPattern(xmlPatParserContextPtr ctxt) {
 1223|    140|    SKIP_BLANKS;
  ------------------
  |  |  711|    140|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1224|    140|    if (CUR == '/') {
  ------------------
  |  |  704|    140|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1224:9): [True: 18, False: 122]
  ------------------
 1225|     18|        ctxt->comp->flags |= PAT_FROM_ROOT;
  ------------------
  |  |  158|     18|#define PAT_FROM_ROOT	(1<<8)
  ------------------
 1226|    122|    } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {
  ------------------
  |  |  704|    122|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '.') || (ctxt->comp->flags & XML_PATTERN_NOTPATTERN)) {
  ------------------
  |  |   68|    120|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|    120|				 XML_PATTERN_XSSEL | \
  |  |   70|    120|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1226:16): [True: 2, False: 120]
  |  Branch (1226:32): [True: 120, False: 0]
  ------------------
 1227|    122|        ctxt->comp->flags |= PAT_FROM_CUR;
  ------------------
  |  |  159|    122|#define PAT_FROM_CUR	(1<<9)
  ------------------
 1228|    122|    }
 1229|       |
 1230|    140|    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  |  704|    140|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  |  706|     18|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1230:9): [True: 18, False: 122]
  |  Branch (1230:25): [True: 9, False: 9]
  ------------------
 1231|      9|	PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      9|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 9]
  |  |  ------------------
  ------------------
 1232|      9|	NEXT;
  ------------------
  |  |  714|      9|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 1233|      9|	NEXT;
  ------------------
  |  |  714|      9|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 1234|    131|    } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  704|    131|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  706|      2|#define NXT(val) ctxt->cur[(val)]
  ------------------
                  } else if ((CUR == '.') && (NXT(1) == '/') && (NXT(2) == '/')) {
  ------------------
  |  |  706|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1234:16): [True: 2, False: 129]
  |  Branch (1234:32): [True: 0, False: 2]
  |  Branch (1234:51): [True: 0, False: 0]
  ------------------
 1235|      0|	PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      0|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1236|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1237|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1238|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1239|       |	/* Check for incompleteness. */
 1240|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1241|      0|	if (CUR == 0) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1241:6): [True: 0, False: 0]
  ------------------
 1242|      0|	    ERROR5(NULL, NULL, NULL,
 1243|      0|	       "Incomplete expression '%s'.\n", ctxt->base);
 1244|      0|	    ctxt->error = 1;
 1245|      0|	    goto error;
 1246|      0|	}
 1247|      0|    }
 1248|    140|    if (CUR == '@') {
  ------------------
  |  |  704|    140|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1248:9): [True: 0, False: 140]
  ------------------
 1249|      0|	NEXT;
  ------------------
  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 1250|      0|	xmlCompileAttributeTest(ctxt);
 1251|      0|	SKIP_BLANKS;
  ------------------
  |  |  711|      0|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1252|       |	/* TODO: check for incompleteness */
 1253|      0|	if (CUR != 0) {
  ------------------
  |  |  704|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1253:6): [True: 0, False: 0]
  ------------------
 1254|      0|	    xmlCompileStepPattern(ctxt);
 1255|      0|	    if (ctxt->error != 0)
  ------------------
  |  Branch (1255:10): [True: 0, False: 0]
  ------------------
 1256|      0|		goto error;
 1257|      0|	}
 1258|    140|    } else {
 1259|    140|        if (CUR == '/') {
  ------------------
  |  |  704|    140|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1259:13): [True: 9, False: 131]
  ------------------
 1260|      9|	    PUSH(XML_OP_ROOT, NULL, NULL);
  ------------------
  |  |  718|      9|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 9]
  |  |  ------------------
  ------------------
 1261|      9|	    NEXT;
  ------------------
  |  |  714|      9|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 9, False: 0]
  |  |  ------------------
  ------------------
 1262|       |	    /* Check for incompleteness. */
 1263|      9|	    SKIP_BLANKS;
  ------------------
  |  |  711|      9|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      9|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1264|      9|	    if (CUR == 0) {
  ------------------
  |  |  704|      9|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1264:10): [True: 0, False: 9]
  ------------------
 1265|      0|		ERROR5(NULL, NULL, NULL,
 1266|      0|		    "Incomplete expression '%s'.\n", ctxt->base);
 1267|      0|		ctxt->error = 1;
 1268|      0|		goto error;
 1269|      0|	    }
 1270|      9|	}
 1271|    140|	xmlCompileStepPattern(ctxt);
 1272|    140|	if (ctxt->error != 0)
  ------------------
  |  Branch (1272:6): [True: 112, False: 28]
  ------------------
 1273|    112|	    goto error;
 1274|     28|	SKIP_BLANKS;
  ------------------
  |  |  711|     28|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|    140|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1275|     45|	while (CUR == '/') {
  ------------------
  |  |  704|     45|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1275:9): [True: 17, False: 28]
  ------------------
 1276|     17|	    if (NXT(1) == '/') {
  ------------------
  |  |  706|     17|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1276:10): [True: 6, False: 11]
  ------------------
 1277|      6|	        PUSH(XML_OP_ANCESTOR, NULL, NULL);
  ------------------
  |  |  718|      6|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 6]
  |  |  ------------------
  ------------------
 1278|      6|		NEXT;
  ------------------
  |  |  714|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 1279|      6|		NEXT;
  ------------------
  |  |  714|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 1280|      6|		SKIP_BLANKS;
  ------------------
  |  |  711|      6|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1281|      6|		xmlCompileStepPattern(ctxt);
 1282|      6|		if (ctxt->error != 0)
  ------------------
  |  Branch (1282:7): [True: 0, False: 6]
  ------------------
 1283|      0|		    goto error;
 1284|     11|	    } else {
 1285|     11|	        PUSH(XML_OP_PARENT, NULL, NULL);
  ------------------
  |  |  718|     11|    if (xmlPatternAdd(ctxt, ctxt->comp, (op), (val), (val2))) goto error;
  |  |  ------------------
  |  |  |  Branch (718:9): [True: 0, False: 11]
  |  |  ------------------
  ------------------
 1286|     11|		NEXT;
  ------------------
  |  |  714|     11|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (714:15): [True: 11, False: 0]
  |  |  ------------------
  ------------------
 1287|     11|		SKIP_BLANKS;
  ------------------
  |  |  711|     11|    while (IS_BLANK_CH(CUR)) NEXT
  |  |  ------------------
  |  |  |  |  714|     11|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (714:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1288|     11|		if (CUR == 0) {
  ------------------
  |  |  704|     11|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1288:7): [True: 0, False: 11]
  ------------------
 1289|      0|		    ERROR5(NULL, NULL, NULL,
 1290|      0|		    "Incomplete expression '%s'.\n", ctxt->base);
 1291|      0|		    ctxt->error = 1;
 1292|      0|		    goto error;
 1293|      0|		}
 1294|     11|		xmlCompileStepPattern(ctxt);
 1295|     11|		if (ctxt->error != 0)
  ------------------
  |  Branch (1295:7): [True: 0, False: 11]
  ------------------
 1296|      0|		    goto error;
 1297|     11|	    }
 1298|     17|	}
 1299|     28|    }
 1300|     28|    if (CUR != 0) {
  ------------------
  |  |  704|     28|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1300:9): [True: 3, False: 25]
  ------------------
 1301|      3|	ERROR5(NULL, NULL, NULL,
 1302|      3|	       "Failed to compile pattern %s\n", ctxt->base);
 1303|      3|	ctxt->error = 1;
 1304|      3|    }
 1305|    140|error:
 1306|    140|    return;
 1307|     28|}
pattern.c:xmlFreePatParserContext:
  328|    140|xmlFreePatParserContext(xmlPatParserContextPtr ctxt) {
  329|    140|    if (ctxt == NULL)
  ------------------
  |  Branch (329:9): [True: 0, False: 140]
  ------------------
  330|      0|	return;
  331|    140|    memset(ctxt, -1, sizeof(xmlPatParserContext));
  332|    140|    xmlFree(ctxt);
  333|    140|}
pattern.c:xmlStreamCompile:
 1511|     21|xmlStreamCompile(xmlPatternPtr comp) {
 1512|     21|    xmlStreamCompPtr stream;
 1513|     21|    int i, s = 0, root = 0, flags = 0, prevs = -1;
 1514|     21|    xmlStepOp step;
 1515|       |
 1516|     21|    if ((comp == NULL) || (comp->steps == NULL))
  ------------------
  |  Branch (1516:9): [True: 0, False: 21]
  |  Branch (1516:27): [True: 0, False: 21]
  ------------------
 1517|      0|        return(-1);
 1518|       |    /*
 1519|       |     * special case for .
 1520|       |     */
 1521|     21|    if ((comp->nbStep == 1) &&
  ------------------
  |  Branch (1521:9): [True: 4, False: 17]
  ------------------
 1522|     21|        (comp->steps[0].op == XML_OP_ELEM) &&
  ------------------
  |  Branch (1522:9): [True: 4, False: 0]
  ------------------
 1523|     21|	(comp->steps[0].value == NULL) &&
  ------------------
  |  Branch (1523:2): [True: 0, False: 4]
  ------------------
 1524|     21|	(comp->steps[0].value2 == NULL)) {
  ------------------
  |  Branch (1524:2): [True: 0, False: 0]
  ------------------
 1525|      0|	stream = xmlNewStreamComp(0);
 1526|      0|	if (stream == NULL)
  ------------------
  |  Branch (1526:6): [True: 0, False: 0]
  ------------------
 1527|      0|	    return(-1);
 1528|       |	/* Note that the stream will have no steps in this case. */
 1529|      0|	stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      0|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1530|      0|	comp->stream = stream;
 1531|      0|	return(0);
 1532|      0|    }
 1533|       |
 1534|     21|    stream = xmlNewStreamComp((comp->nbStep / 2) + 1);
 1535|     21|    if (stream == NULL)
  ------------------
  |  Branch (1535:9): [True: 0, False: 21]
  ------------------
 1536|      0|        return(-1);
 1537|     21|    if (comp->dict != NULL) {
  ------------------
  |  Branch (1537:9): [True: 0, False: 21]
  ------------------
 1538|      0|        stream->dict = comp->dict;
 1539|      0|	xmlDictReference(stream->dict);
 1540|      0|    }
 1541|       |
 1542|     21|    i = 0;
 1543|     21|    if (comp->flags & PAT_FROM_ROOT)
  ------------------
  |  |  158|     21|#define PAT_FROM_ROOT	(1<<8)
  ------------------
  |  Branch (1543:9): [True: 16, False: 5]
  ------------------
 1544|     16|	stream->flags |= XML_STREAM_FROM_ROOT;
  ------------------
  |  |   59|     16|#define XML_STREAM_FROM_ROOT 1<<15
  ------------------
 1545|       |
 1546|     88|    for (;i < comp->nbStep;i++) {
  ------------------
  |  Branch (1546:11): [True: 67, False: 21]
  ------------------
 1547|     67|	step = comp->steps[i];
 1548|     67|        switch (step.op) {
  ------------------
  |  Branch (1548:17): [True: 0, False: 67]
  ------------------
 1549|      0|	    case XML_OP_END:
  ------------------
  |  Branch (1549:6): [True: 0, False: 67]
  ------------------
 1550|      0|	        break;
 1551|      8|	    case XML_OP_ROOT:
  ------------------
  |  Branch (1551:6): [True: 8, False: 59]
  ------------------
 1552|      8|	        if (i != 0)
  ------------------
  |  Branch (1552:14): [True: 0, False: 8]
  ------------------
 1553|      0|		    goto error;
 1554|      8|		root = 1;
 1555|      8|		break;
 1556|      0|	    case XML_OP_NS:
  ------------------
  |  Branch (1556:6): [True: 0, False: 67]
  ------------------
 1557|      0|		s = xmlStreamCompAddStep(stream, NULL, step.value,
 1558|      0|		    XML_ELEMENT_NODE, flags);
 1559|      0|		if (s < 0)
  ------------------
  |  Branch (1559:7): [True: 0, False: 0]
  ------------------
 1560|      0|		    goto error;
 1561|      0|		prevs = s;
 1562|      0|		flags = 0;
 1563|      0|		break;
 1564|      0|	    case XML_OP_ATTR:
  ------------------
  |  Branch (1564:6): [True: 0, False: 67]
  ------------------
 1565|      0|		flags |= XML_STREAM_STEP_ATTR;
  ------------------
  |  |   48|      0|#define XML_STREAM_STEP_ATTR	8
  ------------------
 1566|      0|		prevs = -1;
 1567|      0|		s = xmlStreamCompAddStep(stream,
 1568|      0|		    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);
 1569|      0|		flags = 0;
 1570|      0|		if (s < 0)
  ------------------
  |  Branch (1570:7): [True: 0, False: 0]
  ------------------
 1571|      0|		    goto error;
 1572|      0|		break;
 1573|     36|	    case XML_OP_ELEM:
  ------------------
  |  Branch (1573:6): [True: 36, False: 31]
  ------------------
 1574|     36|	        if ((step.value == NULL) && (step.value2 == NULL)) {
  ------------------
  |  Branch (1574:14): [True: 12, False: 24]
  |  Branch (1574:38): [True: 12, False: 0]
  ------------------
 1575|       |		    /*
 1576|       |		    * We have a "." or "self::node()" here.
 1577|       |		    * Eliminate redundant self::node() tests like in "/./."
 1578|       |		    * or "//./"
 1579|       |		    * The only case we won't eliminate is "//.", i.e. if
 1580|       |		    * self::node() is the last node test and we had
 1581|       |		    * continuation somewhere beforehand.
 1582|       |		    */
 1583|     12|		    if ((comp->nbStep == i + 1) &&
  ------------------
  |  Branch (1583:11): [True: 6, False: 6]
  ------------------
 1584|     12|			(flags & XML_STREAM_STEP_DESC)) {
  ------------------
  |  |   45|      6|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1584:4): [True: 5, False: 1]
  ------------------
 1585|       |			/*
 1586|       |			* Mark the special case where the expression resolves
 1587|       |			* to any type of node.
 1588|       |			*/
 1589|      5|			if (comp->nbStep == i + 1) {
  ------------------
  |  Branch (1589:8): [True: 5, False: 0]
  ------------------
 1590|      5|			    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;
  ------------------
  |  |   58|      5|#define XML_STREAM_FINAL_IS_ANY_NODE 1<<14
  ------------------
 1591|      5|			}
 1592|      5|			flags |= XML_STREAM_STEP_NODE;
  ------------------
  |  |   49|      5|#define XML_STREAM_STEP_NODE	16
  ------------------
 1593|      5|			s = xmlStreamCompAddStep(stream, NULL, NULL,
 1594|      5|			    XML_STREAM_ANY_NODE, flags);
  ------------------
  |  |   66|      5|#define XML_STREAM_ANY_NODE 100
  ------------------
 1595|      5|			if (s < 0)
  ------------------
  |  Branch (1595:8): [True: 0, False: 5]
  ------------------
 1596|      0|			    goto error;
 1597|      5|			flags = 0;
 1598|       |			/*
 1599|       |			* If there was a previous step, mark it to be added to
 1600|       |			* the result node-set; this is needed since only
 1601|       |			* the last step will be marked as "final" and only
 1602|       |			* "final" nodes are added to the resulting set.
 1603|       |			*/
 1604|      5|			if (prevs != -1) {
  ------------------
  |  Branch (1604:8): [True: 2, False: 3]
  ------------------
 1605|      2|			    stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;
  ------------------
  |  |   50|      2|#define XML_STREAM_STEP_IN_SET	32
  ------------------
 1606|      2|			    prevs = -1;
 1607|      2|			}
 1608|      5|			break;
 1609|       |
 1610|      7|		    } else {
 1611|       |			/* Just skip this one. */
 1612|      7|			continue;
 1613|      7|		    }
 1614|     12|		}
 1615|       |		/* An element node. */
 1616|     24|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1617|     24|		    XML_ELEMENT_NODE, flags);
 1618|     24|		if (s < 0)
  ------------------
  |  Branch (1618:7): [True: 0, False: 24]
  ------------------
 1619|      0|		    goto error;
 1620|     24|		prevs = s;
 1621|     24|		flags = 0;
 1622|     24|		break;
 1623|      0|	    case XML_OP_CHILD:
  ------------------
  |  Branch (1623:6): [True: 0, False: 67]
  ------------------
 1624|       |		/* An element node child. */
 1625|      0|	        s = xmlStreamCompAddStep(stream, step.value, step.value2,
 1626|      0|		    XML_ELEMENT_NODE, flags);
 1627|      0|		if (s < 0)
  ------------------
  |  Branch (1627:7): [True: 0, False: 0]
  ------------------
 1628|      0|		    goto error;
 1629|      0|		prevs = s;
 1630|      0|		flags = 0;
 1631|      0|		break;
 1632|      0|	    case XML_OP_ALL:
  ------------------
  |  Branch (1632:6): [True: 0, False: 67]
  ------------------
 1633|      0|	        s = xmlStreamCompAddStep(stream, NULL, NULL,
 1634|      0|		    XML_ELEMENT_NODE, flags);
 1635|      0|		if (s < 0)
  ------------------
  |  Branch (1635:7): [True: 0, False: 0]
  ------------------
 1636|      0|		    goto error;
 1637|      0|		prevs = s;
 1638|      0|		flags = 0;
 1639|      0|		break;
 1640|      9|	    case XML_OP_PARENT:
  ------------------
  |  Branch (1640:6): [True: 9, False: 58]
  ------------------
 1641|      9|	        break;
 1642|     14|	    case XML_OP_ANCESTOR:
  ------------------
  |  Branch (1642:6): [True: 14, False: 53]
  ------------------
 1643|       |		/* Skip redundant continuations. */
 1644|     14|		if (flags & XML_STREAM_STEP_DESC)
  ------------------
  |  |   45|     14|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1644:7): [True: 3, False: 11]
  ------------------
 1645|      3|		    break;
 1646|     11|	        flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|     11|#define XML_STREAM_STEP_DESC	1
  ------------------
 1647|       |		/*
 1648|       |		* Mark the expression as having "//".
 1649|       |		*/
 1650|     11|		if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|     11|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1650:7): [True: 10, False: 1]
  ------------------
 1651|     10|		    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|     10|#define XML_STREAM_DESC 1<<16
  ------------------
 1652|     11|		break;
 1653|     67|	}
 1654|     67|    }
 1655|     21|    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {
  ------------------
  |  |   68|     13|#define XML_PATTERN_NOTPATTERN  (XML_PATTERN_XPATH | \
  |  |   69|     13|				 XML_PATTERN_XSSEL | \
  |  |   70|     13|				 XML_PATTERN_XSFIELD)
  ------------------
  |  Branch (1655:9): [True: 13, False: 8]
  |  Branch (1655:21): [True: 0, False: 13]
  ------------------
 1656|       |	/*
 1657|       |	* If this should behave like a real pattern, we will mark
 1658|       |	* the first step as having "//", to be reentrant on every
 1659|       |	* tree level.
 1660|       |	*/
 1661|      0|	if ((stream->flags & XML_STREAM_DESC) == 0)
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
  |  Branch (1661:6): [True: 0, False: 0]
  ------------------
 1662|      0|	    stream->flags |= XML_STREAM_DESC;
  ------------------
  |  |   60|      0|#define XML_STREAM_DESC 1<<16
  ------------------
 1663|       |
 1664|      0|	if (stream->nbStep > 0) {
  ------------------
  |  Branch (1664:6): [True: 0, False: 0]
  ------------------
 1665|      0|	    if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
  |  Branch (1665:10): [True: 0, False: 0]
  ------------------
 1666|      0|		stream->steps[0].flags |= XML_STREAM_STEP_DESC;
  ------------------
  |  |   45|      0|#define XML_STREAM_STEP_DESC	1
  ------------------
 1667|      0|	}
 1668|      0|    }
 1669|     21|    if (stream->nbStep <= s)
  ------------------
  |  Branch (1669:9): [True: 1, False: 20]
  ------------------
 1670|      1|	goto error;
 1671|     20|    stream->steps[s].flags |= XML_STREAM_STEP_FINAL;
  ------------------
  |  |   46|     20|#define XML_STREAM_STEP_FINAL	2
  ------------------
 1672|     20|    if (root)
  ------------------
  |  Branch (1672:9): [True: 7, False: 13]
  ------------------
 1673|      7|	stream->steps[0].flags |= XML_STREAM_STEP_ROOT;
  ------------------
  |  |   47|      7|#define XML_STREAM_STEP_ROOT	4
  ------------------
 1674|     20|    comp->stream = stream;
 1675|     20|    return(0);
 1676|      1|error:
 1677|      1|    xmlFreeStreamComp(stream);
 1678|      1|    return(0);
 1679|     21|}
pattern.c:xmlNewStreamComp:
 1425|     21|xmlNewStreamComp(int size) {
 1426|     21|    xmlStreamCompPtr cur;
 1427|       |
 1428|     21|    if (size < 4)
  ------------------
  |  Branch (1428:9): [True: 18, False: 3]
  ------------------
 1429|     18|        size  = 4;
 1430|       |
 1431|     21|    cur = (xmlStreamCompPtr) xmlMalloc(sizeof(xmlStreamComp));
 1432|     21|    if (cur == NULL) {
  ------------------
  |  Branch (1432:9): [True: 0, False: 21]
  ------------------
 1433|      0|	ERROR(NULL, NULL, NULL,
 1434|      0|		"xmlNewStreamComp: malloc failed\n");
 1435|      0|	return(NULL);
 1436|      0|    }
 1437|     21|    memset(cur, 0, sizeof(xmlStreamComp));
 1438|     21|    cur->steps = (xmlStreamStepPtr) xmlMalloc(size * sizeof(xmlStreamStep));
 1439|     21|    if (cur->steps == NULL) {
  ------------------
  |  Branch (1439:9): [True: 0, False: 21]
  ------------------
 1440|      0|	xmlFree(cur);
 1441|      0|	ERROR(NULL, NULL, NULL,
 1442|      0|	      "xmlNewStreamComp: malloc failed\n");
 1443|      0|	return(NULL);
 1444|      0|    }
 1445|     21|    cur->nbStep = 0;
 1446|     21|    cur->maxStep = size;
 1447|     21|    return(cur);
 1448|     21|}
pattern.c:xmlStreamCompAddStep:
 1480|     29|                     const xmlChar *ns, int nodeType, int flags) {
 1481|     29|    xmlStreamStepPtr cur;
 1482|       |
 1483|     29|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (1483:9): [True: 0, False: 29]
  ------------------
 1484|      0|	cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,
 1485|      0|				 comp->maxStep * 2 * sizeof(xmlStreamStep));
 1486|      0|	if (cur == NULL) {
  ------------------
  |  Branch (1486:6): [True: 0, False: 0]
  ------------------
 1487|      0|	    ERROR(NULL, NULL, NULL,
 1488|      0|		  "xmlNewStreamComp: malloc failed\n");
 1489|      0|	    return(-1);
 1490|      0|	}
 1491|      0|	comp->steps = cur;
 1492|      0|        comp->maxStep *= 2;
 1493|      0|    }
 1494|     29|    cur = &comp->steps[comp->nbStep++];
 1495|     29|    cur->flags = flags;
 1496|     29|    cur->name = name;
 1497|     29|    cur->ns = ns;
 1498|     29|    cur->nodeType = nodeType;
 1499|     29|    return(comp->nbStep - 1);
 1500|     29|}
pattern.c:xmlReversePattern:
  408|     25|xmlReversePattern(xmlPatternPtr comp) {
  409|     25|    int i, j;
  410|       |
  411|       |    /*
  412|       |     * remove the leading // for //a or .//a
  413|       |     */
  414|     25|    if ((comp->nbStep > 0) && (comp->steps[0].op == XML_OP_ANCESTOR)) {
  ------------------
  |  Branch (414:9): [True: 25, False: 0]
  |  Branch (414:31): [True: 9, False: 16]
  ------------------
  415|     28|        for (i = 0, j = 1;j < comp->nbStep;i++,j++) {
  ------------------
  |  Branch (415:27): [True: 19, False: 9]
  ------------------
  416|     19|	    comp->steps[i].value = comp->steps[j].value;
  417|     19|	    comp->steps[i].value2 = comp->steps[j].value2;
  418|     19|	    comp->steps[i].op = comp->steps[j].op;
  419|     19|	}
  420|      9|	comp->nbStep--;
  421|      9|    }
  422|     25|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (422:9): [True: 1, False: 24]
  ------------------
  423|      1|        xmlStepOpPtr temp;
  424|      1|	temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *
  425|      1|	                                 sizeof(xmlStepOp));
  426|      1|        if (temp == NULL) {
  ------------------
  |  Branch (426:13): [True: 0, False: 1]
  ------------------
  427|      0|	    ERROR(ctxt, NULL, NULL,
  428|      0|			     "xmlReversePattern: realloc failed\n");
  429|      0|	    return (-1);
  430|      0|	}
  431|      1|	comp->steps = temp;
  432|      1|	comp->maxStep *= 2;
  433|      1|    }
  434|     25|    i = 0;
  435|     25|    j = comp->nbStep - 1;
  436|     51|    while (j > i) {
  ------------------
  |  Branch (436:12): [True: 26, False: 25]
  ------------------
  437|     26|	register const xmlChar *tmp;
  438|     26|	register xmlPatOp op;
  439|     26|	tmp = comp->steps[i].value;
  440|     26|	comp->steps[i].value = comp->steps[j].value;
  441|     26|	comp->steps[j].value = tmp;
  442|     26|	tmp = comp->steps[i].value2;
  443|     26|	comp->steps[i].value2 = comp->steps[j].value2;
  444|     26|	comp->steps[j].value2 = tmp;
  445|     26|	op = comp->steps[i].op;
  446|     26|	comp->steps[i].op = comp->steps[j].op;
  447|     26|	comp->steps[j].op = op;
  448|     26|	j--;
  449|     26|	i++;
  450|     26|    }
  451|     25|    comp->steps[comp->nbStep].value = NULL;
  452|     25|    comp->steps[comp->nbStep].value2 = NULL;
  453|     25|    comp->steps[comp->nbStep++].op = XML_OP_END;
  454|     25|    return(0);
  455|     25|}
pattern.c:xmlFreeStreamComp:
 1457|     21|xmlFreeStreamComp(xmlStreamCompPtr comp) {
 1458|     21|    if (comp != NULL) {
  ------------------
  |  Branch (1458:9): [True: 21, False: 0]
  ------------------
 1459|     21|        if (comp->steps != NULL)
  ------------------
  |  Branch (1459:13): [True: 21, False: 0]
  ------------------
 1460|     21|	    xmlFree(comp->steps);
 1461|     21|	if (comp->dict != NULL)
  ------------------
  |  Branch (1461:6): [True: 0, False: 21]
  ------------------
 1462|      0|	    xmlDictFree(comp->dict);
 1463|     21|        xmlFree(comp);
 1464|     21|    }
 1465|     21|}
pattern.c:xmlNewStreamCtxt:
 1690|     16|xmlNewStreamCtxt(xmlStreamCompPtr stream) {
 1691|     16|    xmlStreamCtxtPtr cur;
 1692|       |
 1693|     16|    cur = (xmlStreamCtxtPtr) xmlMalloc(sizeof(xmlStreamCtxt));
 1694|     16|    if (cur == NULL) {
  ------------------
  |  Branch (1694:9): [True: 0, False: 16]
  ------------------
 1695|      0|	ERROR(NULL, NULL, NULL,
 1696|      0|		"xmlNewStreamCtxt: malloc failed\n");
 1697|      0|	return(NULL);
 1698|      0|    }
 1699|     16|    memset(cur, 0, sizeof(xmlStreamCtxt));
 1700|     16|    cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));
 1701|     16|    if (cur->states == NULL) {
  ------------------
  |  Branch (1701:9): [True: 0, False: 16]
  ------------------
 1702|      0|	xmlFree(cur);
 1703|      0|	ERROR(NULL, NULL, NULL,
 1704|      0|	      "xmlNewStreamCtxt: malloc failed\n");
 1705|      0|	return(NULL);
 1706|      0|    }
 1707|     16|    cur->nbState = 0;
 1708|     16|    cur->maxState = 4;
 1709|     16|    cur->level = 0;
 1710|     16|    cur->comp = stream;
 1711|     16|    cur->blockLevel = -1;
 1712|     16|    return(cur);
 1713|     16|}

xmlInitMutex:
  129|      8|{
  130|      8|#ifdef HAVE_POSIX_THREADS
  131|      8|    if (XML_IS_NEVER_THREADED() == 0)
  ------------------
  |  |   85|      8|#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)
  ------------------
  |  Branch (131:9): [True: 8, False: 0]
  ------------------
  132|      8|        pthread_mutex_init(&mutex->lock, NULL);
  133|       |#elif defined HAVE_WIN32_THREADS
  134|       |    InitializeCriticalSection(&mutex->cs);
  135|       |#else
  136|       |    (void) mutex;
  137|       |#endif
  138|      8|}
xmlMutexLock:
  202|  1.63k|{
  203|  1.63k|    if (tok == NULL)
  ------------------
  |  Branch (203:9): [True: 0, False: 1.63k]
  ------------------
  204|      0|        return;
  205|  1.63k|#ifdef HAVE_POSIX_THREADS
  206|       |    /*
  207|       |     * This assumes that __libc_single_threaded won't change while the
  208|       |     * lock is held.
  209|       |     */
  210|  1.63k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  1.63k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (210:9): [True: 1.63k, False: 0]
  ------------------
  211|  1.63k|        pthread_mutex_lock(&tok->lock);
  212|       |#elif defined HAVE_WIN32_THREADS
  213|       |    EnterCriticalSection(&tok->cs);
  214|       |#endif
  215|       |
  216|  1.63k|}
xmlMutexUnlock:
  226|  1.63k|{
  227|  1.63k|    if (tok == NULL)
  ------------------
  |  Branch (227:9): [True: 0, False: 1.63k]
  ------------------
  228|      0|        return;
  229|  1.63k|#ifdef HAVE_POSIX_THREADS
  230|  1.63k|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|  1.63k|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (230:9): [True: 1.63k, False: 0]
  ------------------
  231|  1.63k|        pthread_mutex_unlock(&tok->lock);
  232|       |#elif defined HAVE_WIN32_THREADS
  233|       |    LeaveCriticalSection(&tok->cs);
  234|       |#endif
  235|  1.63k|}
xmlInitParser:
  569|  3.50k|xmlInitParser(void) {
  570|       |    /*
  571|       |     * Note that the initialization code must not make memory allocations.
  572|       |     */
  573|  3.50k|    if (xmlParserInitialized != 0)
  ------------------
  |  Branch (573:9): [True: 3.50k, False: 2]
  ------------------
  574|  3.50k|        return;
  575|       |
  576|      2|    xmlGlobalInitMutexLock();
  577|       |
  578|      2|    if (xmlParserInnerInitialized == 0) {
  ------------------
  |  Branch (578:9): [True: 2, False: 0]
  ------------------
  579|       |#if defined(_WIN32) && \
  580|       |    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \
  581|       |    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))
  582|       |        if (xmlFree == free)
  583|       |            atexit(xmlCleanupParser);
  584|       |#endif
  585|       |
  586|      2|        xmlInitMemoryInternal(); /* Should come second */
  587|      2|        xmlInitGlobalsInternal();
  588|      2|        xmlInitRandom();
  589|      2|        xmlInitDictInternal();
  590|      2|        xmlInitEncodingInternal();
  591|      2|#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
  592|      2|        xmlInitXPathInternal();
  593|      2|#endif
  594|       |
  595|      2|        xmlRegisterDefaultInputCallbacks();
  596|      2|#ifdef LIBXML_OUTPUT_ENABLED
  597|      2|        xmlRegisterDefaultOutputCallbacks();
  598|      2|#endif /* LIBXML_OUTPUT_ENABLED */
  599|       |
  600|      2|        xmlParserInnerInitialized = 1;
  601|      2|    }
  602|       |
  603|      2|    xmlGlobalInitMutexUnlock();
  604|       |
  605|      2|    xmlParserInitialized = 1;
  606|      2|}
threads.c:xmlGlobalInitMutexLock:
  462|      2|xmlGlobalInitMutexLock(void) {
  463|      2|#ifdef HAVE_POSIX_THREADS
  464|       |
  465|      2|#ifdef XML_PTHREAD_WEAK
  466|       |    /*
  467|       |     * This is somewhat unreliable since libpthread could be loaded
  468|       |     * later with dlopen() and threads could be created. But it's
  469|       |     * long-standing behavior and hard to work around.
  470|       |     */
  471|      2|    if (libxml_is_threaded == -1)
  ------------------
  |  Branch (471:9): [True: 2, False: 0]
  ------------------
  472|      2|        libxml_is_threaded =
  473|      2|            (pthread_mutex_init != NULL) &&
  ------------------
  |  Branch (473:13): [True: 2, False: 0]
  ------------------
  474|      2|            (pthread_mutex_destroy != NULL) &&
  ------------------
  |  Branch (474:13): [True: 2, False: 0]
  ------------------
  475|      2|            (pthread_mutex_lock != NULL) &&
  ------------------
  |  Branch (475:13): [True: 2, False: 0]
  ------------------
  476|      2|            (pthread_mutex_unlock != NULL) &&
  ------------------
  |  Branch (476:13): [True: 2, False: 0]
  ------------------
  477|      2|            (pthread_cond_init != NULL) &&
  ------------------
  |  Branch (477:13): [True: 2, False: 0]
  ------------------
  478|      2|            (pthread_cond_destroy != NULL) &&
  ------------------
  |  Branch (478:13): [True: 2, False: 0]
  ------------------
  479|      2|            (pthread_cond_wait != NULL) &&
  ------------------
  |  Branch (479:13): [True: 2, False: 0]
  ------------------
  480|       |            /*
  481|       |             * pthread_equal can be inline, resuting in -Waddress warnings.
  482|       |             * Let's assume it's available if all the other functions are.
  483|       |             */
  484|       |            /* (pthread_equal != NULL) && */
  485|      2|            (pthread_self != NULL) &&
  ------------------
  |  Branch (485:13): [True: 2, False: 0]
  ------------------
  486|      2|            (pthread_cond_signal != NULL);
  ------------------
  |  Branch (486:13): [True: 2, False: 0]
  ------------------
  487|      2|#endif
  488|       |
  489|       |    /* The mutex is statically initialized, so we just lock it. */
  490|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (490:9): [True: 2, False: 0]
  ------------------
  491|      2|        pthread_mutex_lock(&global_init_lock);
  492|       |
  493|       |#elif defined HAVE_WIN32_THREADS
  494|       |
  495|       |    LPCRITICAL_SECTION cs;
  496|       |
  497|       |    /* Create a new critical section */
  498|       |    if (global_init_lock == NULL) {
  499|       |        cs = malloc(sizeof(CRITICAL_SECTION));
  500|       |        if (cs == NULL) {
  501|       |            xmlGenericError(xmlGenericErrorContext,
  502|       |                            "xmlGlobalInitMutexLock: out of memory\n");
  503|       |            return;
  504|       |        }
  505|       |        InitializeCriticalSection(cs);
  506|       |
  507|       |        /* Swap it into the global_init_lock */
  508|       |#ifdef InterlockedCompareExchangePointer
  509|       |        InterlockedCompareExchangePointer((void **) &global_init_lock,
  510|       |                                          cs, NULL);
  511|       |#else /* Use older void* version */
  512|       |        InterlockedCompareExchange((void **) &global_init_lock,
  513|       |                                   (void *) cs, NULL);
  514|       |#endif /* InterlockedCompareExchangePointer */
  515|       |
  516|       |        /* If another thread successfully recorded its critical
  517|       |         * section in the global_init_lock then discard the one
  518|       |         * allocated by this thread. */
  519|       |        if (global_init_lock != cs) {
  520|       |            DeleteCriticalSection(cs);
  521|       |            free(cs);
  522|       |        }
  523|       |    }
  524|       |
  525|       |    /* Lock the chosen critical section */
  526|       |    EnterCriticalSection(global_init_lock);
  527|       |
  528|       |#endif
  529|      2|}
threads.c:xmlGlobalInitMutexUnlock:
  532|      2|xmlGlobalInitMutexUnlock(void) {
  533|      2|#ifdef HAVE_POSIX_THREADS
  534|      2|    if (XML_IS_THREADED() != 0)
  ------------------
  |  |   84|      2|#define XML_IS_THREADED() libxml_is_threaded
  ------------------
  |  Branch (534:9): [True: 2, False: 0]
  ------------------
  535|      2|        pthread_mutex_unlock(&global_init_lock);
  536|       |#elif defined HAVE_WIN32_THREADS
  537|       |    if (global_init_lock != NULL)
  538|       |	LeaveCriticalSection(global_init_lock);
  539|       |#endif
  540|      2|}

libxml_domnode_binary_insertion_sort:
  247|     57|void BINARY_INSERTION_SORT(SORT_TYPE *dst, const size_t size) {
  248|       |  /* don't bother sorting an array of size <= 1 */
  249|     57|  if (size <= 1) {
  ------------------
  |  Branch (249:7): [True: 0, False: 57]
  ------------------
  250|      0|    return;
  251|      0|  }
  252|       |
  253|     57|  BINARY_INSERTION_SORT_START(dst, 1, size);
  ------------------
  |  |  149|     57|#define BINARY_INSERTION_SORT_START    SORT_MAKE_STR(binary_insertion_sort_start)
  |  |  ------------------
  |  |  |  |  146|     57|#define SORT_MAKE_STR(x) SORT_MAKE_STR1(SORT_NAME,x)
  |  |  |  |  ------------------
  |  |  |  |  |  |  145|     57|#define SORT_MAKE_STR1(x, y) SORT_CONCAT(x,y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  144|     57|#define SORT_CONCAT(x, y) x ## _ ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  254|     57|}
libxml_domnode_tim_sort:
  531|     57|void TIM_SORT(SORT_TYPE *dst, const size_t size) {
  532|     57|  size_t minrun;
  533|     57|  TEMP_STORAGE_T _store, *store;
  534|     57|  TIM_SORT_RUN_T run_stack[TIM_SORT_STACK_SIZE];
  535|     57|  size_t stack_curr = 0;
  536|     57|  size_t curr = 0;
  537|       |
  538|       |  /* don't bother sorting an array of size 1 */
  539|     57|  if (size <= 1) {
  ------------------
  |  Branch (539:7): [True: 0, False: 57]
  ------------------
  540|      0|    return;
  541|      0|  }
  542|       |
  543|     57|  if (size < 64) {
  ------------------
  |  Branch (543:7): [True: 57, False: 0]
  ------------------
  544|     57|    BINARY_INSERTION_SORT(dst, size);
  ------------------
  |  |  150|     57|#define BINARY_INSERTION_SORT          SORT_MAKE_STR(binary_insertion_sort)
  |  |  ------------------
  |  |  |  |  146|     57|#define SORT_MAKE_STR(x) SORT_MAKE_STR1(SORT_NAME,x)
  |  |  |  |  ------------------
  |  |  |  |  |  |  145|     57|#define SORT_MAKE_STR1(x, y) SORT_CONCAT(x,y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  144|     57|#define SORT_CONCAT(x, y) x ## _ ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  545|     57|    return;
  546|     57|  }
  547|       |
  548|       |  /* compute the minimum run length */
  549|      0|  minrun = compute_minrun(size);
  550|       |  /* temporary storage for merges */
  551|      0|  store = &_store;
  552|      0|  store->alloc = 0;
  553|      0|  store->storage = NULL;
  554|       |
  555|      0|  if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
  ------------------
  |  Branch (555:7): [True: 0, False: 0]
  ------------------
  556|      0|    return;
  557|      0|  }
  558|       |
  559|      0|  if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
  ------------------
  |  Branch (559:7): [True: 0, False: 0]
  ------------------
  560|      0|    return;
  561|      0|  }
  562|       |
  563|      0|  if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
  ------------------
  |  Branch (563:7): [True: 0, False: 0]
  ------------------
  564|      0|    return;
  565|      0|  }
  566|       |
  567|      0|  while (1) {
  ------------------
  |  Branch (567:10): [Folded - Ignored]
  ------------------
  568|      0|    if (!CHECK_INVARIANT(run_stack, stack_curr)) {
  ------------------
  |  |  153|      0|#define CHECK_INVARIANT                SORT_MAKE_STR(check_invariant)
  |  |  ------------------
  |  |  |  |  146|      0|#define SORT_MAKE_STR(x) SORT_MAKE_STR1(SORT_NAME,x)
  |  |  |  |  ------------------
  |  |  |  |  |  |  145|      0|#define SORT_MAKE_STR1(x, y) SORT_CONCAT(x,y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  144|      0|#define SORT_CONCAT(x, y) x ## _ ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (568:9): [True: 0, False: 0]
  ------------------
  569|      0|      stack_curr = TIM_SORT_COLLAPSE(dst, run_stack, stack_curr, store, size);
  ------------------
  |  |  157|      0|#define TIM_SORT_COLLAPSE              SORT_MAKE_STR(tim_sort_collapse)
  |  |  ------------------
  |  |  |  |  146|      0|#define SORT_MAKE_STR(x) SORT_MAKE_STR1(SORT_NAME,x)
  |  |  |  |  ------------------
  |  |  |  |  |  |  145|      0|#define SORT_MAKE_STR1(x, y) SORT_CONCAT(x,y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  144|      0|#define SORT_CONCAT(x, y) x ## _ ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  570|      0|      continue;
  571|      0|    }
  572|       |
  573|      0|    if (!PUSH_NEXT(dst, size, store, minrun, run_stack, &stack_curr, &curr)) {
  ------------------
  |  Branch (573:9): [True: 0, False: 0]
  ------------------
  574|      0|      return;
  575|      0|    }
  576|      0|  }
  577|      0|}
xpath.c:libxml_domnode_binary_insertion_sort_start:
  217|     57|static void BINARY_INSERTION_SORT_START(SORT_TYPE *dst, const size_t start, const size_t size) {
  218|     57|  size_t i;
  219|       |
  220|    478|  for (i = start; i < size; i++) {
  ------------------
  |  Branch (220:19): [True: 421, False: 57]
  ------------------
  221|    421|    size_t j;
  222|    421|    SORT_TYPE x;
  ------------------
  |  |  546|    421|#define SORT_TYPE xmlNodePtr
  ------------------
  223|    421|    size_t location;
  224|       |
  225|       |    /* If this entry is already correct, just move along */
  226|    421|    if (SORT_CMP(dst[i - 1], dst[i]) <= 0) {
  ------------------
  |  |  572|    421|#define SORT_CMP(x, y)  (wrap_cmp(x, y))
  ------------------
  |  Branch (226:9): [True: 402, False: 19]
  ------------------
  227|    402|      continue;
  228|    402|    }
  229|       |
  230|       |    /* Else we need to find the right place, shift everything over, and squeeze in */
  231|     19|    x = dst[i];
  232|     19|    location = BINARY_INSERTION_FIND(dst, x, i);
  ------------------
  |  |  148|     19|#define BINARY_INSERTION_FIND          SORT_MAKE_STR(binary_insertion_find)
  |  |  ------------------
  |  |  |  |  146|     19|#define SORT_MAKE_STR(x) SORT_MAKE_STR1(SORT_NAME,x)
  |  |  |  |  ------------------
  |  |  |  |  |  |  145|     19|#define SORT_MAKE_STR1(x, y) SORT_CONCAT(x,y)
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  144|     19|#define SORT_CONCAT(x, y) x ## _ ## y
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  233|       |
  234|     73|    for (j = i - 1; j >= location; j--) {
  ------------------
  |  Branch (234:21): [True: 70, False: 3]
  ------------------
  235|     70|      dst[j + 1] = dst[j];
  236|       |
  237|     70|      if (j == 0) { /* check edge case because j is unsigned */
  ------------------
  |  Branch (237:11): [True: 16, False: 54]
  ------------------
  238|     16|        break;
  239|     16|      }
  240|     70|    }
  241|       |
  242|     19|    dst[location] = x;
  243|     19|  }
  244|     57|}
xpath.c:libxml_domnode_binary_insertion_find:
  178|     19|    const size_t size) {
  179|     19|  size_t l, c, r;
  180|     19|  SORT_TYPE cx;
  ------------------
  |  |  546|     19|#define SORT_TYPE xmlNodePtr
  ------------------
  181|     19|  l = 0;
  182|     19|  r = size - 1;
  183|     19|  c = r >> 1;
  184|       |
  185|       |  /* check for out of bounds at the beginning. */
  186|     19|  if (SORT_CMP(x, dst[0]) < 0) {
  ------------------
  |  |  572|     19|#define SORT_CMP(x, y)  (wrap_cmp(x, y))
  ------------------
  |  Branch (186:7): [True: 16, False: 3]
  ------------------
  187|     16|    return 0;
  188|     16|  } else if (SORT_CMP(x, dst[r]) > 0) {
  ------------------
  |  |  572|      3|#define SORT_CMP(x, y)  (wrap_cmp(x, y))
  ------------------
  |  Branch (188:14): [True: 0, False: 3]
  ------------------
  189|      0|    return r;
  190|      0|  }
  191|       |
  192|      3|  cx = dst[c];
  193|       |
  194|      8|  while (1) {
  ------------------
  |  Branch (194:10): [Folded - Ignored]
  ------------------
  195|      8|    const int val = SORT_CMP(x, cx);
  ------------------
  |  |  572|      8|#define SORT_CMP(x, y)  (wrap_cmp(x, y))
  ------------------
  196|       |
  197|      8|    if (val < 0) {
  ------------------
  |  Branch (197:9): [True: 5, False: 3]
  ------------------
  198|      5|      if (c - l <= 1) {
  ------------------
  |  Branch (198:11): [True: 2, False: 3]
  ------------------
  199|      2|        return c;
  200|      2|      }
  201|       |
  202|      3|      r = c;
  203|      3|    } else { /* allow = for stability. The binary search favors the right. */
  204|      3|      if (r - c <= 1) {
  ------------------
  |  Branch (204:11): [True: 1, False: 2]
  ------------------
  205|      1|        return c + 1;
  206|      1|      }
  207|       |
  208|      2|      l = c;
  209|      2|    }
  210|       |
  211|      5|    c = l + ((r - l) >> 1);
  212|      5|    cx = dst[c];
  213|      5|  }
  214|      3|}

xmlSplitQName2:
  262|    374|xmlSplitQName2(const xmlChar *name, xmlChar **prefix) {
  263|    374|    int len = 0;
  264|    374|    xmlChar *ret = NULL;
  265|       |
  266|    374|    if (prefix == NULL) return(NULL);
  ------------------
  |  Branch (266:9): [True: 0, False: 374]
  ------------------
  267|    374|    *prefix = NULL;
  268|    374|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (268:9): [True: 0, False: 374]
  ------------------
  269|       |
  270|       |#ifndef XML_XML_NAMESPACE
  271|       |    /* xml: prefix is not really a namespace */
  272|       |    if ((name[0] == 'x') && (name[1] == 'm') &&
  273|       |        (name[2] == 'l') && (name[3] == ':'))
  274|       |	return(NULL);
  275|       |#endif
  276|       |
  277|       |    /* nasty but valid */
  278|    374|    if (name[0] == ':')
  ------------------
  |  Branch (278:9): [True: 0, False: 374]
  ------------------
  279|      0|	return(NULL);
  280|       |
  281|       |    /*
  282|       |     * we are not trying to validate but just to cut, and yes it will
  283|       |     * work even if this is as set of UTF-8 encoded chars
  284|       |     */
  285|  1.87k|    while ((name[len] != 0) && (name[len] != ':'))
  ------------------
  |  Branch (285:12): [True: 1.49k, False: 374]
  |  Branch (285:32): [True: 1.49k, False: 0]
  ------------------
  286|  1.49k|	len++;
  287|       |
  288|    374|    if (name[len] == 0)
  ------------------
  |  Branch (288:9): [True: 374, False: 0]
  ------------------
  289|    374|	return(NULL);
  290|       |
  291|      0|    *prefix = xmlStrndup(name, len);
  292|      0|    if (*prefix == NULL) {
  ------------------
  |  Branch (292:9): [True: 0, False: 0]
  ------------------
  293|      0|	xmlTreeErrMemory("QName split");
  294|      0|	return(NULL);
  295|      0|    }
  296|      0|    ret = xmlStrdup(&name[len + 1]);
  297|      0|    if (ret == NULL) {
  ------------------
  |  Branch (297:9): [True: 0, False: 0]
  ------------------
  298|      0|	xmlTreeErrMemory("QName split");
  299|      0|	if (*prefix != NULL) {
  ------------------
  |  Branch (299:6): [True: 0, False: 0]
  ------------------
  300|      0|	    xmlFree(*prefix);
  301|      0|	    *prefix = NULL;
  302|      0|	}
  303|      0|	return(NULL);
  304|      0|    }
  305|       |
  306|      0|    return(ret);
  307|      0|}
xmlSplitQName3:
  322|    155|xmlSplitQName3(const xmlChar *name, int *len) {
  323|    155|    int l = 0;
  324|       |
  325|    155|    if (name == NULL) return(NULL);
  ------------------
  |  Branch (325:9): [True: 0, False: 155]
  ------------------
  326|    155|    if (len == NULL) return(NULL);
  ------------------
  |  Branch (326:9): [True: 0, False: 155]
  ------------------
  327|       |
  328|       |    /* nasty but valid */
  329|    155|    if (name[0] == ':')
  ------------------
  |  Branch (329:9): [True: 0, False: 155]
  ------------------
  330|      0|	return(NULL);
  331|       |
  332|       |    /*
  333|       |     * we are not trying to validate but just to cut, and yes it will
  334|       |     * work even if this is as set of UTF-8 encoded chars
  335|       |     */
  336|    775|    while ((name[l] != 0) && (name[l] != ':'))
  ------------------
  |  Branch (336:12): [True: 620, False: 155]
  |  Branch (336:30): [True: 620, False: 0]
  ------------------
  337|    620|	l++;
  338|       |
  339|    155|    if (name[l] == 0)
  ------------------
  |  Branch (339:9): [True: 155, False: 0]
  ------------------
  340|    155|	return(NULL);
  341|       |
  342|      0|    *len = l;
  343|       |
  344|      0|    return(&name[l+1]);
  345|    155|}
xmlNewNs:
  726|     18|xmlNewNs(xmlNodePtr node, const xmlChar *href, const xmlChar *prefix) {
  727|     18|    xmlNsPtr cur;
  728|       |
  729|     18|    if ((node != NULL) && (node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (729:9): [True: 0, False: 18]
  |  Branch (729:27): [True: 0, False: 0]
  ------------------
  730|      0|	return(NULL);
  731|       |
  732|     18|    if ((prefix != NULL) && (xmlStrEqual(prefix, BAD_CAST "xml"))) {
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (732:9): [True: 12, False: 6]
  |  Branch (732:29): [True: 0, False: 12]
  ------------------
  733|       |        /* xml namespace is predefined, no need to add it */
  734|      0|        if (xmlStrEqual(href, XML_XML_NAMESPACE))
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (734:13): [True: 0, False: 0]
  ------------------
  735|      0|            return(NULL);
  736|       |
  737|       |        /*
  738|       |         * Problem, this is an attempt to bind xml prefix to a wrong
  739|       |         * namespace, which breaks
  740|       |         * Namespace constraint: Reserved Prefixes and Namespace Names
  741|       |         * from XML namespace. But documents authors may not care in
  742|       |         * their context so let's proceed.
  743|       |         */
  744|      0|    }
  745|       |
  746|       |    /*
  747|       |     * Allocate a new Namespace and fill the fields.
  748|       |     */
  749|     18|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
  750|     18|    if (cur == NULL) {
  ------------------
  |  Branch (750:9): [True: 0, False: 18]
  ------------------
  751|      0|	xmlTreeErrMemory("building namespace");
  752|      0|	return(NULL);
  753|      0|    }
  754|     18|    memset(cur, 0, sizeof(xmlNs));
  755|     18|    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|     18|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
  756|       |
  757|     18|    if (href != NULL)
  ------------------
  |  Branch (757:9): [True: 18, False: 0]
  ------------------
  758|     18|	cur->href = xmlStrdup(href);
  759|     18|    if (prefix != NULL)
  ------------------
  |  Branch (759:9): [True: 12, False: 6]
  ------------------
  760|     12|	cur->prefix = xmlStrdup(prefix);
  761|       |
  762|       |    /*
  763|       |     * Add it at the end to preserve parsing order ...
  764|       |     * and checks for existing use of the prefix
  765|       |     */
  766|     18|    if (node != NULL) {
  ------------------
  |  Branch (766:9): [True: 0, False: 18]
  ------------------
  767|      0|	if (node->nsDef == NULL) {
  ------------------
  |  Branch (767:6): [True: 0, False: 0]
  ------------------
  768|      0|	    node->nsDef = cur;
  769|      0|	} else {
  770|      0|	    xmlNsPtr prev = node->nsDef;
  771|       |
  772|      0|	    if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (772:11): [True: 0, False: 0]
  |  Branch (772:37): [True: 0, False: 0]
  ------------------
  773|      0|		(xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (773:3): [True: 0, False: 0]
  ------------------
  774|      0|		xmlFreeNs(cur);
  775|      0|		return(NULL);
  776|      0|	    }
  777|      0|	    while (prev->next != NULL) {
  ------------------
  |  Branch (777:13): [True: 0, False: 0]
  ------------------
  778|      0|	        prev = prev->next;
  779|      0|		if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||
  ------------------
  |  Branch (779:8): [True: 0, False: 0]
  |  Branch (779:34): [True: 0, False: 0]
  ------------------
  780|      0|		    (xmlStrEqual(prev->prefix, cur->prefix))) {
  ------------------
  |  Branch (780:7): [True: 0, False: 0]
  ------------------
  781|      0|		    xmlFreeNs(cur);
  782|      0|		    return(NULL);
  783|      0|		}
  784|      0|	    }
  785|      0|	    prev->next = cur;
  786|      0|	}
  787|      0|    }
  788|     18|    return(cur);
  789|     18|}
xmlFreeNs:
  815|     25|xmlFreeNs(xmlNsPtr cur) {
  816|     25|    if (cur == NULL) {
  ------------------
  |  Branch (816:9): [True: 0, False: 25]
  ------------------
  817|      0|	return;
  818|      0|    }
  819|     25|    if (cur->href != NULL) xmlFree((char *) cur->href);
  ------------------
  |  Branch (819:9): [True: 25, False: 0]
  ------------------
  820|     25|    if (cur->prefix != NULL) xmlFree((char *) cur->prefix);
  ------------------
  |  Branch (820:9): [True: 19, False: 6]
  ------------------
  821|     25|    xmlFree(cur);
  822|     25|}
xmlFreeNsList:
  831|     25|xmlFreeNsList(xmlNsPtr cur) {
  832|     25|    xmlNsPtr next;
  833|     25|    if (cur == NULL) {
  ------------------
  |  Branch (833:9): [True: 0, False: 25]
  ------------------
  834|      0|	return;
  835|      0|    }
  836|     50|    while (cur != NULL) {
  ------------------
  |  Branch (836:12): [True: 25, False: 25]
  ------------------
  837|     25|        next = cur->next;
  838|     25|        xmlFreeNs(cur);
  839|     25|	cur = next;
  840|     25|    }
  841|     25|}
xmlGetIntSubset:
  899|     46|xmlGetIntSubset(const xmlDoc *doc) {
  900|     46|    xmlNodePtr cur;
  901|       |
  902|     46|    if (doc == NULL)
  ------------------
  |  Branch (902:9): [True: 0, False: 46]
  ------------------
  903|      0|	return(NULL);
  904|     46|    cur = doc->children;
  905|     46|    while (cur != NULL) {
  ------------------
  |  Branch (905:12): [True: 0, False: 46]
  ------------------
  906|      0|	if (cur->type == XML_DTD_NODE)
  ------------------
  |  Branch (906:6): [True: 0, False: 0]
  ------------------
  907|      0|	    return((xmlDtdPtr) cur);
  908|      0|	cur = cur->next;
  909|      0|    }
  910|     46|    return((xmlDtdPtr) doc->intSubset);
  911|     46|}
xmlCreateIntSubset:
  925|     23|                   const xmlChar *ExternalID, const xmlChar *SystemID) {
  926|     23|    xmlDtdPtr cur;
  927|       |
  928|     23|    if ((doc != NULL) && (xmlGetIntSubset(doc) != NULL)) {
  ------------------
  |  Branch (928:9): [True: 23, False: 0]
  |  Branch (928:26): [True: 0, False: 23]
  ------------------
  929|      0|	return(NULL);
  930|      0|    }
  931|       |
  932|       |    /*
  933|       |     * Allocate a new DTD and fill the fields.
  934|       |     */
  935|     23|    cur = (xmlDtdPtr) xmlMalloc(sizeof(xmlDtd));
  936|     23|    if (cur == NULL) {
  ------------------
  |  Branch (936:9): [True: 0, False: 23]
  ------------------
  937|      0|	xmlTreeErrMemory("building internal subset");
  938|      0|	return(NULL);
  939|      0|    }
  940|     23|    memset(cur, 0, sizeof(xmlDtd));
  941|     23|    cur->type = XML_DTD_NODE;
  942|       |
  943|     23|    if (name != NULL) {
  ------------------
  |  Branch (943:9): [True: 23, False: 0]
  ------------------
  944|     23|	cur->name = xmlStrdup(name);
  945|     23|	if (cur->name == NULL) {
  ------------------
  |  Branch (945:6): [True: 0, False: 23]
  ------------------
  946|      0|	    xmlTreeErrMemory("building internal subset");
  947|      0|	    xmlFree(cur);
  948|      0|	    return(NULL);
  949|      0|	}
  950|     23|    }
  951|     23|    if (ExternalID != NULL) {
  ------------------
  |  Branch (951:9): [True: 0, False: 23]
  ------------------
  952|      0|	cur->ExternalID = xmlStrdup(ExternalID);
  953|      0|	if (cur->ExternalID  == NULL) {
  ------------------
  |  Branch (953:6): [True: 0, False: 0]
  ------------------
  954|      0|	    xmlTreeErrMemory("building internal subset");
  955|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (955:10): [True: 0, False: 0]
  ------------------
  956|      0|	        xmlFree((char *)cur->name);
  957|      0|	    xmlFree(cur);
  958|      0|	    return(NULL);
  959|      0|	}
  960|      0|    }
  961|     23|    if (SystemID != NULL) {
  ------------------
  |  Branch (961:9): [True: 0, False: 23]
  ------------------
  962|      0|	cur->SystemID = xmlStrdup(SystemID);
  963|      0|	if (cur->SystemID == NULL) {
  ------------------
  |  Branch (963:6): [True: 0, False: 0]
  ------------------
  964|      0|	    xmlTreeErrMemory("building internal subset");
  965|      0|	    if (cur->name != NULL)
  ------------------
  |  Branch (965:10): [True: 0, False: 0]
  ------------------
  966|      0|	        xmlFree((char *)cur->name);
  967|      0|	    if (cur->ExternalID != NULL)
  ------------------
  |  Branch (967:10): [True: 0, False: 0]
  ------------------
  968|      0|	        xmlFree((char *)cur->ExternalID);
  969|      0|	    xmlFree(cur);
  970|      0|	    return(NULL);
  971|      0|	}
  972|      0|    }
  973|     23|    if (doc != NULL) {
  ------------------
  |  Branch (973:9): [True: 23, False: 0]
  ------------------
  974|     23|	doc->intSubset = cur;
  975|     23|	cur->parent = doc;
  976|     23|	cur->doc = doc;
  977|     23|	if (doc->children == NULL) {
  ------------------
  |  Branch (977:6): [True: 23, False: 0]
  ------------------
  978|     23|	    doc->children = (xmlNodePtr) cur;
  979|     23|	    doc->last = (xmlNodePtr) cur;
  980|     23|	} else {
  981|      0|	    if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (981:10): [True: 0, False: 0]
  ------------------
  982|      0|		xmlNodePtr prev;
  983|       |
  984|      0|		prev = doc->children;
  985|      0|		prev->prev = (xmlNodePtr) cur;
  986|      0|		cur->next = prev;
  987|      0|		doc->children = (xmlNodePtr) cur;
  988|      0|	    } else {
  989|      0|		xmlNodePtr next;
  990|       |
  991|      0|		next = doc->children;
  992|      0|		while ((next != NULL) && (next->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (992:10): [True: 0, False: 0]
  |  Branch (992:28): [True: 0, False: 0]
  ------------------
  993|      0|		    next = next->next;
  994|      0|		if (next == NULL) {
  ------------------
  |  Branch (994:7): [True: 0, False: 0]
  ------------------
  995|      0|		    cur->prev = doc->last;
  996|      0|		    cur->prev->next = (xmlNodePtr) cur;
  997|      0|		    cur->next = NULL;
  998|      0|		    doc->last = (xmlNodePtr) cur;
  999|      0|		} else {
 1000|      0|		    cur->next = next;
 1001|      0|		    cur->prev = next->prev;
 1002|      0|		    if (cur->prev == NULL)
  ------------------
  |  Branch (1002:11): [True: 0, False: 0]
  ------------------
 1003|      0|			doc->children = (xmlNodePtr) cur;
 1004|      0|		    else
 1005|      0|			cur->prev->next = (xmlNodePtr) cur;
 1006|      0|		    next->prev = (xmlNodePtr) cur;
 1007|      0|		}
 1008|      0|	    }
 1009|      0|	}
 1010|     23|    }
 1011|       |
 1012|     23|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1012:9): [True: 0, False: 23]
  |  Branch (1012:37): [True: 0, False: 0]
  ------------------
 1013|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1014|     23|    return(cur);
 1015|     23|}
xmlFreeDtd:
 1072|     23|xmlFreeDtd(xmlDtdPtr cur) {
 1073|     23|    xmlDictPtr dict = NULL;
 1074|       |
 1075|     23|    if (cur == NULL) {
  ------------------
  |  Branch (1075:9): [True: 0, False: 23]
  ------------------
 1076|      0|	return;
 1077|      0|    }
 1078|     23|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (1078:9): [True: 23, False: 0]
  ------------------
 1079|       |
 1080|     23|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1080:9): [True: 0, False: 23]
  |  Branch (1080:37): [True: 0, False: 0]
  ------------------
 1081|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1082|       |
 1083|     23|    if (cur->children != NULL) {
  ------------------
  |  Branch (1083:9): [True: 22, False: 1]
  ------------------
 1084|     22|	xmlNodePtr next, c = cur->children;
 1085|       |
 1086|       |	/*
 1087|       |	 * Cleanup all nodes which are not part of the specific lists
 1088|       |	 * of notations, elements, attributes and entities.
 1089|       |	 */
 1090|    242|        while (c != NULL) {
  ------------------
  |  Branch (1090:16): [True: 220, False: 22]
  ------------------
 1091|    220|	    next = c->next;
 1092|    220|	    if ((c->type != XML_NOTATION_NODE) &&
  ------------------
  |  Branch (1092:10): [True: 220, False: 0]
  ------------------
 1093|    220|	        (c->type != XML_ELEMENT_DECL) &&
  ------------------
  |  Branch (1093:10): [True: 88, False: 132]
  ------------------
 1094|    220|		(c->type != XML_ATTRIBUTE_DECL) &&
  ------------------
  |  Branch (1094:3): [True: 0, False: 88]
  ------------------
 1095|    220|		(c->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (1095:3): [True: 0, False: 0]
  ------------------
 1096|      0|		xmlUnlinkNode(c);
 1097|      0|		xmlFreeNode(c);
 1098|      0|	    }
 1099|    220|	    c = next;
 1100|    220|	}
 1101|     22|    }
 1102|     23|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|     23|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 23, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 23]
  |  |  ------------------
  |  | 1026|     23|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 23, False: 0]
  |  |  ------------------
  |  | 1027|     23|	    xmlFree((char *)(str));
  ------------------
 1103|     23|    DICT_FREE(cur->SystemID)
  ------------------
  |  | 1025|     23|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 23]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|     23|	    xmlFree((char *)(str));
  ------------------
 1104|     23|    DICT_FREE(cur->ExternalID)
  ------------------
  |  | 1025|     23|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 23]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|     23|	    xmlFree((char *)(str));
  ------------------
 1105|       |    /* TODO !!! */
 1106|     23|    if (cur->notations != NULL)
  ------------------
  |  Branch (1106:9): [True: 0, False: 23]
  ------------------
 1107|      0|        xmlFreeNotationTable((xmlNotationTablePtr) cur->notations);
 1108|       |
 1109|     23|    if (cur->elements != NULL)
  ------------------
  |  Branch (1109:9): [True: 22, False: 1]
  ------------------
 1110|     22|        xmlFreeElementTable((xmlElementTablePtr) cur->elements);
 1111|     23|    if (cur->attributes != NULL)
  ------------------
  |  Branch (1111:9): [True: 22, False: 1]
  ------------------
 1112|     22|        xmlFreeAttributeTable((xmlAttributeTablePtr) cur->attributes);
 1113|     23|    if (cur->entities != NULL)
  ------------------
  |  Branch (1113:9): [True: 0, False: 23]
  ------------------
 1114|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->entities);
 1115|     23|    if (cur->pentities != NULL)
  ------------------
  |  Branch (1115:9): [True: 0, False: 23]
  ------------------
 1116|      0|        xmlFreeEntitiesTable((xmlEntitiesTablePtr) cur->pentities);
 1117|       |
 1118|     23|    xmlFree(cur);
 1119|     23|}
xmlNewDoc:
 1130|    486|xmlNewDoc(const xmlChar *version) {
 1131|    486|    xmlDocPtr cur;
 1132|       |
 1133|    486|    if (version == NULL)
  ------------------
  |  Branch (1133:9): [True: 2, False: 484]
  ------------------
 1134|      2|	version = (const xmlChar *) "1.0";
 1135|       |
 1136|       |    /*
 1137|       |     * Allocate a new document and fill the fields.
 1138|       |     */
 1139|    486|    cur = (xmlDocPtr) xmlMalloc(sizeof(xmlDoc));
 1140|    486|    if (cur == NULL) {
  ------------------
  |  Branch (1140:9): [True: 0, False: 486]
  ------------------
 1141|      0|	xmlTreeErrMemory("building doc");
 1142|      0|	return(NULL);
 1143|      0|    }
 1144|    486|    memset(cur, 0, sizeof(xmlDoc));
 1145|    486|    cur->type = XML_DOCUMENT_NODE;
 1146|       |
 1147|    486|    cur->version = xmlStrdup(version);
 1148|    486|    if (cur->version == NULL) {
  ------------------
  |  Branch (1148:9): [True: 0, False: 486]
  ------------------
 1149|      0|	xmlTreeErrMemory("building doc");
 1150|      0|	xmlFree(cur);
 1151|      0|	return(NULL);
 1152|      0|    }
 1153|    486|    cur->standalone = -1;
 1154|    486|    cur->compression = -1; /* not initialized */
 1155|    486|    cur->doc = cur;
 1156|    486|    cur->parseFlags = 0;
 1157|    486|    cur->properties = XML_DOC_USERBUILT;
 1158|       |    /*
 1159|       |     * The in memory encoding is always UTF8
 1160|       |     * This field will never change and would
 1161|       |     * be obsolete if not for binary compatibility.
 1162|       |     */
 1163|    486|    cur->charset = XML_CHAR_ENCODING_UTF8;
 1164|       |
 1165|    486|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1165:9): [True: 0, False: 486]
  |  Branch (1165:37): [True: 0, False: 0]
  ------------------
 1166|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1167|    486|    return(cur);
 1168|    486|}
xmlFreeDoc:
 1177|    486|xmlFreeDoc(xmlDocPtr cur) {
 1178|    486|    xmlDtdPtr extSubset, intSubset;
 1179|    486|    xmlDictPtr dict = NULL;
 1180|       |
 1181|    486|    if (cur == NULL) {
  ------------------
  |  Branch (1181:9): [True: 0, False: 486]
  ------------------
 1182|      0|	return;
 1183|      0|    }
 1184|       |
 1185|    486|    if (cur != NULL) dict = cur->dict;
  ------------------
  |  Branch (1185:9): [True: 486, False: 0]
  ------------------
 1186|       |
 1187|    486|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (1187:9): [True: 0, False: 486]
  |  Branch (1187:37): [True: 0, False: 0]
  ------------------
 1188|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 1189|       |
 1190|       |    /*
 1191|       |     * Do this before freeing the children list to avoid ID lookups
 1192|       |     */
 1193|    486|    if (cur->ids != NULL) xmlFreeIDTable((xmlIDTablePtr) cur->ids);
  ------------------
  |  Branch (1193:9): [True: 22, False: 464]
  ------------------
 1194|    486|    cur->ids = NULL;
 1195|    486|    if (cur->refs != NULL) xmlFreeRefTable((xmlRefTablePtr) cur->refs);
  ------------------
  |  Branch (1195:9): [True: 0, False: 486]
  ------------------
 1196|    486|    cur->refs = NULL;
 1197|    486|    extSubset = cur->extSubset;
 1198|    486|    intSubset = cur->intSubset;
 1199|    486|    if (intSubset == extSubset)
  ------------------
  |  Branch (1199:9): [True: 463, False: 23]
  ------------------
 1200|    463|	extSubset = NULL;
 1201|    486|    if (extSubset != NULL) {
  ------------------
  |  Branch (1201:9): [True: 0, False: 486]
  ------------------
 1202|      0|	xmlUnlinkNode((xmlNodePtr) cur->extSubset);
 1203|      0|	cur->extSubset = NULL;
 1204|      0|	xmlFreeDtd(extSubset);
 1205|      0|    }
 1206|    486|    if (intSubset != NULL) {
  ------------------
  |  Branch (1206:9): [True: 23, False: 463]
  ------------------
 1207|     23|	xmlUnlinkNode((xmlNodePtr) cur->intSubset);
 1208|     23|	cur->intSubset = NULL;
 1209|     23|	xmlFreeDtd(intSubset);
 1210|     23|    }
 1211|       |
 1212|    486|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (1212:9): [True: 480, False: 6]
  ------------------
 1213|    486|    if (cur->oldNs != NULL) xmlFreeNsList(cur->oldNs);
  ------------------
  |  Branch (1213:9): [True: 7, False: 479]
  ------------------
 1214|       |
 1215|    486|    DICT_FREE(cur->version)
  ------------------
  |  | 1025|    486|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 486, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 486]
  |  |  ------------------
  |  | 1026|    486|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 486, False: 0]
  |  |  ------------------
  |  | 1027|    486|	    xmlFree((char *)(str));
  ------------------
 1216|    486|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    486|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 486]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    486|	    xmlFree((char *)(str));
  ------------------
 1217|    486|    DICT_FREE(cur->encoding)
  ------------------
  |  | 1025|    486|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 486]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    486|	    xmlFree((char *)(str));
  ------------------
 1218|    486|    DICT_FREE(cur->URL)
  ------------------
  |  | 1025|    486|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 0, False: 486]
  |  |  |  Branch (1025:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 1026|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 1027|    486|	    xmlFree((char *)(str));
  ------------------
 1219|    486|    xmlFree(cur);
 1220|    486|    if (dict) xmlDictFree(dict);
  ------------------
  |  Branch (1220:9): [True: 486, False: 0]
  ------------------
 1221|    486|}
xmlStringLenGetNodeList:
 1234|    109|xmlStringLenGetNodeList(const xmlDoc *doc, const xmlChar *value, int len) {
 1235|    109|    xmlNodePtr ret = NULL, last = NULL;
 1236|    109|    xmlNodePtr node;
 1237|    109|    xmlChar *val;
 1238|    109|    const xmlChar *cur, *end;
 1239|    109|    const xmlChar *q;
 1240|    109|    xmlEntityPtr ent;
 1241|    109|    xmlBufPtr buf;
 1242|       |
 1243|    109|    if (value == NULL) return(NULL);
  ------------------
  |  Branch (1243:9): [True: 0, False: 109]
  ------------------
 1244|    109|    cur = value;
 1245|    109|    end = cur + len;
 1246|       |
 1247|    109|    buf = xmlBufCreateSize(0);
 1248|    109|    if (buf == NULL) return(NULL);
  ------------------
  |  Branch (1248:9): [True: 0, False: 109]
  ------------------
 1249|    109|    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 1250|       |
 1251|    109|    q = cur;
 1252|  1.85k|    while ((cur < end) && (*cur != 0)) {
  ------------------
  |  Branch (1252:12): [True: 1.74k, False: 109]
  |  Branch (1252:27): [True: 1.74k, False: 0]
  ------------------
 1253|  1.74k|	if (cur[0] == '&') {
  ------------------
  |  Branch (1253:6): [True: 102, False: 1.63k]
  ------------------
 1254|    102|	    int charval = 0;
 1255|    102|	    xmlChar tmp;
 1256|       |
 1257|       |	    /*
 1258|       |	     * Save the current text.
 1259|       |	     */
 1260|    102|            if (cur != q) {
  ------------------
  |  Branch (1260:17): [True: 0, False: 102]
  ------------------
 1261|      0|		if (xmlBufAdd(buf, q, cur - q))
  ------------------
  |  Branch (1261:7): [True: 0, False: 0]
  ------------------
 1262|      0|		    goto out;
 1263|      0|	    }
 1264|    102|	    q = cur;
 1265|    102|	    if ((cur + 2 < end) && (cur[1] == '#') && (cur[2] == 'x')) {
  ------------------
  |  Branch (1265:10): [True: 102, False: 0]
  |  Branch (1265:29): [True: 102, False: 0]
  |  Branch (1265:48): [True: 0, False: 102]
  ------------------
 1266|      0|		cur += 3;
 1267|      0|		if (cur < end)
  ------------------
  |  Branch (1267:7): [True: 0, False: 0]
  ------------------
 1268|      0|		    tmp = *cur;
 1269|      0|		else
 1270|      0|		    tmp = 0;
 1271|      0|		while (tmp != ';') { /* Non input consuming loop */
  ------------------
  |  Branch (1271:10): [True: 0, False: 0]
  ------------------
 1272|       |                    /*
 1273|       |                     * If you find an integer overflow here when fuzzing,
 1274|       |                     * the bug is probably elsewhere. This function should
 1275|       |                     * only receive entities that were already validated by
 1276|       |                     * the parser, typically by xmlParseAttValueComplex
 1277|       |                     * calling xmlStringDecodeEntities.
 1278|       |                     *
 1279|       |                     * So it's better *not* to check for overflow to
 1280|       |                     * potentially discover new bugs.
 1281|       |                     */
 1282|      0|		    if ((tmp >= '0') && (tmp <= '9'))
  ------------------
  |  Branch (1282:11): [True: 0, False: 0]
  |  Branch (1282:27): [True: 0, False: 0]
  ------------------
 1283|      0|			charval = charval * 16 + (tmp - '0');
 1284|      0|		    else if ((tmp >= 'a') && (tmp <= 'f'))
  ------------------
  |  Branch (1284:16): [True: 0, False: 0]
  |  Branch (1284:32): [True: 0, False: 0]
  ------------------
 1285|      0|			charval = charval * 16 + (tmp - 'a') + 10;
 1286|      0|		    else if ((tmp >= 'A') && (tmp <= 'F'))
  ------------------
  |  Branch (1286:16): [True: 0, False: 0]
  |  Branch (1286:32): [True: 0, False: 0]
  ------------------
 1287|      0|			charval = charval * 16 + (tmp - 'A') + 10;
 1288|      0|		    else {
 1289|      0|			xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,
 1290|      0|			           NULL);
 1291|      0|			charval = 0;
 1292|      0|			break;
 1293|      0|		    }
 1294|      0|		    cur++;
 1295|      0|		    if (cur < end)
  ------------------
  |  Branch (1295:11): [True: 0, False: 0]
  ------------------
 1296|      0|			tmp = *cur;
 1297|      0|		    else
 1298|      0|			tmp = 0;
 1299|      0|		}
 1300|      0|		if (tmp == ';')
  ------------------
  |  Branch (1300:7): [True: 0, False: 0]
  ------------------
 1301|      0|		    cur++;
 1302|      0|		q = cur;
 1303|    102|	    } else if ((cur + 1 < end) && (cur[1] == '#')) {
  ------------------
  |  Branch (1303:17): [True: 102, False: 0]
  |  Branch (1303:36): [True: 102, False: 0]
  ------------------
 1304|    102|		cur += 2;
 1305|    102|		if (cur < end)
  ------------------
  |  Branch (1305:7): [True: 102, False: 0]
  ------------------
 1306|    102|		    tmp = *cur;
 1307|      0|		else
 1308|      0|		    tmp = 0;
 1309|    306|		while (tmp != ';') { /* Non input consuming loops */
  ------------------
  |  Branch (1309:10): [True: 204, False: 102]
  ------------------
 1310|       |                    /* Don't check for integer overflow, see above. */
 1311|    204|		    if ((tmp >= '0') && (tmp <= '9'))
  ------------------
  |  Branch (1311:11): [True: 204, False: 0]
  |  Branch (1311:27): [True: 204, False: 0]
  ------------------
 1312|    204|			charval = charval * 10 + (tmp - '0');
 1313|      0|		    else {
 1314|      0|			xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,
 1315|      0|			           NULL);
 1316|      0|			charval = 0;
 1317|      0|			break;
 1318|      0|		    }
 1319|    204|		    cur++;
 1320|    204|		    if (cur < end)
  ------------------
  |  Branch (1320:11): [True: 204, False: 0]
  ------------------
 1321|    204|			tmp = *cur;
 1322|      0|		    else
 1323|      0|			tmp = 0;
 1324|    204|		}
 1325|    102|		if (tmp == ';')
  ------------------
  |  Branch (1325:7): [True: 102, False: 0]
  ------------------
 1326|    102|		    cur++;
 1327|    102|		q = cur;
 1328|    102|	    } else {
 1329|       |		/*
 1330|       |		 * Read the entity string
 1331|       |		 */
 1332|      0|		cur++;
 1333|      0|		q = cur;
 1334|      0|		while ((cur < end) && (*cur != 0) && (*cur != ';')) cur++;
  ------------------
  |  Branch (1334:10): [True: 0, False: 0]
  |  Branch (1334:25): [True: 0, False: 0]
  |  Branch (1334:40): [True: 0, False: 0]
  ------------------
 1335|      0|		if ((cur >= end) || (*cur == 0)) {
  ------------------
  |  Branch (1335:7): [True: 0, False: 0]
  |  Branch (1335:23): [True: 0, False: 0]
  ------------------
 1336|      0|		    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY, (xmlNodePtr) doc,
 1337|      0|		               (const char *) q);
 1338|      0|		    goto out;
 1339|      0|		}
 1340|      0|		if (cur != q) {
  ------------------
  |  Branch (1340:7): [True: 0, False: 0]
  ------------------
 1341|       |		    /*
 1342|       |		     * Predefined entities don't generate nodes
 1343|       |		     */
 1344|      0|		    val = xmlStrndup(q, cur - q);
 1345|      0|		    ent = xmlGetDocEntity(doc, val);
 1346|      0|		    if ((ent != NULL) &&
  ------------------
  |  Branch (1346:11): [True: 0, False: 0]
  ------------------
 1347|      0|			(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
  ------------------
  |  Branch (1347:4): [True: 0, False: 0]
  ------------------
 1348|       |
 1349|      0|			if (xmlBufCat(buf, ent->content))
  ------------------
  |  Branch (1349:8): [True: 0, False: 0]
  ------------------
 1350|      0|			    goto out;
 1351|       |
 1352|      0|		    } else {
 1353|       |			/*
 1354|       |			 * Flush buffer so far
 1355|       |			 */
 1356|      0|			if (!xmlBufIsEmpty(buf)) {
  ------------------
  |  Branch (1356:8): [True: 0, False: 0]
  ------------------
 1357|      0|			    node = xmlNewDocText(doc, NULL);
 1358|      0|			    if (node == NULL) {
  ------------------
  |  Branch (1358:12): [True: 0, False: 0]
  ------------------
 1359|      0|				if (val != NULL) xmlFree(val);
  ------------------
  |  Branch (1359:9): [True: 0, False: 0]
  ------------------
 1360|      0|				goto out;
 1361|      0|			    }
 1362|      0|			    node->content = xmlBufDetach(buf);
 1363|       |
 1364|      0|			    if (last == NULL) {
  ------------------
  |  Branch (1364:12): [True: 0, False: 0]
  ------------------
 1365|      0|				last = ret = node;
 1366|      0|			    } else {
 1367|      0|				last = xmlAddNextSibling(last, node);
 1368|      0|			    }
 1369|      0|			}
 1370|       |
 1371|       |			/*
 1372|       |			 * Create a new REFERENCE_REF node
 1373|       |			 */
 1374|      0|			node = xmlNewReference(doc, val);
 1375|      0|			if (node == NULL) {
  ------------------
  |  Branch (1375:8): [True: 0, False: 0]
  ------------------
 1376|      0|			    if (val != NULL) xmlFree(val);
  ------------------
  |  Branch (1376:12): [True: 0, False: 0]
  ------------------
 1377|      0|			    goto out;
 1378|      0|			}
 1379|      0|			else if ((ent != NULL) &&
  ------------------
  |  Branch (1379:13): [True: 0, False: 0]
  ------------------
 1380|      0|                                 ((ent->flags & XML_ENT_PARSED) == 0) &&
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
  |  Branch (1380:34): [True: 0, False: 0]
  ------------------
 1381|      0|                                 ((ent->flags & XML_ENT_EXPANDING) == 0)) {
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
  |  Branch (1381:34): [True: 0, False: 0]
  ------------------
 1382|      0|			    xmlNodePtr temp;
 1383|       |
 1384|       |                            /*
 1385|       |                             * The entity should have been checked already,
 1386|       |                             * but set the flag anyway to avoid recursion.
 1387|       |                             */
 1388|      0|			    ent->flags |= XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 1389|      0|			    ent->children = xmlStringGetNodeList(doc,
 1390|      0|				    (const xmlChar*)node->content);
 1391|      0|			    ent->owner = 1;
 1392|      0|			    ent->flags &= ~XML_ENT_EXPANDING;
  ------------------
  |  |   16|      0|#define XML_ENT_EXPANDING   (1<<2)
  ------------------
 1393|      0|                            ent->flags |= XML_ENT_PARSED;
  ------------------
  |  |   14|      0|#define XML_ENT_PARSED      (1<<0)
  ------------------
 1394|      0|			    temp = ent->children;
 1395|      0|			    while (temp) {
  ------------------
  |  Branch (1395:15): [True: 0, False: 0]
  ------------------
 1396|      0|				temp->parent = (xmlNodePtr)ent;
 1397|      0|				ent->last = temp;
 1398|      0|				temp = temp->next;
 1399|      0|			    }
 1400|      0|			}
 1401|      0|			if (last == NULL) {
  ------------------
  |  Branch (1401:8): [True: 0, False: 0]
  ------------------
 1402|      0|			    last = ret = node;
 1403|      0|			} else {
 1404|      0|			    last = xmlAddNextSibling(last, node);
 1405|      0|			}
 1406|      0|		    }
 1407|      0|		    xmlFree(val);
 1408|      0|		}
 1409|      0|		cur++;
 1410|      0|		q = cur;
 1411|      0|	    }
 1412|    102|	    if (charval != 0) {
  ------------------
  |  Branch (1412:10): [True: 102, False: 0]
  ------------------
 1413|    102|		xmlChar buffer[10];
 1414|    102|		int l;
 1415|       |
 1416|    102|		l = xmlCopyCharMultiByte(buffer, charval);
 1417|    102|		buffer[l] = 0;
 1418|       |
 1419|    102|		if (xmlBufCat(buf, buffer))
  ------------------
  |  Branch (1419:7): [True: 0, False: 102]
  ------------------
 1420|      0|		    goto out;
 1421|    102|		charval = 0;
 1422|    102|	    }
 1423|    102|	} else
 1424|  1.63k|	    cur++;
 1425|  1.74k|    }
 1426|       |
 1427|    109|    if (cur != q) {
  ------------------
  |  Branch (1427:9): [True: 109, False: 0]
  ------------------
 1428|       |        /*
 1429|       |	 * Handle the last piece of text.
 1430|       |	 */
 1431|    109|	if (xmlBufAdd(buf, q, cur - q))
  ------------------
  |  Branch (1431:6): [True: 0, False: 109]
  ------------------
 1432|      0|	    goto out;
 1433|    109|    }
 1434|       |
 1435|    109|    if (!xmlBufIsEmpty(buf)) {
  ------------------
  |  Branch (1435:9): [True: 109, False: 0]
  ------------------
 1436|    109|	node = xmlNewDocText(doc, NULL);
 1437|    109|	if (node == NULL) goto out;
  ------------------
  |  Branch (1437:6): [True: 0, False: 109]
  ------------------
 1438|    109|	node->content = xmlBufDetach(buf);
 1439|       |
 1440|    109|	if (last == NULL) {
  ------------------
  |  Branch (1440:6): [True: 109, False: 0]
  ------------------
 1441|    109|	    ret = node;
 1442|    109|	} else {
 1443|      0|	    xmlAddNextSibling(last, node);
 1444|      0|	}
 1445|    109|    } else if (ret == NULL) {
  ------------------
  |  Branch (1445:16): [True: 0, False: 0]
  ------------------
 1446|      0|        ret = xmlNewDocText(doc, BAD_CAST "");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1447|      0|    }
 1448|       |
 1449|    109|out:
 1450|    109|    xmlBufFree(buf);
 1451|    109|    return(ret);
 1452|    109|}
xmlFreePropList:
 2047|    781|xmlFreePropList(xmlAttrPtr cur) {
 2048|    781|    xmlAttrPtr next;
 2049|    781|    if (cur == NULL) return;
  ------------------
  |  Branch (2049:9): [True: 0, False: 781]
  ------------------
 2050|  1.67k|    while (cur != NULL) {
  ------------------
  |  Branch (2050:12): [True: 896, False: 781]
  ------------------
 2051|    896|        next = cur->next;
 2052|    896|        xmlFreeProp(cur);
 2053|    896|	cur = next;
 2054|    896|    }
 2055|    781|}
xmlFreeProp:
 2064|    896|xmlFreeProp(xmlAttrPtr cur) {
 2065|    896|    xmlDictPtr dict = NULL;
 2066|    896|    if (cur == NULL) return;
  ------------------
  |  Branch (2066:9): [True: 0, False: 896]
  ------------------
 2067|       |
 2068|    896|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (2068:9): [True: 896, False: 0]
  ------------------
 2069|       |
 2070|    896|    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2070:9): [True: 0, False: 896]
  |  Branch (2070:37): [True: 0, False: 0]
  ------------------
 2071|      0|	xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2072|       |
 2073|       |    /* Check for ID removal -> leading to invalid references ! */
 2074|    896|    if ((cur->doc != NULL) && (cur->atype == XML_ATTRIBUTE_ID)) {
  ------------------
  |  Branch (2074:9): [True: 896, False: 0]
  |  Branch (2074:31): [True: 110, False: 786]
  ------------------
 2075|    110|	    xmlRemoveID(cur->doc, cur);
 2076|    110|    }
 2077|    896|    if (cur->children != NULL) xmlFreeNodeList(cur->children);
  ------------------
  |  Branch (2077:9): [True: 896, False: 0]
  ------------------
 2078|    896|    DICT_FREE(cur->name)
  ------------------
  |  | 1025|    896|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 896, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 896]
  |  |  ------------------
  |  | 1026|    896|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 896]
  |  |  ------------------
  |  | 1027|    896|	    xmlFree((char *)(str));
  ------------------
 2079|    896|    xmlFree(cur);
 2080|    896|}
xmlNewDocPI:
 2131|     12|xmlNewDocPI(xmlDocPtr doc, const xmlChar *name, const xmlChar *content) {
 2132|     12|    xmlNodePtr cur;
 2133|       |
 2134|     12|    if (name == NULL) {
  ------------------
  |  Branch (2134:9): [True: 0, False: 12]
  ------------------
 2135|      0|	return(NULL);
 2136|      0|    }
 2137|       |
 2138|       |    /*
 2139|       |     * Allocate a new node and fill the fields.
 2140|       |     */
 2141|     12|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2142|     12|    if (cur == NULL) {
  ------------------
  |  Branch (2142:9): [True: 0, False: 12]
  ------------------
 2143|      0|	xmlTreeErrMemory("building PI");
 2144|      0|	return(NULL);
 2145|      0|    }
 2146|     12|    memset(cur, 0, sizeof(xmlNode));
 2147|     12|    cur->type = XML_PI_NODE;
 2148|       |
 2149|     12|    if ((doc != NULL) && (doc->dict != NULL))
  ------------------
  |  Branch (2149:9): [True: 12, False: 0]
  |  Branch (2149:26): [True: 12, False: 0]
  ------------------
 2150|     12|        cur->name = xmlDictLookup(doc->dict, name, -1);
 2151|      0|    else
 2152|      0|	cur->name = xmlStrdup(name);
 2153|     12|    if (content != NULL) {
  ------------------
  |  Branch (2153:9): [True: 12, False: 0]
  ------------------
 2154|     12|	cur->content = xmlStrdup(content);
 2155|     12|    }
 2156|     12|    cur->doc = doc;
 2157|       |
 2158|     12|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2158:9): [True: 0, False: 12]
  |  Branch (2158:37): [True: 0, False: 0]
  ------------------
 2159|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2160|     12|    return(cur);
 2161|     12|}
xmlNewNodeEatName:
 2232|  2.95k|xmlNewNodeEatName(xmlNsPtr ns, xmlChar *name) {
 2233|  2.95k|    xmlNodePtr cur;
 2234|       |
 2235|  2.95k|    if (name == NULL) {
  ------------------
  |  Branch (2235:9): [True: 0, False: 2.95k]
  ------------------
 2236|      0|	return(NULL);
 2237|      0|    }
 2238|       |
 2239|       |    /*
 2240|       |     * Allocate a new node and fill the fields.
 2241|       |     */
 2242|  2.95k|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2243|  2.95k|    if (cur == NULL) {
  ------------------
  |  Branch (2243:9): [True: 0, False: 2.95k]
  ------------------
 2244|      0|	xmlTreeErrMemory("building node");
 2245|       |	/* we can't check here that name comes from the doc dictionary */
 2246|      0|	return(NULL);
 2247|      0|    }
 2248|  2.95k|    memset(cur, 0, sizeof(xmlNode));
 2249|  2.95k|    cur->type = XML_ELEMENT_NODE;
 2250|       |
 2251|  2.95k|    cur->name = name;
 2252|  2.95k|    cur->ns = ns;
 2253|       |
 2254|  2.95k|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2254:9): [True: 0, False: 2.95k]
  |  Branch (2254:37): [True: 0, False: 0]
  ------------------
 2255|      0|	xmlRegisterNodeDefaultValue((xmlNodePtr)cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2256|  2.95k|    return(cur);
 2257|  2.95k|}
xmlNewDocNodeEatName:
 2314|  2.95k|              xmlChar *name, const xmlChar *content) {
 2315|  2.95k|    xmlNodePtr cur;
 2316|       |
 2317|  2.95k|    cur = xmlNewNodeEatName(ns, name);
 2318|  2.95k|    if (cur != NULL) {
  ------------------
  |  Branch (2318:9): [True: 2.95k, False: 0]
  ------------------
 2319|  2.95k|        cur->doc = doc;
 2320|  2.95k|	if (content != NULL) {
  ------------------
  |  Branch (2320:6): [True: 0, False: 2.95k]
  ------------------
 2321|      0|	    cur->children = xmlStringGetNodeList(doc, content);
 2322|      0|	    UPDATE_LAST_CHILD_AND_PARENT(cur)
  ------------------
  |  |  127|      0|#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {		\
  |  |  ------------------
  |  |  |  Branch (127:45): [True: 0, False: 0]
  |  |  ------------------
  |  |  128|      0|    xmlNodePtr ulccur = (n)->children;					\
  |  |  129|      0|    if (ulccur == NULL) {						\
  |  |  ------------------
  |  |  |  Branch (129:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  130|      0|        (n)->last = NULL;						\
  |  |  131|      0|    } else {								\
  |  |  132|      0|        while (ulccur->next != NULL) {					\
  |  |  ------------------
  |  |  |  Branch (132:16): [True: 0, False: 0]
  |  |  ------------------
  |  |  133|      0|		ulccur->parent = (n);					\
  |  |  134|      0|		ulccur = ulccur->next;					\
  |  |  135|      0|	}								\
  |  |  136|      0|	ulccur->parent = (n);						\
  |  |  137|      0|	(n)->last = ulccur;						\
  |  |  138|      0|}}
  ------------------
 2323|      0|	}
 2324|  2.95k|    } else {
 2325|       |        /* if name don't come from the doc dictionary free it here */
 2326|      0|        if ((name != NULL) &&
  ------------------
  |  Branch (2326:13): [True: 0, False: 0]
  ------------------
 2327|      0|            ((doc == NULL) || (doc->dict == NULL) ||
  ------------------
  |  Branch (2327:14): [True: 0, False: 0]
  |  Branch (2327:31): [True: 0, False: 0]
  ------------------
 2328|      0|	     (!(xmlDictOwns(doc->dict, name)))))
  ------------------
  |  Branch (2328:7): [True: 0, False: 0]
  ------------------
 2329|      0|	    xmlFree(name);
 2330|      0|    }
 2331|  2.95k|    return(cur);
 2332|  2.95k|}
xmlNewText:
 2404|    109|xmlNewText(const xmlChar *content) {
 2405|    109|    xmlNodePtr cur;
 2406|       |
 2407|       |    /*
 2408|       |     * Allocate a new node and fill the fields.
 2409|       |     */
 2410|    109|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2411|    109|    if (cur == NULL) {
  ------------------
  |  Branch (2411:9): [True: 0, False: 109]
  ------------------
 2412|      0|	xmlTreeErrMemory("building text");
 2413|      0|	return(NULL);
 2414|      0|    }
 2415|    109|    memset(cur, 0, sizeof(xmlNode));
 2416|    109|    cur->type = XML_TEXT_NODE;
 2417|       |
 2418|    109|    cur->name = xmlStringText;
 2419|    109|    if (content != NULL) {
  ------------------
  |  Branch (2419:9): [True: 0, False: 109]
  ------------------
 2420|      0|	cur->content = xmlStrdup(content);
 2421|      0|    }
 2422|       |
 2423|    109|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2423:9): [True: 0, False: 109]
  |  Branch (2423:37): [True: 0, False: 0]
  ------------------
 2424|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2425|    109|    return(cur);
 2426|    109|}
xmlNewDocText:
 2610|    109|xmlNewDocText(const xmlDoc *doc, const xmlChar *content) {
 2611|    109|    xmlNodePtr cur;
 2612|       |
 2613|    109|    cur = xmlNewText(content);
 2614|    109|    if (cur != NULL) cur->doc = (xmlDoc *)doc;
  ------------------
  |  Branch (2614:9): [True: 109, False: 0]
  ------------------
 2615|    109|    return(cur);
 2616|    109|}
xmlNewComment:
 2682|     37|xmlNewComment(const xmlChar *content) {
 2683|     37|    xmlNodePtr cur;
 2684|       |
 2685|       |    /*
 2686|       |     * Allocate a new node and fill the fields.
 2687|       |     */
 2688|     37|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2689|     37|    if (cur == NULL) {
  ------------------
  |  Branch (2689:9): [True: 0, False: 37]
  ------------------
 2690|      0|	xmlTreeErrMemory("building comment");
 2691|      0|	return(NULL);
 2692|      0|    }
 2693|     37|    memset(cur, 0, sizeof(xmlNode));
 2694|     37|    cur->type = XML_COMMENT_NODE;
 2695|       |
 2696|     37|    cur->name = xmlStringComment;
 2697|     37|    if (content != NULL) {
  ------------------
  |  Branch (2697:9): [True: 37, False: 0]
  ------------------
 2698|     37|	cur->content = xmlStrdup(content);
 2699|     37|    }
 2700|       |
 2701|     37|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2701:9): [True: 0, False: 37]
  |  Branch (2701:37): [True: 0, False: 0]
  ------------------
 2702|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2703|     37|    return(cur);
 2704|     37|}
xmlNewCDataBlock:
 2716|     12|xmlNewCDataBlock(xmlDocPtr doc, const xmlChar *content, int len) {
 2717|     12|    xmlNodePtr cur;
 2718|       |
 2719|       |    /*
 2720|       |     * Allocate a new node and fill the fields.
 2721|       |     */
 2722|     12|    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
 2723|     12|    if (cur == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 12]
  ------------------
 2724|      0|	xmlTreeErrMemory("building CDATA");
 2725|      0|	return(NULL);
 2726|      0|    }
 2727|     12|    memset(cur, 0, sizeof(xmlNode));
 2728|     12|    cur->type = XML_CDATA_SECTION_NODE;
 2729|     12|    cur->doc = doc;
 2730|       |
 2731|     12|    if (content != NULL) {
  ------------------
  |  Branch (2731:9): [True: 12, False: 0]
  ------------------
 2732|     12|	cur->content = xmlStrndup(content, len);
 2733|     12|    }
 2734|       |
 2735|     12|    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (2735:9): [True: 0, False: 12]
  |  Branch (2735:37): [True: 0, False: 0]
  ------------------
 2736|      0|	xmlRegisterNodeDefaultValue(cur);
  ------------------
  |  |  682|      0|    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2737|     12|    return(cur);
 2738|     12|}
xmlNewDocComment:
 2749|     37|xmlNewDocComment(xmlDocPtr doc, const xmlChar *content) {
 2750|     37|    xmlNodePtr cur;
 2751|       |
 2752|     37|    cur = xmlNewComment(content);
 2753|     37|    if (cur != NULL) cur->doc = doc;
  ------------------
  |  Branch (2753:9): [True: 37, False: 0]
  ------------------
 2754|     37|    return(cur);
 2755|     37|}
xmlAddChild:
 3279|  5.41k|xmlAddChild(xmlNodePtr parent, xmlNodePtr cur) {
 3280|  5.41k|    xmlNodePtr prev;
 3281|       |
 3282|  5.41k|    if ((parent == NULL) || (parent->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3282:9): [True: 0, False: 5.41k]
  |  Branch (3282:29): [True: 0, False: 5.41k]
  ------------------
 3283|      0|	return(NULL);
 3284|      0|    }
 3285|       |
 3286|  5.41k|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3286:9): [True: 0, False: 5.41k]
  |  Branch (3286:26): [True: 0, False: 5.41k]
  ------------------
 3287|      0|	return(NULL);
 3288|      0|    }
 3289|       |
 3290|  5.41k|    if (parent == cur) {
  ------------------
  |  Branch (3290:9): [True: 0, False: 5.41k]
  ------------------
 3291|      0|	return(NULL);
 3292|      0|    }
 3293|       |    /*
 3294|       |     * If cur is a TEXT node, merge its content with adjacent TEXT nodes
 3295|       |     * cur is then freed.
 3296|       |     */
 3297|  5.41k|    if (cur->type == XML_TEXT_NODE) {
  ------------------
  |  Branch (3297:9): [True: 2.40k, False: 3.01k]
  ------------------
 3298|  2.40k|	if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3298:6): [True: 0, False: 2.40k]
  ------------------
 3299|  2.40k|	    (parent->content != NULL) &&
  ------------------
  |  Branch (3299:6): [True: 0, False: 0]
  ------------------
 3300|  2.40k|	    (parent->name == cur->name)) {
  ------------------
  |  Branch (3300:6): [True: 0, False: 0]
  ------------------
 3301|      0|	    xmlNodeAddContent(parent, cur->content);
 3302|      0|	    xmlFreeNode(cur);
 3303|      0|	    return(parent);
 3304|      0|	}
 3305|  2.40k|	if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3305:6): [True: 2.40k, False: 0]
  |  Branch (3305:32): [True: 0, False: 2.40k]
  ------------------
 3306|  2.40k|	    (parent->last->name == cur->name) &&
  ------------------
  |  Branch (3306:6): [True: 0, False: 0]
  ------------------
 3307|  2.40k|	    (parent->last != cur)) {
  ------------------
  |  Branch (3307:6): [True: 0, False: 0]
  ------------------
 3308|      0|	    xmlNodeAddContent(parent->last, cur->content);
 3309|      0|	    xmlFreeNode(cur);
 3310|      0|	    return(parent->last);
 3311|      0|	}
 3312|  2.40k|    }
 3313|       |
 3314|       |    /*
 3315|       |     * add the new element at the end of the children list.
 3316|       |     */
 3317|  5.41k|    prev = cur->parent;
 3318|  5.41k|    cur->parent = parent;
 3319|  5.41k|    if (cur->doc != parent->doc) {
  ------------------
  |  Branch (3319:9): [True: 0, False: 5.41k]
  ------------------
 3320|      0|	xmlSetTreeDoc(cur, parent->doc);
 3321|      0|    }
 3322|       |    /* this check prevents a loop on tree-traversions if a developer
 3323|       |     * tries to add a node to its parent multiple times
 3324|       |     */
 3325|  5.41k|    if (prev == parent)
  ------------------
  |  Branch (3325:9): [True: 0, False: 5.41k]
  ------------------
 3326|      0|	return(cur);
 3327|       |
 3328|       |    /*
 3329|       |     * Coalescing
 3330|       |     */
 3331|  5.41k|    if ((parent->type == XML_TEXT_NODE) &&
  ------------------
  |  Branch (3331:9): [True: 0, False: 5.41k]
  ------------------
 3332|  5.41k|	(parent->content != NULL) &&
  ------------------
  |  Branch (3332:2): [True: 0, False: 0]
  ------------------
 3333|  5.41k|	(parent != cur)) {
  ------------------
  |  Branch (3333:2): [True: 0, False: 0]
  ------------------
 3334|      0|	xmlNodeAddContent(parent, cur->content);
 3335|      0|	xmlFreeNode(cur);
 3336|      0|	return(parent);
 3337|      0|    }
 3338|  5.41k|    if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3338:9): [True: 0, False: 5.41k]
  ------------------
 3339|      0|		if (parent->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (3339:7): [True: 0, False: 0]
  ------------------
 3340|      0|			return(NULL);
 3341|      0|	if (parent->properties != NULL) {
  ------------------
  |  Branch (3341:6): [True: 0, False: 0]
  ------------------
 3342|       |	    /* check if an attribute with the same name exists */
 3343|      0|	    xmlAttrPtr lastattr;
 3344|       |
 3345|      0|	    if (cur->ns == NULL)
  ------------------
  |  Branch (3345:10): [True: 0, False: 0]
  ------------------
 3346|      0|		lastattr = xmlHasNsProp(parent, cur->name, NULL);
 3347|      0|	    else
 3348|      0|		lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);
 3349|      0|	    if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {
  ------------------
  |  Branch (3349:10): [True: 0, False: 0]
  |  Branch (3349:32): [True: 0, False: 0]
  |  Branch (3349:66): [True: 0, False: 0]
  ------------------
 3350|       |		/* different instance, destroy it (attributes must be unique) */
 3351|      0|			xmlUnlinkNode((xmlNodePtr) lastattr);
 3352|      0|		xmlFreeProp(lastattr);
 3353|      0|	    }
 3354|      0|		if (lastattr == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3354:7): [True: 0, False: 0]
  ------------------
 3355|      0|			return(cur);
 3356|       |
 3357|      0|	}
 3358|      0|	if (parent->properties == NULL) {
  ------------------
  |  Branch (3358:6): [True: 0, False: 0]
  ------------------
 3359|      0|	    parent->properties = (xmlAttrPtr) cur;
 3360|      0|	} else {
 3361|       |	    /* find the end */
 3362|      0|	    xmlAttrPtr lastattr = parent->properties;
 3363|      0|	    while (lastattr->next != NULL) {
  ------------------
  |  Branch (3363:13): [True: 0, False: 0]
  ------------------
 3364|      0|		lastattr = lastattr->next;
 3365|      0|	    }
 3366|      0|	    lastattr->next = (xmlAttrPtr) cur;
 3367|      0|	    ((xmlAttrPtr) cur)->prev = lastattr;
 3368|      0|	}
 3369|  5.41k|    } else {
 3370|  5.41k|	if (parent->children == NULL) {
  ------------------
  |  Branch (3370:6): [True: 548, False: 4.87k]
  ------------------
 3371|    548|	    parent->children = cur;
 3372|    548|	    parent->last = cur;
 3373|  4.87k|	} else {
 3374|  4.87k|	    prev = parent->last;
 3375|  4.87k|	    prev->next = cur;
 3376|  4.87k|	    cur->prev = prev;
 3377|  4.87k|	    parent->last = cur;
 3378|  4.87k|	}
 3379|  5.41k|    }
 3380|  5.41k|    return(cur);
 3381|  5.41k|}
xmlFreeNodeList:
 3602|  1.37k|xmlFreeNodeList(xmlNodePtr cur) {
 3603|  1.37k|    xmlNodePtr next;
 3604|  1.37k|    xmlNodePtr parent;
 3605|  1.37k|    xmlDictPtr dict = NULL;
 3606|  1.37k|    size_t depth = 0;
 3607|       |
 3608|  1.37k|    if (cur == NULL) return;
  ------------------
  |  Branch (3608:9): [True: 0, False: 1.37k]
  ------------------
 3609|  1.37k|    if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3609:9): [True: 0, False: 1.37k]
  ------------------
 3610|      0|	xmlFreeNsList((xmlNsPtr) cur);
 3611|      0|	return;
 3612|      0|    }
 3613|  1.37k|    if (cur->doc != NULL) dict = cur->doc->dict;
  ------------------
  |  Branch (3613:9): [True: 1.37k, False: 0]
  ------------------
 3614|  8.66k|    while (1) {
  ------------------
  |  Branch (3614:12): [Folded - Ignored]
  ------------------
 3615|  11.0k|        while ((cur->children != NULL) &&
  ------------------
  |  Branch (3615:16): [True: 2.43k, False: 8.66k]
  ------------------
 3616|  11.0k|               (cur->type != XML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3616:16): [True: 2.43k, False: 0]
  ------------------
 3617|  11.0k|               (cur->type != XML_HTML_DOCUMENT_NODE) &&
  ------------------
  |  Branch (3617:16): [True: 2.43k, False: 0]
  ------------------
 3618|  11.0k|               (cur->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (3618:16): [True: 2.43k, False: 0]
  ------------------
 3619|  11.0k|               (cur->type != XML_ENTITY_REF_NODE)) {
  ------------------
  |  Branch (3619:16): [True: 2.43k, False: 0]
  ------------------
 3620|  2.43k|            cur = cur->children;
 3621|  2.43k|            depth += 1;
 3622|  2.43k|        }
 3623|       |
 3624|  8.66k|        next = cur->next;
 3625|  8.66k|        parent = cur->parent;
 3626|  8.66k|	if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (3626:6): [True: 0, False: 8.66k]
  ------------------
 3627|  8.66k|            (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (3627:13): [True: 0, False: 8.66k]
  ------------------
 3628|      0|            xmlFreeDoc((xmlDocPtr) cur);
 3629|  8.66k|        } else if (cur->type != XML_DTD_NODE) {
  ------------------
  |  Branch (3629:20): [True: 8.66k, False: 0]
  ------------------
 3630|       |
 3631|  8.66k|	    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
  |  Branch (3631:10): [True: 0, False: 8.66k]
  |  Branch (3631:38): [True: 0, False: 0]
  ------------------
 3632|      0|		xmlDeregisterNodeDefaultValue(cur);
  ------------------
  |  |  684|      0|    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 3633|       |
 3634|  8.66k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3634:11): [True: 2.95k, False: 5.70k]
  ------------------
 3635|  8.66k|		 (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3635:4): [True: 0, False: 5.70k]
  ------------------
 3636|  8.66k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3636:4): [True: 0, False: 5.70k]
  ------------------
 3637|  8.66k|		(cur->properties != NULL))
  ------------------
  |  Branch (3637:3): [True: 781, False: 2.17k]
  ------------------
 3638|    781|		xmlFreePropList(cur->properties);
 3639|  8.66k|	    if ((cur->type != XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (3639:10): [True: 5.70k, False: 2.95k]
  ------------------
 3640|  8.66k|		(cur->type != XML_XINCLUDE_START) &&
  ------------------
  |  Branch (3640:3): [True: 5.70k, False: 0]
  ------------------
 3641|  8.66k|		(cur->type != XML_XINCLUDE_END) &&
  ------------------
  |  Branch (3641:3): [True: 5.70k, False: 0]
  ------------------
 3642|  8.66k|		(cur->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (3642:3): [True: 5.70k, False: 0]
  ------------------
 3643|  8.66k|		(cur->content != (xmlChar *) &(cur->properties))) {
  ------------------
  |  Branch (3643:3): [True: 5.70k, False: 0]
  ------------------
 3644|  5.70k|		DICT_FREE(cur->content)
  ------------------
  |  | 1025|  5.70k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 5.70k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 5.70k]
  |  |  ------------------
  |  | 1026|  5.70k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 2.23k, False: 3.47k]
  |  |  ------------------
  |  | 1027|  5.70k|	    xmlFree((char *)(str));
  ------------------
 3645|  5.70k|	    }
 3646|  8.66k|	    if (((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (3646:11): [True: 2.95k, False: 5.70k]
  ------------------
 3647|  8.66k|	         (cur->type == XML_XINCLUDE_START) ||
  ------------------
  |  Branch (3647:11): [True: 0, False: 5.70k]
  ------------------
 3648|  8.66k|		 (cur->type == XML_XINCLUDE_END)) &&
  ------------------
  |  Branch (3648:4): [True: 0, False: 5.70k]
  ------------------
 3649|  8.66k|		(cur->nsDef != NULL))
  ------------------
  |  Branch (3649:3): [True: 18, False: 2.93k]
  ------------------
 3650|     18|		xmlFreeNsList(cur->nsDef);
 3651|       |
 3652|       |	    /*
 3653|       |	     * When a node is a text node or a comment, it uses a global static
 3654|       |	     * variable for the name of the node.
 3655|       |	     * Otherwise the node name might come from the document's
 3656|       |	     * dictionary
 3657|       |	     */
 3658|  8.66k|	    if ((cur->name != NULL) &&
  ------------------
  |  Branch (3658:10): [True: 8.64k, False: 12]
  ------------------
 3659|  8.66k|		(cur->type != XML_TEXT_NODE) &&
  ------------------
  |  Branch (3659:3): [True: 3.00k, False: 5.64k]
  ------------------
 3660|  8.66k|		(cur->type != XML_COMMENT_NODE))
  ------------------
  |  Branch (3660:3): [True: 2.96k, False: 37]
  ------------------
 3661|  2.96k|		DICT_FREE(cur->name)
  ------------------
  |  | 1025|  2.96k|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (1025:6): [True: 2.96k, False: 0]
  |  |  |  Branch (1025:16): [True: 0, False: 2.96k]
  |  |  ------------------
  |  | 1026|  2.96k|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (1026:6): [True: 0, False: 2.96k]
  |  |  ------------------
  |  | 1027|  2.96k|	    xmlFree((char *)(str));
  ------------------
 3662|  8.66k|	    xmlFree(cur);
 3663|  8.66k|	}
 3664|       |
 3665|  8.66k|        if (next != NULL) {
  ------------------
  |  Branch (3665:13): [True: 4.84k, False: 3.81k]
  ------------------
 3666|  4.84k|	    cur = next;
 3667|  4.84k|        } else {
 3668|  3.81k|            if ((depth == 0) || (parent == NULL))
  ------------------
  |  Branch (3668:17): [True: 1.37k, False: 2.43k]
  |  Branch (3668:33): [True: 0, False: 2.43k]
  ------------------
 3669|  1.37k|                break;
 3670|  2.43k|            depth -= 1;
 3671|  2.43k|            cur = parent;
 3672|  2.43k|            cur->children = NULL;
 3673|  2.43k|        }
 3674|  8.66k|    }
 3675|  1.37k|}
xmlUnlinkNode:
 3755|    243|xmlUnlinkNode(xmlNodePtr cur) {
 3756|    243|    if (cur == NULL) {
  ------------------
  |  Branch (3756:9): [True: 0, False: 243]
  ------------------
 3757|      0|	return;
 3758|      0|    }
 3759|    243|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (3759:9): [True: 0, False: 243]
  ------------------
 3760|      0|        return;
 3761|    243|    if (cur->type == XML_DTD_NODE) {
  ------------------
  |  Branch (3761:9): [True: 23, False: 220]
  ------------------
 3762|     23|	xmlDocPtr doc;
 3763|     23|	doc = cur->doc;
 3764|     23|	if (doc != NULL) {
  ------------------
  |  Branch (3764:6): [True: 23, False: 0]
  ------------------
 3765|     23|	    if (doc->intSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3765:10): [True: 23, False: 0]
  ------------------
 3766|     23|		doc->intSubset = NULL;
 3767|     23|	    if (doc->extSubset == (xmlDtdPtr) cur)
  ------------------
  |  Branch (3767:10): [True: 0, False: 23]
  ------------------
 3768|      0|		doc->extSubset = NULL;
 3769|     23|	}
 3770|     23|    }
 3771|    243|    if (cur->type == XML_ENTITY_DECL) {
  ------------------
  |  Branch (3771:9): [True: 0, False: 243]
  ------------------
 3772|      0|        xmlDocPtr doc;
 3773|      0|	doc = cur->doc;
 3774|      0|	if (doc != NULL) {
  ------------------
  |  Branch (3774:6): [True: 0, False: 0]
  ------------------
 3775|      0|	    if (doc->intSubset != NULL) {
  ------------------
  |  Branch (3775:10): [True: 0, False: 0]
  ------------------
 3776|      0|	        if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3776:14): [True: 0, False: 0]
  ------------------
 3777|      0|		    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,
 3778|      0|		                       NULL);
 3779|      0|	        if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3779:14): [True: 0, False: 0]
  ------------------
 3780|      0|		    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,
 3781|      0|		                       NULL);
 3782|      0|	    }
 3783|      0|	    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (3783:10): [True: 0, False: 0]
  ------------------
 3784|      0|	        if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)
  ------------------
  |  Branch (3784:14): [True: 0, False: 0]
  ------------------
 3785|      0|		    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,
 3786|      0|		                       NULL);
 3787|      0|	        if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)
  ------------------
  |  Branch (3787:14): [True: 0, False: 0]
  ------------------
 3788|      0|		    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,
 3789|      0|		                       NULL);
 3790|      0|	    }
 3791|      0|	}
 3792|      0|    }
 3793|    243|    if (cur->parent != NULL) {
  ------------------
  |  Branch (3793:9): [True: 243, False: 0]
  ------------------
 3794|    243|	xmlNodePtr parent;
 3795|    243|	parent = cur->parent;
 3796|    243|	if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (3796:6): [True: 0, False: 243]
  ------------------
 3797|      0|	    if (parent->properties == (xmlAttrPtr) cur)
  ------------------
  |  Branch (3797:10): [True: 0, False: 0]
  ------------------
 3798|      0|		parent->properties = ((xmlAttrPtr) cur)->next;
 3799|    243|	} else {
 3800|    243|	    if (parent->children == cur)
  ------------------
  |  Branch (3800:10): [True: 67, False: 176]
  ------------------
 3801|     67|		parent->children = cur->next;
 3802|    243|	    if (parent->last == cur)
  ------------------
  |  Branch (3802:10): [True: 111, False: 132]
  ------------------
 3803|    111|		parent->last = cur->prev;
 3804|    243|	}
 3805|    243|	cur->parent = NULL;
 3806|    243|    }
 3807|    243|    if (cur->next != NULL)
  ------------------
  |  Branch (3807:9): [True: 132, False: 111]
  ------------------
 3808|    132|        cur->next->prev = cur->prev;
 3809|    243|    if (cur->prev != NULL)
  ------------------
  |  Branch (3809:9): [True: 176, False: 67]
  ------------------
 3810|    176|        cur->prev->next = cur->next;
 3811|    243|    cur->next = cur->prev = NULL;
 3812|    243|}
xmlGetLineNo:
 4629|    110|{
 4630|    110|    return(xmlGetLineNoInternal(node, 0));
 4631|    110|}
xmlDocGetRootElement:
 4892|     87|xmlDocGetRootElement(const xmlDoc *doc) {
 4893|     87|    xmlNodePtr ret;
 4894|       |
 4895|     87|    if (doc == NULL) return(NULL);
  ------------------
  |  Branch (4895:9): [True: 0, False: 87]
  ------------------
 4896|     87|    ret = doc->children;
 4897|     89|    while (ret != NULL) {
  ------------------
  |  Branch (4897:12): [True: 88, False: 1]
  ------------------
 4898|     88|	if (ret->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (4898:6): [True: 86, False: 2]
  ------------------
 4899|     86|	    return(ret);
 4900|      2|        ret = ret->next;
 4901|      2|    }
 4902|      1|    return(ret);
 4903|     87|}
xmlNodeGetLang:
 5003|     76|xmlNodeGetLang(const xmlNode *cur) {
 5004|     76|    xmlChar *lang;
 5005|       |
 5006|     76|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5006:9): [True: 0, False: 76]
  |  Branch (5006:26): [True: 0, False: 76]
  ------------------
 5007|      0|        return(NULL);
 5008|    151|    while (cur != NULL) {
  ------------------
  |  Branch (5008:12): [True: 130, False: 21]
  ------------------
 5009|    130|        lang = xmlGetNsProp(cur, BAD_CAST "lang", XML_XML_NAMESPACE);
  ------------------
  |  |   35|    130|#define BAD_CAST (xmlChar *)
  ------------------
                      lang = xmlGetNsProp(cur, BAD_CAST "lang", XML_XML_NAMESPACE);
  ------------------
  |  |  143|    130|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5010|    130|	if (lang != NULL)
  ------------------
  |  Branch (5010:6): [True: 55, False: 75]
  ------------------
 5011|     55|	    return(lang);
 5012|     75|	cur = cur->parent;
 5013|     75|    }
 5014|     21|    return(NULL);
 5015|     76|}
xmlBufGetNodeContent:
 5359|      2|{
 5360|      2|    if ((cur == NULL) || (buf == NULL)) return(-1);
  ------------------
  |  Branch (5360:9): [True: 0, False: 2]
  |  Branch (5360:26): [True: 0, False: 2]
  ------------------
 5361|      2|    switch (cur->type) {
  ------------------
  |  Branch (5361:13): [True: 0, False: 2]
  ------------------
 5362|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5362:9): [True: 0, False: 2]
  ------------------
 5363|      0|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5363:9): [True: 0, False: 2]
  ------------------
 5364|      0|	    xmlBufCat(buf, cur->content);
 5365|      0|            break;
 5366|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5366:9): [True: 0, False: 2]
  ------------------
 5367|      2|        case XML_ELEMENT_NODE:{
  ------------------
  |  Branch (5367:9): [True: 2, False: 0]
  ------------------
 5368|      2|                const xmlNode *tmp = cur;
 5369|       |
 5370|     10|                while (tmp != NULL) {
  ------------------
  |  Branch (5370:24): [True: 8, False: 2]
  ------------------
 5371|      8|                    switch (tmp->type) {
 5372|      0|                        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5372:25): [True: 0, False: 8]
  ------------------
 5373|      4|                        case XML_TEXT_NODE:
  ------------------
  |  Branch (5373:25): [True: 4, False: 4]
  ------------------
 5374|      4|                            if (tmp->content != NULL)
  ------------------
  |  Branch (5374:33): [True: 4, False: 0]
  ------------------
 5375|      4|                                xmlBufCat(buf, tmp->content);
 5376|      4|                            break;
 5377|      0|                        case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (5377:25): [True: 0, False: 8]
  ------------------
 5378|      0|                            xmlBufGetNodeContent(buf, tmp);
 5379|      0|                            break;
 5380|      4|                        default:
  ------------------
  |  Branch (5380:25): [True: 4, False: 4]
  ------------------
 5381|      4|                            break;
 5382|      8|                    }
 5383|       |                    /*
 5384|       |                     * Skip to next node
 5385|       |                     */
 5386|      8|                    if (tmp->children != NULL) {
  ------------------
  |  Branch (5386:25): [True: 3, False: 5]
  ------------------
 5387|      3|                        if (tmp->children->type != XML_ENTITY_DECL) {
  ------------------
  |  Branch (5387:29): [True: 3, False: 0]
  ------------------
 5388|      3|                            tmp = tmp->children;
 5389|      3|                            continue;
 5390|      3|                        }
 5391|      3|                    }
 5392|      5|                    if (tmp == cur)
  ------------------
  |  Branch (5392:25): [True: 0, False: 5]
  ------------------
 5393|      0|                        break;
 5394|       |
 5395|      5|                    if (tmp->next != NULL) {
  ------------------
  |  Branch (5395:25): [True: 2, False: 3]
  ------------------
 5396|      2|                        tmp = tmp->next;
 5397|      2|                        continue;
 5398|      2|                    }
 5399|       |
 5400|      3|                    do {
 5401|      3|                        tmp = tmp->parent;
 5402|      3|                        if (tmp == NULL)
  ------------------
  |  Branch (5402:29): [True: 0, False: 3]
  ------------------
 5403|      0|                            break;
 5404|      3|                        if (tmp == cur) {
  ------------------
  |  Branch (5404:29): [True: 2, False: 1]
  ------------------
 5405|      2|                            tmp = NULL;
 5406|      2|                            break;
 5407|      2|                        }
 5408|      1|                        if (tmp->next != NULL) {
  ------------------
  |  Branch (5408:29): [True: 1, False: 0]
  ------------------
 5409|      1|                            tmp = tmp->next;
 5410|      1|                            break;
 5411|      1|                        }
 5412|      1|                    } while (tmp != NULL);
  ------------------
  |  Branch (5412:30): [True: 0, False: 0]
  ------------------
 5413|      3|                }
 5414|      2|		break;
 5415|      2|            }
 5416|      2|        case XML_ATTRIBUTE_NODE:{
  ------------------
  |  Branch (5416:9): [True: 0, False: 2]
  ------------------
 5417|      0|                xmlAttrPtr attr = (xmlAttrPtr) cur;
 5418|      0|		xmlNodePtr tmp = attr->children;
 5419|       |
 5420|      0|		while (tmp != NULL) {
  ------------------
  |  Branch (5420:10): [True: 0, False: 0]
  ------------------
 5421|      0|		    if (tmp->type == XML_TEXT_NODE)
  ------------------
  |  Branch (5421:11): [True: 0, False: 0]
  ------------------
 5422|      0|		        xmlBufCat(buf, tmp->content);
 5423|      0|		    else
 5424|      0|		        xmlBufGetNodeContent(buf, tmp);
 5425|      0|		    tmp = tmp->next;
 5426|      0|		}
 5427|      0|                break;
 5428|      2|            }
 5429|      0|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5429:9): [True: 0, False: 2]
  ------------------
 5430|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (5430:9): [True: 0, False: 2]
  ------------------
 5431|      0|	    xmlBufCat(buf, cur->content);
 5432|      0|            break;
 5433|      0|        case XML_ENTITY_REF_NODE:{
  ------------------
  |  Branch (5433:9): [True: 0, False: 2]
  ------------------
 5434|      0|                xmlEntityPtr ent;
 5435|      0|                xmlNodePtr tmp;
 5436|       |
 5437|       |                /* lookup entity declaration */
 5438|      0|                ent = xmlGetDocEntity(cur->doc, cur->name);
 5439|      0|                if (ent == NULL)
  ------------------
  |  Branch (5439:21): [True: 0, False: 0]
  ------------------
 5440|      0|                    return(-1);
 5441|       |
 5442|       |                /* an entity content can be any "well balanced chunk",
 5443|       |                 * i.e. the result of the content [43] production:
 5444|       |                 * http://www.w3.org/TR/REC-xml#NT-content
 5445|       |                 * -> we iterate through child nodes and recursive call
 5446|       |                 * xmlNodeGetContent() which handles all possible node types */
 5447|      0|                tmp = ent->children;
 5448|      0|                while (tmp) {
  ------------------
  |  Branch (5448:24): [True: 0, False: 0]
  ------------------
 5449|      0|		    xmlBufGetNodeContent(buf, tmp);
 5450|      0|                    tmp = tmp->next;
 5451|      0|                }
 5452|      0|		break;
 5453|      0|            }
 5454|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5454:9): [True: 0, False: 2]
  ------------------
 5455|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5455:9): [True: 0, False: 2]
  ------------------
 5456|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5456:9): [True: 0, False: 2]
  ------------------
 5457|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5457:9): [True: 0, False: 2]
  ------------------
 5458|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (5458:9): [True: 0, False: 2]
  ------------------
 5459|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (5459:9): [True: 0, False: 2]
  ------------------
 5460|      0|            break;
 5461|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5461:9): [True: 0, False: 2]
  ------------------
 5462|      0|        case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (5462:9): [True: 0, False: 2]
  ------------------
 5463|      0|	    cur = cur->children;
 5464|      0|	    while (cur!= NULL) {
  ------------------
  |  Branch (5464:13): [True: 0, False: 0]
  ------------------
 5465|      0|		if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (5465:7): [True: 0, False: 0]
  ------------------
 5466|      0|		    (cur->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (5466:7): [True: 0, False: 0]
  ------------------
 5467|      0|		    (cur->type == XML_CDATA_SECTION_NODE)) {
  ------------------
  |  Branch (5467:7): [True: 0, False: 0]
  ------------------
 5468|      0|		    xmlBufGetNodeContent(buf, cur);
 5469|      0|		}
 5470|      0|		cur = cur->next;
 5471|      0|	    }
 5472|      0|	    break;
 5473|      0|        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5473:9): [True: 0, False: 2]
  ------------------
 5474|      0|	    xmlBufCat(buf, ((xmlNsPtr) cur)->href);
 5475|      0|	    break;
 5476|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5476:9): [True: 0, False: 2]
  ------------------
 5477|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5477:9): [True: 0, False: 2]
  ------------------
 5478|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5478:9): [True: 0, False: 2]
  ------------------
 5479|      0|            break;
 5480|      2|    }
 5481|      2|    return(0);
 5482|      2|}
xmlNodeGetContent:
 5497|     47|{
 5498|     47|    if (cur == NULL)
  ------------------
  |  Branch (5498:9): [True: 0, False: 47]
  ------------------
 5499|      0|        return (NULL);
 5500|     47|    switch (cur->type) {
  ------------------
  |  Branch (5500:13): [True: 0, False: 47]
  ------------------
 5501|      0|        case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (5501:9): [True: 0, False: 47]
  ------------------
 5502|      2|        case XML_ELEMENT_NODE:{
  ------------------
  |  Branch (5502:9): [True: 2, False: 45]
  ------------------
 5503|      2|                xmlBufPtr buf;
 5504|      2|                xmlChar *ret;
 5505|       |
 5506|      2|                buf = xmlBufCreateSize(64);
 5507|      2|                if (buf == NULL)
  ------------------
  |  Branch (5507:21): [True: 0, False: 2]
  ------------------
 5508|      0|                    return (NULL);
 5509|      2|                xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5510|      2|		xmlBufGetNodeContent(buf, cur);
 5511|      2|                ret = xmlBufDetach(buf);
 5512|      2|                xmlBufFree(buf);
 5513|      2|                return (ret);
 5514|      2|            }
 5515|     45|        case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5515:9): [True: 45, False: 2]
  ------------------
 5516|     45|	    return(xmlGetPropNodeValueInternal((xmlAttrPtr) cur));
 5517|      0|        case XML_COMMENT_NODE:
  ------------------
  |  Branch (5517:9): [True: 0, False: 47]
  ------------------
 5518|      0|        case XML_PI_NODE:
  ------------------
  |  Branch (5518:9): [True: 0, False: 47]
  ------------------
 5519|      0|            if (cur->content != NULL)
  ------------------
  |  Branch (5519:17): [True: 0, False: 0]
  ------------------
 5520|      0|                return (xmlStrdup(cur->content));
 5521|      0|            return (NULL);
 5522|      0|        case XML_ENTITY_REF_NODE:{
  ------------------
  |  Branch (5522:9): [True: 0, False: 47]
  ------------------
 5523|      0|                xmlEntityPtr ent;
 5524|      0|                xmlBufPtr buf;
 5525|      0|                xmlChar *ret;
 5526|       |
 5527|       |                /* lookup entity declaration */
 5528|      0|                ent = xmlGetDocEntity(cur->doc, cur->name);
 5529|      0|                if (ent == NULL)
  ------------------
  |  Branch (5529:21): [True: 0, False: 0]
  ------------------
 5530|      0|                    return (NULL);
 5531|       |
 5532|      0|                buf = xmlBufCreate();
 5533|      0|                if (buf == NULL)
  ------------------
  |  Branch (5533:21): [True: 0, False: 0]
  ------------------
 5534|      0|                    return (NULL);
 5535|      0|                xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5536|       |
 5537|      0|                xmlBufGetNodeContent(buf, cur);
 5538|       |
 5539|      0|                ret = xmlBufDetach(buf);
 5540|      0|                xmlBufFree(buf);
 5541|      0|                return (ret);
 5542|      0|            }
 5543|      0|        case XML_ENTITY_NODE:
  ------------------
  |  Branch (5543:9): [True: 0, False: 47]
  ------------------
 5544|      0|        case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (5544:9): [True: 0, False: 47]
  ------------------
 5545|      0|        case XML_NOTATION_NODE:
  ------------------
  |  Branch (5545:9): [True: 0, False: 47]
  ------------------
 5546|      0|        case XML_DTD_NODE:
  ------------------
  |  Branch (5546:9): [True: 0, False: 47]
  ------------------
 5547|      0|        case XML_XINCLUDE_START:
  ------------------
  |  Branch (5547:9): [True: 0, False: 47]
  ------------------
 5548|      0|        case XML_XINCLUDE_END:
  ------------------
  |  Branch (5548:9): [True: 0, False: 47]
  ------------------
 5549|      0|            return (NULL);
 5550|      0|        case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (5550:9): [True: 0, False: 47]
  ------------------
 5551|      0|        case XML_HTML_DOCUMENT_NODE: {
  ------------------
  |  Branch (5551:9): [True: 0, False: 47]
  ------------------
 5552|      0|	    xmlBufPtr buf;
 5553|      0|	    xmlChar *ret;
 5554|       |
 5555|      0|	    buf = xmlBufCreate();
 5556|      0|	    if (buf == NULL)
  ------------------
  |  Branch (5556:10): [True: 0, False: 0]
  ------------------
 5557|      0|		return (NULL);
 5558|      0|            xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);
 5559|       |
 5560|      0|	    xmlBufGetNodeContent(buf, (xmlNodePtr) cur);
 5561|       |
 5562|      0|	    ret = xmlBufDetach(buf);
 5563|      0|	    xmlBufFree(buf);
 5564|      0|	    return (ret);
 5565|      0|	}
 5566|      0|        case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (5566:9): [True: 0, False: 47]
  ------------------
 5567|      0|	    xmlChar *tmp;
 5568|       |
 5569|      0|	    tmp = xmlStrdup(((xmlNsPtr) cur)->href);
 5570|      0|            return (tmp);
 5571|      0|	}
 5572|      0|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (5572:9): [True: 0, False: 47]
  ------------------
 5573|       |            /* TODO !!! */
 5574|      0|            return (NULL);
 5575|      0|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (5575:9): [True: 0, False: 47]
  ------------------
 5576|       |            /* TODO !!! */
 5577|      0|            return (NULL);
 5578|      0|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (5578:9): [True: 0, False: 47]
  ------------------
 5579|       |            /* TODO !!! */
 5580|      0|            return (NULL);
 5581|      0|        case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5581:9): [True: 0, False: 47]
  ------------------
 5582|      0|        case XML_TEXT_NODE:
  ------------------
  |  Branch (5582:9): [True: 0, False: 47]
  ------------------
 5583|      0|            if (cur->content != NULL)
  ------------------
  |  Branch (5583:17): [True: 0, False: 0]
  ------------------
 5584|      0|                return (xmlStrdup(cur->content));
 5585|      0|            return (NULL);
 5586|     47|    }
 5587|      0|    return (NULL);
 5588|     47|}
xmlGetNsList:
 5850|      8|{
 5851|      8|    xmlNsPtr cur;
 5852|      8|    xmlNsPtr *ret = NULL;
 5853|      8|    int nbns = 0;
 5854|      8|    int maxns = 0;
 5855|      8|    int i;
 5856|       |
 5857|      8|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (5857:9): [True: 0, False: 8]
  |  Branch (5857:27): [True: 0, False: 8]
  ------------------
 5858|      0|        return(NULL);
 5859|       |
 5860|     31|    while (node != NULL) {
  ------------------
  |  Branch (5860:12): [True: 23, False: 8]
  ------------------
 5861|     23|        if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5861:13): [True: 15, False: 8]
  ------------------
 5862|     15|            cur = node->nsDef;
 5863|     28|            while (cur != NULL) {
  ------------------
  |  Branch (5863:20): [True: 13, False: 15]
  ------------------
 5864|     18|                for (i = 0; i < nbns; i++) {
  ------------------
  |  Branch (5864:29): [True: 5, False: 13]
  ------------------
 5865|      5|                    if ((cur->prefix == ret[i]->prefix) ||
  ------------------
  |  Branch (5865:25): [True: 0, False: 5]
  ------------------
 5866|      5|                        (xmlStrEqual(cur->prefix, ret[i]->prefix)))
  ------------------
  |  Branch (5866:25): [True: 0, False: 5]
  ------------------
 5867|      0|                        break;
 5868|      5|                }
 5869|     13|                if (i >= nbns) {
  ------------------
  |  Branch (5869:21): [True: 13, False: 0]
  ------------------
 5870|     13|                    if (nbns >= maxns) {
  ------------------
  |  Branch (5870:25): [True: 8, False: 5]
  ------------------
 5871|      8|                        xmlNsPtr *tmp;
 5872|       |
 5873|      8|                        maxns = maxns ? maxns * 2 : 10;
  ------------------
  |  Branch (5873:33): [True: 0, False: 8]
  ------------------
 5874|      8|                        tmp = (xmlNsPtr *) xmlRealloc(ret,
 5875|      8|                                                      (maxns + 1) *
 5876|      8|                                                      sizeof(xmlNsPtr));
 5877|      8|                        if (tmp == NULL) {
  ------------------
  |  Branch (5877:29): [True: 0, False: 8]
  ------------------
 5878|      0|			    xmlTreeErrMemory("getting namespace list");
 5879|      0|                            xmlFree(ret);
 5880|      0|                            return (NULL);
 5881|      0|                        }
 5882|      8|                        ret = tmp;
 5883|      8|                    }
 5884|     13|                    ret[nbns++] = cur;
 5885|     13|                    ret[nbns] = NULL;
 5886|     13|                }
 5887|       |
 5888|     13|                cur = cur->next;
 5889|     13|            }
 5890|     15|        }
 5891|     23|        node = node->parent;
 5892|     23|    }
 5893|      8|    return (ret);
 5894|      8|}
xmlSearchNs:
 5946|     36|xmlSearchNs(xmlDocPtr doc, xmlNodePtr node, const xmlChar *nameSpace) {
 5947|       |
 5948|     36|    xmlNsPtr cur;
 5949|     36|    const xmlNode *orig = node;
 5950|       |
 5951|     36|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL)) return(NULL);
  ------------------
  |  Branch (5951:9): [True: 0, False: 36]
  |  Branch (5951:27): [True: 0, False: 36]
  ------------------
 5952|     36|    if ((nameSpace != NULL) &&
  ------------------
  |  Branch (5952:9): [True: 36, False: 0]
  ------------------
 5953|     36|	(xmlStrEqual(nameSpace, (const xmlChar *)"xml"))) {
  ------------------
  |  Branch (5953:2): [True: 36, False: 0]
  ------------------
 5954|     36|	if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {
  ------------------
  |  Branch (5954:6): [True: 0, False: 36]
  |  Branch (5954:23): [True: 0, False: 0]
  ------------------
 5955|       |	    /*
 5956|       |	     * The XML-1.0 namespace is normally held on the root
 5957|       |	     * element. In this case exceptionally create it on the
 5958|       |	     * node element.
 5959|       |	     */
 5960|      0|	    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5961|      0|	    if (cur == NULL) {
  ------------------
  |  Branch (5961:10): [True: 0, False: 0]
  ------------------
 5962|      0|		xmlTreeErrMemory("searching namespace");
 5963|      0|		return(NULL);
 5964|      0|	    }
 5965|      0|	    memset(cur, 0, sizeof(xmlNs));
 5966|      0|	    cur->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      0|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5967|      0|	    cur->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5968|      0|	    cur->prefix = xmlStrdup((const xmlChar *)"xml");
 5969|      0|	    cur->next = node->nsDef;
 5970|      0|	    node->nsDef = cur;
 5971|      0|	    return(cur);
 5972|      0|	}
 5973|     36|	if (doc == NULL) {
  ------------------
  |  Branch (5973:6): [True: 0, False: 36]
  ------------------
 5974|      0|	    doc = node->doc;
 5975|      0|	    if (doc == NULL)
  ------------------
  |  Branch (5975:10): [True: 0, False: 0]
  ------------------
 5976|      0|		return(NULL);
 5977|      0|	}
 5978|       |	/*
 5979|       |	* Return the XML namespace declaration held by the doc.
 5980|       |	*/
 5981|     36|	if (doc->oldNs == NULL)
  ------------------
  |  Branch (5981:6): [True: 7, False: 29]
  ------------------
 5982|      7|	    return(xmlTreeEnsureXMLDecl(doc));
 5983|     29|	else
 5984|     29|	    return(doc->oldNs);
 5985|     36|    }
 5986|      0|    while (node != NULL) {
  ------------------
  |  Branch (5986:12): [True: 0, False: 0]
  ------------------
 5987|      0|	if ((node->type == XML_ENTITY_REF_NODE) ||
  ------------------
  |  Branch (5987:6): [True: 0, False: 0]
  ------------------
 5988|      0|	    (node->type == XML_ENTITY_NODE) ||
  ------------------
  |  Branch (5988:6): [True: 0, False: 0]
  ------------------
 5989|      0|	    (node->type == XML_ENTITY_DECL))
  ------------------
  |  Branch (5989:6): [True: 0, False: 0]
  ------------------
 5990|      0|	    return(NULL);
 5991|      0|	if (node->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (5991:6): [True: 0, False: 0]
  ------------------
 5992|      0|	    cur = node->nsDef;
 5993|      0|	    while (cur != NULL) {
  ------------------
  |  Branch (5993:13): [True: 0, False: 0]
  ------------------
 5994|      0|		if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (5994:7): [True: 0, False: 0]
  |  Branch (5994:32): [True: 0, False: 0]
  ------------------
 5995|      0|		    (cur->href != NULL))
  ------------------
  |  Branch (5995:7): [True: 0, False: 0]
  ------------------
 5996|      0|		    return(cur);
 5997|      0|		if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (5997:7): [True: 0, False: 0]
  |  Branch (5997:32): [True: 0, False: 0]
  ------------------
 5998|      0|		    (cur->href != NULL) &&
  ------------------
  |  Branch (5998:7): [True: 0, False: 0]
  ------------------
 5999|      0|		    (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (5999:7): [True: 0, False: 0]
  ------------------
 6000|      0|		    return(cur);
 6001|      0|		cur = cur->next;
 6002|      0|	    }
 6003|      0|	    if (orig != node) {
  ------------------
  |  Branch (6003:10): [True: 0, False: 0]
  ------------------
 6004|      0|	        cur = node->ns;
 6005|      0|	        if (cur != NULL) {
  ------------------
  |  Branch (6005:14): [True: 0, False: 0]
  ------------------
 6006|      0|		    if ((cur->prefix == NULL) && (nameSpace == NULL) &&
  ------------------
  |  Branch (6006:11): [True: 0, False: 0]
  |  Branch (6006:36): [True: 0, False: 0]
  ------------------
 6007|      0|		        (cur->href != NULL))
  ------------------
  |  Branch (6007:11): [True: 0, False: 0]
  ------------------
 6008|      0|		        return(cur);
 6009|      0|		    if ((cur->prefix != NULL) && (nameSpace != NULL) &&
  ------------------
  |  Branch (6009:11): [True: 0, False: 0]
  |  Branch (6009:36): [True: 0, False: 0]
  ------------------
 6010|      0|		        (cur->href != NULL) &&
  ------------------
  |  Branch (6010:11): [True: 0, False: 0]
  ------------------
 6011|      0|		        (xmlStrEqual(cur->prefix, nameSpace)))
  ------------------
  |  Branch (6011:11): [True: 0, False: 0]
  ------------------
 6012|      0|		        return(cur);
 6013|      0|	        }
 6014|      0|	    }
 6015|      0|	}
 6016|      0|	node = node->parent;
 6017|      0|    }
 6018|      0|    return(NULL);
 6019|      0|}
xmlGetNsProp:
 6710|    130|xmlGetNsProp(const xmlNode *node, const xmlChar *name, const xmlChar *nameSpace) {
 6711|    130|    xmlAttrPtr prop;
 6712|       |
 6713|    130|    prop = xmlGetPropNodeInternal(node, name, nameSpace, xmlCheckDTD);
 6714|    130|    if (prop == NULL)
  ------------------
  |  Branch (6714:9): [True: 75, False: 55]
  ------------------
 6715|     75|	return(NULL);
 6716|     55|    return(xmlGetPropNodeValueInternal(prop));
 6717|    130|}
tree.c:xmlGetLineNoInternal:
 4579|    110|{
 4580|    110|    long result = -1;
 4581|       |
 4582|    110|    if (depth >= 5)
  ------------------
  |  Branch (4582:9): [True: 0, False: 110]
  ------------------
 4583|      0|        return(-1);
 4584|       |
 4585|    110|    if (!node)
  ------------------
  |  Branch (4585:9): [True: 0, False: 110]
  ------------------
 4586|      0|        return result;
 4587|    110|    if ((node->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4587:9): [True: 110, False: 0]
  ------------------
 4588|    110|        (node->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4588:9): [True: 0, False: 0]
  ------------------
 4589|    110|	(node->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4589:2): [True: 0, False: 0]
  ------------------
 4590|    110|	(node->type == XML_PI_NODE)) {
  ------------------
  |  Branch (4590:2): [True: 0, False: 0]
  ------------------
 4591|    110|	if (node->line == 65535) {
  ------------------
  |  Branch (4591:6): [True: 0, False: 110]
  ------------------
 4592|      0|	    if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))
  ------------------
  |  Branch (4592:10): [True: 0, False: 0]
  |  Branch (4592:43): [True: 0, False: 0]
  ------------------
 4593|      0|	        result = (long) (ptrdiff_t) node->psvi;
 4594|      0|	    else if ((node->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (4594:15): [True: 0, False: 0]
  ------------------
 4595|      0|	             (node->children != NULL))
  ------------------
  |  Branch (4595:15): [True: 0, False: 0]
  ------------------
 4596|      0|	        result = xmlGetLineNoInternal(node->children, depth + 1);
 4597|      0|	    else if (node->next != NULL)
  ------------------
  |  Branch (4597:15): [True: 0, False: 0]
  ------------------
 4598|      0|	        result = xmlGetLineNoInternal(node->next, depth + 1);
 4599|      0|	    else if (node->prev != NULL)
  ------------------
  |  Branch (4599:15): [True: 0, False: 0]
  ------------------
 4600|      0|	        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4601|      0|	}
 4602|    110|	if ((result == -1) || (result == 65535))
  ------------------
  |  Branch (4602:6): [True: 110, False: 0]
  |  Branch (4602:24): [True: 0, False: 0]
  ------------------
 4603|    110|	    result = (long) node->line;
 4604|    110|    } else if ((node->prev != NULL) &&
  ------------------
  |  Branch (4604:16): [True: 0, False: 0]
  ------------------
 4605|      0|             ((node->prev->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (4605:15): [True: 0, False: 0]
  ------------------
 4606|      0|	      (node->prev->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (4606:8): [True: 0, False: 0]
  ------------------
 4607|      0|	      (node->prev->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (4607:8): [True: 0, False: 0]
  ------------------
 4608|      0|	      (node->prev->type == XML_PI_NODE)))
  ------------------
  |  Branch (4608:8): [True: 0, False: 0]
  ------------------
 4609|      0|        result = xmlGetLineNoInternal(node->prev, depth + 1);
 4610|      0|    else if ((node->parent != NULL) &&
  ------------------
  |  Branch (4610:14): [True: 0, False: 0]
  ------------------
 4611|      0|             (node->parent->type == XML_ELEMENT_NODE))
  ------------------
  |  Branch (4611:14): [True: 0, False: 0]
  ------------------
 4612|      0|        result = xmlGetLineNoInternal(node->parent, depth + 1);
 4613|       |
 4614|    110|    return result;
 4615|    110|}
tree.c:xmlTreeEnsureXMLDecl:
 5907|      7|{
 5908|      7|    if (doc == NULL)
  ------------------
  |  Branch (5908:9): [True: 0, False: 7]
  ------------------
 5909|      0|	return (NULL);
 5910|      7|    if (doc->oldNs != NULL)
  ------------------
  |  Branch (5910:9): [True: 0, False: 7]
  ------------------
 5911|      0|	return (doc->oldNs);
 5912|      7|    {
 5913|      7|	xmlNsPtr ns;
 5914|      7|	ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 5915|      7|	if (ns == NULL) {
  ------------------
  |  Branch (5915:6): [True: 0, False: 7]
  ------------------
 5916|      0|	    xmlTreeErrMemory(
 5917|      0|		"allocating the XML namespace");
 5918|      0|	    return (NULL);
 5919|      0|	}
 5920|      7|	memset(ns, 0, sizeof(xmlNs));
 5921|      7|	ns->type = XML_LOCAL_NAMESPACE;
  ------------------
  |  |  370|      7|#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
  ------------------
 5922|      7|	ns->href = xmlStrdup(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      7|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 5923|      7|	ns->prefix = xmlStrdup((const xmlChar *)"xml");
 5924|      7|	doc->oldNs = ns;
 5925|      7|	return (ns);
 5926|      7|    }
 5927|      7|}
tree.c:xmlGetPropNodeValueInternal:
 6538|    100|{
 6539|    100|    if (prop == NULL)
  ------------------
  |  Branch (6539:9): [True: 0, False: 100]
  ------------------
 6540|      0|	return(NULL);
 6541|    100|    if (prop->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (6541:9): [True: 100, False: 0]
  ------------------
 6542|       |	/*
 6543|       |	* Note that we return at least the empty string.
 6544|       |	*   TODO: Do we really always want that?
 6545|       |	*/
 6546|    100|	if (prop->children != NULL) {
  ------------------
  |  Branch (6546:6): [True: 100, False: 0]
  ------------------
 6547|    100|	    if ((prop->children->next == NULL) &&
  ------------------
  |  Branch (6547:10): [True: 100, False: 0]
  ------------------
 6548|    100|		((prop->children->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (6548:4): [True: 100, False: 0]
  ------------------
 6549|    100|		(prop->children->type == XML_CDATA_SECTION_NODE)))
  ------------------
  |  Branch (6549:3): [True: 0, False: 0]
  ------------------
 6550|    100|	    {
 6551|       |		/*
 6552|       |		* Optimization for the common case: only 1 text node.
 6553|       |		*/
 6554|    100|		return(xmlStrdup(prop->children->content));
 6555|    100|	    } else {
 6556|      0|		xmlChar *ret;
 6557|       |
 6558|      0|		ret = xmlNodeListGetString(prop->doc, prop->children, 1);
 6559|      0|		if (ret != NULL)
  ------------------
  |  Branch (6559:7): [True: 0, False: 0]
  ------------------
 6560|      0|		    return(ret);
 6561|      0|	    }
 6562|    100|	}
 6563|      0|	return(xmlStrdup((xmlChar *)""));
 6564|    100|    } else if (prop->type == XML_ATTRIBUTE_DECL) {
  ------------------
  |  Branch (6564:16): [True: 0, False: 0]
  ------------------
 6565|      0|	return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));
 6566|      0|    }
 6567|      0|    return(NULL);
 6568|    100|}
tree.c:xmlGetPropNodeInternal:
 6412|    130|{
 6413|    130|    xmlAttrPtr prop;
 6414|       |
 6415|       |    /* Avoid unused variable warning if features are disabled. */
 6416|    130|    (void) useDTD;
 6417|       |
 6418|    130|    if ((node == NULL) || (node->type != XML_ELEMENT_NODE) || (name == NULL))
  ------------------
  |  Branch (6418:9): [True: 0, False: 130]
  |  Branch (6418:27): [True: 21, False: 109]
  |  Branch (6418:63): [True: 0, False: 109]
  ------------------
 6419|     21|	return(NULL);
 6420|       |
 6421|    109|    if (node->properties != NULL) {
  ------------------
  |  Branch (6421:9): [True: 55, False: 54]
  ------------------
 6422|     55|	prop = node->properties;
 6423|     55|	if (nsName == NULL) {
  ------------------
  |  Branch (6423:6): [True: 0, False: 55]
  ------------------
 6424|       |	    /*
 6425|       |	    * We want the attr to be in no namespace.
 6426|       |	    */
 6427|      0|	    do {
 6428|      0|		if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {
  ------------------
  |  Branch (6428:7): [True: 0, False: 0]
  |  Branch (6428:29): [True: 0, False: 0]
  ------------------
 6429|      0|		    return(prop);
 6430|      0|		}
 6431|      0|		prop = prop->next;
 6432|      0|	    } while (prop != NULL);
  ------------------
  |  Branch (6432:15): [True: 0, False: 0]
  ------------------
 6433|     55|	} else {
 6434|       |	    /*
 6435|       |	    * We want the attr to be in the specified namespace.
 6436|       |	    */
 6437|     55|	    do {
 6438|     55|		if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&
  ------------------
  |  Branch (6438:7): [True: 55, False: 0]
  |  Branch (6438:29): [True: 55, False: 0]
  ------------------
 6439|     55|		    ((prop->ns->href == nsName) ||
  ------------------
  |  Branch (6439:8): [True: 0, False: 55]
  ------------------
 6440|     55|		     xmlStrEqual(prop->ns->href, nsName)))
  ------------------
  |  Branch (6440:8): [True: 55, False: 0]
  ------------------
 6441|     55|		{
 6442|     55|		    return(prop);
 6443|     55|		}
 6444|      0|		prop = prop->next;
 6445|      0|	    } while (prop != NULL);
  ------------------
  |  Branch (6445:15): [True: 0, False: 0]
  ------------------
 6446|     55|	}
 6447|     55|    }
 6448|       |
 6449|     54|#ifdef LIBXML_TREE_ENABLED
 6450|     54|    if (! useDTD)
  ------------------
  |  Branch (6450:9): [True: 0, False: 54]
  ------------------
 6451|      0|	return(NULL);
 6452|       |    /*
 6453|       |     * Check if there is a default/fixed attribute declaration in
 6454|       |     * the internal or external subset.
 6455|       |     */
 6456|     54|    if ((node->doc != NULL) && (node->doc->intSubset != NULL)) {
  ------------------
  |  Branch (6456:9): [True: 54, False: 0]
  |  Branch (6456:32): [True: 0, False: 54]
  ------------------
 6457|      0|	xmlDocPtr doc = node->doc;
 6458|      0|	xmlAttributePtr attrDecl = NULL;
 6459|      0|	xmlChar *elemQName, *tmpstr = NULL;
 6460|       |
 6461|       |	/*
 6462|       |	* We need the QName of the element for the DTD-lookup.
 6463|       |	*/
 6464|      0|	if ((node->ns != NULL) && (node->ns->prefix != NULL)) {
  ------------------
  |  Branch (6464:6): [True: 0, False: 0]
  |  Branch (6464:28): [True: 0, False: 0]
  ------------------
 6465|      0|	    tmpstr = xmlStrdup(node->ns->prefix);
 6466|      0|	    tmpstr = xmlStrcat(tmpstr, BAD_CAST ":");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6467|      0|	    tmpstr = xmlStrcat(tmpstr, node->name);
 6468|      0|	    if (tmpstr == NULL)
  ------------------
  |  Branch (6468:10): [True: 0, False: 0]
  ------------------
 6469|      0|		return(NULL);
 6470|      0|	    elemQName = tmpstr;
 6471|      0|	} else
 6472|      0|	    elemQName = (xmlChar *) node->name;
 6473|      0|	if (nsName == NULL) {
  ------------------
  |  Branch (6473:6): [True: 0, False: 0]
  ------------------
 6474|       |	    /*
 6475|       |	    * The common and nice case: Attr in no namespace.
 6476|       |	    */
 6477|      0|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6478|      0|		elemQName, name, NULL);
 6479|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6479:10): [True: 0, False: 0]
  |  Branch (6479:32): [True: 0, False: 0]
  ------------------
 6480|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6481|      0|		    elemQName, name, NULL);
 6482|      0|	    }
 6483|      0|        } else if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
  |  Branch (6483:20): [True: 0, False: 0]
  ------------------
 6484|       |	    /*
 6485|       |	    * The XML namespace must be bound to prefix 'xml'.
 6486|       |	    */
 6487|      0|	    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,
 6488|      0|		elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6489|      0|	    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {
  ------------------
  |  Branch (6489:10): [True: 0, False: 0]
  |  Branch (6489:32): [True: 0, False: 0]
  ------------------
 6490|      0|		attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,
 6491|      0|		    elemQName, name, BAD_CAST "xml");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 6492|      0|	    }
 6493|      0|	} else {
 6494|      0|	    xmlNsPtr *nsList, *cur;
 6495|       |
 6496|       |	    /*
 6497|       |	    * The ugly case: Search using the prefixes of in-scope
 6498|       |	    * ns-decls corresponding to @nsName.
 6499|       |	    */
 6500|      0|	    nsList = xmlGetNsList(node->doc, node);
 6501|      0|	    if (nsList == NULL) {
  ------------------
  |  Branch (6501:10): [True: 0, False: 0]
  ------------------
 6502|      0|		if (tmpstr != NULL)
  ------------------
  |  Branch (6502:7): [True: 0, False: 0]
  ------------------
 6503|      0|		    xmlFree(tmpstr);
 6504|      0|		return(NULL);
 6505|      0|	    }
 6506|      0|	    cur = nsList;
 6507|      0|	    while (*cur != NULL) {
  ------------------
  |  Branch (6507:13): [True: 0, False: 0]
  ------------------
 6508|      0|		if (xmlStrEqual((*cur)->href, nsName)) {
  ------------------
  |  Branch (6508:7): [True: 0, False: 0]
  ------------------
 6509|      0|		    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,
 6510|      0|			name, (*cur)->prefix);
 6511|      0|		    if (attrDecl)
  ------------------
  |  Branch (6511:11): [True: 0, False: 0]
  ------------------
 6512|      0|			break;
 6513|      0|		    if (doc->extSubset != NULL) {
  ------------------
  |  Branch (6513:11): [True: 0, False: 0]
  ------------------
 6514|      0|			attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,
 6515|      0|			    name, (*cur)->prefix);
 6516|      0|			if (attrDecl)
  ------------------
  |  Branch (6516:8): [True: 0, False: 0]
  ------------------
 6517|      0|			    break;
 6518|      0|		    }
 6519|      0|		}
 6520|      0|		cur++;
 6521|      0|	    }
 6522|      0|	    xmlFree(nsList);
 6523|      0|	}
 6524|      0|	if (tmpstr != NULL)
  ------------------
  |  Branch (6524:6): [True: 0, False: 0]
  ------------------
 6525|      0|	    xmlFree(tmpstr);
 6526|       |	/*
 6527|       |	* Only default/fixed attrs are relevant.
 6528|       |	*/
 6529|      0|	if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))
  ------------------
  |  Branch (6529:6): [True: 0, False: 0]
  |  Branch (6529:28): [True: 0, False: 0]
  ------------------
 6530|      0|	    return((xmlAttrPtr) attrDecl);
 6531|      0|    }
 6532|     54|#endif /* LIBXML_TREE_ENABLED */
 6533|     54|    return(NULL);
 6534|     54|}

xmlParseURI:
  947|     18|xmlParseURI(const char *str) {
  948|     18|    xmlURIPtr uri;
  949|     18|    int ret;
  950|       |
  951|     18|    if (str == NULL)
  ------------------
  |  Branch (951:9): [True: 0, False: 18]
  ------------------
  952|      0|	return(NULL);
  953|     18|    uri = xmlCreateURI();
  954|     18|    if (uri != NULL) {
  ------------------
  |  Branch (954:9): [True: 18, False: 0]
  ------------------
  955|     18|	ret = xmlParse3986URIReference(uri, str);
  956|     18|        if (ret) {
  ------------------
  |  Branch (956:13): [True: 1, False: 17]
  ------------------
  957|      1|	    xmlFreeURI(uri);
  958|      1|	    return(NULL);
  959|      1|	}
  960|     18|    }
  961|     17|    return(uri);
  962|     18|}
xmlCreateURI:
 1027|     18|xmlCreateURI(void) {
 1028|     18|    xmlURIPtr ret;
 1029|       |
 1030|     18|    ret = (xmlURIPtr) xmlMalloc(sizeof(xmlURI));
 1031|     18|    if (ret == NULL) {
  ------------------
  |  Branch (1031:9): [True: 0, False: 18]
  ------------------
 1032|      0|        xmlURIErrMemory("creating URI structure\n");
 1033|      0|	return(NULL);
 1034|      0|    }
 1035|     18|    memset(ret, 0, sizeof(xmlURI));
 1036|     18|    ret->port = PORT_EMPTY;
  ------------------
  |  |   37|     18|#define PORT_EMPTY           0
  ------------------
 1037|     18|    return(ret);
 1038|     18|}
xmlFreeURI:
 1396|     18|xmlFreeURI(xmlURIPtr uri) {
 1397|     18|    if (uri == NULL) return;
  ------------------
  |  Branch (1397:9): [True: 0, False: 18]
  ------------------
 1398|       |
 1399|     18|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1399:9): [True: 5, False: 13]
  ------------------
 1400|     18|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1400:9): [True: 5, False: 13]
  ------------------
 1401|     18|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1401:9): [True: 0, False: 18]
  ------------------
 1402|     18|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1402:9): [True: 17, False: 1]
  ------------------
 1403|     18|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1403:9): [True: 0, False: 18]
  ------------------
 1404|     18|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1404:9): [True: 0, False: 18]
  ------------------
 1405|     18|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1405:9): [True: 0, False: 18]
  ------------------
 1406|     18|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1406:9): [True: 0, False: 18]
  ------------------
 1407|     18|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1407:9): [True: 0, False: 18]
  ------------------
 1408|     18|    xmlFree(uri);
 1409|     18|}
xmlURIUnescapeString:
 1629|     24|xmlURIUnescapeString(const char *str, int len, char *target) {
 1630|     24|    char *ret, *out;
 1631|     24|    const char *in;
 1632|       |
 1633|     24|    if (str == NULL)
  ------------------
  |  Branch (1633:9): [True: 0, False: 24]
  ------------------
 1634|      0|	return(NULL);
 1635|     24|    if (len <= 0) len = strlen(str);
  ------------------
  |  Branch (1635:9): [True: 0, False: 24]
  ------------------
 1636|     24|    if (len < 0) return(NULL);
  ------------------
  |  Branch (1636:9): [True: 0, False: 24]
  ------------------
 1637|       |
 1638|     24|    if (target == NULL) {
  ------------------
  |  Branch (1638:9): [True: 24, False: 0]
  ------------------
 1639|     24|	ret = (char *) xmlMallocAtomic(len + 1);
 1640|     24|	if (ret == NULL) {
  ------------------
  |  Branch (1640:6): [True: 0, False: 24]
  ------------------
 1641|      0|            xmlURIErrMemory("unescaping URI value\n");
 1642|      0|	    return(NULL);
 1643|      0|	}
 1644|     24|    } else
 1645|      0|	ret = target;
 1646|     24|    in = str;
 1647|     24|    out = ret;
 1648|    125|    while(len > 0) {
  ------------------
  |  Branch (1648:11): [True: 101, False: 24]
  ------------------
 1649|    101|	if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {
  ------------------
  |  Branch (1649:6): [True: 59, False: 42]
  |  Branch (1649:19): [True: 0, False: 59]
  |  Branch (1649:35): [True: 0, False: 0]
  |  Branch (1649:54): [True: 0, False: 0]
  ------------------
 1650|      0|            int c = 0;
 1651|      0|	    in++;
 1652|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1652:10): [True: 0, False: 0]
  |  Branch (1652:26): [True: 0, False: 0]
  ------------------
 1653|      0|	        c = (*in - '0');
 1654|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1654:15): [True: 0, False: 0]
  |  Branch (1654:31): [True: 0, False: 0]
  ------------------
 1655|      0|	        c = (*in - 'a') + 10;
 1656|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1656:15): [True: 0, False: 0]
  |  Branch (1656:31): [True: 0, False: 0]
  ------------------
 1657|      0|	        c = (*in - 'A') + 10;
 1658|      0|	    in++;
 1659|      0|	    if ((*in >= '0') && (*in <= '9'))
  ------------------
  |  Branch (1659:10): [True: 0, False: 0]
  |  Branch (1659:26): [True: 0, False: 0]
  ------------------
 1660|      0|	        c = c * 16 + (*in - '0');
 1661|      0|	    else if ((*in >= 'a') && (*in <= 'f'))
  ------------------
  |  Branch (1661:15): [True: 0, False: 0]
  |  Branch (1661:31): [True: 0, False: 0]
  ------------------
 1662|      0|	        c = c * 16 + (*in - 'a') + 10;
 1663|      0|	    else if ((*in >= 'A') && (*in <= 'F'))
  ------------------
  |  Branch (1663:15): [True: 0, False: 0]
  |  Branch (1663:31): [True: 0, False: 0]
  ------------------
 1664|      0|	        c = c * 16 + (*in - 'A') + 10;
 1665|      0|	    in++;
 1666|      0|	    len -= 3;
 1667|       |            /* Explicit sign change */
 1668|      0|	    *out++ = (char) c;
 1669|    101|	} else {
 1670|    101|	    *out++ = *in++;
 1671|    101|	    len--;
 1672|    101|	}
 1673|    101|    }
 1674|     24|    *out = 0;
 1675|     24|    return(ret);
 1676|     24|}
uri.c:xmlParse3986URIReference:
  913|     18|xmlParse3986URIReference(xmlURIPtr uri, const char *str) {
  914|     18|    int ret;
  915|       |
  916|     18|    if (str == NULL)
  ------------------
  |  Branch (916:9): [True: 0, False: 18]
  ------------------
  917|      0|	return(-1);
  918|     18|    xmlCleanURI(uri);
  919|       |
  920|       |    /*
  921|       |     * Try first to parse absolute refs, then fallback to relative if
  922|       |     * it fails.
  923|       |     */
  924|     18|    ret = xmlParse3986URI(uri, str);
  925|     18|    if (ret != 0) {
  ------------------
  |  Branch (925:9): [True: 13, False: 5]
  ------------------
  926|     13|	xmlCleanURI(uri);
  927|     13|        ret = xmlParse3986RelativeRef(uri, str);
  928|     13|	if (ret != 0) {
  ------------------
  |  Branch (928:6): [True: 1, False: 12]
  ------------------
  929|      1|	    xmlCleanURI(uri);
  930|      1|	    return(ret);
  931|      1|	}
  932|     13|    }
  933|     17|    return(0);
  934|     18|}
uri.c:xmlCleanURI:
 1366|     34|xmlCleanURI(xmlURIPtr uri) {
 1367|     34|    if (uri == NULL) return;
  ------------------
  |  Branch (1367:9): [True: 0, False: 34]
  ------------------
 1368|       |
 1369|     34|    if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (1369:9): [True: 13, False: 21]
  ------------------
 1370|     34|    uri->scheme = NULL;
 1371|     34|    if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (1371:9): [True: 0, False: 34]
  ------------------
 1372|     34|    uri->server = NULL;
 1373|     34|    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (1373:9): [True: 0, False: 34]
  ------------------
 1374|     34|    uri->user = NULL;
 1375|     34|    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (1375:9): [True: 2, False: 32]
  ------------------
 1376|     34|    uri->path = NULL;
 1377|     34|    if (uri->fragment != NULL) xmlFree(uri->fragment);
  ------------------
  |  Branch (1377:9): [True: 0, False: 34]
  ------------------
 1378|     34|    uri->fragment = NULL;
 1379|     34|    if (uri->opaque != NULL) xmlFree(uri->opaque);
  ------------------
  |  Branch (1379:9): [True: 0, False: 34]
  ------------------
 1380|     34|    uri->opaque = NULL;
 1381|     34|    if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (1381:9): [True: 0, False: 34]
  ------------------
 1382|     34|    uri->authority = NULL;
 1383|     34|    if (uri->query != NULL) xmlFree(uri->query);
  ------------------
  |  Branch (1383:9): [True: 0, False: 34]
  ------------------
 1384|     34|    uri->query = NULL;
 1385|     34|    if (uri->query_raw != NULL) xmlFree(uri->query_raw);
  ------------------
  |  Branch (1385:9): [True: 0, False: 34]
  ------------------
 1386|     34|    uri->query_raw = NULL;
 1387|     34|}
uri.c:xmlParse3986URI:
  872|     18|xmlParse3986URI(xmlURIPtr uri, const char *str) {
  873|     18|    int ret;
  874|       |
  875|     18|    ret = xmlParse3986Scheme(uri, &str);
  876|     18|    if (ret != 0) return(ret);
  ------------------
  |  Branch (876:9): [True: 0, False: 18]
  ------------------
  877|     18|    if (*str != ':') {
  ------------------
  |  Branch (877:9): [True: 12, False: 6]
  ------------------
  878|     12|	return(1);
  879|     12|    }
  880|      6|    str++;
  881|      6|    ret = xmlParse3986HierPart(uri, &str);
  882|      6|    if (ret != 0) return(ret);
  ------------------
  |  Branch (882:9): [True: 0, False: 6]
  ------------------
  883|      6|    if (*str == '?') {
  ------------------
  |  Branch (883:9): [True: 0, False: 6]
  ------------------
  884|      0|	str++;
  885|      0|	ret = xmlParse3986Query(uri, &str);
  886|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (886:6): [True: 0, False: 0]
  ------------------
  887|      0|    }
  888|      6|    if (*str == '#') {
  ------------------
  |  Branch (888:9): [True: 0, False: 6]
  ------------------
  889|      0|	str++;
  890|      0|	ret = xmlParse3986Fragment(uri, &str);
  891|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (891:6): [True: 0, False: 0]
  ------------------
  892|      0|    }
  893|      6|    if (*str != 0) {
  ------------------
  |  Branch (893:9): [True: 1, False: 5]
  ------------------
  894|      1|	xmlCleanURI(uri);
  895|      1|	return(1);
  896|      1|    }
  897|      5|    return(0);
  898|      6|}
uri.c:xmlParse3986Scheme:
  213|     18|xmlParse3986Scheme(xmlURIPtr uri, const char **str) {
  214|     18|    const char *cur;
  215|       |
  216|     18|    if (str == NULL)
  ------------------
  |  Branch (216:9): [True: 0, False: 18]
  ------------------
  217|      0|	return(-1);
  218|       |
  219|     18|    cur = *str;
  220|     18|    if (!ISA_ALPHA(cur))
  ------------------
  |  |  152|     18|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 18, False: 0]
  |  |  |  Branch (152:41): [True: 18, False: 0]
  |  |  ------------------
  |  |  153|     18|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 0, False: 0]
  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  221|      0|	return(2);
  222|     18|    cur++;
  223|     90|    while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  152|    180|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  ------------------
  |  |  |  Branch (152:24): [True: 60, False: 30]
  |  |  |  Branch (152:41): [True: 60, False: 0]
  |  |  ------------------
  |  |  153|    180|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  ------------------
  |  |  |  Branch (153:24): [True: 0, False: 30]
  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  ------------------
  ------------------
                  while (ISA_ALPHA(cur) || ISA_DIGIT(cur) ||
  ------------------
  |  |  151|    120|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 18, False: 12]
  |  |  |  Branch (151:40): [True: 12, False: 6]
  |  |  ------------------
  ------------------
  224|     90|           (*cur == '+') || (*cur == '-') || (*cur == '.')) cur++;
  ------------------
  |  Branch (224:12): [True: 0, False: 18]
  |  Branch (224:29): [True: 0, False: 18]
  |  Branch (224:46): [True: 0, False: 18]
  ------------------
  225|     18|    if (uri != NULL) {
  ------------------
  |  Branch (225:9): [True: 18, False: 0]
  ------------------
  226|     18|	if (uri->scheme != NULL) xmlFree(uri->scheme);
  ------------------
  |  Branch (226:6): [True: 0, False: 18]
  ------------------
  227|     18|	uri->scheme = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|     18|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  228|     18|    }
  229|     18|    *str = cur;
  230|     18|    return(0);
  231|     18|}
uri.c:xmlParse3986HierPart:
  765|      6|{
  766|      6|    const char *cur;
  767|      6|    int ret;
  768|       |
  769|      6|    cur = *str;
  770|       |
  771|      6|    if ((*cur == '/') && (*(cur + 1) == '/')) {
  ------------------
  |  Branch (771:9): [True: 6, False: 0]
  |  Branch (771:26): [True: 5, False: 1]
  ------------------
  772|      5|        cur += 2;
  773|      5|	ret = xmlParse3986Authority(uri, &cur);
  774|      5|	if (ret != 0) return(ret);
  ------------------
  |  Branch (774:6): [True: 0, False: 5]
  ------------------
  775|       |        /*
  776|       |         * An empty server is marked with a special URI value.
  777|       |         */
  778|      5|	if ((uri->server == NULL) && (uri->port == PORT_EMPTY))
  ------------------
  |  |   37|      0|#define PORT_EMPTY           0
  ------------------
  |  Branch (778:6): [True: 0, False: 5]
  |  Branch (778:31): [True: 0, False: 0]
  ------------------
  779|      0|	    uri->port = PORT_EMPTY_SERVER;
  ------------------
  |  |   38|      0|#define PORT_EMPTY_SERVER   -1
  ------------------
  780|      5|	ret = xmlParse3986PathAbEmpty(uri, &cur);
  781|      5|	if (ret != 0) return(ret);
  ------------------
  |  Branch (781:6): [True: 0, False: 5]
  ------------------
  782|      5|	*str = cur;
  783|      5|	return(0);
  784|      5|    } else if (*cur == '/') {
  ------------------
  |  Branch (784:16): [True: 1, False: 0]
  ------------------
  785|      1|        ret = xmlParse3986PathAbsolute(uri, &cur);
  786|      1|	if (ret != 0) return(ret);
  ------------------
  |  Branch (786:6): [True: 0, False: 1]
  ------------------
  787|      1|    } else if (ISA_PCHAR(cur)) {
  ------------------
  |  |  198|      0|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|      0|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|      0|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (152:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|      0|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|      0|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|      0|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|      0|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|      0|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  788|      0|        ret = xmlParse3986PathRootless(uri, &cur);
  789|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (789:6): [True: 0, False: 0]
  ------------------
  790|      0|    } else {
  791|       |	/* path-empty is effectively empty */
  792|      0|	if (uri != NULL) {
  ------------------
  |  Branch (792:6): [True: 0, False: 0]
  ------------------
  793|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (793:10): [True: 0, False: 0]
  ------------------
  794|      0|	    uri->path = NULL;
  795|      0|	}
  796|      0|    }
  797|      1|    *str = cur;
  798|      1|    return (0);
  799|      6|}
uri.c:xmlParse3986Authority:
  521|      5|{
  522|      5|    const char *cur;
  523|      5|    int ret;
  524|       |
  525|      5|    cur = *str;
  526|       |    /*
  527|       |     * try to parse an userinfo and check for the trailing @
  528|       |     */
  529|      5|    ret = xmlParse3986Userinfo(uri, &cur);
  530|      5|    if ((ret != 0) || (*cur != '@'))
  ------------------
  |  Branch (530:9): [True: 5, False: 0]
  |  Branch (530:23): [True: 0, False: 0]
  ------------------
  531|      5|        cur = *str;
  532|      0|    else
  533|      0|        cur++;
  534|      5|    ret = xmlParse3986Host(uri, &cur);
  535|      5|    if (ret != 0) return(ret);
  ------------------
  |  Branch (535:9): [True: 0, False: 5]
  ------------------
  536|      5|    if (*cur == ':') {
  ------------------
  |  Branch (536:9): [True: 0, False: 5]
  ------------------
  537|      0|        cur++;
  538|      0|        ret = xmlParse3986Port(uri, &cur);
  539|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (539:6): [True: 0, False: 0]
  ------------------
  540|      0|    }
  541|      5|    *str = cur;
  542|      5|    return(0);
  543|      5|}
uri.c:xmlParse3986Userinfo:
  370|      5|{
  371|      5|    const char *cur;
  372|       |
  373|      5|    cur = *str;
  374|     10|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  185|     20|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|     10|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 5, False: 5]
  |  |  |  |  |  Branch (152:41): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|     10|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 5]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|      5|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 0, False: 5]
  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 5]
  |  |  ------------------
  |  |  186|     10|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 0, False: 5]
  |  |  |  Branch (186:27): [True: 0, False: 5]
  |  |  |  Branch (186:46): [True: 0, False: 5]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) ||
  ------------------
  |  |  192|     15|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  375|     10|           ISA_SUB_DELIM(cur) || (*cur == ':'))
  ------------------
  |  |  163|     15|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 5]
  |  |  |  Branch (163:27): [True: 0, False: 5]
  |  |  |  Branch (163:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  164|      5|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 5]
  |  |  |  Branch (164:27): [True: 0, False: 5]
  |  |  |  Branch (164:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  165|      5|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 5]
  |  |  |  Branch (165:27): [True: 0, False: 5]
  |  |  |  Branch (165:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  166|      5|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 5]
  |  |  |  Branch (166:27): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  |  Branch (375:34): [True: 0, False: 5]
  ------------------
  376|      5|	NEXT(cur);
  ------------------
  |  |  131|      5|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  377|      5|    if (*cur == '@') {
  ------------------
  |  Branch (377:9): [True: 0, False: 5]
  ------------------
  378|      0|	if (uri != NULL) {
  ------------------
  |  Branch (378:6): [True: 0, False: 0]
  ------------------
  379|      0|	    if (uri->user != NULL) xmlFree(uri->user);
  ------------------
  |  Branch (379:10): [True: 0, False: 0]
  ------------------
  380|      0|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (380:10): [True: 0, False: 0]
  ------------------
  381|      0|		uri->user = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  382|      0|	    else
  383|      0|		uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);
  384|      0|	}
  385|      0|	*str = cur;
  386|      0|	return(0);
  387|      0|    }
  388|      5|    return(1);
  389|      5|}
uri.c:xmlParse3986Host:
  445|      5|{
  446|      5|    const char *cur = *str;
  447|      5|    const char *host;
  448|       |
  449|      5|    host = cur;
  450|       |    /*
  451|       |     * IPv6 and future addressing scheme are enclosed between brackets
  452|       |     */
  453|      5|    if (*cur == '[') {
  ------------------
  |  Branch (453:9): [True: 0, False: 5]
  ------------------
  454|      0|        cur++;
  455|      0|	while ((*cur != ']') && (*cur != 0))
  ------------------
  |  Branch (455:9): [True: 0, False: 0]
  |  Branch (455:26): [True: 0, False: 0]
  ------------------
  456|      0|	    cur++;
  457|      0|	if (*cur != ']')
  ------------------
  |  Branch (457:6): [True: 0, False: 0]
  ------------------
  458|      0|	    return(1);
  459|      0|	cur++;
  460|      0|	goto found;
  461|      0|    }
  462|       |    /*
  463|       |     * try to parse an IPv4
  464|       |     */
  465|      5|    if (ISA_DIGIT(cur)) {
  ------------------
  |  |  151|      5|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  ------------------
  |  |  |  Branch (151:23): [True: 5, False: 0]
  |  |  |  Branch (151:40): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  466|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (466:13): [True: 0, False: 0]
  ------------------
  467|      0|	    goto not_ipv4;
  468|      0|	if (*cur != '.')
  ------------------
  |  Branch (468:6): [True: 0, False: 0]
  ------------------
  469|      0|	    goto not_ipv4;
  470|      0|	cur++;
  471|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (471:13): [True: 0, False: 0]
  ------------------
  472|      0|	    goto not_ipv4;
  473|      0|	if (*cur != '.')
  ------------------
  |  Branch (473:6): [True: 0, False: 0]
  ------------------
  474|      0|	    goto not_ipv4;
  475|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (475:13): [True: 0, False: 0]
  ------------------
  476|      0|	    goto not_ipv4;
  477|      0|	if (*cur != '.')
  ------------------
  |  Branch (477:6): [True: 0, False: 0]
  ------------------
  478|      0|	    goto not_ipv4;
  479|      0|        if (xmlParse3986DecOctet(&cur) != 0)
  ------------------
  |  Branch (479:13): [True: 0, False: 0]
  ------------------
  480|      0|	    goto not_ipv4;
  481|      0|	goto found;
  482|      0|not_ipv4:
  483|      0|        cur = *str;
  484|      0|    }
  485|       |    /*
  486|       |     * then this should be a hostname which can be empty
  487|       |     */
  488|     10|    while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  185|     20|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  152|     10|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:24): [True: 5, False: 5]
  |  |  |  |  |  Branch (152:41): [True: 5, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|     10|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (153:24): [True: 0, False: 5]
  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  ------------------
  |  |  |  |  151|      5|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (151:23): [True: 0, False: 5]
  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (185:44): [True: 0, False: 5]
  |  |  ------------------
  |  |  186|     10|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  ------------------
  |  |  |  Branch (186:8): [True: 0, False: 5]
  |  |  |  Branch (186:27): [True: 0, False: 5]
  |  |  |  Branch (186:46): [True: 0, False: 5]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  192|     15|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  ------------------
  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  |  Branch (192:7): [True: 0, False: 5]
  |  |  ------------------
  ------------------
                  while (ISA_UNRESERVED(cur) || ISA_PCT_ENCODED(cur) || ISA_SUB_DELIM(cur))
  ------------------
  |  |  163|      5|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  ------------------
  |  |  |  Branch (163:8): [True: 0, False: 5]
  |  |  |  Branch (163:27): [True: 0, False: 5]
  |  |  |  Branch (163:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  164|      5|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  ------------------
  |  |  |  Branch (164:8): [True: 0, False: 5]
  |  |  |  Branch (164:27): [True: 0, False: 5]
  |  |  |  Branch (164:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  165|      5|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  ------------------
  |  |  |  Branch (165:8): [True: 0, False: 5]
  |  |  |  Branch (165:27): [True: 0, False: 5]
  |  |  |  Branch (165:46): [True: 0, False: 5]
  |  |  ------------------
  |  |  166|      5|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  ------------------
  |  |  |  Branch (166:8): [True: 0, False: 5]
  |  |  |  Branch (166:27): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  489|      5|        NEXT(cur);
  ------------------
  |  |  131|     10|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 5]
  |  |  ------------------
  ------------------
  490|      5|found:
  491|      5|    if (uri != NULL) {
  ------------------
  |  Branch (491:9): [True: 5, False: 0]
  ------------------
  492|      5|	if (uri->authority != NULL) xmlFree(uri->authority);
  ------------------
  |  Branch (492:6): [True: 0, False: 5]
  ------------------
  493|      5|	uri->authority = NULL;
  494|      5|	if (uri->server != NULL) xmlFree(uri->server);
  ------------------
  |  Branch (494:6): [True: 0, False: 5]
  ------------------
  495|      5|	if (cur != host) {
  ------------------
  |  Branch (495:6): [True: 5, False: 0]
  ------------------
  496|      5|	    if (uri->cleanup & 2)
  ------------------
  |  Branch (496:10): [True: 0, False: 5]
  ------------------
  497|      0|		uri->server = STRNDUP(host, cur - host);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  498|      5|	    else
  499|      5|		uri->server = xmlURIUnescapeString(host, cur - host, NULL);
  500|      5|	} else
  501|      0|	    uri->server = NULL;
  502|      5|    }
  503|      5|    *str = cur;
  504|      5|    return(0);
  505|      5|}
uri.c:xmlParse3986PathAbEmpty:
  592|      5|{
  593|      5|    const char *cur;
  594|      5|    int ret;
  595|       |
  596|      5|    cur = *str;
  597|       |
  598|     10|    while (*cur == '/') {
  ------------------
  |  Branch (598:12): [True: 5, False: 5]
  ------------------
  599|      5|        cur++;
  600|      5|	ret = xmlParse3986Segment(&cur, 0, 1);
  601|      5|	if (ret != 0) return(ret);
  ------------------
  |  Branch (601:6): [True: 0, False: 5]
  ------------------
  602|      5|    }
  603|      5|    if (uri != NULL) {
  ------------------
  |  Branch (603:9): [True: 5, False: 0]
  ------------------
  604|      5|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (604:6): [True: 0, False: 5]
  ------------------
  605|      5|        if (*str != cur) {
  ------------------
  |  Branch (605:13): [True: 5, False: 0]
  ------------------
  606|      5|            if (uri->cleanup & 2)
  ------------------
  |  Branch (606:17): [True: 0, False: 5]
  ------------------
  607|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  608|      5|            else
  609|      5|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  610|      5|        } else {
  611|      0|            uri->path = NULL;
  612|      0|        }
  613|      5|    }
  614|      5|    *str = cur;
  615|      5|    return (0);
  616|      5|}
uri.c:xmlParse3986Segment:
  563|     19|{
  564|     19|    const char *cur;
  565|       |
  566|     19|    cur = *str;
  567|     19|    if (!ISA_PCHAR(cur)) {
  ------------------
  |  |  198|     19|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     38|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     19|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 18, False: 1]
  |  |  |  |  |  |  |  Branch (152:41): [True: 18, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     19|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      1|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 1]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  186|     19|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     20|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     20|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  164|      1|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  165|      1|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 1]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  |  |  166|      1|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 1]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 1]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     19|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 1]
  |  |  |  Branch (199:26): [True: 0, False: 1]
  |  |  ------------------
  ------------------
  568|      1|        if (empty)
  ------------------
  |  Branch (568:13): [True: 0, False: 1]
  ------------------
  569|      0|	    return(0);
  570|      1|	return(1);
  571|      1|    }
  572|    108|    while (ISA_PCHAR(cur) && (*cur != forbid))
  ------------------
  |  |  198|    216|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|    216|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|    108|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 73, False: 35]
  |  |  |  |  |  |  |  Branch (152:41): [True: 73, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|    108|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 35]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|     35|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 18, False: 17]
  |  |  |  |  |  |  |  Branch (151:40): [True: 12, False: 6]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  |  |  186|    108|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 23]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 23]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|    131|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|    131|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 23]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 23]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  |  |  164|     23|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 23]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 23]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  |  |  165|     23|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 23]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 23]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  |  |  166|     23|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 23]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 23]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|    108|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 6, False: 17]
  |  |  |  Branch (199:26): [True: 0, False: 17]
  |  |  ------------------
  ------------------
  |  Branch (572:30): [True: 90, False: 1]
  ------------------
  573|     90|        NEXT(cur);
  ------------------
  |  |  131|    108|#define NEXT(p) ((*p == '%')? p += 3 : p++)
  |  |  ------------------
  |  |  |  Branch (131:18): [True: 0, False: 90]
  |  |  ------------------
  ------------------
  574|     18|    *str = cur;
  575|     18|    return (0);
  576|     19|}
uri.c:xmlParse3986PathAbsolute:
  632|      1|{
  633|      1|    const char *cur;
  634|      1|    int ret;
  635|       |
  636|      1|    cur = *str;
  637|       |
  638|      1|    if (*cur != '/')
  ------------------
  |  Branch (638:9): [True: 0, False: 1]
  ------------------
  639|      0|        return(1);
  640|      1|    cur++;
  641|      1|    ret = xmlParse3986Segment(&cur, 0, 0);
  642|      1|    if (ret == 0) {
  ------------------
  |  Branch (642:9): [True: 0, False: 1]
  ------------------
  643|      0|	while (*cur == '/') {
  ------------------
  |  Branch (643:9): [True: 0, False: 0]
  ------------------
  644|      0|	    cur++;
  645|      0|	    ret = xmlParse3986Segment(&cur, 0, 1);
  646|      0|	    if (ret != 0) return(ret);
  ------------------
  |  Branch (646:10): [True: 0, False: 0]
  ------------------
  647|      0|	}
  648|      0|    }
  649|      1|    if (uri != NULL) {
  ------------------
  |  Branch (649:9): [True: 1, False: 0]
  ------------------
  650|      1|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (650:6): [True: 0, False: 1]
  ------------------
  651|      1|        if (cur != *str) {
  ------------------
  |  Branch (651:13): [True: 1, False: 0]
  ------------------
  652|      1|            if (uri->cleanup & 2)
  ------------------
  |  Branch (652:17): [True: 0, False: 1]
  ------------------
  653|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  654|      1|            else
  655|      1|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  656|      1|        } else {
  657|      0|            uri->path = NULL;
  658|      0|        }
  659|      1|    }
  660|      1|    *str = cur;
  661|      1|    return (0);
  662|      1|}
uri.c:xmlParse3986RelativeRef:
  818|     13|xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
  819|     13|    int ret;
  820|       |
  821|     13|    if ((*str == '/') && (*(str + 1) == '/')) {
  ------------------
  |  Branch (821:9): [True: 0, False: 13]
  |  Branch (821:26): [True: 0, False: 0]
  ------------------
  822|      0|        str += 2;
  823|      0|	ret = xmlParse3986Authority(uri, &str);
  824|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (824:6): [True: 0, False: 0]
  ------------------
  825|      0|	ret = xmlParse3986PathAbEmpty(uri, &str);
  826|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (826:6): [True: 0, False: 0]
  ------------------
  827|     13|    } else if (*str == '/') {
  ------------------
  |  Branch (827:16): [True: 0, False: 13]
  ------------------
  828|      0|	ret = xmlParse3986PathAbsolute(uri, &str);
  829|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (829:6): [True: 0, False: 0]
  ------------------
  830|     13|    } else if (ISA_PCHAR(str)) {
  ------------------
  |  |  198|     13|     (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  185|     26|      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  152|     13|#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (152:24): [True: 13, False: 0]
  |  |  |  |  |  |  |  Branch (152:41): [True: 13, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  153|     13|                      ((*(p) >= 'A') && (*(p) <= 'Z')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (153:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (153:41): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                     ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (185:44): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  186|     13|       ((*(p) == '.')) || ((*(p) == '_')) || ((*(p) == '~')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (186:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (186:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  192|     13|     ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |                    ((*(p) == '%') && (ISA_HEXDIG(p + 1)) && (ISA_HEXDIG(p + 2)))
  |  |  |  |  ------------------
  |  |  |  |  |  |  155|      0|       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||		\
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  151|      0|#define ISA_DIGIT(p) ((*(p) >= '0') && (*(p) <= '9'))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (151:23): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (151:40): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (155:26): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (155:43): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  156|      0|        ((*(p) >= 'A') && (*(p) <= 'F')))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (156:10): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (156:27): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (192:7): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                    (ISA_UNRESERVED(p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||	\
  |  |  ------------------
  |  |  |  |  163|     13|      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (163:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (163:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  164|      0|       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (164:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (164:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  165|      0|       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||		\
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (165:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:27): [True: 0, False: 0]
  |  |  |  |  |  Branch (165:46): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  166|      0|       ((*(p) == '=')) || ((*(p) == '\'')))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (166:8): [True: 0, False: 0]
  |  |  |  |  |  Branch (166:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  |  |  199|     13|      ((*(p) == ':')) || ((*(p) == '@')))
  |  |  ------------------
  |  |  |  Branch (199:7): [True: 0, False: 0]
  |  |  |  Branch (199:26): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  831|     13|        ret = xmlParse3986PathNoScheme(uri, &str);
  832|     13|	if (ret != 0) return(ret);
  ------------------
  |  Branch (832:6): [True: 0, False: 13]
  ------------------
  833|     13|    } else {
  834|       |	/* path-empty is effectively empty */
  835|      0|	if (uri != NULL) {
  ------------------
  |  Branch (835:6): [True: 0, False: 0]
  ------------------
  836|      0|	    if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (836:10): [True: 0, False: 0]
  ------------------
  837|      0|	    uri->path = NULL;
  838|      0|	}
  839|      0|    }
  840|       |
  841|     13|    if (*str == '?') {
  ------------------
  |  Branch (841:9): [True: 0, False: 13]
  ------------------
  842|      0|	str++;
  843|      0|	ret = xmlParse3986Query(uri, &str);
  844|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (844:6): [True: 0, False: 0]
  ------------------
  845|      0|    }
  846|     13|    if (*str == '#') {
  ------------------
  |  Branch (846:9): [True: 0, False: 13]
  ------------------
  847|      0|	str++;
  848|      0|	ret = xmlParse3986Fragment(uri, &str);
  849|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (849:6): [True: 0, False: 0]
  ------------------
  850|      0|    }
  851|     13|    if (*str != 0) {
  ------------------
  |  Branch (851:9): [True: 1, False: 12]
  ------------------
  852|      1|	xmlCleanURI(uri);
  853|      1|	return(1);
  854|      1|    }
  855|     12|    return(0);
  856|     13|}
uri.c:xmlParse3986PathNoScheme:
  720|     13|{
  721|     13|    const char *cur;
  722|     13|    int ret;
  723|       |
  724|     13|    cur = *str;
  725|       |
  726|     13|    ret = xmlParse3986Segment(&cur, ':', 0);
  727|     13|    if (ret != 0) return(ret);
  ------------------
  |  Branch (727:9): [True: 0, False: 13]
  ------------------
  728|     13|    while (*cur == '/') {
  ------------------
  |  Branch (728:12): [True: 0, False: 13]
  ------------------
  729|      0|        cur++;
  730|      0|	ret = xmlParse3986Segment(&cur, 0, 1);
  731|      0|	if (ret != 0) return(ret);
  ------------------
  |  Branch (731:6): [True: 0, False: 0]
  ------------------
  732|      0|    }
  733|     13|    if (uri != NULL) {
  ------------------
  |  Branch (733:9): [True: 13, False: 0]
  ------------------
  734|     13|	if (uri->path != NULL) xmlFree(uri->path);
  ------------------
  |  Branch (734:6): [True: 0, False: 13]
  ------------------
  735|     13|        if (cur != *str) {
  ------------------
  |  Branch (735:13): [True: 13, False: 0]
  ------------------
  736|     13|            if (uri->cleanup & 2)
  ------------------
  |  Branch (736:17): [True: 0, False: 13]
  ------------------
  737|      0|                uri->path = STRNDUP(*str, cur - *str);
  ------------------
  |  |  143|      0|#define STRNDUP(s, n) (char *) xmlStrndup((const xmlChar *)(s), (n))
  ------------------
  738|     13|            else
  739|     13|                uri->path = xmlURIUnescapeString(*str, cur - *str, NULL);
  740|     13|        } else {
  741|      0|            uri->path = NULL;
  742|      0|        }
  743|     13|    }
  744|     13|    *str = cur;
  745|     13|    return (0);
  746|     13|}

xmlNewDocElementContent:
  754|    288|                        xmlElementContentType type) {
  755|    288|    xmlElementContentPtr ret;
  756|    288|    xmlDictPtr dict = NULL;
  757|       |
  758|    288|    if (doc != NULL)
  ------------------
  |  Branch (758:9): [True: 288, False: 0]
  ------------------
  759|    288|        dict = doc->dict;
  760|       |
  761|    288|    switch(type) {
  762|    155|	case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (762:2): [True: 155, False: 133]
  ------------------
  763|    155|	    if (name == NULL) {
  ------------------
  |  Branch (763:10): [True: 0, False: 155]
  ------------------
  764|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  765|      0|			"xmlNewElementContent : name == NULL !\n",
  766|      0|			NULL);
  767|      0|	    }
  768|    155|	    break;
  769|     44|        case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (769:9): [True: 44, False: 244]
  ------------------
  770|    111|	case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (770:2): [True: 67, False: 221]
  ------------------
  771|    133|	case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (771:2): [True: 22, False: 266]
  ------------------
  772|    133|	    if (name != NULL) {
  ------------------
  |  Branch (772:10): [True: 0, False: 133]
  ------------------
  773|      0|	        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  774|      0|			"xmlNewElementContent : name != NULL !\n",
  775|      0|			NULL);
  776|      0|	    }
  777|    133|	    break;
  778|      0|	default:
  ------------------
  |  Branch (778:2): [True: 0, False: 288]
  ------------------
  779|      0|	    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  780|      0|		    "Internal: ELEMENT content corrupted invalid type\n",
  781|      0|		    NULL);
  782|      0|	    return(NULL);
  783|    288|    }
  784|    288|    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));
  785|    288|    if (ret == NULL) {
  ------------------
  |  Branch (785:9): [True: 0, False: 288]
  ------------------
  786|      0|	xmlVErrMemory(NULL, "malloc failed");
  787|      0|	return(NULL);
  788|      0|    }
  789|    288|    memset(ret, 0, sizeof(xmlElementContent));
  790|    288|    ret->type = type;
  791|    288|    ret->ocur = XML_ELEMENT_CONTENT_ONCE;
  792|    288|    if (name != NULL) {
  ------------------
  |  Branch (792:9): [True: 155, False: 133]
  ------------------
  793|    155|        int l;
  794|    155|	const xmlChar *tmp;
  795|       |
  796|    155|	tmp = xmlSplitQName3(name, &l);
  797|    155|	if (tmp == NULL) {
  ------------------
  |  Branch (797:6): [True: 155, False: 0]
  ------------------
  798|    155|	    if (dict == NULL)
  ------------------
  |  Branch (798:10): [True: 0, False: 155]
  ------------------
  799|      0|		ret->name = xmlStrdup(name);
  800|    155|	    else
  801|    155|	        ret->name = xmlDictLookup(dict, name, -1);
  802|    155|	} else {
  803|      0|	    if (dict == NULL) {
  ------------------
  |  Branch (803:10): [True: 0, False: 0]
  ------------------
  804|      0|		ret->prefix = xmlStrndup(name, l);
  805|      0|		ret->name = xmlStrdup(tmp);
  806|      0|	    } else {
  807|      0|	        ret->prefix = xmlDictLookup(dict, name, l);
  808|      0|		ret->name = xmlDictLookup(dict, tmp, -1);
  809|      0|	    }
  810|      0|	}
  811|    155|    }
  812|    288|    return(ret);
  813|    288|}
xmlFreeDocElementContent:
  934|    133|xmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {
  935|    133|    xmlDictPtr dict = NULL;
  936|    133|    size_t depth = 0;
  937|       |
  938|    133|    if (cur == NULL)
  ------------------
  |  Branch (938:9): [True: 22, False: 111]
  ------------------
  939|     22|        return;
  940|    111|    if (doc != NULL)
  ------------------
  |  Branch (940:9): [True: 111, False: 0]
  ------------------
  941|    111|        dict = doc->dict;
  942|       |
  943|    288|    while (1) {
  ------------------
  |  Branch (943:12): [Folded - Ignored]
  ------------------
  944|    288|        xmlElementContentPtr parent;
  945|       |
  946|    377|        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {
  ------------------
  |  Branch (946:16): [True: 89, False: 288]
  |  Branch (946:37): [True: 0, False: 288]
  ------------------
  947|     89|            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;
  ------------------
  |  Branch (947:19): [True: 89, False: 0]
  ------------------
  948|     89|            depth += 1;
  949|     89|        }
  950|       |
  951|    288|	switch (cur->type) {
  952|     44|	    case XML_ELEMENT_CONTENT_PCDATA:
  ------------------
  |  Branch (952:6): [True: 44, False: 244]
  ------------------
  953|    199|	    case XML_ELEMENT_CONTENT_ELEMENT:
  ------------------
  |  Branch (953:6): [True: 155, False: 133]
  ------------------
  954|    266|	    case XML_ELEMENT_CONTENT_SEQ:
  ------------------
  |  Branch (954:6): [True: 67, False: 221]
  ------------------
  955|    288|	    case XML_ELEMENT_CONTENT_OR:
  ------------------
  |  Branch (955:6): [True: 22, False: 266]
  ------------------
  956|    288|		break;
  957|      0|	    default:
  ------------------
  |  Branch (957:6): [True: 0, False: 288]
  ------------------
  958|      0|		xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
  959|      0|			"Internal: ELEMENT content corrupted invalid type\n",
  960|      0|			NULL);
  961|      0|		return;
  962|    288|	}
  963|    288|	if (dict) {
  ------------------
  |  Branch (963:6): [True: 288, False: 0]
  ------------------
  964|    288|	    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))
  ------------------
  |  Branch (964:10): [True: 155, False: 133]
  |  Branch (964:33): [True: 0, False: 155]
  ------------------
  965|      0|	        xmlFree((xmlChar *) cur->name);
  966|    288|	    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))
  ------------------
  |  Branch (966:10): [True: 0, False: 288]
  |  Branch (966:35): [True: 0, False: 0]
  ------------------
  967|      0|	        xmlFree((xmlChar *) cur->prefix);
  968|    288|	} else {
  969|      0|	    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);
  ------------------
  |  Branch (969:10): [True: 0, False: 0]
  ------------------
  970|      0|	    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);
  ------------------
  |  Branch (970:10): [True: 0, False: 0]
  ------------------
  971|      0|	}
  972|    288|        parent = cur->parent;
  973|    288|        if ((depth == 0) || (parent == NULL)) {
  ------------------
  |  Branch (973:13): [True: 111, False: 177]
  |  Branch (973:29): [True: 0, False: 177]
  ------------------
  974|    111|            xmlFree(cur);
  975|    111|            break;
  976|    111|        }
  977|    177|        if (cur == parent->c1)
  ------------------
  |  Branch (977:13): [True: 89, False: 88]
  ------------------
  978|     89|            parent->c1 = NULL;
  979|     88|        else
  980|     88|            parent->c2 = NULL;
  981|    177|	xmlFree(cur);
  982|       |
  983|    177|        if (parent->c2 != NULL) {
  ------------------
  |  Branch (983:13): [True: 88, False: 89]
  ------------------
  984|     88|	    cur = parent->c2;
  985|     89|        } else {
  986|     89|            depth -= 1;
  987|     89|            cur = parent;
  988|     89|        }
  989|    177|    }
  990|    111|}
xmlAddElementDecl:
 1266|    132|		  xmlElementContentPtr content) {
 1267|    132|    xmlElementPtr ret;
 1268|    132|    xmlElementTablePtr table;
 1269|    132|    xmlAttributePtr oldAttributes = NULL;
 1270|    132|    xmlChar *ns, *uqname;
 1271|       |
 1272|    132|    if (dtd == NULL) {
  ------------------
  |  Branch (1272:9): [True: 0, False: 132]
  ------------------
 1273|      0|	return(NULL);
 1274|      0|    }
 1275|    132|    if (name == NULL) {
  ------------------
  |  Branch (1275:9): [True: 0, False: 132]
  ------------------
 1276|      0|	return(NULL);
 1277|      0|    }
 1278|       |
 1279|    132|    switch (type) {
 1280|     22|        case XML_ELEMENT_TYPE_EMPTY:
  ------------------
  |  Branch (1280:9): [True: 22, False: 110]
  ------------------
 1281|     22|	    if (content != NULL) {
  ------------------
  |  Branch (1281:10): [True: 0, False: 22]
  ------------------
 1282|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1283|      0|		        "xmlAddElementDecl: content != NULL for EMPTY\n",
 1284|      0|			NULL);
 1285|      0|		return(NULL);
 1286|      0|	    }
 1287|     22|	    break;
 1288|     22|	case XML_ELEMENT_TYPE_ANY:
  ------------------
  |  Branch (1288:2): [True: 0, False: 132]
  ------------------
 1289|      0|	    if (content != NULL) {
  ------------------
  |  Branch (1289:10): [True: 0, False: 0]
  ------------------
 1290|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1291|      0|		        "xmlAddElementDecl: content != NULL for ANY\n",
 1292|      0|			NULL);
 1293|      0|		return(NULL);
 1294|      0|	    }
 1295|      0|	    break;
 1296|     44|	case XML_ELEMENT_TYPE_MIXED:
  ------------------
  |  Branch (1296:2): [True: 44, False: 88]
  ------------------
 1297|     44|	    if (content == NULL) {
  ------------------
  |  Branch (1297:10): [True: 0, False: 44]
  ------------------
 1298|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1299|      0|		        "xmlAddElementDecl: content == NULL for MIXED\n",
 1300|      0|			NULL);
 1301|      0|		return(NULL);
 1302|      0|	    }
 1303|     44|	    break;
 1304|     66|	case XML_ELEMENT_TYPE_ELEMENT:
  ------------------
  |  Branch (1304:2): [True: 66, False: 66]
  ------------------
 1305|     66|	    if (content == NULL) {
  ------------------
  |  Branch (1305:10): [True: 0, False: 66]
  ------------------
 1306|      0|		xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1307|      0|		        "xmlAddElementDecl: content == NULL for ELEMENT\n",
 1308|      0|			NULL);
 1309|      0|		return(NULL);
 1310|      0|	    }
 1311|     66|	    break;
 1312|     66|	default:
  ------------------
  |  Branch (1312:2): [True: 0, False: 132]
  ------------------
 1313|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1314|      0|		    "Internal: ELEMENT decl corrupted invalid type\n",
 1315|      0|		    NULL);
 1316|      0|	    return(NULL);
 1317|    132|    }
 1318|       |
 1319|       |    /*
 1320|       |     * check if name is a QName
 1321|       |     */
 1322|    132|    uqname = xmlSplitQName2(name, &ns);
 1323|    132|    if (uqname != NULL)
  ------------------
  |  Branch (1323:9): [True: 0, False: 132]
  ------------------
 1324|      0|	name = uqname;
 1325|       |
 1326|       |    /*
 1327|       |     * Create the Element table if needed.
 1328|       |     */
 1329|    132|    table = (xmlElementTablePtr) dtd->elements;
 1330|    132|    if (table == NULL) {
  ------------------
  |  Branch (1330:9): [True: 22, False: 110]
  ------------------
 1331|     22|	xmlDictPtr dict = NULL;
 1332|       |
 1333|     22|	if (dtd->doc != NULL)
  ------------------
  |  Branch (1333:6): [True: 22, False: 0]
  ------------------
 1334|     22|	    dict = dtd->doc->dict;
 1335|     22|        table = xmlHashCreateDict(0, dict);
 1336|     22|	dtd->elements = (void *) table;
 1337|     22|    }
 1338|    132|    if (table == NULL) {
  ------------------
  |  Branch (1338:9): [True: 0, False: 132]
  ------------------
 1339|      0|	xmlVErrMemory(ctxt,
 1340|      0|            "xmlAddElementDecl: Table creation failed!\n");
 1341|      0|	if (uqname != NULL)
  ------------------
  |  Branch (1341:6): [True: 0, False: 0]
  ------------------
 1342|      0|	    xmlFree(uqname);
 1343|      0|	if (ns != NULL)
  ------------------
  |  Branch (1343:6): [True: 0, False: 0]
  ------------------
 1344|      0|	    xmlFree(ns);
 1345|      0|        return(NULL);
 1346|      0|    }
 1347|       |
 1348|       |    /*
 1349|       |     * lookup old attributes inserted on an undefined element in the
 1350|       |     * internal subset.
 1351|       |     */
 1352|    132|    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {
  ------------------
  |  Branch (1352:9): [True: 132, False: 0]
  |  Branch (1352:31): [True: 132, False: 0]
  ------------------
 1353|    132|	ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);
 1354|    132|	if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {
  ------------------
  |  Branch (1354:6): [True: 0, False: 132]
  |  Branch (1354:23): [True: 0, False: 0]
  ------------------
 1355|      0|	    oldAttributes = ret->attributes;
 1356|      0|	    ret->attributes = NULL;
 1357|      0|	    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);
 1358|      0|	    xmlFreeElement(ret);
 1359|      0|	}
 1360|    132|    }
 1361|       |
 1362|       |    /*
 1363|       |     * The element may already be present if one of its attribute
 1364|       |     * was registered first
 1365|       |     */
 1366|    132|    ret = xmlHashLookup2(table, name, ns);
 1367|    132|    if (ret != NULL) {
  ------------------
  |  Branch (1367:9): [True: 0, False: 132]
  ------------------
 1368|      0|	if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {
  ------------------
  |  Branch (1368:6): [True: 0, False: 0]
  ------------------
 1369|      0|#ifdef LIBXML_VALID_ENABLED
 1370|       |	    /*
 1371|       |	     * The element is already defined in this DTD.
 1372|       |	     */
 1373|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1374|      0|	                    "Redefinition of element %s\n",
 1375|      0|			    name, NULL, NULL);
 1376|      0|#endif /* LIBXML_VALID_ENABLED */
 1377|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1377:10): [True: 0, False: 0]
  ------------------
 1378|      0|		xmlFree(uqname);
 1379|      0|            if (ns != NULL)
  ------------------
  |  Branch (1379:17): [True: 0, False: 0]
  ------------------
 1380|      0|	        xmlFree(ns);
 1381|      0|	    return(NULL);
 1382|      0|	}
 1383|      0|	if (ns != NULL) {
  ------------------
  |  Branch (1383:6): [True: 0, False: 0]
  ------------------
 1384|      0|	    xmlFree(ns);
 1385|      0|	    ns = NULL;
 1386|      0|	}
 1387|    132|    } else {
 1388|    132|	ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 1389|    132|	if (ret == NULL) {
  ------------------
  |  Branch (1389:6): [True: 0, False: 132]
  ------------------
 1390|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1391|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1391:10): [True: 0, False: 0]
  ------------------
 1392|      0|		xmlFree(uqname);
 1393|      0|            if (ns != NULL)
  ------------------
  |  Branch (1393:17): [True: 0, False: 0]
  ------------------
 1394|      0|	        xmlFree(ns);
 1395|      0|	    return(NULL);
 1396|      0|	}
 1397|    132|	memset(ret, 0, sizeof(xmlElement));
 1398|    132|	ret->type = XML_ELEMENT_DECL;
 1399|       |
 1400|       |	/*
 1401|       |	 * fill the structure.
 1402|       |	 */
 1403|    132|	ret->name = xmlStrdup(name);
 1404|    132|	if (ret->name == NULL) {
  ------------------
  |  Branch (1404:6): [True: 0, False: 132]
  ------------------
 1405|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 1406|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1406:10): [True: 0, False: 0]
  ------------------
 1407|      0|		xmlFree(uqname);
 1408|      0|            if (ns != NULL)
  ------------------
  |  Branch (1408:17): [True: 0, False: 0]
  ------------------
 1409|      0|	        xmlFree(ns);
 1410|      0|	    xmlFree(ret);
 1411|      0|	    return(NULL);
 1412|      0|	}
 1413|    132|	ret->prefix = ns;
 1414|       |
 1415|       |	/*
 1416|       |	 * Validity Check:
 1417|       |	 * Insertion must not fail
 1418|       |	 */
 1419|    132|	if (xmlHashAddEntry2(table, name, ns, ret)) {
  ------------------
  |  Branch (1419:6): [True: 0, False: 132]
  ------------------
 1420|      0|#ifdef LIBXML_VALID_ENABLED
 1421|       |	    /*
 1422|       |	     * The element is already defined in this DTD.
 1423|       |	     */
 1424|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,
 1425|      0|	                    "Redefinition of element %s\n",
 1426|      0|			    name, NULL, NULL);
 1427|      0|#endif /* LIBXML_VALID_ENABLED */
 1428|      0|	    xmlFreeElement(ret);
 1429|      0|	    if (uqname != NULL)
  ------------------
  |  Branch (1429:10): [True: 0, False: 0]
  ------------------
 1430|      0|		xmlFree(uqname);
 1431|      0|	    return(NULL);
 1432|      0|	}
 1433|       |	/*
 1434|       |	 * For new element, may have attributes from earlier
 1435|       |	 * definition in internal subset
 1436|       |	 */
 1437|    132|	ret->attributes = oldAttributes;
 1438|    132|    }
 1439|       |
 1440|       |    /*
 1441|       |     * Finish to fill the structure.
 1442|       |     */
 1443|    132|    ret->etype = type;
 1444|       |    /*
 1445|       |     * Avoid a stupid copy when called by the parser
 1446|       |     * and flag it by setting a special parent value
 1447|       |     * so the parser doesn't unallocate it.
 1448|       |     */
 1449|    132|    if ((ctxt != NULL) && (ctxt->flags & XML_VCTXT_USE_PCTXT)) {
  ------------------
  |  |   18|    132|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (1449:9): [True: 132, False: 0]
  |  Branch (1449:27): [True: 132, False: 0]
  ------------------
 1450|    132|	ret->content = content;
 1451|    132|	if (content != NULL)
  ------------------
  |  Branch (1451:6): [True: 110, False: 22]
  ------------------
 1452|    110|	    content->parent = (xmlElementContentPtr) 1;
 1453|    132|    } else {
 1454|      0|	ret->content = xmlCopyDocElementContent(dtd->doc, content);
 1455|      0|    }
 1456|       |
 1457|       |    /*
 1458|       |     * Link it to the DTD
 1459|       |     */
 1460|    132|    ret->parent = dtd;
 1461|    132|    ret->doc = dtd->doc;
 1462|    132|    if (dtd->last == NULL) {
  ------------------
  |  Branch (1462:9): [True: 22, False: 110]
  ------------------
 1463|     22|	dtd->children = dtd->last = (xmlNodePtr) ret;
 1464|    110|    } else {
 1465|    110|        dtd->last->next = (xmlNodePtr) ret;
 1466|    110|	ret->prev = dtd->last;
 1467|    110|	dtd->last = (xmlNodePtr) ret;
 1468|    110|    }
 1469|    132|    if (uqname != NULL)
  ------------------
  |  Branch (1469:9): [True: 0, False: 132]
  ------------------
 1470|      0|	xmlFree(uqname);
 1471|    132|    return(ret);
 1472|    132|}
xmlFreeElementTable:
 1486|     22|xmlFreeElementTable(xmlElementTablePtr table) {
 1487|     22|    xmlHashFree(table, xmlFreeElementTableEntry);
 1488|     22|}
xmlAddAttributeDecl:
 1816|     88|		    const xmlChar *defaultValue, xmlEnumerationPtr tree) {
 1817|     88|    xmlAttributePtr ret;
 1818|     88|    xmlAttributeTablePtr table;
 1819|     88|    xmlElementPtr elemDef;
 1820|     88|    xmlDictPtr dict = NULL;
 1821|       |
 1822|     88|    if (dtd == NULL) {
  ------------------
  |  Branch (1822:9): [True: 0, False: 88]
  ------------------
 1823|      0|	xmlFreeEnumeration(tree);
 1824|      0|	return(NULL);
 1825|      0|    }
 1826|     88|    if (name == NULL) {
  ------------------
  |  Branch (1826:9): [True: 0, False: 88]
  ------------------
 1827|      0|	xmlFreeEnumeration(tree);
 1828|      0|	return(NULL);
 1829|      0|    }
 1830|     88|    if (elem == NULL) {
  ------------------
  |  Branch (1830:9): [True: 0, False: 88]
  ------------------
 1831|      0|	xmlFreeEnumeration(tree);
 1832|      0|	return(NULL);
 1833|      0|    }
 1834|     88|    if (dtd->doc != NULL)
  ------------------
  |  Branch (1834:9): [True: 88, False: 0]
  ------------------
 1835|     88|	dict = dtd->doc->dict;
 1836|       |
 1837|     88|#ifdef LIBXML_VALID_ENABLED
 1838|       |    /*
 1839|       |     * Check the type and possibly the default value.
 1840|       |     */
 1841|     88|    switch (type) {
 1842|     22|        case XML_ATTRIBUTE_CDATA:
  ------------------
  |  Branch (1842:9): [True: 22, False: 66]
  ------------------
 1843|     22|	    break;
 1844|     66|        case XML_ATTRIBUTE_ID:
  ------------------
  |  Branch (1844:9): [True: 66, False: 22]
  ------------------
 1845|     66|	    break;
 1846|      0|        case XML_ATTRIBUTE_IDREF:
  ------------------
  |  Branch (1846:9): [True: 0, False: 88]
  ------------------
 1847|      0|	    break;
 1848|      0|        case XML_ATTRIBUTE_IDREFS:
  ------------------
  |  Branch (1848:9): [True: 0, False: 88]
  ------------------
 1849|      0|	    break;
 1850|      0|        case XML_ATTRIBUTE_ENTITY:
  ------------------
  |  Branch (1850:9): [True: 0, False: 88]
  ------------------
 1851|      0|	    break;
 1852|      0|        case XML_ATTRIBUTE_ENTITIES:
  ------------------
  |  Branch (1852:9): [True: 0, False: 88]
  ------------------
 1853|      0|	    break;
 1854|      0|        case XML_ATTRIBUTE_NMTOKEN:
  ------------------
  |  Branch (1854:9): [True: 0, False: 88]
  ------------------
 1855|      0|	    break;
 1856|      0|        case XML_ATTRIBUTE_NMTOKENS:
  ------------------
  |  Branch (1856:9): [True: 0, False: 88]
  ------------------
 1857|      0|	    break;
 1858|      0|        case XML_ATTRIBUTE_ENUMERATION:
  ------------------
  |  Branch (1858:9): [True: 0, False: 88]
  ------------------
 1859|      0|	    break;
 1860|      0|        case XML_ATTRIBUTE_NOTATION:
  ------------------
  |  Branch (1860:9): [True: 0, False: 88]
  ------------------
 1861|      0|	    break;
 1862|      0|	default:
  ------------------
  |  Branch (1862:2): [True: 0, False: 88]
  ------------------
 1863|      0|	    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,
 1864|      0|		    "Internal: ATTRIBUTE struct corrupted invalid type\n",
 1865|      0|		    NULL);
 1866|      0|	    xmlFreeEnumeration(tree);
 1867|      0|	    return(NULL);
 1868|     88|    }
 1869|     88|    if ((defaultValue != NULL) &&
  ------------------
  |  Branch (1869:9): [True: 0, False: 88]
  ------------------
 1870|     88|        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {
  ------------------
  |  Branch (1870:9): [True: 0, False: 0]
  ------------------
 1871|      0|	xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,
 1872|      0|	                "Attribute %s of %s: invalid default value\n",
 1873|      0|	                elem, name, defaultValue);
 1874|      0|	defaultValue = NULL;
 1875|      0|	if (ctxt != NULL)
  ------------------
  |  Branch (1875:6): [True: 0, False: 0]
  ------------------
 1876|      0|	    ctxt->valid = 0;
 1877|      0|    }
 1878|     88|#endif /* LIBXML_VALID_ENABLED */
 1879|       |
 1880|       |    /*
 1881|       |     * Check first that an attribute defined in the external subset wasn't
 1882|       |     * already defined in the internal subset
 1883|       |     */
 1884|     88|    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&
  ------------------
  |  Branch (1884:9): [True: 88, False: 0]
  |  Branch (1884:31): [True: 0, False: 88]
  ------------------
 1885|     88|	(dtd->doc->intSubset != NULL) &&
  ------------------
  |  Branch (1885:2): [True: 0, False: 0]
  ------------------
 1886|     88|	(dtd->doc->intSubset->attributes != NULL)) {
  ------------------
  |  Branch (1886:2): [True: 0, False: 0]
  ------------------
 1887|      0|        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);
 1888|      0|	if (ret != NULL) {
  ------------------
  |  Branch (1888:6): [True: 0, False: 0]
  ------------------
 1889|      0|	    xmlFreeEnumeration(tree);
 1890|      0|	    return(NULL);
 1891|      0|	}
 1892|      0|    }
 1893|       |
 1894|       |    /*
 1895|       |     * Create the Attribute table if needed.
 1896|       |     */
 1897|     88|    table = (xmlAttributeTablePtr) dtd->attributes;
 1898|     88|    if (table == NULL) {
  ------------------
  |  Branch (1898:9): [True: 22, False: 66]
  ------------------
 1899|     22|        table = xmlHashCreateDict(0, dict);
 1900|     22|	dtd->attributes = (void *) table;
 1901|     22|    }
 1902|     88|    if (table == NULL) {
  ------------------
  |  Branch (1902:9): [True: 0, False: 88]
  ------------------
 1903|      0|	xmlVErrMemory(ctxt,
 1904|      0|            "xmlAddAttributeDecl: Table creation failed!\n");
 1905|      0|	xmlFreeEnumeration(tree);
 1906|      0|        return(NULL);
 1907|      0|    }
 1908|       |
 1909|       |
 1910|     88|    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));
 1911|     88|    if (ret == NULL) {
  ------------------
  |  Branch (1911:9): [True: 0, False: 88]
  ------------------
 1912|      0|	xmlVErrMemory(ctxt, "malloc failed");
 1913|      0|	xmlFreeEnumeration(tree);
 1914|      0|	return(NULL);
 1915|      0|    }
 1916|     88|    memset(ret, 0, sizeof(xmlAttribute));
 1917|     88|    ret->type = XML_ATTRIBUTE_DECL;
 1918|       |
 1919|       |    /*
 1920|       |     * fill the structure.
 1921|       |     */
 1922|     88|    ret->atype = type;
 1923|       |    /*
 1924|       |     * doc must be set before possible error causes call
 1925|       |     * to xmlFreeAttribute (because it's used to check on
 1926|       |     * dict use)
 1927|       |     */
 1928|     88|    ret->doc = dtd->doc;
 1929|     88|    if (dict) {
  ------------------
  |  Branch (1929:9): [True: 88, False: 0]
  ------------------
 1930|     88|	ret->name = xmlDictLookup(dict, name, -1);
 1931|     88|	ret->prefix = xmlDictLookup(dict, ns, -1);
 1932|     88|	ret->elem = xmlDictLookup(dict, elem, -1);
 1933|     88|    } else {
 1934|      0|	ret->name = xmlStrdup(name);
 1935|      0|	ret->prefix = xmlStrdup(ns);
 1936|      0|	ret->elem = xmlStrdup(elem);
 1937|      0|    }
 1938|     88|    ret->def = def;
 1939|     88|    ret->tree = tree;
 1940|     88|    if (defaultValue != NULL) {
  ------------------
  |  Branch (1940:9): [True: 0, False: 88]
  ------------------
 1941|      0|        if (dict)
  ------------------
  |  Branch (1941:13): [True: 0, False: 0]
  ------------------
 1942|      0|	    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);
 1943|      0|	else
 1944|      0|	    ret->defaultValue = xmlStrdup(defaultValue);
 1945|      0|    }
 1946|       |
 1947|       |    /*
 1948|       |     * Validity Check:
 1949|       |     * Search the DTD for previous declarations of the ATTLIST
 1950|       |     */
 1951|     88|    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {
  ------------------
  |  Branch (1951:9): [True: 0, False: 88]
  ------------------
 1952|      0|#ifdef LIBXML_VALID_ENABLED
 1953|       |	/*
 1954|       |	 * The attribute is already defined in this DTD.
 1955|       |	 */
 1956|      0|	xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,
 1957|      0|		 "Attribute %s of element %s: already defined\n",
 1958|      0|		 name, elem, NULL);
 1959|      0|#endif /* LIBXML_VALID_ENABLED */
 1960|      0|	xmlFreeAttribute(ret);
 1961|      0|	return(NULL);
 1962|      0|    }
 1963|       |
 1964|       |    /*
 1965|       |     * Validity Check:
 1966|       |     * Multiple ID per element
 1967|       |     */
 1968|     88|    elemDef = xmlGetDtdElementDesc2(ctxt, dtd, elem, 1);
 1969|     88|    if (elemDef != NULL) {
  ------------------
  |  Branch (1969:9): [True: 88, False: 0]
  ------------------
 1970|       |
 1971|     88|#ifdef LIBXML_VALID_ENABLED
 1972|     88|        if ((type == XML_ATTRIBUTE_ID) &&
  ------------------
  |  Branch (1972:13): [True: 66, False: 22]
  ------------------
 1973|     88|	    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {
  ------------------
  |  Branch (1973:6): [True: 0, False: 66]
  ------------------
 1974|      0|	    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,
 1975|      0|	   "Element %s has too may ID attributes defined : %s\n",
 1976|      0|		   elem, name, NULL);
 1977|      0|	    if (ctxt != NULL)
  ------------------
  |  Branch (1977:10): [True: 0, False: 0]
  ------------------
 1978|      0|		ctxt->valid = 0;
 1979|      0|	}
 1980|     88|#endif /* LIBXML_VALID_ENABLED */
 1981|       |
 1982|       |	/*
 1983|       |	 * Insert namespace default def first they need to be
 1984|       |	 * processed first.
 1985|       |	 */
 1986|     88|	if ((xmlStrEqual(ret->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|     88|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1986:6): [True: 0, False: 88]
  ------------------
 1987|     88|	    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1987:8): [True: 0, False: 88]
  ------------------
 1988|     88|	     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns"))))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1988:7): [True: 0, False: 0]
  ------------------
 1989|      0|	    ret->nexth = elemDef->attributes;
 1990|      0|	    elemDef->attributes = ret;
 1991|     88|	} else {
 1992|     88|	    xmlAttributePtr tmp = elemDef->attributes;
 1993|       |
 1994|     88|	    while ((tmp != NULL) &&
  ------------------
  |  Branch (1994:13): [True: 0, False: 88]
  ------------------
 1995|     88|		   ((xmlStrEqual(tmp->name, BAD_CAST "xmlns")) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1995:7): [True: 0, False: 0]
  ------------------
 1996|      0|		    ((ret->prefix != NULL &&
  ------------------
  |  Branch (1996:9): [True: 0, False: 0]
  ------------------
 1997|      0|		     (xmlStrEqual(ret->prefix, BAD_CAST "xmlns")))))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (1997:8): [True: 0, False: 0]
  ------------------
 1998|      0|		if (tmp->nexth == NULL)
  ------------------
  |  Branch (1998:7): [True: 0, False: 0]
  ------------------
 1999|      0|		    break;
 2000|      0|		tmp = tmp->nexth;
 2001|      0|	    }
 2002|     88|	    if (tmp != NULL) {
  ------------------
  |  Branch (2002:10): [True: 0, False: 88]
  ------------------
 2003|      0|		ret->nexth = tmp->nexth;
 2004|      0|	        tmp->nexth = ret;
 2005|     88|	    } else {
 2006|     88|		ret->nexth = elemDef->attributes;
 2007|     88|		elemDef->attributes = ret;
 2008|     88|	    }
 2009|     88|	}
 2010|     88|    }
 2011|       |
 2012|       |    /*
 2013|       |     * Link it to the DTD
 2014|       |     */
 2015|     88|    ret->parent = dtd;
 2016|     88|    if (dtd->last == NULL) {
  ------------------
  |  Branch (2016:9): [True: 0, False: 88]
  ------------------
 2017|      0|	dtd->children = dtd->last = (xmlNodePtr) ret;
 2018|     88|    } else {
 2019|     88|        dtd->last->next = (xmlNodePtr) ret;
 2020|     88|	ret->prev = dtd->last;
 2021|     88|	dtd->last = (xmlNodePtr) ret;
 2022|     88|    }
 2023|     88|    return(ret);
 2024|     88|}
xmlFreeAttributeTable:
 2038|     22|xmlFreeAttributeTable(xmlAttributeTablePtr table) {
 2039|     22|    xmlHashFree(table, xmlFreeAttributeTableEntry);
 2040|     22|}
xmlAddID:
 2518|    110|         xmlAttrPtr attr) {
 2519|    110|    xmlIDPtr ret;
 2520|    110|    xmlIDTablePtr table;
 2521|       |
 2522|    110|    if (doc == NULL) {
  ------------------
  |  Branch (2522:9): [True: 0, False: 110]
  ------------------
 2523|      0|	return(NULL);
 2524|      0|    }
 2525|    110|    if ((value == NULL) || (value[0] == 0)) {
  ------------------
  |  Branch (2525:9): [True: 0, False: 110]
  |  Branch (2525:28): [True: 0, False: 110]
  ------------------
 2526|      0|	return(NULL);
 2527|      0|    }
 2528|    110|    if (attr == NULL) {
  ------------------
  |  Branch (2528:9): [True: 0, False: 110]
  ------------------
 2529|      0|	return(NULL);
 2530|      0|    }
 2531|       |
 2532|       |    /*
 2533|       |     * Create the ID table if needed.
 2534|       |     */
 2535|    110|    table = (xmlIDTablePtr) doc->ids;
 2536|    110|    if (table == NULL)  {
  ------------------
  |  Branch (2536:9): [True: 22, False: 88]
  ------------------
 2537|     22|        doc->ids = table = xmlHashCreateDict(0, doc->dict);
 2538|     22|    }
 2539|    110|    if (table == NULL) {
  ------------------
  |  Branch (2539:9): [True: 0, False: 110]
  ------------------
 2540|      0|	xmlVErrMemory(ctxt,
 2541|      0|		"xmlAddID: Table creation failed!\n");
 2542|      0|        return(NULL);
 2543|      0|    }
 2544|       |
 2545|    110|    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));
 2546|    110|    if (ret == NULL) {
  ------------------
  |  Branch (2546:9): [True: 0, False: 110]
  ------------------
 2547|      0|	xmlVErrMemory(ctxt, "malloc failed");
 2548|      0|	return(NULL);
 2549|      0|    }
 2550|       |
 2551|       |    /*
 2552|       |     * fill the structure.
 2553|       |     */
 2554|    110|    ret->value = xmlStrdup(value);
 2555|    110|    ret->doc = doc;
 2556|    110|    if (xmlIsStreaming(ctxt)) {
  ------------------
  |  Branch (2556:9): [True: 0, False: 110]
  ------------------
 2557|       |	/*
 2558|       |	 * Operating in streaming mode, attr is gonna disappear
 2559|       |	 */
 2560|      0|	if (doc->dict != NULL)
  ------------------
  |  Branch (2560:6): [True: 0, False: 0]
  ------------------
 2561|      0|	    ret->name = xmlDictLookup(doc->dict, attr->name, -1);
 2562|      0|	else
 2563|      0|	    ret->name = xmlStrdup(attr->name);
 2564|      0|	ret->attr = NULL;
 2565|    110|    } else {
 2566|    110|	ret->attr = attr;
 2567|    110|	ret->name = NULL;
 2568|    110|    }
 2569|    110|    ret->lineno = xmlGetLineNo(attr->parent);
 2570|       |
 2571|    110|    if (xmlHashAddEntry(table, value, ret) < 0) {
  ------------------
  |  Branch (2571:9): [True: 0, False: 110]
  ------------------
 2572|      0|#ifdef LIBXML_VALID_ENABLED
 2573|       |	/*
 2574|       |	 * The id is already defined in this DTD.
 2575|       |	 */
 2576|      0|	if (ctxt != NULL) {
  ------------------
  |  Branch (2576:6): [True: 0, False: 0]
  ------------------
 2577|      0|	    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,
 2578|      0|			    "ID %s already defined\n", value, NULL, NULL);
 2579|      0|	}
 2580|      0|#endif /* LIBXML_VALID_ENABLED */
 2581|      0|	xmlFreeID(ret);
 2582|      0|	return(NULL);
 2583|      0|    }
 2584|    110|    if (attr != NULL)
  ------------------
  |  Branch (2584:9): [True: 110, False: 0]
  ------------------
 2585|    110|	attr->atype = XML_ATTRIBUTE_ID;
 2586|    110|    return(ret);
 2587|    110|}
xmlFreeIDTable:
 2601|     22|xmlFreeIDTable(xmlIDTablePtr table) {
 2602|     22|    xmlHashFree(table, xmlFreeIDTableEntry);
 2603|     22|}
xmlIsID:
 2619|    896|xmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2620|    896|    if ((attr == NULL) || (attr->name == NULL)) return(0);
  ------------------
  |  Branch (2620:9): [True: 0, False: 896]
  |  Branch (2620:27): [True: 0, False: 896]
  ------------------
 2621|    896|    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&
  ------------------
  |  Branch (2621:9): [True: 36, False: 860]
  |  Branch (2621:31): [True: 36, False: 0]
  ------------------
 2622|    896|        (!strcmp((char *) attr->name, "id")) &&
  ------------------
  |  Branch (2622:9): [True: 0, False: 36]
  ------------------
 2623|    896|        (!strcmp((char *) attr->ns->prefix, "xml")))
  ------------------
  |  Branch (2623:9): [True: 0, False: 0]
  ------------------
 2624|      0|	return(1);
 2625|    896|    if (doc == NULL) return(0);
  ------------------
  |  Branch (2625:9): [True: 0, False: 896]
  ------------------
 2626|    896|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&
  ------------------
  |  Branch (2626:9): [True: 764, False: 132]
  |  Branch (2626:37): [True: 764, False: 0]
  ------------------
 2627|    896|        (doc->type != XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (2627:9): [True: 764, False: 0]
  ------------------
 2628|    764|	return(0);
 2629|    764|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2629:16): [True: 0, False: 132]
  ------------------
 2630|      0|        if ((xmlStrEqual(BAD_CAST "id", attr->name)) ||
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2630:13): [True: 0, False: 0]
  ------------------
 2631|      0|	    ((xmlStrEqual(BAD_CAST "name", attr->name)) &&
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2631:7): [True: 0, False: 0]
  ------------------
 2632|      0|	    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST "a")))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (2632:7): [True: 0, False: 0]
  |  Branch (2632:25): [True: 0, False: 0]
  ------------------
 2633|      0|	    return(1);
 2634|      0|	return(0);
 2635|    132|    } else if (elem == NULL) {
  ------------------
  |  Branch (2635:16): [True: 0, False: 132]
  ------------------
 2636|      0|	return(0);
 2637|    132|    } else {
 2638|    132|	xmlAttributePtr attrDecl = NULL;
 2639|       |
 2640|    132|	xmlChar felem[50], fattr[50];
 2641|    132|	xmlChar *fullelemname, *fullattrname;
 2642|       |
 2643|    132|	fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?
  ------------------
  |  Branch (2643:18): [True: 0, False: 132]
  |  Branch (2643:38): [True: 0, False: 0]
  ------------------
 2644|      0|	    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :
 2645|    132|	    (xmlChar *)elem->name;
 2646|       |
 2647|    132|	fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?
  ------------------
  |  Branch (2647:18): [True: 0, False: 132]
  |  Branch (2647:38): [True: 0, False: 0]
  ------------------
 2648|      0|	    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :
 2649|    132|	    (xmlChar *)attr->name;
 2650|       |
 2651|    132|	if (fullelemname != NULL && fullattrname != NULL) {
  ------------------
  |  Branch (2651:6): [True: 132, False: 0]
  |  Branch (2651:30): [True: 132, False: 0]
  ------------------
 2652|    132|	    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,
 2653|    132|		                         fullattrname);
 2654|    132|	    if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2654:10): [True: 0, False: 132]
  |  Branch (2654:32): [True: 0, False: 0]
  ------------------
 2655|      0|		attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,
 2656|      0|					     fullattrname);
 2657|    132|	}
 2658|       |
 2659|    132|	if ((fullattrname != fattr) && (fullattrname != attr->name))
  ------------------
  |  Branch (2659:6): [True: 132, False: 0]
  |  Branch (2659:33): [True: 0, False: 132]
  ------------------
 2660|      0|	    xmlFree(fullattrname);
 2661|    132|	if ((fullelemname != felem) && (fullelemname != elem->name))
  ------------------
  |  Branch (2661:6): [True: 132, False: 0]
  |  Branch (2661:33): [True: 0, False: 132]
  ------------------
 2662|      0|	    xmlFree(fullelemname);
 2663|       |
 2664|    132|        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))
  ------------------
  |  Branch (2664:13): [True: 132, False: 0]
  |  Branch (2664:35): [True: 110, False: 22]
  ------------------
 2665|    110|	    return(1);
 2666|    132|    }
 2667|     22|    return(0);
 2668|    896|}
xmlRemoveID:
 2680|    110|xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
 2681|    110|    xmlIDTablePtr table;
 2682|    110|    xmlIDPtr id;
 2683|    110|    xmlChar *ID;
 2684|       |
 2685|    110|    if (doc == NULL) return(-1);
  ------------------
  |  Branch (2685:9): [True: 0, False: 110]
  ------------------
 2686|    110|    if (attr == NULL) return(-1);
  ------------------
  |  Branch (2686:9): [True: 0, False: 110]
  ------------------
 2687|       |
 2688|    110|    table = (xmlIDTablePtr) doc->ids;
 2689|    110|    if (table == NULL)
  ------------------
  |  Branch (2689:9): [True: 110, False: 0]
  ------------------
 2690|    110|        return(-1);
 2691|       |
 2692|      0|    ID = xmlNodeListGetString(doc, attr->children, 1);
 2693|      0|    if (ID == NULL)
  ------------------
  |  Branch (2693:9): [True: 0, False: 0]
  ------------------
 2694|      0|        return(-1);
 2695|      0|    xmlValidNormalizeString(ID);
 2696|       |
 2697|      0|    id = xmlHashLookup(table, ID);
 2698|      0|    if (id == NULL || id->attr != attr) {
  ------------------
  |  Branch (2698:9): [True: 0, False: 0]
  |  Branch (2698:23): [True: 0, False: 0]
  ------------------
 2699|      0|        xmlFree(ID);
 2700|      0|        return(-1);
 2701|      0|    }
 2702|       |
 2703|      0|    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
 2704|      0|    xmlFree(ID);
 2705|      0|    attr->atype = 0;
 2706|      0|    return(0);
 2707|      0|}
xmlGetID:
 2719|     43|xmlGetID(xmlDocPtr doc, const xmlChar *ID) {
 2720|     43|    xmlIDTablePtr table;
 2721|     43|    xmlIDPtr id;
 2722|       |
 2723|     43|    if (doc == NULL) {
  ------------------
  |  Branch (2723:9): [True: 0, False: 43]
  ------------------
 2724|      0|	return(NULL);
 2725|      0|    }
 2726|       |
 2727|     43|    if (ID == NULL) {
  ------------------
  |  Branch (2727:9): [True: 0, False: 43]
  ------------------
 2728|      0|	return(NULL);
 2729|      0|    }
 2730|       |
 2731|     43|    table = (xmlIDTablePtr) doc->ids;
 2732|     43|    if (table == NULL)
  ------------------
  |  Branch (2732:9): [True: 28, False: 15]
  ------------------
 2733|     28|        return(NULL);
 2734|       |
 2735|     15|    id = xmlHashLookup(table, ID);
 2736|     15|    if (id == NULL)
  ------------------
  |  Branch (2736:9): [True: 0, False: 15]
  ------------------
 2737|      0|	return(NULL);
 2738|     15|    if (id->attr == NULL) {
  ------------------
  |  Branch (2738:9): [True: 0, False: 15]
  ------------------
 2739|       |	/*
 2740|       |	 * We are operating on a stream, return a well known reference
 2741|       |	 * since the attribute node doesn't exist anymore
 2742|       |	 */
 2743|      0|	return((xmlAttrPtr) doc);
 2744|      0|    }
 2745|     15|    return(id->attr);
 2746|     15|}
xmlIsRef:
 2967|    786|xmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {
 2968|    786|    if (attr == NULL)
  ------------------
  |  Branch (2968:9): [True: 0, False: 786]
  ------------------
 2969|      0|        return(0);
 2970|    786|    if (doc == NULL) {
  ------------------
  |  Branch (2970:9): [True: 0, False: 786]
  ------------------
 2971|      0|        doc = attr->doc;
 2972|      0|	if (doc == NULL) return(0);
  ------------------
  |  Branch (2972:6): [True: 0, False: 0]
  ------------------
 2973|      0|    }
 2974|       |
 2975|    786|    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {
  ------------------
  |  Branch (2975:9): [True: 764, False: 22]
  |  Branch (2975:37): [True: 764, False: 0]
  ------------------
 2976|    764|        return(0);
 2977|    764|    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {
  ------------------
  |  Branch (2977:16): [True: 0, False: 22]
  ------------------
 2978|       |        /* TODO @@@ */
 2979|      0|        return(0);
 2980|     22|    } else {
 2981|     22|        xmlAttributePtr attrDecl;
 2982|       |
 2983|     22|        if (elem == NULL) return(0);
  ------------------
  |  Branch (2983:13): [True: 0, False: 22]
  ------------------
 2984|     22|        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);
 2985|     22|        if ((attrDecl == NULL) && (doc->extSubset != NULL))
  ------------------
  |  Branch (2985:13): [True: 0, False: 22]
  |  Branch (2985:35): [True: 0, False: 0]
  ------------------
 2986|      0|            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,
 2987|      0|		                         elem->name, attr->name);
 2988|       |
 2989|     22|	if ((attrDecl != NULL) &&
  ------------------
  |  Branch (2989:6): [True: 22, False: 0]
  ------------------
 2990|     22|	    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||
  ------------------
  |  Branch (2990:7): [True: 0, False: 22]
  ------------------
 2991|     22|	     attrDecl->atype == XML_ATTRIBUTE_IDREFS))
  ------------------
  |  Branch (2991:7): [True: 0, False: 22]
  ------------------
 2992|      0|	return(1);
 2993|     22|    }
 2994|     22|    return(0);
 2995|    786|}
xmlGetDtdAttrDesc:
 3230|    154|xmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {
 3231|    154|    xmlAttributeTablePtr table;
 3232|    154|    xmlAttributePtr cur;
 3233|    154|    xmlChar *uqname = NULL, *prefix = NULL;
 3234|       |
 3235|    154|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3235:9): [True: 0, False: 154]
  ------------------
 3236|    154|    if (dtd->attributes == NULL) return(NULL);
  ------------------
  |  Branch (3236:9): [True: 0, False: 154]
  ------------------
 3237|       |
 3238|    154|    table = (xmlAttributeTablePtr) dtd->attributes;
 3239|    154|    if (table == NULL)
  ------------------
  |  Branch (3239:9): [True: 0, False: 154]
  ------------------
 3240|      0|	return(NULL);
 3241|       |
 3242|    154|    uqname = xmlSplitQName2(name, &prefix);
 3243|       |
 3244|    154|    if (uqname != NULL) {
  ------------------
  |  Branch (3244:9): [True: 0, False: 154]
  ------------------
 3245|      0|	cur = xmlHashLookup3(table, uqname, prefix, elem);
 3246|      0|	if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3246:6): [True: 0, False: 0]
  ------------------
 3247|      0|	if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3247:6): [True: 0, False: 0]
  ------------------
 3248|      0|    } else
 3249|    154|	cur = xmlHashLookup3(table, name, NULL, elem);
 3250|    154|    return(cur);
 3251|    154|}
valid.c:xmlFreeElement:
 1234|    132|xmlFreeElement(xmlElementPtr elem) {
 1235|    132|    if (elem == NULL) return;
  ------------------
  |  Branch (1235:9): [True: 0, False: 132]
  ------------------
 1236|    132|    xmlUnlinkNode((xmlNodePtr) elem);
 1237|    132|    xmlFreeDocElementContent(elem->doc, elem->content);
 1238|    132|    if (elem->name != NULL)
  ------------------
  |  Branch (1238:9): [True: 132, False: 0]
  ------------------
 1239|    132|	xmlFree((xmlChar *) elem->name);
 1240|    132|    if (elem->prefix != NULL)
  ------------------
  |  Branch (1240:9): [True: 0, False: 132]
  ------------------
 1241|      0|	xmlFree((xmlChar *) elem->prefix);
 1242|    132|#ifdef LIBXML_REGEXP_ENABLED
 1243|    132|    if (elem->contModel != NULL)
  ------------------
  |  Branch (1243:9): [True: 0, False: 132]
  ------------------
 1244|      0|	xmlRegFreeRegexp(elem->contModel);
 1245|    132|#endif
 1246|    132|    xmlFree(elem);
 1247|    132|}
valid.c:xmlFreeElementTableEntry:
 1475|    132|xmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {
 1476|    132|    xmlFreeElement((xmlElementPtr) elem);
 1477|    132|}
valid.c:xmlFreeAttribute:
 1759|     88|xmlFreeAttribute(xmlAttributePtr attr) {
 1760|     88|    xmlDictPtr dict;
 1761|       |
 1762|     88|    if (attr == NULL) return;
  ------------------
  |  Branch (1762:9): [True: 0, False: 88]
  ------------------
 1763|     88|    if (attr->doc != NULL)
  ------------------
  |  Branch (1763:9): [True: 88, False: 0]
  ------------------
 1764|     88|	dict = attr->doc->dict;
 1765|      0|    else
 1766|      0|	dict = NULL;
 1767|     88|    xmlUnlinkNode((xmlNodePtr) attr);
 1768|     88|    if (attr->tree != NULL)
  ------------------
  |  Branch (1768:9): [True: 0, False: 88]
  ------------------
 1769|      0|        xmlFreeEnumeration(attr->tree);
 1770|     88|    if (dict) {
  ------------------
  |  Branch (1770:9): [True: 88, False: 0]
  ------------------
 1771|     88|        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))
  ------------------
  |  Branch (1771:13): [True: 88, False: 0]
  |  Branch (1771:37): [True: 0, False: 88]
  ------------------
 1772|      0|	    xmlFree((xmlChar *) attr->elem);
 1773|     88|        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))
  ------------------
  |  Branch (1773:13): [True: 88, False: 0]
  |  Branch (1773:37): [True: 0, False: 88]
  ------------------
 1774|      0|	    xmlFree((xmlChar *) attr->name);
 1775|     88|        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))
  ------------------
  |  Branch (1775:13): [True: 0, False: 88]
  |  Branch (1775:39): [True: 0, False: 0]
  ------------------
 1776|      0|	    xmlFree((xmlChar *) attr->prefix);
 1777|     88|        if ((attr->defaultValue != NULL) &&
  ------------------
  |  Branch (1777:13): [True: 0, False: 88]
  ------------------
 1778|     88|	    (!xmlDictOwns(dict, attr->defaultValue)))
  ------------------
  |  Branch (1778:6): [True: 0, False: 0]
  ------------------
 1779|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1780|     88|    } else {
 1781|      0|	if (attr->elem != NULL)
  ------------------
  |  Branch (1781:6): [True: 0, False: 0]
  ------------------
 1782|      0|	    xmlFree((xmlChar *) attr->elem);
 1783|      0|	if (attr->name != NULL)
  ------------------
  |  Branch (1783:6): [True: 0, False: 0]
  ------------------
 1784|      0|	    xmlFree((xmlChar *) attr->name);
 1785|      0|	if (attr->defaultValue != NULL)
  ------------------
  |  Branch (1785:6): [True: 0, False: 0]
  ------------------
 1786|      0|	    xmlFree((xmlChar *) attr->defaultValue);
 1787|      0|	if (attr->prefix != NULL)
  ------------------
  |  Branch (1787:6): [True: 0, False: 0]
  ------------------
 1788|      0|	    xmlFree((xmlChar *) attr->prefix);
 1789|      0|    }
 1790|     88|    xmlFree(attr);
 1791|     88|}
valid.c:xmlScanIDAttributeDecl:
 1732|     66|xmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {
 1733|     66|    xmlAttributePtr cur;
 1734|     66|    int ret = 0;
 1735|       |
 1736|     66|    if (elem == NULL) return(0);
  ------------------
  |  Branch (1736:9): [True: 0, False: 66]
  ------------------
 1737|     66|    cur = elem->attributes;
 1738|     66|    while (cur != NULL) {
  ------------------
  |  Branch (1738:12): [True: 0, False: 66]
  ------------------
 1739|      0|        if (cur->atype == XML_ATTRIBUTE_ID) {
  ------------------
  |  Branch (1739:13): [True: 0, False: 0]
  ------------------
 1740|      0|	    ret ++;
 1741|      0|	    if ((ret > 1) && (err))
  ------------------
  |  Branch (1741:10): [True: 0, False: 0]
  |  Branch (1741:23): [True: 0, False: 0]
  ------------------
 1742|      0|		xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,
 1743|      0|	       "Element %s has too many ID attributes defined : %s\n",
 1744|      0|		       elem->name, cur->name, NULL);
 1745|      0|	}
 1746|      0|	cur = cur->nexth;
 1747|      0|    }
 1748|     66|    return(ret);
 1749|     66|}
valid.c:xmlFreeAttributeTableEntry:
 2027|     88|xmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {
 2028|     88|    xmlFreeAttribute((xmlAttributePtr) attr);
 2029|     88|}
valid.c:xmlIsStreaming:
 2471|    110|xmlIsStreaming(xmlValidCtxtPtr ctxt) {
 2472|    110|    xmlParserCtxtPtr pctxt;
 2473|       |
 2474|    110|    if (ctxt == NULL)
  ------------------
  |  Branch (2474:9): [True: 0, False: 110]
  ------------------
 2475|      0|        return(0);
 2476|    110|    if ((ctxt->flags & XML_VCTXT_USE_PCTXT) == 0)
  ------------------
  |  |   18|    110|#define XML_VCTXT_USE_PCTXT (1u << 1)
  ------------------
  |  Branch (2476:9): [True: 0, False: 110]
  ------------------
 2477|      0|        return(0);
 2478|    110|    pctxt = ctxt->userData;
 2479|    110|    return(pctxt->parseMode == XML_PARSE_READER);
 2480|    110|}
valid.c:xmlFreeID:
 2489|    110|xmlFreeID(xmlIDPtr id) {
 2490|    110|    xmlDictPtr dict = NULL;
 2491|       |
 2492|    110|    if (id == NULL) return;
  ------------------
  |  Branch (2492:9): [True: 0, False: 110]
  ------------------
 2493|       |
 2494|    110|    if (id->doc != NULL)
  ------------------
  |  Branch (2494:9): [True: 110, False: 0]
  ------------------
 2495|    110|        dict = id->doc->dict;
 2496|       |
 2497|    110|    if (id->value != NULL)
  ------------------
  |  Branch (2497:9): [True: 110, False: 0]
  ------------------
 2498|    110|	DICT_FREE(id->value)
  ------------------
  |  | 2437|    110|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 110, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 110]
  |  |  ------------------
  |  | 2438|    110|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 110, False: 0]
  |  |  ------------------
  |  | 2439|    110|	    xmlFree((char *)(str));
  ------------------
 2499|    110|    if (id->name != NULL)
  ------------------
  |  Branch (2499:9): [True: 0, False: 110]
  ------------------
 2500|      0|	DICT_FREE(id->name)
  ------------------
  |  | 2437|      0|	if ((str) && ((!dict) ||				\
  |  |  ------------------
  |  |  |  Branch (2437:6): [True: 0, False: 0]
  |  |  |  Branch (2437:16): [True: 0, False: 0]
  |  |  ------------------
  |  | 2438|      0|	    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))	\
  |  |  ------------------
  |  |  |  Branch (2438:6): [True: 0, False: 0]
  |  |  ------------------
  |  | 2439|      0|	    xmlFree((char *)(str));
  ------------------
 2501|    110|    xmlFree(id);
 2502|    110|}
valid.c:xmlFreeIDTableEntry:
 2590|    110|xmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {
 2591|    110|    xmlFreeID((xmlIDPtr) id);
 2592|    110|}
valid.c:xmlGetDtdElementDesc2:
 3133|     88|                      int create) {
 3134|     88|    xmlElementTablePtr table;
 3135|     88|    xmlElementPtr cur;
 3136|     88|    xmlChar *uqname = NULL, *prefix = NULL;
 3137|       |
 3138|     88|    if (dtd == NULL) return(NULL);
  ------------------
  |  Branch (3138:9): [True: 0, False: 88]
  ------------------
 3139|     88|    if (dtd->elements == NULL) {
  ------------------
  |  Branch (3139:9): [True: 0, False: 88]
  ------------------
 3140|      0|	xmlDictPtr dict = NULL;
 3141|       |
 3142|      0|	if (dtd->doc != NULL)
  ------------------
  |  Branch (3142:6): [True: 0, False: 0]
  ------------------
 3143|      0|	    dict = dtd->doc->dict;
 3144|       |
 3145|      0|	if (!create)
  ------------------
  |  Branch (3145:6): [True: 0, False: 0]
  ------------------
 3146|      0|	    return(NULL);
 3147|       |	/*
 3148|       |	 * Create the Element table if needed.
 3149|       |	 */
 3150|      0|	table = (xmlElementTablePtr) dtd->elements;
 3151|      0|	if (table == NULL) {
  ------------------
  |  Branch (3151:6): [True: 0, False: 0]
  ------------------
 3152|      0|	    table = xmlHashCreateDict(0, dict);
 3153|      0|	    dtd->elements = (void *) table;
 3154|      0|	}
 3155|      0|	if (table == NULL) {
  ------------------
  |  Branch (3155:6): [True: 0, False: 0]
  ------------------
 3156|      0|	    xmlVErrMemory(ctxt, "element table allocation failed");
 3157|      0|	    return(NULL);
 3158|      0|	}
 3159|      0|    }
 3160|     88|    table = (xmlElementTablePtr) dtd->elements;
 3161|       |
 3162|     88|    uqname = xmlSplitQName2(name, &prefix);
 3163|     88|    if (uqname != NULL)
  ------------------
  |  Branch (3163:9): [True: 0, False: 88]
  ------------------
 3164|      0|        name = uqname;
 3165|     88|    cur = xmlHashLookup2(table, name, prefix);
 3166|     88|    if ((cur == NULL) && (create)) {
  ------------------
  |  Branch (3166:9): [True: 0, False: 88]
  |  Branch (3166:26): [True: 0, False: 0]
  ------------------
 3167|      0|	cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));
 3168|      0|	if (cur == NULL) {
  ------------------
  |  Branch (3168:6): [True: 0, False: 0]
  ------------------
 3169|      0|	    xmlVErrMemory(ctxt, "malloc failed");
 3170|      0|	    goto error;
 3171|      0|	}
 3172|      0|	memset(cur, 0, sizeof(xmlElement));
 3173|      0|	cur->type = XML_ELEMENT_DECL;
 3174|       |
 3175|       |	/*
 3176|       |	 * fill the structure.
 3177|       |	 */
 3178|      0|	cur->name = xmlStrdup(name);
 3179|      0|	cur->prefix = xmlStrdup(prefix);
 3180|      0|	cur->etype = XML_ELEMENT_TYPE_UNDEFINED;
 3181|       |
 3182|      0|	if (xmlHashAddEntry2(table, name, prefix, cur) < 0) {
  ------------------
  |  Branch (3182:6): [True: 0, False: 0]
  ------------------
 3183|      0|	    xmlVErrMemory(ctxt, "adding entry failed");
 3184|      0|            xmlFreeElement(cur);
 3185|      0|            cur = NULL;
 3186|      0|        }
 3187|      0|    }
 3188|     88|error:
 3189|     88|    if (prefix != NULL) xmlFree(prefix);
  ------------------
  |  Branch (3189:9): [True: 0, False: 88]
  ------------------
 3190|     88|    if (uqname != NULL) xmlFree(uqname);
  ------------------
  |  Branch (3190:9): [True: 0, False: 88]
  ------------------
 3191|     88|    return(cur);
 3192|     88|}

xmlRegisterInputCallbacks:
 2102|      6|	xmlInputCloseCallback closeFunc) {
 2103|      6|    if (xmlInputCallbackNr >= MAX_INPUT_CALLBACK) {
  ------------------
  |  |   85|      6|#define MAX_INPUT_CALLBACK 15
  ------------------
  |  Branch (2103:9): [True: 0, False: 6]
  ------------------
 2104|      0|	return(-1);
 2105|      0|    }
 2106|      6|    xmlInputCallbackTable[xmlInputCallbackNr].matchcallback = matchFunc;
 2107|      6|    xmlInputCallbackTable[xmlInputCallbackNr].opencallback = openFunc;
 2108|      6|    xmlInputCallbackTable[xmlInputCallbackNr].readcallback = readFunc;
 2109|      6|    xmlInputCallbackTable[xmlInputCallbackNr].closecallback = closeFunc;
 2110|      6|    xmlInputCallbackInitialized = 1;
 2111|      6|    return(xmlInputCallbackNr++);
 2112|      6|}
xmlRegisterOutputCallbacks:
 2129|      2|	xmlOutputCloseCallback closeFunc) {
 2130|      2|    if (xmlOutputCallbackNr >= MAX_OUTPUT_CALLBACK) {
  ------------------
  |  |  102|      2|#define MAX_OUTPUT_CALLBACK 15
  ------------------
  |  Branch (2130:9): [True: 0, False: 2]
  ------------------
 2131|      0|	return(-1);
 2132|      0|    }
 2133|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].matchcallback = matchFunc;
 2134|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].opencallback = openFunc;
 2135|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].writecallback = writeFunc;
 2136|      2|    xmlOutputCallbackTable[xmlOutputCallbackNr].closecallback = closeFunc;
 2137|      2|    xmlOutputCallbackInitialized = 1;
 2138|      2|    return(xmlOutputCallbackNr++);
 2139|      2|}
xmlRegisterDefaultInputCallbacks:
 2148|      2|xmlRegisterDefaultInputCallbacks(void) {
 2149|      2|    if (xmlInputCallbackInitialized)
  ------------------
  |  Branch (2149:9): [True: 0, False: 2]
  ------------------
 2150|      0|	return;
 2151|       |
 2152|      2|    xmlRegisterInputCallbacks(xmlFileMatch, xmlFileOpen,
 2153|      2|	                      xmlFileRead, xmlFileClose);
 2154|      2|#ifdef LIBXML_ZLIB_ENABLED
 2155|      2|    xmlRegisterInputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2156|      2|	                      xmlGzfileRead, xmlGzfileClose);
 2157|      2|#endif /* LIBXML_ZLIB_ENABLED */
 2158|      2|#ifdef LIBXML_LZMA_ENABLED
 2159|      2|    xmlRegisterInputCallbacks(xmlXzfileMatch, xmlXzfileOpen,
 2160|      2|	                      xmlXzfileRead, xmlXzfileClose);
 2161|      2|#endif /* LIBXML_LZMA_ENABLED */
 2162|       |
 2163|       |#ifdef LIBXML_HTTP_ENABLED
 2164|       |    xmlRegisterInputCallbacks(xmlIOHTTPMatch, xmlIOHTTPOpen,
 2165|       |	                      xmlIOHTTPRead, xmlIOHTTPClose);
 2166|       |#endif /* LIBXML_HTTP_ENABLED */
 2167|       |
 2168|       |#ifdef LIBXML_FTP_ENABLED
 2169|       |    xmlRegisterInputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2170|       |	                      xmlIOFTPRead, xmlIOFTPClose);
 2171|       |#endif /* LIBXML_FTP_ENABLED */
 2172|      2|    xmlInputCallbackInitialized = 1;
 2173|      2|}
xmlRegisterDefaultOutputCallbacks:
 2182|      2|xmlRegisterDefaultOutputCallbacks (void) {
 2183|      2|    if (xmlOutputCallbackInitialized)
  ------------------
  |  Branch (2183:9): [True: 0, False: 2]
  ------------------
 2184|      0|	return;
 2185|       |
 2186|      2|    xmlRegisterOutputCallbacks(xmlFileMatch, xmlFileOpenW,
 2187|      2|	                      xmlFileWrite, xmlFileClose);
 2188|       |
 2189|       |#ifdef LIBXML_HTTP_ENABLED
 2190|       |    xmlRegisterOutputCallbacks(xmlIOHTTPMatch, xmlIOHTTPDfltOpenW,
 2191|       |	                       xmlIOHTTPWrite, xmlIOHTTPClosePut);
 2192|       |#endif
 2193|       |
 2194|       |/*********************************
 2195|       | No way a-priori to distinguish between gzipped files from
 2196|       | uncompressed ones except opening if existing then closing
 2197|       | and saving with same compression ratio ... a pain.
 2198|       |
 2199|       |#ifdef LIBXML_ZLIB_ENABLED
 2200|       |    xmlRegisterOutputCallbacks(xmlGzfileMatch, xmlGzfileOpen,
 2201|       |	                       xmlGzfileWrite, xmlGzfileClose);
 2202|       |#endif
 2203|       |
 2204|       | Nor FTP PUT ....
 2205|       |#ifdef LIBXML_FTP_ENABLED
 2206|       |    xmlRegisterOutputCallbacks(xmlIOFTPMatch, xmlIOFTPOpen,
 2207|       |	                       xmlIOFTPWrite, xmlIOFTPClose);
 2208|       |#endif
 2209|       | **********************************/
 2210|      2|    xmlOutputCallbackInitialized = 1;
 2211|      2|}
xmlAllocParserInputBuffer:
 2246|    486|xmlAllocParserInputBuffer(xmlCharEncoding enc) {
 2247|    486|    xmlParserInputBufferPtr ret;
 2248|       |
 2249|    486|    ret = (xmlParserInputBufferPtr) xmlMalloc(sizeof(xmlParserInputBuffer));
 2250|    486|    if (ret == NULL) {
  ------------------
  |  Branch (2250:9): [True: 0, False: 486]
  ------------------
 2251|      0|	return(NULL);
 2252|      0|    }
 2253|    486|    memset(ret, 0, sizeof(xmlParserInputBuffer));
 2254|    486|    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|    486|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|    486|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2255|    486|    if (ret->buffer == NULL) {
  ------------------
  |  Branch (2255:9): [True: 0, False: 486]
  ------------------
 2256|      0|        xmlFree(ret);
 2257|      0|	return(NULL);
 2258|      0|    }
 2259|    486|    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);
 2260|    486|    ret->encoder = xmlGetCharEncodingHandler(enc);
 2261|    486|    if (ret->encoder != NULL)
  ------------------
  |  Branch (2261:9): [True: 0, False: 486]
  ------------------
 2262|      0|        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);
  ------------------
  |  |  680|      0|  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 2263|    486|    else
 2264|    486|        ret->raw = NULL;
 2265|    486|    ret->readcallback = NULL;
 2266|    486|    ret->closecallback = NULL;
 2267|    486|    ret->context = NULL;
 2268|    486|    ret->compressed = -1;
 2269|    486|    ret->rawconsumed = 0;
 2270|       |
 2271|    486|    return(ret);
 2272|    486|}
xmlFreeParserInputBuffer:
 2383|    486|xmlFreeParserInputBuffer(xmlParserInputBufferPtr in) {
 2384|    486|    if (in == NULL) return;
  ------------------
  |  Branch (2384:9): [True: 0, False: 486]
  ------------------
 2385|       |
 2386|    486|    if (in->raw) {
  ------------------
  |  Branch (2386:9): [True: 0, False: 486]
  ------------------
 2387|      0|        xmlBufFree(in->raw);
 2388|      0|	in->raw = NULL;
 2389|      0|    }
 2390|    486|    if (in->encoder != NULL) {
  ------------------
  |  Branch (2390:9): [True: 0, False: 486]
  ------------------
 2391|      0|        xmlCharEncCloseFunc(in->encoder);
 2392|      0|    }
 2393|    486|    if (in->closecallback != NULL) {
  ------------------
  |  Branch (2393:9): [True: 486, False: 0]
  ------------------
 2394|    486|	in->closecallback(in->context);
 2395|    486|    }
 2396|    486|    if (in->buffer != NULL) {
  ------------------
  |  Branch (2396:9): [True: 486, False: 0]
  ------------------
 2397|    486|        xmlBufFree(in->buffer);
 2398|    486|	in->buffer = NULL;
 2399|    486|    }
 2400|       |
 2401|    486|    xmlFree(in);
 2402|    486|}
xmlParserInputBufferCreateMem:
 2870|    486|xmlParserInputBufferCreateMem(const char *mem, int size, xmlCharEncoding enc) {
 2871|    486|    xmlParserInputBufferPtr ret;
 2872|    486|    xmlMemIOCtxt *ctxt;
 2873|       |
 2874|    486|    if (size < 0) return(NULL);
  ------------------
  |  Branch (2874:9): [True: 0, False: 486]
  ------------------
 2875|    486|    if (mem == NULL) return(NULL);
  ------------------
  |  Branch (2875:9): [True: 0, False: 486]
  ------------------
 2876|       |
 2877|    486|    ret = xmlAllocParserInputBuffer(enc);
 2878|    486|    if (ret == NULL)
  ------------------
  |  Branch (2878:9): [True: 0, False: 486]
  ------------------
 2879|      0|        return(NULL);
 2880|       |
 2881|    486|    ctxt = xmlMalloc(sizeof(*ctxt));
 2882|    486|    if (ctxt == NULL) {
  ------------------
  |  Branch (2882:9): [True: 0, False: 486]
  ------------------
 2883|      0|        xmlFreeParserInputBuffer(ret);
 2884|      0|        return(NULL);
 2885|      0|    }
 2886|    486|    ctxt->mem = mem;
 2887|    486|    ctxt->size = size;
 2888|       |
 2889|    486|    ret->context = ctxt;
 2890|    486|    ret->readcallback = xmlMemRead;
 2891|    486|    ret->closecallback = xmlMemClose;
 2892|       |
 2893|    486|    return(ret);
 2894|    486|}
xmlParserInputBufferGrow:
 3185|  24.6k|xmlParserInputBufferGrow(xmlParserInputBufferPtr in, int len) {
 3186|  24.6k|    xmlBufPtr buf;
 3187|  24.6k|    int res = 0;
 3188|       |
 3189|  24.6k|    if ((in == NULL) || (in->error)) return(-1);
  ------------------
  |  Branch (3189:9): [True: 0, False: 24.6k]
  |  Branch (3189:25): [True: 0, False: 24.6k]
  ------------------
 3190|  24.6k|    if ((len <= MINLEN) && (len != 4))
  ------------------
  |  |   73|  24.6k|#define MINLEN 4000
  ------------------
  |  Branch (3190:9): [True: 24.6k, False: 0]
  |  Branch (3190:28): [True: 24.6k, False: 0]
  ------------------
 3191|  24.6k|        len = MINLEN;
  ------------------
  |  |   73|  24.6k|#define MINLEN 4000
  ------------------
 3192|       |
 3193|  24.6k|    if (in->encoder == NULL) {
  ------------------
  |  Branch (3193:9): [True: 24.6k, False: 0]
  ------------------
 3194|  24.6k|        if (in->readcallback == NULL)
  ------------------
  |  Branch (3194:13): [True: 0, False: 24.6k]
  ------------------
 3195|      0|            return(0);
 3196|  24.6k|        buf = in->buffer;
 3197|  24.6k|    } else {
 3198|      0|        if (in->raw == NULL) {
  ------------------
  |  Branch (3198:13): [True: 0, False: 0]
  ------------------
 3199|      0|	    in->raw = xmlBufCreate();
 3200|      0|	}
 3201|      0|        buf = in->raw;
 3202|      0|    }
 3203|       |
 3204|       |    /*
 3205|       |     * Call the read method for this I/O type.
 3206|       |     */
 3207|  24.6k|    if (in->readcallback != NULL) {
  ------------------
  |  Branch (3207:9): [True: 24.6k, False: 0]
  ------------------
 3208|  24.6k|        if (xmlBufGrow(buf, len + 1) < 0) {
  ------------------
  |  Branch (3208:13): [True: 0, False: 24.6k]
  ------------------
 3209|      0|            in->error = XML_ERR_NO_MEMORY;
 3210|      0|            return(-1);
 3211|      0|        }
 3212|       |
 3213|  24.6k|	res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);
 3214|  24.6k|	if (res <= 0)
  ------------------
  |  Branch (3214:6): [True: 24.2k, False: 486]
  ------------------
 3215|  24.2k|	    in->readcallback = endOfInput;
 3216|  24.6k|        if (res < 0) {
  ------------------
  |  Branch (3216:13): [True: 0, False: 24.6k]
  ------------------
 3217|      0|            in->error = XML_IO_UNKNOWN;
 3218|      0|            return(-1);
 3219|      0|        }
 3220|       |
 3221|  24.6k|        if (xmlBufAddLen(buf, res) < 0) {
  ------------------
  |  Branch (3221:13): [True: 0, False: 24.6k]
  ------------------
 3222|      0|            in->error = XML_ERR_NO_MEMORY;
 3223|      0|            return(-1);
 3224|      0|        }
 3225|  24.6k|    }
 3226|       |
 3227|       |    /*
 3228|       |     * try to establish compressed status of input if not done already
 3229|       |     */
 3230|  24.6k|    if (in->compressed == -1) {
  ------------------
  |  Branch (3230:9): [True: 24.6k, False: 0]
  ------------------
 3231|  24.6k|#ifdef LIBXML_LZMA_ENABLED
 3232|  24.6k|	if (in->readcallback == xmlXzfileRead)
  ------------------
  |  Branch (3232:6): [True: 0, False: 24.6k]
  ------------------
 3233|      0|            in->compressed = __libxml2_xzcompressed(in->context);
 3234|  24.6k|#endif
 3235|  24.6k|    }
 3236|       |
 3237|  24.6k|    if (in->encoder != NULL) {
  ------------------
  |  Branch (3237:9): [True: 0, False: 24.6k]
  ------------------
 3238|      0|	res = xmlCharEncInput(in);
 3239|      0|	if (res < 0)
  ------------------
  |  Branch (3239:6): [True: 0, False: 0]
  ------------------
 3240|      0|	    return(-1);
 3241|      0|    }
 3242|  24.6k|    return(res);
 3243|  24.6k|}
xmlIO.c:xmlMemRead:
 2839|    966|xmlMemRead(void *vctxt, char *buf, int size) {
 2840|    966|    xmlMemIOCtxt *ctxt = vctxt;
 2841|       |
 2842|    966|    if ((size_t) size > ctxt->size)
  ------------------
  |  Branch (2842:9): [True: 966, False: 0]
  ------------------
 2843|    966|        size = ctxt->size;
 2844|       |
 2845|    966|    memcpy(buf, ctxt->mem, size);
 2846|    966|    ctxt->mem += size;
 2847|    966|    ctxt->size -= size;
 2848|       |
 2849|    966|    return size;
 2850|    966|}
xmlIO.c:xmlMemClose:
 2853|    486|xmlMemClose(void *vctxt) {
 2854|    486|    xmlFree(vctxt);
 2855|    486|    return(0);
 2856|    486|}
xmlIO.c:endOfInput:
 3165|  23.7k|	    int len ATTRIBUTE_UNUSED) {
 3166|  23.7k|    return(0);
 3167|  23.7k|}

xmlInitMemoryInternal:
  846|      2|xmlInitMemoryInternal(void) {
  847|      2|     char *breakpoint;
  848|      2|     xmlInitMutex(&xmlMemMutex);
  849|       |
  850|      2|     breakpoint = getenv("XML_MEM_BREAKPOINT");
  851|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (851:10): [True: 0, False: 2]
  ------------------
  852|      0|         sscanf(breakpoint, "%ud", &xmlMemStopAtBlock);
  853|      0|     }
  854|      2|     breakpoint = getenv("XML_MEM_TRACE");
  855|      2|     if (breakpoint != NULL) {
  ------------------
  |  Branch (855:10): [True: 0, False: 2]
  ------------------
  856|      0|         sscanf(breakpoint, "%p", &xmlMemTraceBlockAt);
  857|      0|     }
  858|       |
  859|      2|}
xmlMemSetup:
  910|      2|            xmlReallocFunc reallocFunc, xmlStrdupFunc strdupFunc) {
  911|      2|    if (freeFunc == NULL)
  ------------------
  |  Branch (911:9): [True: 0, False: 2]
  ------------------
  912|      0|	return(-1);
  913|      2|    if (mallocFunc == NULL)
  ------------------
  |  Branch (913:9): [True: 0, False: 2]
  ------------------
  914|      0|	return(-1);
  915|      2|    if (reallocFunc == NULL)
  ------------------
  |  Branch (915:9): [True: 0, False: 2]
  ------------------
  916|      0|	return(-1);
  917|      2|    if (strdupFunc == NULL)
  ------------------
  |  Branch (917:9): [True: 0, False: 2]
  ------------------
  918|      0|	return(-1);
  919|      2|    xmlFree = freeFunc;
  920|      2|    xmlMalloc = mallocFunc;
  921|      2|    xmlMallocAtomic = mallocFunc;
  922|      2|    xmlRealloc = reallocFunc;
  923|      2|    xmlMemStrdup = strdupFunc;
  924|      2|    return(0);
  925|      2|}

xmlStrndup:
   45|  6.18k|xmlStrndup(const xmlChar *cur, int len) {
   46|  6.18k|    xmlChar *ret;
   47|       |
   48|  6.18k|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (48:9): [True: 0, False: 6.18k]
  |  Branch (48:26): [True: 0, False: 6.18k]
  ------------------
   49|  6.18k|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   50|  6.18k|    if (ret == NULL) {
  ------------------
  |  Branch (50:9): [True: 10, False: 6.17k]
  ------------------
   51|     10|        return(NULL);
   52|     10|    }
   53|  6.17k|    memcpy(ret, cur, len);
   54|  6.17k|    ret[len] = 0;
   55|  6.17k|    return(ret);
   56|  6.18k|}
xmlStrdup:
   69|  3.40k|xmlStrdup(const xmlChar *cur) {
   70|  3.40k|    const xmlChar *p = cur;
   71|       |
   72|  3.40k|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (72:9): [True: 959, False: 2.44k]
  ------------------
   73|  31.9k|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (73:12): [True: 29.5k, False: 2.44k]
  ------------------
   74|  2.44k|    return(xmlStrndup(cur, p - cur));
   75|  3.40k|}
xmlCharStrndup:
   88|    305|xmlCharStrndup(const char *cur, int len) {
   89|    305|    int i;
   90|    305|    xmlChar *ret;
   91|       |
   92|    305|    if ((cur == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (92:9): [True: 0, False: 305]
  |  Branch (92:26): [True: 0, False: 305]
  ------------------
   93|    305|    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);
   94|    305|    if (ret == NULL) {
  ------------------
  |  Branch (94:9): [True: 0, False: 305]
  ------------------
   95|      0|        return(NULL);
   96|      0|    }
   97|  1.22k|    for (i = 0;i < len;i++) {
  ------------------
  |  Branch (97:16): [True: 915, False: 305]
  ------------------
   98|       |        /* Explicit sign change */
   99|    915|        ret[i] = (xmlChar) cur[i];
  100|    915|        if (ret[i] == 0) return(ret);
  ------------------
  |  Branch (100:13): [True: 0, False: 915]
  ------------------
  101|    915|    }
  102|    305|    ret[len] = 0;
  103|    305|    return(ret);
  104|    305|}
xmlCharStrdup:
  116|    305|xmlCharStrdup(const char *cur) {
  117|    305|    const char *p = cur;
  118|       |
  119|    305|    if (cur == NULL) return(NULL);
  ------------------
  |  Branch (119:9): [True: 0, False: 305]
  ------------------
  120|  1.22k|    while (*p != '\0') p++; /* non input consuming */
  ------------------
  |  Branch (120:12): [True: 915, False: 305]
  ------------------
  121|    305|    return(xmlCharStrndup(cur, p - cur));
  122|    305|}
xmlStrEqual:
  162|  4.62k|xmlStrEqual(const xmlChar *str1, const xmlChar *str2) {
  163|  4.62k|    if (str1 == str2) return(1);
  ------------------
  |  Branch (163:9): [True: 330, False: 4.29k]
  ------------------
  164|  4.29k|    if (str1 == NULL) return(0);
  ------------------
  |  Branch (164:9): [True: 0, False: 4.29k]
  ------------------
  165|  4.29k|    if (str2 == NULL) return(0);
  ------------------
  |  Branch (165:9): [True: 0, False: 4.29k]
  ------------------
  166|  4.29k|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  167|  4.29k|    return(strcmp((const char *)str1, (const char *)str2) == 0);
  168|       |#else
  169|       |    do {
  170|       |        if (*str1++ != *str2) return(0);
  171|       |    } while (*str2++);
  172|       |    return(1);
  173|       |#endif
  174|  4.29k|}
xmlStrQEqual:
  188|    330|xmlStrQEqual(const xmlChar *pref, const xmlChar *name, const xmlChar *str) {
  189|    330|    if (pref == NULL) return(xmlStrEqual(name, str));
  ------------------
  |  Branch (189:9): [True: 330, False: 0]
  ------------------
  190|      0|    if (name == NULL) return(0);
  ------------------
  |  Branch (190:9): [True: 0, False: 0]
  ------------------
  191|      0|    if (str == NULL) return(0);
  ------------------
  |  Branch (191:9): [True: 0, False: 0]
  ------------------
  192|       |
  193|      0|    do {
  194|      0|        if (*pref++ != *str) return(0);
  ------------------
  |  Branch (194:13): [True: 0, False: 0]
  ------------------
  195|      0|    } while ((*str++) && (*pref));
  ------------------
  |  Branch (195:14): [True: 0, False: 0]
  |  Branch (195:26): [True: 0, False: 0]
  ------------------
  196|      0|    if (*str++ != ':') return(0);
  ------------------
  |  Branch (196:9): [True: 0, False: 0]
  ------------------
  197|      0|    do {
  198|      0|        if (*name++ != *str) return(0);
  ------------------
  |  Branch (198:13): [True: 0, False: 0]
  ------------------
  199|      0|    } while (*str++);
  ------------------
  |  Branch (199:14): [True: 0, False: 0]
  ------------------
  200|      0|    return(1);
  201|      0|}
xmlStrncmp:
  215|     19|xmlStrncmp(const xmlChar *str1, const xmlChar *str2, int len) {
  216|     19|    if (len <= 0) return(0);
  ------------------
  |  Branch (216:9): [True: 0, False: 19]
  ------------------
  217|     19|    if (str1 == str2) return(0);
  ------------------
  |  Branch (217:9): [True: 0, False: 19]
  ------------------
  218|     19|    if (str1 == NULL) return(-1);
  ------------------
  |  Branch (218:9): [True: 0, False: 19]
  ------------------
  219|     19|    if (str2 == NULL) return(1);
  ------------------
  |  Branch (219:9): [True: 0, False: 19]
  ------------------
  220|     19|#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
  221|     19|    return(strncmp((const char *)str1, (const char *)str2, len));
  222|       |#else
  223|       |    do {
  224|       |        int tmp = *str1++ - *str2;
  225|       |        if (tmp != 0 || --len == 0) return(tmp);
  226|       |    } while (*str2++ != 0);
  227|       |    return 0;
  228|       |#endif
  229|     19|}
xmlStrchr:
  327|  1.18k|xmlStrchr(const xmlChar *str, xmlChar val) {
  328|  1.18k|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (328:9): [True: 0, False: 1.18k]
  ------------------
  329|  17.0k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (329:12): [True: 16.1k, False: 876]
  ------------------
  330|  16.1k|        if (*str == val) return((xmlChar *) str);
  ------------------
  |  Branch (330:13): [True: 307, False: 15.8k]
  ------------------
  331|  15.8k|        str++;
  332|  15.8k|    }
  333|    876|    return(NULL);
  334|  1.18k|}
xmlStrstr:
  347|    245|xmlStrstr(const xmlChar *str, const xmlChar *val) {
  348|    245|    int n;
  349|       |
  350|    245|    if (str == NULL) return(NULL);
  ------------------
  |  Branch (350:9): [True: 0, False: 245]
  ------------------
  351|    245|    if (val == NULL) return(NULL);
  ------------------
  |  Branch (351:9): [True: 0, False: 245]
  ------------------
  352|    245|    n = xmlStrlen(val);
  353|       |
  354|    245|    if (n == 0) return(str);
  ------------------
  |  Branch (354:9): [True: 0, False: 245]
  ------------------
  355|  1.92k|    while (*str != 0) { /* non input consuming */
  ------------------
  |  Branch (355:12): [True: 1.68k, False: 240]
  ------------------
  356|  1.68k|        if (*str == *val) {
  ------------------
  |  Branch (356:13): [True: 17, False: 1.66k]
  ------------------
  357|     17|            if (!xmlStrncmp(str, val, n)) return((const xmlChar *) str);
  ------------------
  |  Branch (357:17): [True: 5, False: 12]
  ------------------
  358|     17|        }
  359|  1.67k|        str++;
  360|  1.67k|    }
  361|    240|    return(NULL);
  362|    245|}
xmlStrlen:
  428|  1.33k|xmlStrlen(const xmlChar *str) {
  429|  1.33k|    size_t len = str ? strlen((const char *)str) : 0;
  ------------------
  |  Branch (429:18): [True: 1.33k, False: 0]
  ------------------
  430|  1.33k|    return(len > INT_MAX ? 0 : len);
  ------------------
  |  Branch (430:12): [True: 0, False: 1.33k]
  ------------------
  431|  1.33k|}
xmlStrncat:
  448|      7|xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {
  449|      7|    int size;
  450|      7|    xmlChar *ret;
  451|       |
  452|      7|    if ((add == NULL) || (len == 0))
  ------------------
  |  Branch (452:9): [True: 0, False: 7]
  |  Branch (452:26): [True: 0, False: 7]
  ------------------
  453|      0|        return(cur);
  454|      7|    if (len < 0)
  ------------------
  |  Branch (454:9): [True: 0, False: 7]
  ------------------
  455|      0|	return(NULL);
  456|      7|    if (cur == NULL)
  ------------------
  |  Branch (456:9): [True: 0, False: 7]
  ------------------
  457|      0|        return(xmlStrndup(add, len));
  458|       |
  459|      7|    size = xmlStrlen(cur);
  460|      7|    if ((size < 0) || (size > INT_MAX - len))
  ------------------
  |  Branch (460:9): [True: 0, False: 7]
  |  Branch (460:23): [True: 0, False: 7]
  ------------------
  461|      0|        return(NULL);
  462|      7|    ret = (xmlChar *) xmlRealloc(cur, (size_t) size + len + 1);
  463|      7|    if (ret == NULL) {
  ------------------
  |  Branch (463:9): [True: 0, False: 7]
  ------------------
  464|      0|        return(cur);
  465|      0|    }
  466|      7|    memcpy(&ret[size], add, len);
  467|      7|    ret[size + len] = 0;
  468|      7|    return(ret);
  469|      7|}
xmlStrcat:
  524|      7|xmlStrcat(xmlChar *cur, const xmlChar *add) {
  525|      7|    const xmlChar *p = add;
  526|       |
  527|      7|    if (add == NULL) return(cur);
  ------------------
  |  Branch (527:9): [True: 0, False: 7]
  ------------------
  528|      7|    if (cur == NULL)
  ------------------
  |  Branch (528:9): [True: 0, False: 7]
  ------------------
  529|      0|        return(xmlStrdup(add));
  530|       |
  531|     51|    while (*p != 0) p++; /* non input consuming */
  ------------------
  |  Branch (531:12): [True: 44, False: 7]
  ------------------
  532|      7|    return(xmlStrncat(cur, add, p - add));
  533|      7|}
xmlStrPrintf:
  547|      9|xmlStrPrintf(xmlChar *buf, int len, const char *msg, ...) {
  548|      9|    va_list args;
  549|      9|    int ret;
  550|       |
  551|      9|    if((buf == NULL) || (msg == NULL)) {
  ------------------
  |  Branch (551:8): [True: 0, False: 9]
  |  Branch (551:25): [True: 0, False: 9]
  ------------------
  552|      0|        return(-1);
  553|      0|    }
  554|       |
  555|      9|    va_start(args, msg);
  556|      9|    ret = vsnprintf((char *) buf, len, (const char *) msg, args);
  557|      9|    va_end(args);
  558|      9|    buf[len - 1] = 0; /* be safe ! */
  559|       |
  560|      9|    return(ret);
  561|      9|}
xmlUTF8Strlen:
  664|      2|xmlUTF8Strlen(const xmlChar *utf) {
  665|      2|    size_t ret = 0;
  666|       |
  667|      2|    if (utf == NULL)
  ------------------
  |  Branch (667:9): [True: 0, False: 2]
  ------------------
  668|      0|        return(-1);
  669|       |
  670|      6|    while (*utf != 0) {
  ------------------
  |  Branch (670:12): [True: 4, False: 2]
  ------------------
  671|      4|        if (utf[0] & 0x80) {
  ------------------
  |  Branch (671:13): [True: 0, False: 4]
  ------------------
  672|      0|            if ((utf[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (672:17): [True: 0, False: 0]
  ------------------
  673|      0|                return(-1);
  674|      0|            if ((utf[0] & 0xe0) == 0xe0) {
  ------------------
  |  Branch (674:17): [True: 0, False: 0]
  ------------------
  675|      0|                if ((utf[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (675:21): [True: 0, False: 0]
  ------------------
  676|      0|                    return(-1);
  677|      0|                if ((utf[0] & 0xf0) == 0xf0) {
  ------------------
  |  Branch (677:21): [True: 0, False: 0]
  ------------------
  678|      0|                    if ((utf[0] & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)
  ------------------
  |  Branch (678:25): [True: 0, False: 0]
  |  Branch (678:52): [True: 0, False: 0]
  ------------------
  679|      0|                        return(-1);
  680|      0|                    utf += 4;
  681|      0|                } else {
  682|      0|                    utf += 3;
  683|      0|                }
  684|      0|            } else {
  685|      0|                utf += 2;
  686|      0|            }
  687|      4|        } else {
  688|      4|            utf++;
  689|      4|        }
  690|      4|        ret++;
  691|      4|    }
  692|      2|    return(ret > INT_MAX ? 0 : ret);
  ------------------
  |  Branch (692:12): [True: 0, False: 2]
  ------------------
  693|      2|}
xmlGetUTF8Char:
  708|  4.10k|xmlGetUTF8Char(const unsigned char *utf, int *len) {
  709|  4.10k|    unsigned int c;
  710|       |
  711|  4.10k|    if (utf == NULL)
  ------------------
  |  Branch (711:9): [True: 0, False: 4.10k]
  ------------------
  712|      0|        goto error;
  713|  4.10k|    if (len == NULL)
  ------------------
  |  Branch (713:9): [True: 0, False: 4.10k]
  ------------------
  714|      0|        goto error;
  715|       |
  716|  4.10k|    c = utf[0];
  717|  4.10k|    if (c < 0x80) {
  ------------------
  |  Branch (717:9): [True: 4.07k, False: 29]
  ------------------
  718|  4.07k|        if (*len < 1)
  ------------------
  |  Branch (718:13): [True: 0, False: 4.07k]
  ------------------
  719|      0|            goto error;
  720|       |        /* 1-byte code */
  721|  4.07k|        *len = 1;
  722|  4.07k|    } else {
  723|     29|        if ((*len < 2) || ((utf[1] & 0xc0) != 0x80))
  ------------------
  |  Branch (723:13): [True: 0, False: 29]
  |  Branch (723:27): [True: 26, False: 3]
  ------------------
  724|     26|            goto error;
  725|      3|        if (c < 0xe0) {
  ------------------
  |  Branch (725:13): [True: 3, False: 0]
  ------------------
  726|      3|            if (c < 0xc2)
  ------------------
  |  Branch (726:17): [True: 3, False: 0]
  ------------------
  727|      3|                goto error;
  728|       |            /* 2-byte code */
  729|      0|            *len = 2;
  730|      0|            c = (c & 0x1f) << 6;
  731|      0|            c |= utf[1] & 0x3f;
  732|      0|        } else {
  733|      0|            if ((*len < 3) || ((utf[2] & 0xc0) != 0x80))
  ------------------
  |  Branch (733:17): [True: 0, False: 0]
  |  Branch (733:31): [True: 0, False: 0]
  ------------------
  734|      0|                goto error;
  735|      0|            if (c < 0xf0) {
  ------------------
  |  Branch (735:17): [True: 0, False: 0]
  ------------------
  736|       |                /* 3-byte code */
  737|      0|                *len = 3;
  738|      0|                c = (c & 0xf) << 12;
  739|      0|                c |= (utf[1] & 0x3f) << 6;
  740|      0|                c |= utf[2] & 0x3f;
  741|      0|                if ((c < 0x800) || ((c >= 0xd800) && (c < 0xe000)))
  ------------------
  |  Branch (741:21): [True: 0, False: 0]
  |  Branch (741:37): [True: 0, False: 0]
  |  Branch (741:54): [True: 0, False: 0]
  ------------------
  742|      0|                    goto error;
  743|      0|            } else {
  744|      0|                if ((*len < 4) || ((utf[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (744:21): [True: 0, False: 0]
  |  Branch (744:35): [True: 0, False: 0]
  ------------------
  745|      0|                    goto error;
  746|      0|                *len = 4;
  747|       |                /* 4-byte code */
  748|      0|                c = (c & 0x7) << 18;
  749|      0|                c |= (utf[1] & 0x3f) << 12;
  750|      0|                c |= (utf[2] & 0x3f) << 6;
  751|      0|                c |= utf[3] & 0x3f;
  752|      0|                if ((c < 0x10000) || (c >= 0x110000))
  ------------------
  |  Branch (752:21): [True: 0, False: 0]
  |  Branch (752:38): [True: 0, False: 0]
  ------------------
  753|      0|                    goto error;
  754|      0|            }
  755|      0|        }
  756|      3|    }
  757|  4.07k|    return(c);
  758|       |
  759|     29|error:
  760|     29|    if (len != NULL)
  ------------------
  |  Branch (760:9): [True: 29, False: 0]
  ------------------
  761|     29|	*len = 0;
  762|     29|    return(-1);
  763|  4.10k|}
xmlUTF8Strsize:
  833|     13|xmlUTF8Strsize(const xmlChar *utf, int len) {
  834|     13|    const xmlChar *ptr=utf;
  835|     13|    int ch;
  836|     13|    size_t ret;
  837|       |
  838|     13|    if (utf == NULL)
  ------------------
  |  Branch (838:9): [True: 0, False: 13]
  ------------------
  839|      0|        return(0);
  840|       |
  841|     13|    if (len <= 0)
  ------------------
  |  Branch (841:9): [True: 0, False: 13]
  ------------------
  842|      0|        return(0);
  843|       |
  844|     53|    while ( len-- > 0) {
  ------------------
  |  Branch (844:13): [True: 46, False: 7]
  ------------------
  845|     46|        if ( !*ptr )
  ------------------
  |  Branch (845:14): [True: 6, False: 40]
  ------------------
  846|      6|            break;
  847|     40|        if ( (ch = *ptr++) & 0x80)
  ------------------
  |  Branch (847:14): [True: 0, False: 40]
  ------------------
  848|      0|            while ((ch<<=1) & 0x80 ) {
  ------------------
  |  Branch (848:20): [True: 0, False: 0]
  ------------------
  849|      0|		if (*ptr == 0) break;
  ------------------
  |  Branch (849:7): [True: 0, False: 0]
  ------------------
  850|      0|                ptr++;
  851|      0|	    }
  852|     40|    }
  853|     13|    ret = ptr - utf;
  854|     13|    return (ret > INT_MAX ? 0 : ret);
  ------------------
  |  Branch (854:13): [True: 0, False: 13]
  ------------------
  855|     13|}
xmlUTF8Strndup:
  868|     13|xmlUTF8Strndup(const xmlChar *utf, int len) {
  869|     13|    xmlChar *ret;
  870|     13|    int i;
  871|       |
  872|     13|    if ((utf == NULL) || (len < 0)) return(NULL);
  ------------------
  |  Branch (872:9): [True: 0, False: 13]
  |  Branch (872:26): [True: 0, False: 13]
  ------------------
  873|     13|    i = xmlUTF8Strsize(utf, len);
  874|     13|    ret = (xmlChar *) xmlMallocAtomic((size_t) i + 1);
  875|     13|    if (ret == NULL) {
  ------------------
  |  Branch (875:9): [True: 0, False: 13]
  ------------------
  876|      0|        return(NULL);
  877|      0|    }
  878|     13|    memcpy(ret, utf, i);
  879|     13|    ret[i] = 0;
  880|     13|    return(ret);
  881|     13|}
xmlUTF8Strsub:
  964|     13|xmlUTF8Strsub(const xmlChar *utf, int start, int len) {
  965|     13|    int i;
  966|     13|    int ch;
  967|       |
  968|     13|    if (utf == NULL) return(NULL);
  ------------------
  |  Branch (968:9): [True: 0, False: 13]
  ------------------
  969|     13|    if (start < 0) return(NULL);
  ------------------
  |  Branch (969:9): [True: 0, False: 13]
  ------------------
  970|     13|    if (len < 0) return(NULL);
  ------------------
  |  Branch (970:9): [True: 0, False: 13]
  ------------------
  971|       |
  972|       |    /*
  973|       |     * Skip over any leading chars
  974|       |     */
  975|     22|    for (i = 0;i < start;i++) {
  ------------------
  |  Branch (975:16): [True: 9, False: 13]
  ------------------
  976|      9|        if ((ch=*utf++) == 0) return(NULL);
  ------------------
  |  Branch (976:13): [True: 0, False: 9]
  ------------------
  977|      9|        if ( ch & 0x80 ) {
  ------------------
  |  Branch (977:14): [True: 0, False: 9]
  ------------------
  978|       |            /* if not simple ascii, verify proper format */
  979|      0|            if ( (ch & 0xc0) != 0xc0 )
  ------------------
  |  Branch (979:18): [True: 0, False: 0]
  ------------------
  980|      0|                return(NULL);
  981|       |            /* then skip over remaining bytes for this char */
  982|      0|            while ( (ch <<= 1) & 0x80 )
  ------------------
  |  Branch (982:21): [True: 0, False: 0]
  ------------------
  983|      0|                if ( (*utf++ & 0xc0) != 0x80 )
  ------------------
  |  Branch (983:22): [True: 0, False: 0]
  ------------------
  984|      0|                    return(NULL);
  985|      0|        }
  986|      9|    }
  987|       |
  988|     13|    return(xmlUTF8Strndup(utf, len));
  989|     13|}

xmlInitXPathInternal:
  168|      2|xmlInitXPathInternal(void) {
  169|      2|#if defined(NAN) && defined(INFINITY)
  170|      2|    xmlXPathNAN = NAN;
  171|      2|    xmlXPathPINF = INFINITY;
  172|      2|    xmlXPathNINF = -INFINITY;
  173|       |#else
  174|       |    /* MSVC doesn't allow division by zero in constant expressions. */
  175|       |    double zero = 0.0;
  176|       |    xmlXPathNAN = 0.0 / zero;
  177|       |    xmlXPathPINF = 1.0 / zero;
  178|       |    xmlXPathNINF = -xmlXPathPINF;
  179|       |#endif
  180|      2|}
xmlXPathIsNaN:
  191|    196|xmlXPathIsNaN(double val) {
  192|    196|#ifdef isnan
  193|    196|    return isnan(val);
  194|       |#else
  195|       |    return !(val == val);
  196|       |#endif
  197|    196|}
xmlXPathIsInf:
  208|    205|xmlXPathIsInf(double val) {
  209|    205|#ifdef isinf
  210|    205|    return isinf(val) ? (val > 0 ? 1 : -1) : 0;
  ------------------
  |  Branch (210:26): [True: 18, False: 16]
  ------------------
  211|       |#else
  212|       |    if (val >= xmlXPathPINF)
  213|       |        return 1;
  214|       |    if (val <= -xmlXPathPINF)
  215|       |        return -1;
  216|       |    return 0;
  217|       |#endif
  218|    205|}
xmlXPathErr:
  696|     76|{
  697|     76|    if ((error < 0) || (error > MAXERRNO))
  ------------------
  |  |  624|     76|#define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) /	\
  |  |  625|     76|		   sizeof(xmlXPathErrorMessages[0])) - 1)
  ------------------
  |  Branch (697:9): [True: 0, False: 76]
  |  Branch (697:24): [True: 0, False: 76]
  ------------------
  698|      0|	error = MAXERRNO;
  ------------------
  |  |  624|      0|#define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) /	\
  |  |  625|      0|		   sizeof(xmlXPathErrorMessages[0])) - 1)
  ------------------
  699|     76|    if (ctxt == NULL) {
  ------------------
  |  Branch (699:9): [True: 0, False: 76]
  ------------------
  700|      0|	__xmlRaiseError(NULL, NULL, NULL,
  701|      0|			NULL, NULL, XML_FROM_XPATH,
  702|      0|			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
  703|      0|			XML_ERR_ERROR, NULL, 0,
  704|      0|			NULL, NULL, NULL, 0, 0,
  705|      0|			"%s", xmlXPathErrorMessages[error]);
  706|      0|	return;
  707|      0|    }
  708|       |    /* Only report the first error */
  709|     76|    if (ctxt->error != 0)
  ------------------
  |  Branch (709:9): [True: 6, False: 70]
  ------------------
  710|      6|        return;
  711|     70|    ctxt->error = error;
  712|     70|    if (ctxt->context == NULL) {
  ------------------
  |  Branch (712:9): [True: 0, False: 70]
  ------------------
  713|      0|	__xmlRaiseError(NULL, NULL, NULL,
  714|      0|			NULL, NULL, XML_FROM_XPATH,
  715|      0|			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
  716|      0|			XML_ERR_ERROR, NULL, 0,
  717|      0|			(const char *) ctxt->base, NULL, NULL,
  718|      0|			ctxt->cur - ctxt->base, 0,
  719|      0|			"%s", xmlXPathErrorMessages[error]);
  720|      0|	return;
  721|      0|    }
  722|       |
  723|       |    /* cleanup current last error */
  724|     70|    xmlResetError(&ctxt->context->lastError);
  725|       |
  726|     70|    ctxt->context->lastError.domain = XML_FROM_XPATH;
  727|     70|    ctxt->context->lastError.code = error + XML_XPATH_EXPRESSION_OK -
  728|     70|                           XPATH_EXPRESSION_OK;
  729|     70|    ctxt->context->lastError.level = XML_ERR_ERROR;
  730|     70|    ctxt->context->lastError.str1 = (char *) xmlStrdup(ctxt->base);
  731|     70|    ctxt->context->lastError.int1 = ctxt->cur - ctxt->base;
  732|     70|    ctxt->context->lastError.node = ctxt->context->debugNode;
  733|     70|    if (ctxt->context->error != NULL) {
  ------------------
  |  Branch (733:9): [True: 0, False: 70]
  ------------------
  734|      0|	ctxt->context->error(ctxt->context->userData,
  735|      0|	                     &ctxt->context->lastError);
  736|     70|    } else {
  737|     70|	__xmlRaiseError(NULL, NULL, NULL,
  738|     70|			NULL, ctxt->context->debugNode, XML_FROM_XPATH,
  739|     70|			error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,
  740|     70|			XML_ERR_ERROR, NULL, 0,
  741|     70|			(const char *) ctxt->base, NULL, NULL,
  742|     70|			ctxt->cur - ctxt->base, 0,
  743|     70|			"%s", xmlXPathErrorMessages[error]);
  744|     70|    }
  745|       |
  746|     70|}
xmlXPathFreeCompExpr:
 1044|    492|{
 1045|    492|    xmlXPathStepOpPtr op;
 1046|    492|    int i;
 1047|       |
 1048|    492|    if (comp == NULL)
  ------------------
  |  Branch (1048:9): [True: 0, False: 492]
  ------------------
 1049|      0|        return;
 1050|    492|    if (comp->dict == NULL) {
  ------------------
  |  Branch (1050:9): [True: 492, False: 0]
  ------------------
 1051|  3.08k|	for (i = 0; i < comp->nbStep; i++) {
  ------------------
  |  Branch (1051:14): [True: 2.59k, False: 492]
  ------------------
 1052|  2.59k|	    op = &comp->steps[i];
 1053|  2.59k|	    if (op->value4 != NULL) {
  ------------------
  |  Branch (1053:10): [True: 897, False: 1.69k]
  ------------------
 1054|    897|		if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (1054:7): [True: 666, False: 231]
  ------------------
 1055|    666|		    xmlXPathFreeObject(op->value4);
 1056|    231|		else
 1057|    231|		    xmlFree(op->value4);
 1058|    897|	    }
 1059|  2.59k|	    if (op->value5 != NULL)
  ------------------
  |  Branch (1059:10): [True: 202, False: 2.39k]
  ------------------
 1060|    202|		xmlFree(op->value5);
 1061|  2.59k|	}
 1062|    492|    } else {
 1063|      0|	for (i = 0; i < comp->nbStep; i++) {
  ------------------
  |  Branch (1063:14): [True: 0, False: 0]
  ------------------
 1064|      0|	    op = &comp->steps[i];
 1065|      0|	    if (op->value4 != NULL) {
  ------------------
  |  Branch (1065:10): [True: 0, False: 0]
  ------------------
 1066|      0|		if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (1066:7): [True: 0, False: 0]
  ------------------
 1067|      0|		    xmlXPathFreeObject(op->value4);
 1068|      0|	    }
 1069|      0|	}
 1070|      0|        xmlDictFree(comp->dict);
 1071|      0|    }
 1072|    492|    if (comp->steps != NULL) {
  ------------------
  |  Branch (1072:9): [True: 492, False: 0]
  ------------------
 1073|    492|        xmlFree(comp->steps);
 1074|    492|    }
 1075|    492|#ifdef XPATH_STREAMING
 1076|    492|    if (comp->stream != NULL) {
  ------------------
  |  Branch (1076:9): [True: 0, False: 492]
  ------------------
 1077|      0|        xmlFreePatternList(comp->stream);
 1078|      0|    }
 1079|    492|#endif
 1080|    492|    if (comp->expr != NULL) {
  ------------------
  |  Branch (1080:9): [True: 0, False: 492]
  ------------------
 1081|      0|        xmlFree(comp->expr);
 1082|      0|    }
 1083|       |
 1084|    492|    xmlFree(comp);
 1085|    492|}
valuePop:
 2265|  3.80k|{
 2266|  3.80k|    xmlXPathObjectPtr ret;
 2267|       |
 2268|  3.80k|    if ((ctxt == NULL) || (ctxt->valueNr <= 0))
  ------------------
  |  Branch (2268:9): [True: 0, False: 3.80k]
  |  Branch (2268:27): [True: 1.10k, False: 2.70k]
  ------------------
 2269|  1.10k|        return (NULL);
 2270|       |
 2271|  2.70k|    ctxt->valueNr--;
 2272|  2.70k|    if (ctxt->valueNr > 0)
  ------------------
  |  Branch (2272:9): [True: 630, False: 2.07k]
  ------------------
 2273|    630|        ctxt->value = ctxt->valueTab[ctxt->valueNr - 1];
 2274|  2.07k|    else
 2275|  2.07k|        ctxt->value = NULL;
 2276|  2.70k|    ret = ctxt->valueTab[ctxt->valueNr];
 2277|  2.70k|    ctxt->valueTab[ctxt->valueNr] = NULL;
 2278|  2.70k|    return (ret);
 2279|  3.80k|}
valuePush:
 2294|  2.70k|{
 2295|  2.70k|    if (ctxt == NULL) return(-1);
  ------------------
  |  Branch (2295:9): [True: 0, False: 2.70k]
  ------------------
 2296|  2.70k|    if (value == NULL) {
  ------------------
  |  Branch (2296:9): [True: 1, False: 2.70k]
  ------------------
 2297|       |        /*
 2298|       |         * A NULL value typically indicates that a memory allocation failed,
 2299|       |         * so we set ctxt->error here to propagate the error.
 2300|       |         */
 2301|      1|	ctxt->error = XPATH_MEMORY_ERROR;
 2302|      1|        return(-1);
 2303|      1|    }
 2304|  2.70k|    if (ctxt->valueNr >= ctxt->valueMax) {
  ------------------
  |  Branch (2304:9): [True: 0, False: 2.70k]
  ------------------
 2305|      0|        xmlXPathObjectPtr *tmp;
 2306|       |
 2307|      0|        if (ctxt->valueMax >= XPATH_MAX_STACK_DEPTH) {
  ------------------
  |  |  106|      0|#define XPATH_MAX_STACK_DEPTH 1000000
  ------------------
  |  Branch (2307:13): [True: 0, False: 0]
  ------------------
 2308|      0|            xmlXPathPErrMemory(ctxt, "XPath stack depth limit reached\n");
 2309|      0|            xmlXPathFreeObject(value);
 2310|      0|            return (-1);
 2311|      0|        }
 2312|      0|        tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt->valueTab,
 2313|      0|                                             2 * ctxt->valueMax *
 2314|      0|                                             sizeof(ctxt->valueTab[0]));
 2315|      0|        if (tmp == NULL) {
  ------------------
  |  Branch (2315:13): [True: 0, False: 0]
  ------------------
 2316|      0|            xmlXPathPErrMemory(ctxt, "pushing value\n");
 2317|      0|            xmlXPathFreeObject(value);
 2318|      0|            return (-1);
 2319|      0|        }
 2320|      0|        ctxt->valueMax *= 2;
 2321|      0|	ctxt->valueTab = tmp;
 2322|      0|    }
 2323|  2.70k|    ctxt->valueTab[ctxt->valueNr] = value;
 2324|  2.70k|    ctxt->value = value;
 2325|  2.70k|    return (ctxt->valueNr++);
 2326|  2.70k|}
xmlXPathNodeSetSort:
 2867|     57|xmlXPathNodeSetSort(xmlNodeSetPtr set) {
 2868|       |#ifndef WITH_TIM_SORT
 2869|       |    int i, j, incr, len;
 2870|       |    xmlNodePtr tmp;
 2871|       |#endif
 2872|       |
 2873|     57|    if (set == NULL)
  ------------------
  |  Branch (2873:9): [True: 0, False: 57]
  ------------------
 2874|      0|	return;
 2875|       |
 2876|       |#ifndef WITH_TIM_SORT
 2877|       |    /*
 2878|       |     * Use the old Shell's sort implementation to sort the node-set
 2879|       |     * Timsort ought to be quite faster
 2880|       |     */
 2881|       |    len = set->nodeNr;
 2882|       |    for (incr = len / 2; incr > 0; incr /= 2) {
 2883|       |	for (i = incr; i < len; i++) {
 2884|       |	    j = i - incr;
 2885|       |	    while (j >= 0) {
 2886|       |#ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
 2887|       |		if (xmlXPathCmpNodesExt(set->nodeTab[j],
 2888|       |			set->nodeTab[j + incr]) == -1)
 2889|       |#else
 2890|       |		if (xmlXPathCmpNodes(set->nodeTab[j],
 2891|       |			set->nodeTab[j + incr]) == -1)
 2892|       |#endif
 2893|       |		{
 2894|       |		    tmp = set->nodeTab[j];
 2895|       |		    set->nodeTab[j] = set->nodeTab[j + incr];
 2896|       |		    set->nodeTab[j + incr] = tmp;
 2897|       |		    j -= incr;
 2898|       |		} else
 2899|       |		    break;
 2900|       |	    }
 2901|       |	}
 2902|       |    }
 2903|       |#else /* WITH_TIM_SORT */
 2904|     57|    libxml_domnode_tim_sort(set->nodeTab, set->nodeNr);
 2905|     57|#endif /* WITH_TIM_SORT */
 2906|     57|}
xmlXPathNodeSetFreeNs:
 2956|     15|xmlXPathNodeSetFreeNs(xmlNsPtr ns) {
 2957|     15|    if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL))
  ------------------
  |  Branch (2957:9): [True: 0, False: 15]
  |  Branch (2957:25): [True: 0, False: 15]
  ------------------
 2958|      0|	return;
 2959|       |
 2960|     15|    if ((ns->next != NULL) && (ns->next->type != XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (2960:9): [True: 15, False: 0]
  |  Branch (2960:31): [True: 15, False: 0]
  ------------------
 2961|     15|	if (ns->href != NULL)
  ------------------
  |  Branch (2961:6): [True: 15, False: 0]
  ------------------
 2962|     15|	    xmlFree((xmlChar *)ns->href);
 2963|     15|	if (ns->prefix != NULL)
  ------------------
  |  Branch (2963:6): [True: 15, False: 0]
  ------------------
 2964|     15|	    xmlFree((xmlChar *)ns->prefix);
 2965|     15|	xmlFree(ns);
 2966|     15|    }
 2967|     15|}
xmlXPathNodeSetCreate:
 2978|    969|xmlXPathNodeSetCreate(xmlNodePtr val) {
 2979|    969|    xmlNodeSetPtr ret;
 2980|       |
 2981|    969|    ret = (xmlNodeSetPtr) xmlMalloc(sizeof(xmlNodeSet));
 2982|    969|    if (ret == NULL) {
  ------------------
  |  Branch (2982:9): [True: 0, False: 969]
  ------------------
 2983|      0|        xmlXPathErrMemory(NULL, "creating nodeset\n");
 2984|      0|	return(NULL);
 2985|      0|    }
 2986|    969|    memset(ret, 0 , sizeof(xmlNodeSet));
 2987|    969|    if (val != NULL) {
  ------------------
  |  Branch (2987:9): [True: 383, False: 586]
  ------------------
 2988|    383|        ret->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|    383|#define XML_NODESET_DEFAULT	10
  ------------------
 2989|    383|					     sizeof(xmlNodePtr));
 2990|    383|	if (ret->nodeTab == NULL) {
  ------------------
  |  Branch (2990:6): [True: 0, False: 383]
  ------------------
 2991|      0|	    xmlXPathErrMemory(NULL, "creating nodeset\n");
 2992|      0|	    xmlFree(ret);
 2993|      0|	    return(NULL);
 2994|      0|	}
 2995|    383|	memset(ret->nodeTab, 0 ,
 2996|    383|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|    383|#define XML_NODESET_DEFAULT	10
  ------------------
 2997|    383|        ret->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|    383|#define XML_NODESET_DEFAULT	10
  ------------------
 2998|    383|	if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (2998:6): [True: 0, False: 383]
  ------------------
 2999|      0|	    xmlNsPtr ns = (xmlNsPtr) val;
 3000|      0|            xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3001|       |
 3002|      0|            if (nsNode == NULL) {
  ------------------
  |  Branch (3002:17): [True: 0, False: 0]
  ------------------
 3003|      0|                xmlXPathFreeNodeSet(ret);
 3004|      0|                return(NULL);
 3005|      0|            }
 3006|      0|	    ret->nodeTab[ret->nodeNr++] = nsNode;
 3007|      0|	} else
 3008|    383|	    ret->nodeTab[ret->nodeNr++] = val;
 3009|    383|    }
 3010|    969|    return(ret);
 3011|    969|}
xmlXPathNodeSetAddNs:
 3061|     12|xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {
 3062|     12|    int i;
 3063|     12|    xmlNodePtr nsNode;
 3064|       |
 3065|     12|    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||
  ------------------
  |  Branch (3065:9): [True: 0, False: 12]
  |  Branch (3065:26): [True: 0, False: 12]
  |  Branch (3065:42): [True: 0, False: 12]
  ------------------
 3066|     12|        (ns->type != XML_NAMESPACE_DECL) ||
  ------------------
  |  Branch (3066:9): [True: 0, False: 12]
  ------------------
 3067|     12|	(node->type != XML_ELEMENT_NODE))
  ------------------
  |  Branch (3067:2): [True: 0, False: 12]
  ------------------
 3068|      0|	return(-1);
 3069|       |
 3070|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3071|       |    /*
 3072|       |     * prevent duplicates
 3073|       |     */
 3074|     18|    for (i = 0;i < cur->nodeNr;i++) {
  ------------------
  |  Branch (3074:16): [True: 6, False: 12]
  ------------------
 3075|      6|        if ((cur->nodeTab[i] != NULL) &&
  ------------------
  |  Branch (3075:13): [True: 6, False: 0]
  ------------------
 3076|      6|	    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&
  ------------------
  |  Branch (3076:6): [True: 6, False: 0]
  ------------------
 3077|      6|	    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&
  ------------------
  |  Branch (3077:6): [True: 6, False: 0]
  ------------------
 3078|      6|	    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))
  ------------------
  |  Branch (3078:6): [True: 0, False: 6]
  ------------------
 3079|      0|	    return(0);
 3080|      6|    }
 3081|       |
 3082|       |    /*
 3083|       |     * grow the nodeTab if needed
 3084|       |     */
 3085|     12|    if (cur->nodeMax == 0) {
  ------------------
  |  Branch (3085:9): [True: 8, False: 4]
  ------------------
 3086|      8|        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|      8|#define XML_NODESET_DEFAULT	10
  ------------------
 3087|      8|					     sizeof(xmlNodePtr));
 3088|      8|	if (cur->nodeTab == NULL) {
  ------------------
  |  Branch (3088:6): [True: 0, False: 8]
  ------------------
 3089|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3090|      0|	    return(-1);
 3091|      0|	}
 3092|      8|	memset(cur->nodeTab, 0 ,
 3093|      8|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      8|#define XML_NODESET_DEFAULT	10
  ------------------
 3094|      8|        cur->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      8|#define XML_NODESET_DEFAULT	10
  ------------------
 3095|      8|    } else if (cur->nodeNr == cur->nodeMax) {
  ------------------
  |  Branch (3095:16): [True: 0, False: 4]
  ------------------
 3096|      0|        xmlNodePtr *temp;
 3097|       |
 3098|      0|        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3098:13): [True: 0, False: 0]
  ------------------
 3099|      0|            xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
 3100|      0|            return(-1);
 3101|      0|        }
 3102|      0|	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 3103|      0|				      sizeof(xmlNodePtr));
 3104|      0|	if (temp == NULL) {
  ------------------
  |  Branch (3104:6): [True: 0, False: 0]
  ------------------
 3105|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3106|      0|	    return(-1);
 3107|      0|	}
 3108|      0|        cur->nodeMax *= 2;
 3109|      0|	cur->nodeTab = temp;
 3110|      0|    }
 3111|     12|    nsNode = xmlXPathNodeSetDupNs(node, ns);
 3112|     12|    if(nsNode == NULL)
  ------------------
  |  Branch (3112:8): [True: 0, False: 12]
  ------------------
 3113|      0|        return(-1);
 3114|     12|    cur->nodeTab[cur->nodeNr++] = nsNode;
 3115|     12|    return(0);
 3116|     12|}
xmlXPathNodeSetAdd:
 3128|     15|xmlXPathNodeSetAdd(xmlNodeSetPtr cur, xmlNodePtr val) {
 3129|     15|    int i;
 3130|       |
 3131|     15|    if ((cur == NULL) || (val == NULL)) return(-1);
  ------------------
  |  Branch (3131:9): [True: 0, False: 15]
  |  Branch (3131:26): [True: 0, False: 15]
  ------------------
 3132|       |
 3133|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3134|       |    /*
 3135|       |     * prevent duplicates
 3136|       |     */
 3137|     15|    for (i = 0;i < cur->nodeNr;i++)
  ------------------
  |  Branch (3137:16): [True: 0, False: 15]
  ------------------
 3138|      0|        if (cur->nodeTab[i] == val) return(0);
  ------------------
  |  Branch (3138:13): [True: 0, False: 0]
  ------------------
 3139|       |
 3140|       |    /*
 3141|       |     * grow the nodeTab if needed
 3142|       |     */
 3143|     15|    if (cur->nodeMax == 0) {
  ------------------
  |  Branch (3143:9): [True: 15, False: 0]
  ------------------
 3144|     15|        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|     15|#define XML_NODESET_DEFAULT	10
  ------------------
 3145|     15|					     sizeof(xmlNodePtr));
 3146|     15|	if (cur->nodeTab == NULL) {
  ------------------
  |  Branch (3146:6): [True: 0, False: 15]
  ------------------
 3147|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3148|      0|	    return(-1);
 3149|      0|	}
 3150|     15|	memset(cur->nodeTab, 0 ,
 3151|     15|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|     15|#define XML_NODESET_DEFAULT	10
  ------------------
 3152|     15|        cur->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|     15|#define XML_NODESET_DEFAULT	10
  ------------------
 3153|     15|    } else if (cur->nodeNr == cur->nodeMax) {
  ------------------
  |  Branch (3153:16): [True: 0, False: 0]
  ------------------
 3154|      0|        xmlNodePtr *temp;
 3155|       |
 3156|      0|        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3156:13): [True: 0, False: 0]
  ------------------
 3157|      0|            xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
 3158|      0|            return(-1);
 3159|      0|        }
 3160|      0|	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 3161|      0|				      sizeof(xmlNodePtr));
 3162|      0|	if (temp == NULL) {
  ------------------
  |  Branch (3162:6): [True: 0, False: 0]
  ------------------
 3163|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3164|      0|	    return(-1);
 3165|      0|	}
 3166|      0|        cur->nodeMax *= 2;
 3167|      0|	cur->nodeTab = temp;
 3168|      0|    }
 3169|     15|    if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3169:9): [True: 0, False: 15]
  ------------------
 3170|      0|	xmlNsPtr ns = (xmlNsPtr) val;
 3171|      0|        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3172|       |
 3173|      0|        if (nsNode == NULL)
  ------------------
  |  Branch (3173:13): [True: 0, False: 0]
  ------------------
 3174|      0|            return(-1);
 3175|      0|	cur->nodeTab[cur->nodeNr++] = nsNode;
 3176|      0|    } else
 3177|     15|	cur->nodeTab[cur->nodeNr++] = val;
 3178|     15|    return(0);
 3179|     15|}
xmlXPathNodeSetAddUnique:
 3192|  2.98k|xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {
 3193|  2.98k|    if ((cur == NULL) || (val == NULL)) return(-1);
  ------------------
  |  Branch (3193:9): [True: 0, False: 2.98k]
  |  Branch (3193:26): [True: 0, False: 2.98k]
  ------------------
 3194|       |
 3195|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3196|       |    /*
 3197|       |     * grow the nodeTab if needed
 3198|       |     */
 3199|  2.98k|    if (cur->nodeMax == 0) {
  ------------------
  |  Branch (3199:9): [True: 328, False: 2.65k]
  ------------------
 3200|    328|        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|    328|#define XML_NODESET_DEFAULT	10
  ------------------
 3201|    328|					     sizeof(xmlNodePtr));
 3202|    328|	if (cur->nodeTab == NULL) {
  ------------------
  |  Branch (3202:6): [True: 0, False: 328]
  ------------------
 3203|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3204|      0|	    return(-1);
 3205|      0|	}
 3206|    328|	memset(cur->nodeTab, 0 ,
 3207|    328|	       XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|    328|#define XML_NODESET_DEFAULT	10
  ------------------
 3208|    328|        cur->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|    328|#define XML_NODESET_DEFAULT	10
  ------------------
 3209|  2.65k|    } else if (cur->nodeNr == cur->nodeMax) {
  ------------------
  |  Branch (3209:16): [True: 129, False: 2.52k]
  ------------------
 3210|    129|        xmlNodePtr *temp;
 3211|       |
 3212|    129|        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|    129|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3212:13): [True: 0, False: 129]
  ------------------
 3213|      0|            xmlXPathErrMemory(NULL, "growing nodeset hit limit\n");
 3214|      0|            return(-1);
 3215|      0|        }
 3216|    129|	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 3217|    129|				      sizeof(xmlNodePtr));
 3218|    129|	if (temp == NULL) {
  ------------------
  |  Branch (3218:6): [True: 0, False: 129]
  ------------------
 3219|      0|	    xmlXPathErrMemory(NULL, "growing nodeset\n");
 3220|      0|	    return(-1);
 3221|      0|	}
 3222|    129|	cur->nodeTab = temp;
 3223|    129|        cur->nodeMax *= 2;
 3224|    129|    }
 3225|  2.98k|    if (val->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3225:9): [True: 3, False: 2.98k]
  ------------------
 3226|      3|	xmlNsPtr ns = (xmlNsPtr) val;
 3227|      3|        xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3228|       |
 3229|      3|        if (nsNode == NULL)
  ------------------
  |  Branch (3229:13): [True: 0, False: 3]
  ------------------
 3230|      0|            return(-1);
 3231|      3|	cur->nodeTab[cur->nodeNr++] = nsNode;
 3232|      3|    } else
 3233|  2.98k|	cur->nodeTab[cur->nodeNr++] = val;
 3234|  2.98k|    return(0);
 3235|  2.98k|}
xmlXPathNodeSetMerge:
 3250|      2|xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {
 3251|      2|    int i, j, initNr, skip;
 3252|      2|    xmlNodePtr n1, n2;
 3253|       |
 3254|      2|    if (val2 == NULL) return(val1);
  ------------------
  |  Branch (3254:9): [True: 0, False: 2]
  ------------------
 3255|      2|    if (val1 == NULL) {
  ------------------
  |  Branch (3255:9): [True: 0, False: 2]
  ------------------
 3256|      0|	val1 = xmlXPathNodeSetCreate(NULL);
 3257|      0|        if (val1 == NULL)
  ------------------
  |  Branch (3257:13): [True: 0, False: 0]
  ------------------
 3258|      0|            return (NULL);
 3259|      0|    }
 3260|       |
 3261|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3262|      2|    initNr = val1->nodeNr;
 3263|       |
 3264|      6|    for (i = 0;i < val2->nodeNr;i++) {
  ------------------
  |  Branch (3264:16): [True: 4, False: 2]
  ------------------
 3265|      4|	n2 = val2->nodeTab[i];
 3266|       |	/*
 3267|       |	 * check against duplicates
 3268|       |	 */
 3269|      4|	skip = 0;
 3270|      4|	for (j = 0; j < initNr; j++) {
  ------------------
  |  Branch (3270:14): [True: 0, False: 4]
  ------------------
 3271|      0|	    n1 = val1->nodeTab[j];
 3272|      0|	    if (n1 == n2) {
  ------------------
  |  Branch (3272:10): [True: 0, False: 0]
  ------------------
 3273|      0|		skip = 1;
 3274|      0|		break;
 3275|      0|	    } else if ((n1->type == XML_NAMESPACE_DECL) &&
  ------------------
  |  Branch (3275:17): [True: 0, False: 0]
  ------------------
 3276|      0|		       (n2->type == XML_NAMESPACE_DECL)) {
  ------------------
  |  Branch (3276:10): [True: 0, False: 0]
  ------------------
 3277|      0|		if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&
  ------------------
  |  Branch (3277:7): [True: 0, False: 0]
  ------------------
 3278|      0|		    (xmlStrEqual(((xmlNsPtr) n1)->prefix,
  ------------------
  |  Branch (3278:7): [True: 0, False: 0]
  ------------------
 3279|      0|			((xmlNsPtr) n2)->prefix)))
 3280|      0|		{
 3281|      0|		    skip = 1;
 3282|      0|		    break;
 3283|      0|		}
 3284|      0|	    }
 3285|      0|	}
 3286|      4|	if (skip)
  ------------------
  |  Branch (3286:6): [True: 0, False: 4]
  ------------------
 3287|      0|	    continue;
 3288|       |
 3289|       |	/*
 3290|       |	 * grow the nodeTab if needed
 3291|       |	 */
 3292|      4|	if (val1->nodeMax == 0) {
  ------------------
  |  Branch (3292:6): [True: 2, False: 2]
  ------------------
 3293|      2|	    val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3294|      2|						    sizeof(xmlNodePtr));
 3295|      2|	    if (val1->nodeTab == NULL) {
  ------------------
  |  Branch (3295:10): [True: 0, False: 2]
  ------------------
 3296|      0|	        xmlXPathErrMemory(NULL, "merging nodeset\n");
 3297|      0|		goto error;
 3298|      0|	    }
 3299|      2|	    memset(val1->nodeTab, 0 ,
 3300|      2|		   XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3301|      2|	    val1->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
 3302|      2|	} else if (val1->nodeNr == val1->nodeMax) {
  ------------------
  |  Branch (3302:13): [True: 0, False: 2]
  ------------------
 3303|      0|	    xmlNodePtr *temp;
 3304|       |
 3305|      0|            if (val1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3305:17): [True: 0, False: 0]
  ------------------
 3306|      0|                xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
 3307|      0|                goto error;
 3308|      0|            }
 3309|      0|	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *
 3310|      0|					     sizeof(xmlNodePtr));
 3311|      0|	    if (temp == NULL) {
  ------------------
  |  Branch (3311:10): [True: 0, False: 0]
  ------------------
 3312|      0|	        xmlXPathErrMemory(NULL, "merging nodeset\n");
 3313|      0|		goto error;
 3314|      0|	    }
 3315|      0|	    val1->nodeTab = temp;
 3316|      0|	    val1->nodeMax *= 2;
 3317|      0|	}
 3318|      4|	if (n2->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (3318:6): [True: 0, False: 4]
  ------------------
 3319|      0|	    xmlNsPtr ns = (xmlNsPtr) n2;
 3320|      0|            xmlNodePtr nsNode = xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);
 3321|       |
 3322|      0|            if (nsNode == NULL)
  ------------------
  |  Branch (3322:17): [True: 0, False: 0]
  ------------------
 3323|      0|                goto error;
 3324|      0|	    val1->nodeTab[val1->nodeNr++] = nsNode;
 3325|      0|	} else
 3326|      4|	    val1->nodeTab[val1->nodeNr++] = n2;
 3327|      4|    }
 3328|       |
 3329|      2|    return(val1);
 3330|       |
 3331|      0|error:
 3332|      0|    xmlXPathFreeNodeSet(val1);
 3333|      0|    return(NULL);
 3334|      2|}
xmlXPathFreeNodeSet:
 3543|    969|xmlXPathFreeNodeSet(xmlNodeSetPtr obj) {
 3544|    969|    if (obj == NULL) return;
  ------------------
  |  Branch (3544:9): [True: 0, False: 969]
  ------------------
 3545|    969|    if (obj->nodeTab != NULL) {
  ------------------
  |  Branch (3545:9): [True: 736, False: 233]
  ------------------
 3546|    736|	int i;
 3547|       |
 3548|       |	/* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3549|  3.69k|	for (i = 0;i < obj->nodeNr;i++)
  ------------------
  |  Branch (3549:13): [True: 2.95k, False: 736]
  ------------------
 3550|  2.95k|	    if ((obj->nodeTab[i] != NULL) &&
  ------------------
  |  Branch (3550:10): [True: 2.95k, False: 0]
  ------------------
 3551|  2.95k|		(obj->nodeTab[i]->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (3551:3): [True: 15, False: 2.94k]
  ------------------
 3552|     15|		xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);
 3553|    736|	xmlFree(obj->nodeTab);
 3554|    736|    }
 3555|    969|    xmlFree(obj);
 3556|    969|}
xmlXPathNewNodeSet:
 3664|    407|xmlXPathNewNodeSet(xmlNodePtr val) {
 3665|    407|    xmlXPathObjectPtr ret;
 3666|       |
 3667|    407|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 3668|    407|    if (ret == NULL) {
  ------------------
  |  Branch (3668:9): [True: 0, False: 407]
  ------------------
 3669|      0|        xmlXPathErrMemory(NULL, "creating nodeset\n");
 3670|      0|	return(NULL);
 3671|      0|    }
 3672|    407|    memset(ret, 0 , sizeof(xmlXPathObject));
 3673|    407|    ret->type = XPATH_NODESET;
 3674|    407|    ret->boolval = 0;
 3675|       |    /* TODO: Check memory error. */
 3676|    407|    ret->nodesetval = xmlXPathNodeSetCreate(val);
 3677|       |    /* @@ with_ns to check whether namespace nodes should be looked at @@ */
 3678|    407|    return(ret);
 3679|    407|}
xmlXPathWrapNodeSet:
 3751|    536|xmlXPathWrapNodeSet(xmlNodeSetPtr val) {
 3752|    536|    xmlXPathObjectPtr ret;
 3753|       |
 3754|    536|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 3755|    536|    if (ret == NULL) {
  ------------------
  |  Branch (3755:9): [True: 1, False: 535]
  ------------------
 3756|      1|        xmlXPathErrMemory(NULL, "creating node set object\n");
 3757|      1|        xmlXPathFreeNodeSet(val);
 3758|      1|	return(NULL);
 3759|      1|    }
 3760|    535|    memset(ret, 0 , sizeof(xmlXPathObject));
 3761|    535|    ret->type = XPATH_NODESET;
 3762|    535|    ret->nodesetval = val;
 3763|    535|    return(ret);
 3764|    536|}
xmlXPathRegisterFunc:
 4184|  13.1k|		     xmlXPathFunction f) {
 4185|  13.1k|    return(xmlXPathRegisterFuncNS(ctxt, name, NULL, f));
 4186|  13.1k|}
xmlXPathRegisterFuncNS:
 4201|  13.6k|		       const xmlChar *ns_uri, xmlXPathFunction f) {
 4202|  13.6k|    if (ctxt == NULL)
  ------------------
  |  Branch (4202:9): [True: 0, False: 13.6k]
  ------------------
 4203|      0|	return(-1);
 4204|  13.6k|    if (name == NULL)
  ------------------
  |  Branch (4204:9): [True: 0, False: 13.6k]
  ------------------
 4205|      0|	return(-1);
 4206|       |
 4207|  13.6k|    if (ctxt->funcHash == NULL)
  ------------------
  |  Branch (4207:9): [True: 0, False: 13.6k]
  ------------------
 4208|      0|	ctxt->funcHash = xmlHashCreate(0);
 4209|  13.6k|    if (ctxt->funcHash == NULL)
  ------------------
  |  Branch (4209:9): [True: 0, False: 13.6k]
  ------------------
 4210|      0|	return(-1);
 4211|  13.6k|    if (f == NULL)
  ------------------
  |  Branch (4211:9): [True: 0, False: 13.6k]
  ------------------
 4212|      0|        return(xmlHashRemoveEntry2(ctxt->funcHash, name, ns_uri, NULL));
 4213|  13.6k|XML_IGNORE_FPTR_CAST_WARNINGS
 4214|  13.6k|    return(xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f));
 4215|  13.6k|XML_POP_WARNINGS
 4216|  13.6k|}
xmlXPathFunctionLookup:
 4247|    202|xmlXPathFunctionLookup(xmlXPathContextPtr ctxt, const xmlChar *name) {
 4248|    202|    if (ctxt == NULL)
  ------------------
  |  Branch (4248:9): [True: 0, False: 202]
  ------------------
 4249|      0|	return (NULL);
 4250|       |
 4251|    202|    if (ctxt->funcLookupFunc != NULL) {
  ------------------
  |  Branch (4251:9): [True: 0, False: 202]
  ------------------
 4252|      0|	xmlXPathFunction ret;
 4253|      0|	xmlXPathFuncLookupFunc f;
 4254|       |
 4255|      0|	f = ctxt->funcLookupFunc;
 4256|      0|	ret = f(ctxt->funcLookupData, name, NULL);
 4257|      0|	if (ret != NULL)
  ------------------
  |  Branch (4257:6): [True: 0, False: 0]
  ------------------
 4258|      0|	    return(ret);
 4259|      0|    }
 4260|    202|    return(xmlXPathFunctionLookupNS(ctxt, name, NULL));
 4261|    202|}
xmlXPathFunctionLookupNS:
 4276|    202|			 const xmlChar *ns_uri) {
 4277|    202|    xmlXPathFunction ret;
 4278|       |
 4279|    202|    if (ctxt == NULL)
  ------------------
  |  Branch (4279:9): [True: 0, False: 202]
  ------------------
 4280|      0|	return(NULL);
 4281|    202|    if (name == NULL)
  ------------------
  |  Branch (4281:9): [True: 0, False: 202]
  ------------------
 4282|      0|	return(NULL);
 4283|       |
 4284|    202|    if (ctxt->funcLookupFunc != NULL) {
  ------------------
  |  Branch (4284:9): [True: 0, False: 202]
  ------------------
 4285|      0|	xmlXPathFuncLookupFunc f;
 4286|       |
 4287|      0|	f = ctxt->funcLookupFunc;
 4288|      0|	ret = f(ctxt->funcLookupData, name, ns_uri);
 4289|      0|	if (ret != NULL)
  ------------------
  |  Branch (4289:6): [True: 0, False: 0]
  ------------------
 4290|      0|	    return(ret);
 4291|      0|    }
 4292|       |
 4293|    202|    if (ctxt->funcHash == NULL)
  ------------------
  |  Branch (4293:9): [True: 0, False: 202]
  ------------------
 4294|      0|	return(NULL);
 4295|       |
 4296|    202|XML_IGNORE_FPTR_CAST_WARNINGS
 4297|    202|    ret = (xmlXPathFunction) xmlHashLookup2(ctxt->funcHash, name, ns_uri);
 4298|    202|XML_POP_WARNINGS
 4299|    202|    return(ret);
 4300|    202|}
xmlXPathRegisteredFuncsCleanup:
 4309|    486|xmlXPathRegisteredFuncsCleanup(xmlXPathContextPtr ctxt) {
 4310|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (4310:9): [True: 0, False: 486]
  ------------------
 4311|      0|	return;
 4312|       |
 4313|    486|    xmlHashFree(ctxt->funcHash, NULL);
 4314|    486|    ctxt->funcHash = NULL;
 4315|    486|}
xmlXPathRegisteredVariablesCleanup:
 4455|    486|xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt) {
 4456|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (4456:9): [True: 0, False: 486]
  ------------------
 4457|      0|	return;
 4458|       |
 4459|    486|    xmlHashFree(ctxt->varHash, xmlXPathFreeObjectEntry);
 4460|    486|    ctxt->varHash = NULL;
 4461|    486|}
xmlXPathRegisterNs:
 4476|      6|			   const xmlChar *ns_uri) {
 4477|      6|    xmlChar *copy;
 4478|       |
 4479|      6|    if (ctxt == NULL)
  ------------------
  |  Branch (4479:9): [True: 0, False: 6]
  ------------------
 4480|      0|	return(-1);
 4481|      6|    if (prefix == NULL)
  ------------------
  |  Branch (4481:9): [True: 0, False: 6]
  ------------------
 4482|      0|	return(-1);
 4483|      6|    if (prefix[0] == 0)
  ------------------
  |  Branch (4483:9): [True: 0, False: 6]
  ------------------
 4484|      0|	return(-1);
 4485|       |
 4486|      6|    if (ctxt->nsHash == NULL)
  ------------------
  |  Branch (4486:9): [True: 6, False: 0]
  ------------------
 4487|      6|	ctxt->nsHash = xmlHashCreate(10);
 4488|      6|    if (ctxt->nsHash == NULL)
  ------------------
  |  Branch (4488:9): [True: 0, False: 6]
  ------------------
 4489|      0|	return(-1);
 4490|      6|    if (ns_uri == NULL)
  ------------------
  |  Branch (4490:9): [True: 0, False: 6]
  ------------------
 4491|      0|        return(xmlHashRemoveEntry(ctxt->nsHash, prefix,
 4492|      0|	                          xmlHashDefaultDeallocator));
 4493|       |
 4494|      6|    copy = xmlStrdup(ns_uri);
 4495|      6|    if (copy == NULL)
  ------------------
  |  Branch (4495:9): [True: 0, False: 6]
  ------------------
 4496|      0|        return(-1);
 4497|      6|    if (xmlHashUpdateEntry(ctxt->nsHash, prefix, copy,
  ------------------
  |  Branch (4497:9): [True: 0, False: 6]
  ------------------
 4498|      6|                           xmlHashDefaultDeallocator) < 0) {
 4499|      0|        xmlFree(copy);
 4500|      0|        return(-1);
 4501|      0|    }
 4502|       |
 4503|      6|    return(0);
 4504|      6|}
xmlXPathNsLookup:
 4517|      4|xmlXPathNsLookup(xmlXPathContextPtr ctxt, const xmlChar *prefix) {
 4518|      4|    if (ctxt == NULL)
  ------------------
  |  Branch (4518:9): [True: 0, False: 4]
  ------------------
 4519|      0|	return(NULL);
 4520|      4|    if (prefix == NULL)
  ------------------
  |  Branch (4520:9): [True: 0, False: 4]
  ------------------
 4521|      0|	return(NULL);
 4522|       |
 4523|      4|#ifdef XML_XML_NAMESPACE
 4524|      4|    if (xmlStrEqual(prefix, (const xmlChar *) "xml"))
  ------------------
  |  Branch (4524:9): [True: 0, False: 4]
  ------------------
 4525|      0|	return(XML_XML_NAMESPACE);
  ------------------
  |  |  143|      0|    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
  ------------------
 4526|      4|#endif
 4527|       |
 4528|      4|    if (ctxt->namespaces != NULL) {
  ------------------
  |  Branch (4528:9): [True: 0, False: 4]
  ------------------
 4529|      0|	int i;
 4530|       |
 4531|      0|	for (i = 0;i < ctxt->nsNr;i++) {
  ------------------
  |  Branch (4531:13): [True: 0, False: 0]
  ------------------
 4532|      0|	    if ((ctxt->namespaces[i] != NULL) &&
  ------------------
  |  Branch (4532:10): [True: 0, False: 0]
  ------------------
 4533|      0|		(xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))
  ------------------
  |  Branch (4533:3): [True: 0, False: 0]
  ------------------
 4534|      0|		return(ctxt->namespaces[i]->href);
 4535|      0|	}
 4536|      0|    }
 4537|       |
 4538|      4|    return((const xmlChar *) xmlHashLookup(ctxt->nsHash, prefix));
 4539|      4|}
xmlXPathRegisteredNsCleanup:
 4548|    486|xmlXPathRegisteredNsCleanup(xmlXPathContextPtr ctxt) {
 4549|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (4549:9): [True: 0, False: 486]
  ------------------
 4550|      0|	return;
 4551|       |
 4552|    486|    xmlHashFree(ctxt->nsHash, xmlHashDefaultDeallocator);
 4553|    486|    ctxt->nsHash = NULL;
 4554|    486|}
xmlXPathNewFloat:
 4573|    562|xmlXPathNewFloat(double val) {
 4574|    562|    xmlXPathObjectPtr ret;
 4575|       |
 4576|    562|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4577|    562|    if (ret == NULL) {
  ------------------
  |  Branch (4577:9): [True: 0, False: 562]
  ------------------
 4578|      0|        xmlXPathErrMemory(NULL, "creating float object\n");
 4579|      0|	return(NULL);
 4580|      0|    }
 4581|    562|    memset(ret, 0 , sizeof(xmlXPathObject));
 4582|    562|    ret->type = XPATH_NUMBER;
 4583|    562|    ret->floatval = val;
 4584|    562|    return(ret);
 4585|    562|}
xmlXPathNewBoolean:
 4596|    604|xmlXPathNewBoolean(int val) {
 4597|    604|    xmlXPathObjectPtr ret;
 4598|       |
 4599|    604|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4600|    604|    if (ret == NULL) {
  ------------------
  |  Branch (4600:9): [True: 0, False: 604]
  ------------------
 4601|      0|        xmlXPathErrMemory(NULL, "creating boolean object\n");
 4602|      0|	return(NULL);
 4603|      0|    }
 4604|    604|    memset(ret, 0 , sizeof(xmlXPathObject));
 4605|    604|    ret->type = XPATH_BOOLEAN;
 4606|    604|    ret->boolval = (val != 0);
 4607|    604|    return(ret);
 4608|    604|}
xmlXPathNewString:
 4619|    228|xmlXPathNewString(const xmlChar *val) {
 4620|    228|    xmlXPathObjectPtr ret;
 4621|       |
 4622|    228|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4623|    228|    if (ret == NULL) {
  ------------------
  |  Branch (4623:9): [True: 0, False: 228]
  ------------------
 4624|      0|        xmlXPathErrMemory(NULL, "creating string object\n");
 4625|      0|	return(NULL);
 4626|      0|    }
 4627|    228|    memset(ret, 0 , sizeof(xmlXPathObject));
 4628|    228|    ret->type = XPATH_STRING;
 4629|    228|    if (val == NULL)
  ------------------
  |  Branch (4629:9): [True: 0, False: 228]
  ------------------
 4630|      0|        val = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 4631|    228|    ret->stringval = xmlStrdup(val);
 4632|    228|    if (ret->stringval == NULL) {
  ------------------
  |  Branch (4632:9): [True: 0, False: 228]
  ------------------
 4633|      0|        xmlFree(ret);
 4634|      0|        return(NULL);
 4635|      0|    }
 4636|    228|    return(ret);
 4637|    228|}
xmlXPathWrapString:
 4650|      7|xmlXPathWrapString (xmlChar *val) {
 4651|      7|    xmlXPathObjectPtr ret;
 4652|       |
 4653|      7|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4654|      7|    if (ret == NULL) {
  ------------------
  |  Branch (4654:9): [True: 0, False: 7]
  ------------------
 4655|      0|        xmlXPathErrMemory(NULL, "creating string object\n");
 4656|      0|        xmlFree(val);
 4657|      0|	return(NULL);
 4658|      0|    }
 4659|      7|    memset(ret, 0 , sizeof(xmlXPathObject));
 4660|      7|    ret->type = XPATH_STRING;
 4661|      7|    ret->stringval = val;
 4662|      7|    return(ret);
 4663|      7|}
xmlXPathObjectCopy:
 4723|    938|xmlXPathObjectCopy(xmlXPathObjectPtr val) {
 4724|    938|    xmlXPathObjectPtr ret;
 4725|       |
 4726|    938|    if (val == NULL)
  ------------------
  |  Branch (4726:9): [True: 0, False: 938]
  ------------------
 4727|      0|	return(NULL);
 4728|       |
 4729|    938|    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
 4730|    938|    if (ret == NULL) {
  ------------------
  |  Branch (4730:9): [True: 0, False: 938]
  ------------------
 4731|      0|        xmlXPathErrMemory(NULL, "copying object\n");
 4732|      0|	return(NULL);
 4733|      0|    }
 4734|    938|    memcpy(ret, val , sizeof(xmlXPathObject));
 4735|    938|    switch (val->type) {
  ------------------
  |  Branch (4735:13): [True: 0, False: 938]
  ------------------
 4736|      0|	case XPATH_BOOLEAN:
  ------------------
  |  Branch (4736:2): [True: 0, False: 938]
  ------------------
 4737|    465|	case XPATH_NUMBER:
  ------------------
  |  Branch (4737:2): [True: 465, False: 473]
  ------------------
 4738|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4739|       |	case XPATH_POINT:
 4740|       |	case XPATH_RANGE:
 4741|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 4742|    465|	    break;
 4743|    473|	case XPATH_STRING:
  ------------------
  |  Branch (4743:2): [True: 473, False: 465]
  ------------------
 4744|    473|	    ret->stringval = xmlStrdup(val->stringval);
 4745|    473|            if (ret->stringval == NULL) {
  ------------------
  |  Branch (4745:17): [True: 0, False: 473]
  ------------------
 4746|      0|                xmlFree(ret);
 4747|      0|                return(NULL);
 4748|      0|            }
 4749|    473|	    break;
 4750|    473|	case XPATH_XSLT_TREE:
  ------------------
  |  Branch (4750:2): [True: 0, False: 938]
  ------------------
 4751|       |#if 0
 4752|       |/*
 4753|       |  Removed 11 July 2004 - the current handling of xslt tmpRVT nodes means that
 4754|       |  this previous handling is no longer correct, and can cause some serious
 4755|       |  problems (ref. bug 145547)
 4756|       |*/
 4757|       |	    if ((val->nodesetval != NULL) &&
 4758|       |		(val->nodesetval->nodeTab != NULL)) {
 4759|       |		xmlNodePtr cur, tmp;
 4760|       |		xmlDocPtr top;
 4761|       |
 4762|       |		ret->boolval = 1;
 4763|       |		top =  xmlNewDoc(NULL);
 4764|       |		top->name = (char *)
 4765|       |		    xmlStrdup(val->nodesetval->nodeTab[0]->name);
 4766|       |		ret->user = top;
 4767|       |		if (top != NULL) {
 4768|       |		    top->doc = top;
 4769|       |		    cur = val->nodesetval->nodeTab[0]->children;
 4770|       |		    while (cur != NULL) {
 4771|       |			tmp = xmlDocCopyNode(cur, top, 1);
 4772|       |			xmlAddChild((xmlNodePtr) top, tmp);
 4773|       |			cur = cur->next;
 4774|       |		    }
 4775|       |		}
 4776|       |
 4777|       |		ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);
 4778|       |	    } else
 4779|       |		ret->nodesetval = xmlXPathNodeSetCreate(NULL);
 4780|       |	    /* Deallocate the copied tree value */
 4781|       |	    break;
 4782|       |#endif
 4783|      0|	case XPATH_NODESET:
  ------------------
  |  Branch (4783:2): [True: 0, False: 938]
  ------------------
 4784|       |            /* TODO: Check memory error. */
 4785|      0|	    ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);
 4786|       |	    /* Do not deallocate the copied tree value */
 4787|      0|	    ret->boolval = 0;
 4788|      0|	    break;
 4789|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4790|       |	case XPATH_LOCATIONSET:
 4791|       |	{
 4792|       |	    xmlLocationSetPtr loc = val->user;
 4793|       |	    ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc);
 4794|       |	    break;
 4795|       |	}
 4796|       |#endif
 4797|      0|        case XPATH_USERS:
  ------------------
  |  Branch (4797:9): [True: 0, False: 938]
  ------------------
 4798|      0|	    ret->user = val->user;
 4799|      0|	    break;
 4800|      0|        case XPATH_UNDEFINED:
  ------------------
  |  Branch (4800:9): [True: 0, False: 938]
  ------------------
 4801|      0|	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
 4802|      0|		    "xmlXPathObjectCopy: unsupported type %d\n",
 4803|      0|		    val->type);
 4804|      0|	    break;
 4805|    938|    }
 4806|    938|    return(ret);
 4807|    938|}
xmlXPathFreeObject:
 4816|  3.72k|xmlXPathFreeObject(xmlXPathObjectPtr obj) {
 4817|  3.72k|    if (obj == NULL) return;
  ------------------
  |  Branch (4817:9): [True: 439, False: 3.28k]
  ------------------
 4818|  3.28k|    if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (4818:9): [True: 942, False: 2.33k]
  |  Branch (4818:41): [True: 0, False: 2.33k]
  ------------------
 4819|    942|	if (obj->boolval) {
  ------------------
  |  Branch (4819:6): [True: 0, False: 942]
  ------------------
 4820|       |#if 0
 4821|       |	    if (obj->user != NULL) {
 4822|       |                xmlXPathFreeNodeSet(obj->nodesetval);
 4823|       |		xmlFreeNodeList((xmlNodePtr) obj->user);
 4824|       |	    } else
 4825|       |#endif
 4826|      0|	    obj->type = XPATH_XSLT_TREE; /* TODO: Just for debugging. */
 4827|      0|	    if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4827:10): [True: 0, False: 0]
  ------------------
 4828|      0|		xmlXPathFreeValueTree(obj->nodesetval);
 4829|    942|	} else {
 4830|    942|	    if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4830:10): [True: 933, False: 9]
  ------------------
 4831|    933|		xmlXPathFreeNodeSet(obj->nodesetval);
 4832|    942|	}
 4833|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4834|       |    } else if (obj->type == XPATH_LOCATIONSET) {
 4835|       |	if (obj->user != NULL)
 4836|       |	    xmlXPtrFreeLocationSet(obj->user);
 4837|       |#endif
 4838|  2.33k|    } else if (obj->type == XPATH_STRING) {
  ------------------
  |  Branch (4838:16): [True: 708, False: 1.63k]
  ------------------
 4839|    708|	if (obj->stringval != NULL)
  ------------------
  |  Branch (4839:6): [True: 708, False: 0]
  ------------------
 4840|    708|	    xmlFree(obj->stringval);
 4841|    708|    }
 4842|  3.28k|    xmlFree(obj);
 4843|  3.28k|}
xmlXPathCastBooleanToString:
 5001|      2|xmlXPathCastBooleanToString (int val) {
 5002|      2|    xmlChar *ret;
 5003|      2|    if (val)
  ------------------
  |  Branch (5003:9): [True: 1, False: 1]
  ------------------
 5004|      1|	ret = xmlStrdup((const xmlChar *) "true");
 5005|      1|    else
 5006|      1|	ret = xmlStrdup((const xmlChar *) "false");
 5007|      2|    return(ret);
 5008|      2|}
xmlXPathCastNumberToString:
 5019|      5|xmlXPathCastNumberToString (double val) {
 5020|      5|    xmlChar *ret;
 5021|      5|    switch (xmlXPathIsInf(val)) {
 5022|      0|    case 1:
  ------------------
  |  Branch (5022:5): [True: 0, False: 5]
  ------------------
 5023|      0|	ret = xmlStrdup((const xmlChar *) "Infinity");
 5024|      0|	break;
 5025|      0|    case -1:
  ------------------
  |  Branch (5025:5): [True: 0, False: 5]
  ------------------
 5026|      0|	ret = xmlStrdup((const xmlChar *) "-Infinity");
 5027|      0|	break;
 5028|      5|    default:
  ------------------
  |  Branch (5028:5): [True: 5, False: 0]
  ------------------
 5029|      5|	if (xmlXPathIsNaN(val)) {
  ------------------
  |  Branch (5029:6): [True: 0, False: 5]
  ------------------
 5030|      0|	    ret = xmlStrdup((const xmlChar *) "NaN");
 5031|      5|	} else if (val == 0) {
  ------------------
  |  Branch (5031:13): [True: 0, False: 5]
  ------------------
 5032|       |            /* Omit sign for negative zero. */
 5033|      0|	    ret = xmlStrdup((const xmlChar *) "0");
 5034|      5|	} else {
 5035|       |	    /* could be improved */
 5036|      5|	    char buf[100];
 5037|      5|	    xmlXPathFormatNumber(val, buf, 99);
 5038|      5|	    buf[99] = 0;
 5039|      5|	    ret = xmlStrdup((const xmlChar *) buf);
 5040|      5|	}
 5041|      5|    }
 5042|      5|    return(ret);
 5043|      5|}
xmlXPathCastNodeSetToString:
 5070|      1|xmlXPathCastNodeSetToString (xmlNodeSetPtr ns) {
 5071|      1|    if ((ns == NULL) || (ns->nodeNr == 0) || (ns->nodeTab == NULL))
  ------------------
  |  Branch (5071:9): [True: 0, False: 1]
  |  Branch (5071:25): [True: 1, False: 0]
  |  Branch (5071:46): [True: 0, False: 0]
  ------------------
 5072|      1|	return(xmlStrdup((const xmlChar *) ""));
 5073|       |
 5074|      0|    if (ns->nodeNr > 1)
  ------------------
  |  Branch (5074:9): [True: 0, False: 0]
  ------------------
 5075|      0|	xmlXPathNodeSetSort(ns);
 5076|      0|    return(xmlXPathCastNodeToString(ns->nodeTab[0]));
 5077|      1|}
xmlXPathCastBooleanToNumber:
 5179|      5|xmlXPathCastBooleanToNumber(int val) {
 5180|      5|    if (val)
  ------------------
  |  Branch (5180:9): [True: 2, False: 3]
  ------------------
 5181|      2|	return(1.0);
 5182|      3|    return(0.0);
 5183|      5|}
xmlXPathCastStringToNumber:
 5194|     52|xmlXPathCastStringToNumber(const xmlChar * val) {
 5195|     52|    return(xmlXPathStringEvalNumber(val));
 5196|     52|}
xmlXPathCastNodeSetToNumber:
 5231|      1|xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns) {
 5232|      1|    xmlChar *str;
 5233|      1|    double ret;
 5234|       |
 5235|      1|    if (ns == NULL)
  ------------------
  |  Branch (5235:9): [True: 0, False: 1]
  ------------------
 5236|      0|	return(xmlXPathNAN);
 5237|      1|    str = xmlXPathCastNodeSetToString(ns);
 5238|      1|    ret = xmlXPathCastStringToNumber(str);
 5239|      1|    xmlFree(str);
 5240|      1|    return(ret);
 5241|      1|}
xmlXPathCastToNumber:
 5252|    216|xmlXPathCastToNumber(xmlXPathObjectPtr val) {
 5253|    216|    double ret = 0.0;
 5254|       |
 5255|    216|    if (val == NULL)
  ------------------
  |  Branch (5255:9): [True: 0, False: 216]
  ------------------
 5256|      0|	return(xmlXPathNAN);
 5257|    216|    switch (val->type) {
  ------------------
  |  Branch (5257:13): [True: 0, False: 216]
  ------------------
 5258|      0|    case XPATH_UNDEFINED:
  ------------------
  |  Branch (5258:5): [True: 0, False: 216]
  ------------------
 5259|      0|	ret = xmlXPathNAN;
 5260|      0|	break;
 5261|      1|    case XPATH_NODESET:
  ------------------
  |  Branch (5261:5): [True: 1, False: 215]
  ------------------
 5262|      1|    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (5262:5): [True: 0, False: 216]
  ------------------
 5263|      1|	ret = xmlXPathCastNodeSetToNumber(val->nodesetval);
 5264|      1|	break;
 5265|     51|    case XPATH_STRING:
  ------------------
  |  Branch (5265:5): [True: 51, False: 165]
  ------------------
 5266|     51|	ret = xmlXPathCastStringToNumber(val->stringval);
 5267|     51|	break;
 5268|    159|    case XPATH_NUMBER:
  ------------------
  |  Branch (5268:5): [True: 159, False: 57]
  ------------------
 5269|    159|	ret = val->floatval;
 5270|    159|	break;
 5271|      5|    case XPATH_BOOLEAN:
  ------------------
  |  Branch (5271:5): [True: 5, False: 211]
  ------------------
 5272|      5|	ret = xmlXPathCastBooleanToNumber(val->boolval);
 5273|      5|	break;
 5274|      0|    case XPATH_USERS:
  ------------------
  |  Branch (5274:5): [True: 0, False: 216]
  ------------------
 5275|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 5276|       |    case XPATH_POINT:
 5277|       |    case XPATH_RANGE:
 5278|       |    case XPATH_LOCATIONSET:
 5279|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 5280|      0|	TODO;
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 5281|      0|	ret = xmlXPathNAN;
 5282|      0|	break;
 5283|    216|    }
 5284|    216|    return(ret);
 5285|    216|}
xmlXPathCastNumberToBoolean:
 5318|     10|xmlXPathCastNumberToBoolean (double val) {
 5319|     10|     if (xmlXPathIsNaN(val) || (val == 0.0))
  ------------------
  |  Branch (5319:10): [True: 1, False: 9]
  |  Branch (5319:32): [True: 5, False: 4]
  ------------------
 5320|      6|	 return(0);
 5321|      4|     return(1);
 5322|     10|}
xmlXPathNewContext:
 5436|    486|xmlXPathNewContext(xmlDocPtr doc) {
 5437|    486|    xmlXPathContextPtr ret;
 5438|       |
 5439|    486|    ret = (xmlXPathContextPtr) xmlMalloc(sizeof(xmlXPathContext));
 5440|    486|    if (ret == NULL) {
  ------------------
  |  Branch (5440:9): [True: 0, False: 486]
  ------------------
 5441|      0|        xmlXPathErrMemory(NULL, "creating context\n");
 5442|      0|	return(NULL);
 5443|      0|    }
 5444|    486|    memset(ret, 0 , sizeof(xmlXPathContext));
 5445|    486|    ret->doc = doc;
 5446|    486|    ret->node = NULL;
 5447|       |
 5448|    486|    ret->varHash = NULL;
 5449|       |
 5450|    486|    ret->nb_types = 0;
 5451|    486|    ret->max_types = 0;
 5452|    486|    ret->types = NULL;
 5453|       |
 5454|    486|    ret->funcHash = xmlHashCreate(0);
 5455|       |
 5456|    486|    ret->nb_axis = 0;
 5457|    486|    ret->max_axis = 0;
 5458|    486|    ret->axis = NULL;
 5459|       |
 5460|    486|    ret->nsHash = NULL;
 5461|    486|    ret->user = NULL;
 5462|       |
 5463|    486|    ret->contextSize = -1;
 5464|    486|    ret->proximityPosition = -1;
 5465|       |
 5466|       |#ifdef XP_DEFAULT_CACHE_ON
 5467|       |    if (xmlXPathContextSetCache(ret, 1, -1, 0) == -1) {
 5468|       |	xmlXPathFreeContext(ret);
 5469|       |	return(NULL);
 5470|       |    }
 5471|       |#endif
 5472|       |
 5473|    486|    xmlXPathRegisterAllFunctions(ret);
 5474|       |
 5475|    486|    return(ret);
 5476|    486|}
xmlXPathFreeContext:
 5485|    486|xmlXPathFreeContext(xmlXPathContextPtr ctxt) {
 5486|    486|    if (ctxt == NULL) return;
  ------------------
  |  Branch (5486:9): [True: 0, False: 486]
  ------------------
 5487|       |
 5488|    486|    if (ctxt->cache != NULL)
  ------------------
  |  Branch (5488:9): [True: 0, False: 486]
  ------------------
 5489|      0|	xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);
 5490|    486|    xmlXPathRegisteredNsCleanup(ctxt);
 5491|    486|    xmlXPathRegisteredFuncsCleanup(ctxt);
 5492|    486|    xmlXPathRegisteredVariablesCleanup(ctxt);
 5493|    486|    xmlResetError(&ctxt->lastError);
 5494|    486|    xmlFree(ctxt);
 5495|    486|}
xmlXPathNewParserContext:
 5544|    486|xmlXPathNewParserContext(const xmlChar *str, xmlXPathContextPtr ctxt) {
 5545|    486|    xmlXPathParserContextPtr ret;
 5546|       |
 5547|    486|    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));
 5548|    486|    if (ret == NULL) {
  ------------------
  |  Branch (5548:9): [True: 9, False: 477]
  ------------------
 5549|      9|        xmlXPathErrMemory(ctxt, "creating parser context\n");
 5550|      9|	return(NULL);
 5551|      9|    }
 5552|    477|    memset(ret, 0 , sizeof(xmlXPathParserContext));
 5553|    477|    ret->cur = ret->base = str;
 5554|    477|    ret->context = ctxt;
 5555|       |
 5556|    477|    ret->comp = xmlXPathNewCompExpr();
 5557|    477|    if (ret->comp == NULL) {
  ------------------
  |  Branch (5557:9): [True: 0, False: 477]
  ------------------
 5558|      0|	xmlFree(ret->valueTab);
 5559|      0|	xmlFree(ret);
 5560|      0|	return(NULL);
 5561|      0|    }
 5562|    477|    if ((ctxt != NULL) && (ctxt->dict != NULL)) {
  ------------------
  |  Branch (5562:9): [True: 477, False: 0]
  |  Branch (5562:27): [True: 0, False: 477]
  ------------------
 5563|      0|        ret->comp->dict = ctxt->dict;
 5564|      0|	xmlDictReference(ret->comp->dict);
 5565|      0|    }
 5566|       |
 5567|    477|    return(ret);
 5568|    477|}
xmlXPathFreeParserContext:
 5615|    477|xmlXPathFreeParserContext(xmlXPathParserContextPtr ctxt) {
 5616|    477|    int i;
 5617|       |
 5618|    477|    if (ctxt->valueTab != NULL) {
  ------------------
  |  Branch (5618:9): [True: 477, False: 0]
  ------------------
 5619|    477|        for (i = 0; i < ctxt->valueNr; i++) {
  ------------------
  |  Branch (5619:21): [True: 0, False: 477]
  ------------------
 5620|      0|            if (ctxt->context)
  ------------------
  |  Branch (5620:17): [True: 0, False: 0]
  ------------------
 5621|      0|                xmlXPathReleaseObject(ctxt->context, ctxt->valueTab[i]);
 5622|      0|            else
 5623|      0|                xmlXPathFreeObject(ctxt->valueTab[i]);
 5624|      0|        }
 5625|    477|        xmlFree(ctxt->valueTab);
 5626|    477|    }
 5627|    477|    if (ctxt->comp != NULL) {
  ------------------
  |  Branch (5627:9): [True: 477, False: 0]
  ------------------
 5628|    477|#ifdef XPATH_STREAMING
 5629|    477|	if (ctxt->comp->stream != NULL) {
  ------------------
  |  Branch (5629:6): [True: 15, False: 462]
  ------------------
 5630|     15|	    xmlFreePatternList(ctxt->comp->stream);
 5631|     15|	    ctxt->comp->stream = NULL;
 5632|     15|	}
 5633|    477|#endif
 5634|    477|	xmlXPathFreeCompExpr(ctxt->comp);
 5635|    477|    }
 5636|    477|    xmlFree(ctxt);
 5637|    477|}
xmlXPathEqualValues:
 6467|    275|xmlXPathEqualValues(xmlXPathParserContextPtr ctxt) {
 6468|    275|    xmlXPathObjectPtr arg1, arg2, argtmp;
 6469|    275|    int ret = 0;
 6470|       |
 6471|    275|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);
  ------------------
  |  Branch (6471:9): [True: 0, False: 275]
  |  Branch (6471:27): [True: 0, False: 275]
  ------------------
 6472|    275|    arg2 = valuePop(ctxt);
 6473|    275|    arg1 = valuePop(ctxt);
 6474|    275|    if ((arg1 == NULL) || (arg2 == NULL)) {
  ------------------
  |  Branch (6474:9): [True: 0, False: 275]
  |  Branch (6474:27): [True: 0, False: 275]
  ------------------
 6475|      0|	if (arg1 != NULL)
  ------------------
  |  Branch (6475:6): [True: 0, False: 0]
  ------------------
 6476|      0|	    xmlXPathReleaseObject(ctxt->context, arg1);
 6477|      0|	else
 6478|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
 6479|      0|	XP_ERROR0(XPATH_INVALID_OPERAND);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 6480|      0|    }
 6481|       |
 6482|    275|    if (arg1 == arg2) {
  ------------------
  |  Branch (6482:9): [True: 0, False: 275]
  ------------------
 6483|      0|	xmlXPathFreeObject(arg1);
 6484|      0|        return(1);
 6485|      0|    }
 6486|       |
 6487|       |    /*
 6488|       |     *If either argument is a nodeset, it's a 'special case'
 6489|       |     */
 6490|    275|    if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
  ------------------
  |  Branch (6490:9): [True: 0, False: 275]
  |  Branch (6490:42): [True: 0, False: 275]
  ------------------
 6491|    275|      (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6491:7): [True: 236, False: 39]
  |  Branch (6491:40): [True: 0, False: 39]
  ------------------
 6492|       |	/*
 6493|       |	 *Hack it to assure arg1 is the nodeset
 6494|       |	 */
 6495|    236|	if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6495:6): [True: 0, False: 236]
  |  Branch (6495:39): [True: 0, False: 0]
  ------------------
 6496|      0|		argtmp = arg2;
 6497|      0|		arg2 = arg1;
 6498|      0|		arg1 = argtmp;
 6499|      0|	}
 6500|    236|	switch (arg2->type) {
  ------------------
  |  Branch (6500:10): [True: 0, False: 236]
  ------------------
 6501|      0|	    case XPATH_UNDEFINED:
  ------------------
  |  Branch (6501:6): [True: 0, False: 236]
  ------------------
 6502|      0|		break;
 6503|      0|	    case XPATH_NODESET:
  ------------------
  |  Branch (6503:6): [True: 0, False: 236]
  ------------------
 6504|      0|	    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6504:6): [True: 0, False: 236]
  ------------------
 6505|      0|		ret = xmlXPathEqualNodeSets(arg1, arg2, 0);
 6506|      0|		break;
 6507|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (6507:6): [True: 0, False: 236]
  ------------------
 6508|      0|		if ((arg1->nodesetval == NULL) ||
  ------------------
  |  Branch (6508:7): [True: 0, False: 0]
  ------------------
 6509|      0|		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
  ------------------
  |  Branch (6509:5): [True: 0, False: 0]
  ------------------
 6510|      0|		else
 6511|      0|		    ret = 1;
 6512|      0|		ret = (ret == arg2->boolval);
 6513|      0|		break;
 6514|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (6514:6): [True: 0, False: 236]
  ------------------
 6515|      0|		ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);
 6516|      0|		break;
 6517|    236|	    case XPATH_STRING:
  ------------------
  |  Branch (6517:6): [True: 236, False: 0]
  ------------------
 6518|    236|		ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval, 0);
 6519|    236|		break;
 6520|      0|	    case XPATH_USERS:
  ------------------
  |  Branch (6520:6): [True: 0, False: 236]
  ------------------
 6521|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6522|       |	    case XPATH_POINT:
 6523|       |	    case XPATH_RANGE:
 6524|       |	    case XPATH_LOCATIONSET:
 6525|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6526|      0|		TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6527|      0|		break;
 6528|    236|	}
 6529|    236|	xmlXPathReleaseObject(ctxt->context, arg1);
 6530|    236|	xmlXPathReleaseObject(ctxt->context, arg2);
 6531|    236|	return(ret);
 6532|    236|    }
 6533|       |
 6534|     39|    return (xmlXPathEqualValuesCommon(ctxt, arg1, arg2));
 6535|    275|}
xmlXPathNotEqualValues:
 6546|     16|xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt) {
 6547|     16|    xmlXPathObjectPtr arg1, arg2, argtmp;
 6548|     16|    int ret = 0;
 6549|       |
 6550|     16|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);
  ------------------
  |  Branch (6550:9): [True: 0, False: 16]
  |  Branch (6550:27): [True: 0, False: 16]
  ------------------
 6551|     16|    arg2 = valuePop(ctxt);
 6552|     16|    arg1 = valuePop(ctxt);
 6553|     16|    if ((arg1 == NULL) || (arg2 == NULL)) {
  ------------------
  |  Branch (6553:9): [True: 0, False: 16]
  |  Branch (6553:27): [True: 0, False: 16]
  ------------------
 6554|      0|	if (arg1 != NULL)
  ------------------
  |  Branch (6554:6): [True: 0, False: 0]
  ------------------
 6555|      0|	    xmlXPathReleaseObject(ctxt->context, arg1);
 6556|      0|	else
 6557|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
 6558|      0|	XP_ERROR0(XPATH_INVALID_OPERAND);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 6559|      0|    }
 6560|       |
 6561|     16|    if (arg1 == arg2) {
  ------------------
  |  Branch (6561:9): [True: 0, False: 16]
  ------------------
 6562|      0|	xmlXPathReleaseObject(ctxt->context, arg1);
 6563|      0|        return(0);
 6564|      0|    }
 6565|       |
 6566|       |    /*
 6567|       |     *If either argument is a nodeset, it's a 'special case'
 6568|       |     */
 6569|     16|    if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
  ------------------
  |  Branch (6569:9): [True: 0, False: 16]
  |  Branch (6569:42): [True: 0, False: 16]
  ------------------
 6570|     16|      (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6570:7): [True: 0, False: 16]
  |  Branch (6570:40): [True: 0, False: 16]
  ------------------
 6571|       |	/*
 6572|       |	 *Hack it to assure arg1 is the nodeset
 6573|       |	 */
 6574|      0|	if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6574:6): [True: 0, False: 0]
  |  Branch (6574:39): [True: 0, False: 0]
  ------------------
 6575|      0|		argtmp = arg2;
 6576|      0|		arg2 = arg1;
 6577|      0|		arg1 = argtmp;
 6578|      0|	}
 6579|      0|	switch (arg2->type) {
  ------------------
  |  Branch (6579:10): [True: 0, False: 0]
  ------------------
 6580|      0|	    case XPATH_UNDEFINED:
  ------------------
  |  Branch (6580:6): [True: 0, False: 0]
  ------------------
 6581|      0|		break;
 6582|      0|	    case XPATH_NODESET:
  ------------------
  |  Branch (6582:6): [True: 0, False: 0]
  ------------------
 6583|      0|	    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6583:6): [True: 0, False: 0]
  ------------------
 6584|      0|		ret = xmlXPathEqualNodeSets(arg1, arg2, 1);
 6585|      0|		break;
 6586|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (6586:6): [True: 0, False: 0]
  ------------------
 6587|      0|		if ((arg1->nodesetval == NULL) ||
  ------------------
  |  Branch (6587:7): [True: 0, False: 0]
  ------------------
 6588|      0|		  (arg1->nodesetval->nodeNr == 0)) ret = 0;
  ------------------
  |  Branch (6588:5): [True: 0, False: 0]
  ------------------
 6589|      0|		else
 6590|      0|		    ret = 1;
 6591|      0|		ret = (ret != arg2->boolval);
 6592|      0|		break;
 6593|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (6593:6): [True: 0, False: 0]
  ------------------
 6594|      0|		ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);
 6595|      0|		break;
 6596|      0|	    case XPATH_STRING:
  ------------------
  |  Branch (6596:6): [True: 0, False: 0]
  ------------------
 6597|      0|		ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval,1);
 6598|      0|		break;
 6599|      0|	    case XPATH_USERS:
  ------------------
  |  Branch (6599:6): [True: 0, False: 0]
  ------------------
 6600|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6601|       |	    case XPATH_POINT:
 6602|       |	    case XPATH_RANGE:
 6603|       |	    case XPATH_LOCATIONSET:
 6604|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6605|      0|		TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6606|      0|		break;
 6607|      0|	}
 6608|      0|	xmlXPathReleaseObject(ctxt->context, arg1);
 6609|      0|	xmlXPathReleaseObject(ctxt->context, arg2);
 6610|      0|	return(ret);
 6611|      0|    }
 6612|       |
 6613|     16|    return (!xmlXPathEqualValuesCommon(ctxt, arg1, arg2));
 6614|     16|}
xmlXPathCompareValues:
 6641|     69|xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict) {
 6642|     69|    int ret = 0, arg1i = 0, arg2i = 0;
 6643|     69|    xmlXPathObjectPtr arg1, arg2;
 6644|       |
 6645|     69|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);
  ------------------
  |  Branch (6645:9): [True: 0, False: 69]
  |  Branch (6645:27): [True: 0, False: 69]
  ------------------
 6646|     69|    arg2 = valuePop(ctxt);
 6647|     69|    arg1 = valuePop(ctxt);
 6648|     69|    if ((arg1 == NULL) || (arg2 == NULL)) {
  ------------------
  |  Branch (6648:9): [True: 0, False: 69]
  |  Branch (6648:27): [True: 0, False: 69]
  ------------------
 6649|      0|	if (arg1 != NULL)
  ------------------
  |  Branch (6649:6): [True: 0, False: 0]
  ------------------
 6650|      0|	    xmlXPathReleaseObject(ctxt->context, arg1);
 6651|      0|	else
 6652|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
 6653|      0|	XP_ERROR0(XPATH_INVALID_OPERAND);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 6654|      0|    }
 6655|       |
 6656|     69|    if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||
  ------------------
  |  Branch (6656:9): [True: 0, False: 69]
  |  Branch (6656:42): [True: 0, False: 69]
  ------------------
 6657|     69|      (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6657:7): [True: 0, False: 69]
  |  Branch (6657:40): [True: 0, False: 69]
  ------------------
 6658|       |	/*
 6659|       |	 * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments
 6660|       |	 * are not freed from within this routine; they will be freed from the
 6661|       |	 * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue
 6662|       |	 */
 6663|      0|	if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&
  ------------------
  |  Branch (6663:7): [True: 0, False: 0]
  |  Branch (6663:40): [True: 0, False: 0]
  ------------------
 6664|      0|	  ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){
  ------------------
  |  Branch (6664:5): [True: 0, False: 0]
  |  Branch (6664:38): [True: 0, False: 0]
  ------------------
 6665|      0|	    ret = xmlXPathCompareNodeSets(inf, strict, arg1, arg2);
 6666|      0|	} else {
 6667|      0|	    if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (6667:10): [True: 0, False: 0]
  |  Branch (6667:43): [True: 0, False: 0]
  ------------------
 6668|      0|		ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,
 6669|      0|			                          arg1, arg2);
 6670|      0|	    } else {
 6671|      0|		ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,
 6672|      0|			                          arg2, arg1);
 6673|      0|	    }
 6674|      0|	}
 6675|      0|	return(ret);
 6676|      0|    }
 6677|       |
 6678|     69|    if (arg1->type != XPATH_NUMBER) {
  ------------------
  |  Branch (6678:9): [True: 21, False: 48]
  ------------------
 6679|     21|	valuePush(ctxt, arg1);
 6680|     21|	xmlXPathNumberFunction(ctxt, 1);
 6681|     21|	arg1 = valuePop(ctxt);
 6682|     21|    }
 6683|     69|    if (arg2->type != XPATH_NUMBER) {
  ------------------
  |  Branch (6683:9): [True: 25, False: 44]
  ------------------
 6684|     25|	valuePush(ctxt, arg2);
 6685|     25|	xmlXPathNumberFunction(ctxt, 1);
 6686|     25|	arg2 = valuePop(ctxt);
 6687|     25|    }
 6688|     69|    if (ctxt->error)
  ------------------
  |  Branch (6688:9): [True: 0, False: 69]
  ------------------
 6689|      0|        goto error;
 6690|       |    /*
 6691|       |     * Add tests for infinity and nan
 6692|       |     * => feedback on 3.4 for Inf and NaN
 6693|       |     */
 6694|       |    /* Hand check NaN and Infinity comparisons */
 6695|     69|    if (xmlXPathIsNaN(arg1->floatval) || xmlXPathIsNaN(arg2->floatval)) {
  ------------------
  |  Branch (6695:9): [True: 21, False: 48]
  |  Branch (6695:42): [True: 0, False: 48]
  ------------------
 6696|     21|	ret=0;
 6697|     48|    } else {
 6698|     48|	arg1i=xmlXPathIsInf(arg1->floatval);
 6699|     48|	arg2i=xmlXPathIsInf(arg2->floatval);
 6700|     48|	if (inf && strict) {
  ------------------
  |  Branch (6700:6): [True: 23, False: 25]
  |  Branch (6700:13): [True: 13, False: 10]
  ------------------
 6701|     13|	    if ((arg1i == -1 && arg2i != -1) ||
  ------------------
  |  Branch (6701:11): [True: 2, False: 11]
  |  Branch (6701:26): [True: 2, False: 0]
  ------------------
 6702|     13|		(arg2i == 1 && arg1i != 1)) {
  ------------------
  |  Branch (6702:4): [True: 1, False: 10]
  |  Branch (6702:18): [True: 0, False: 1]
  ------------------
 6703|      2|		ret = 1;
 6704|     11|	    } else if (arg1i == 0 && arg2i == 0) {
  ------------------
  |  Branch (6704:17): [True: 8, False: 3]
  |  Branch (6704:31): [True: 8, False: 0]
  ------------------
 6705|      8|		ret = (arg1->floatval < arg2->floatval);
 6706|      8|	    } else {
 6707|      3|		ret = 0;
 6708|      3|	    }
 6709|     13|	}
 6710|     35|	else if (inf && !strict) {
  ------------------
  |  Branch (6710:11): [True: 10, False: 25]
  |  Branch (6710:18): [True: 10, False: 0]
  ------------------
 6711|     10|	    if (arg1i == -1 || arg2i == 1) {
  ------------------
  |  Branch (6711:10): [True: 0, False: 10]
  |  Branch (6711:25): [True: 0, False: 10]
  ------------------
 6712|      0|		ret = 1;
 6713|     10|	    } else if (arg1i == 0 && arg2i == 0) {
  ------------------
  |  Branch (6713:17): [True: 8, False: 2]
  |  Branch (6713:31): [True: 8, False: 0]
  ------------------
 6714|      8|		ret = (arg1->floatval <= arg2->floatval);
 6715|      8|	    } else {
 6716|      2|		ret = 0;
 6717|      2|	    }
 6718|     10|	}
 6719|     25|	else if (!inf && strict) {
  ------------------
  |  Branch (6719:11): [True: 25, False: 0]
  |  Branch (6719:19): [True: 14, False: 11]
  ------------------
 6720|     14|	    if ((arg1i == 1 && arg2i != 1) ||
  ------------------
  |  Branch (6720:11): [True: 3, False: 11]
  |  Branch (6720:25): [True: 2, False: 1]
  ------------------
 6721|     14|		(arg2i == -1 && arg1i != -1)) {
  ------------------
  |  Branch (6721:4): [True: 0, False: 12]
  |  Branch (6721:19): [True: 0, False: 0]
  ------------------
 6722|      2|		ret = 1;
 6723|     12|	    } else if (arg1i == 0 && arg2i == 0) {
  ------------------
  |  Branch (6723:17): [True: 8, False: 4]
  |  Branch (6723:31): [True: 8, False: 0]
  ------------------
 6724|      8|		ret = (arg1->floatval > arg2->floatval);
 6725|      8|	    } else {
 6726|      4|		ret = 0;
 6727|      4|	    }
 6728|     14|	}
 6729|     11|	else if (!inf && !strict) {
  ------------------
  |  Branch (6729:11): [True: 11, False: 0]
  |  Branch (6729:19): [True: 11, False: 0]
  ------------------
 6730|     11|	    if (arg1i == 1 || arg2i == -1) {
  ------------------
  |  Branch (6730:10): [True: 2, False: 9]
  |  Branch (6730:24): [True: 0, False: 9]
  ------------------
 6731|      2|		ret = 1;
 6732|      9|	    } else if (arg1i == 0 && arg2i == 0) {
  ------------------
  |  Branch (6732:17): [True: 9, False: 0]
  |  Branch (6732:31): [True: 9, False: 0]
  ------------------
 6733|      9|		ret = (arg1->floatval >= arg2->floatval);
 6734|      9|	    } else {
 6735|      0|		ret = 0;
 6736|      0|	    }
 6737|     11|	}
 6738|     48|    }
 6739|     69|error:
 6740|     69|    xmlXPathReleaseObject(ctxt->context, arg1);
 6741|     69|    xmlXPathReleaseObject(ctxt->context, arg2);
 6742|     69|    return(ret);
 6743|     69|}
xmlXPathValueFlipSign:
 6754|     68|xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt) {
 6755|     68|    if ((ctxt == NULL) || (ctxt->context == NULL)) return;
  ------------------
  |  Branch (6755:9): [True: 0, False: 68]
  |  Branch (6755:27): [True: 0, False: 68]
  ------------------
 6756|     68|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     68|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 68, False: 0]
  |  |  |  Branch (319:34): [True: 1, False: 67]
  |  |  ------------------
  |  |  320|     68|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 6757|     68|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     68|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 68]
  |  |  |  Branch (277:34): [True: 0, False: 68]
  |  |  ------------------
  |  |  278|     68|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 6758|     68|    ctxt->value->floatval = -ctxt->value->floatval;
 6759|     68|}
xmlXPathAddValues:
 6770|     27|xmlXPathAddValues(xmlXPathParserContextPtr ctxt) {
 6771|     27|    xmlXPathObjectPtr arg;
 6772|     27|    double val;
 6773|       |
 6774|     27|    arg = valuePop(ctxt);
 6775|     27|    if (arg == NULL)
  ------------------
  |  Branch (6775:9): [True: 0, False: 27]
  ------------------
 6776|     27|	XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 6777|     27|    val = xmlXPathCastToNumber(arg);
 6778|     27|    xmlXPathReleaseObject(ctxt->context, arg);
 6779|     27|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     27|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 27, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 27]
  |  |  ------------------
  |  |  320|     27|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 6780|     27|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     27|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 27]
  |  |  |  Branch (277:34): [True: 0, False: 27]
  |  |  ------------------
  |  |  278|     27|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 6781|     27|    ctxt->value->floatval += val;
 6782|     27|}
xmlXPathMultValues:
 6816|     25|xmlXPathMultValues(xmlXPathParserContextPtr ctxt) {
 6817|     25|    xmlXPathObjectPtr arg;
 6818|     25|    double val;
 6819|       |
 6820|     25|    arg = valuePop(ctxt);
 6821|     25|    if (arg == NULL)
  ------------------
  |  Branch (6821:9): [True: 0, False: 25]
  ------------------
 6822|     25|	XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 6823|     25|    val = xmlXPathCastToNumber(arg);
 6824|     25|    xmlXPathReleaseObject(ctxt->context, arg);
 6825|     25|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     25|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 25, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 25]
  |  |  ------------------
  |  |  320|     25|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 6826|     25|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     25|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 25]
  |  |  |  Branch (277:34): [True: 0, False: 25]
  |  |  ------------------
  |  |  278|     25|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 6827|     25|    ctxt->value->floatval *= val;
 6828|     25|}
xmlXPathDivValues:
 6840|     96|xmlXPathDivValues(xmlXPathParserContextPtr ctxt) {
 6841|     96|    xmlXPathObjectPtr arg;
 6842|     96|    double val;
 6843|       |
 6844|     96|    arg = valuePop(ctxt);
 6845|     96|    if (arg == NULL)
  ------------------
  |  Branch (6845:9): [True: 0, False: 96]
  ------------------
 6846|     96|	XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 6847|     96|    val = xmlXPathCastToNumber(arg);
 6848|     96|    xmlXPathReleaseObject(ctxt->context, arg);
 6849|     96|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     96|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 96, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 96]
  |  |  ------------------
  |  |  320|     96|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 6850|     96|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     96|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 96]
  |  |  |  Branch (277:34): [True: 0, False: 96]
  |  |  ------------------
  |  |  278|     96|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 6851|     96|    ctxt->value->floatval /= val;
 6852|     96|}
xmlXPathModValues:
 6863|     11|xmlXPathModValues(xmlXPathParserContextPtr ctxt) {
 6864|     11|    xmlXPathObjectPtr arg;
 6865|     11|    double arg1, arg2;
 6866|       |
 6867|     11|    arg = valuePop(ctxt);
 6868|     11|    if (arg == NULL)
  ------------------
  |  Branch (6868:9): [True: 0, False: 11]
  ------------------
 6869|     11|	XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 6870|     11|    arg2 = xmlXPathCastToNumber(arg);
 6871|     11|    xmlXPathReleaseObject(ctxt->context, arg);
 6872|     11|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     11|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 11, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 11]
  |  |  ------------------
  |  |  320|     11|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 6873|     11|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     11|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 11]
  |  |  |  Branch (277:34): [True: 0, False: 11]
  |  |  ------------------
  |  |  278|     11|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 6874|     11|    arg1 = ctxt->value->floatval;
 6875|     11|    if (arg2 == 0)
  ------------------
  |  Branch (6875:9): [True: 0, False: 11]
  ------------------
 6876|      0|	ctxt->value->floatval = xmlXPathNAN;
 6877|     11|    else {
 6878|     11|	ctxt->value->floatval = fmod(arg1, arg2);
 6879|     11|    }
 6880|     11|}
xmlXPathNextSelf:
 6925|     10|xmlXPathNextSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 6926|     10|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (6926:9): [True: 0, False: 10]
  |  Branch (6926:27): [True: 0, False: 10]
  ------------------
 6927|     10|    if (cur == NULL)
  ------------------
  |  Branch (6927:9): [True: 5, False: 5]
  ------------------
 6928|      5|        return(ctxt->context->node);
 6929|      5|    return(NULL);
 6930|     10|}
xmlXPathNextChild:
 6943|    155|xmlXPathNextChild(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 6944|    155|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (6944:9): [True: 0, False: 155]
  |  Branch (6944:27): [True: 0, False: 155]
  ------------------
 6945|    155|    if (cur == NULL) {
  ------------------
  |  Branch (6945:9): [True: 76, False: 79]
  ------------------
 6946|     76|	if (ctxt->context->node == NULL) return(NULL);
  ------------------
  |  Branch (6946:6): [True: 0, False: 76]
  ------------------
 6947|     76|	switch (ctxt->context->node->type) {
  ------------------
  |  Branch (6947:10): [True: 0, False: 76]
  ------------------
 6948|     37|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (6948:13): [True: 37, False: 39]
  ------------------
 6949|     75|            case XML_TEXT_NODE:
  ------------------
  |  Branch (6949:13): [True: 38, False: 38]
  ------------------
 6950|     75|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (6950:13): [True: 0, False: 76]
  ------------------
 6951|     75|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (6951:13): [True: 0, False: 76]
  ------------------
 6952|     75|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (6952:13): [True: 0, False: 76]
  ------------------
 6953|     75|            case XML_PI_NODE:
  ------------------
  |  Branch (6953:13): [True: 0, False: 76]
  ------------------
 6954|     75|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (6954:13): [True: 0, False: 76]
  ------------------
 6955|     75|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (6955:13): [True: 0, False: 76]
  ------------------
 6956|     75|            case XML_DTD_NODE:
  ------------------
  |  Branch (6956:13): [True: 0, False: 76]
  ------------------
 6957|     75|		return(ctxt->context->node->children);
 6958|      1|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (6958:13): [True: 1, False: 75]
  ------------------
 6959|      1|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (6959:13): [True: 0, False: 76]
  ------------------
 6960|      1|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (6960:13): [True: 0, False: 76]
  ------------------
 6961|      1|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (6961:13): [True: 0, False: 76]
  ------------------
 6962|      1|		return(((xmlDocPtr) ctxt->context->node)->children);
 6963|      0|	    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (6963:6): [True: 0, False: 76]
  ------------------
 6964|      0|	    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (6964:6): [True: 0, False: 76]
  ------------------
 6965|      0|	    case XML_ENTITY_DECL:
  ------------------
  |  Branch (6965:6): [True: 0, False: 76]
  ------------------
 6966|      0|            case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (6966:13): [True: 0, False: 76]
  ------------------
 6967|      0|	    case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (6967:6): [True: 0, False: 76]
  ------------------
 6968|      0|	    case XML_XINCLUDE_START:
  ------------------
  |  Branch (6968:6): [True: 0, False: 76]
  ------------------
 6969|      0|	    case XML_XINCLUDE_END:
  ------------------
  |  Branch (6969:6): [True: 0, False: 76]
  ------------------
 6970|      0|		return(NULL);
 6971|     76|	}
 6972|      0|	return(NULL);
 6973|     76|    }
 6974|     79|    if ((cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (6974:9): [True: 0, False: 79]
  ------------------
 6975|     79|        (cur->type == XML_HTML_DOCUMENT_NODE))
  ------------------
  |  Branch (6975:9): [True: 0, False: 79]
  ------------------
 6976|      0|	return(NULL);
 6977|     79|    return(cur->next);
 6978|     79|}
xmlXPathNextDescendant:
 7136|  3.41k|xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7137|  3.41k|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7137:9): [True: 0, False: 3.41k]
  |  Branch (7137:27): [True: 0, False: 3.41k]
  ------------------
 7138|  3.41k|    if (cur == NULL) {
  ------------------
  |  Branch (7138:9): [True: 43, False: 3.37k]
  ------------------
 7139|     43|	if (ctxt->context->node == NULL)
  ------------------
  |  Branch (7139:6): [True: 0, False: 43]
  ------------------
 7140|      0|	    return(NULL);
 7141|     43|	if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
  ------------------
  |  Branch (7141:6): [True: 0, False: 43]
  ------------------
 7142|     43|	    (ctxt->context->node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7142:6): [True: 0, False: 43]
  ------------------
 7143|      0|	    return(NULL);
 7144|       |
 7145|     43|        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)
  ------------------
  |  Branch (7145:13): [True: 42, False: 1]
  ------------------
 7146|     42|	    return(ctxt->context->doc->children);
 7147|      1|        return(ctxt->context->node->children);
 7148|     43|    }
 7149|       |
 7150|  3.37k|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (7150:9): [True: 0, False: 3.37k]
  ------------------
 7151|      0|        return(NULL);
 7152|  3.37k|    if (cur->children != NULL) {
  ------------------
  |  Branch (7152:9): [True: 1.14k, False: 2.23k]
  ------------------
 7153|       |	/*
 7154|       |	 * Do not descend on entities declarations
 7155|       |	 */
 7156|  1.14k|	if (cur->children->type != XML_ENTITY_DECL) {
  ------------------
  |  Branch (7156:6): [True: 1.14k, False: 0]
  ------------------
 7157|  1.14k|	    cur = cur->children;
 7158|       |	    /*
 7159|       |	     * Skip DTDs
 7160|       |	     */
 7161|  1.14k|	    if (cur->type != XML_DTD_NODE)
  ------------------
  |  Branch (7161:10): [True: 1.13k, False: 2]
  ------------------
 7162|  1.13k|		return(cur);
 7163|  1.14k|	}
 7164|  1.14k|    }
 7165|       |
 7166|  2.23k|    if (cur == ctxt->context->node) return(NULL);
  ------------------
  |  Branch (7166:9): [True: 1, False: 2.23k]
  ------------------
 7167|       |
 7168|  2.23k|    while (cur->next != NULL) {
  ------------------
  |  Branch (7168:12): [True: 1.18k, False: 1.05k]
  ------------------
 7169|  1.18k|	cur = cur->next;
 7170|  1.18k|	if ((cur->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (7170:6): [True: 1.18k, False: 0]
  ------------------
 7171|  1.18k|	    (cur->type != XML_DTD_NODE))
  ------------------
  |  Branch (7171:6): [True: 1.18k, False: 0]
  ------------------
 7172|  1.18k|	    return(cur);
 7173|  1.18k|    }
 7174|       |
 7175|  1.18k|    do {
 7176|  1.18k|        cur = cur->parent;
 7177|  1.18k|	if (cur == NULL) break;
  ------------------
  |  Branch (7177:6): [True: 0, False: 1.18k]
  ------------------
 7178|  1.18k|	if (cur == ctxt->context->node) return(NULL);
  ------------------
  |  Branch (7178:6): [True: 81, False: 1.10k]
  ------------------
 7179|  1.10k|	if (cur->next != NULL) {
  ------------------
  |  Branch (7179:6): [True: 972, False: 130]
  ------------------
 7180|    972|	    cur = cur->next;
 7181|    972|	    return(cur);
 7182|    972|	}
 7183|  1.10k|    } while (cur != NULL);
  ------------------
  |  Branch (7183:14): [True: 130, False: 0]
  ------------------
 7184|      0|    return(cur);
 7185|  1.05k|}
xmlXPathNextDescendantOrSelf:
 7201|  1.90k|xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7202|  1.90k|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7202:9): [True: 0, False: 1.90k]
  |  Branch (7202:27): [True: 0, False: 1.90k]
  ------------------
 7203|  1.90k|    if (cur == NULL)
  ------------------
  |  Branch (7203:9): [True: 42, False: 1.86k]
  ------------------
 7204|     42|        return(ctxt->context->node);
 7205|       |
 7206|  1.86k|    if (ctxt->context->node == NULL)
  ------------------
  |  Branch (7206:9): [True: 0, False: 1.86k]
  ------------------
 7207|      0|        return(NULL);
 7208|  1.86k|    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
  ------------------
  |  Branch (7208:9): [True: 3, False: 1.86k]
  ------------------
 7209|  1.86k|        (ctxt->context->node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7209:9): [True: 0, False: 1.86k]
  ------------------
 7210|      3|        return(NULL);
 7211|       |
 7212|  1.86k|    return(xmlXPathNextDescendant(ctxt, cur));
 7213|  1.86k|}
xmlXPathNextParent:
 7226|      6|xmlXPathNextParent(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7227|      6|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7227:9): [True: 0, False: 6]
  |  Branch (7227:27): [True: 0, False: 6]
  ------------------
 7228|       |    /*
 7229|       |     * the parent of an attribute or namespace node is the element
 7230|       |     * to which the attribute or namespace node is attached
 7231|       |     * Namespace handling !!!
 7232|       |     */
 7233|      6|    if (cur == NULL) {
  ------------------
  |  Branch (7233:9): [True: 3, False: 3]
  ------------------
 7234|      3|	if (ctxt->context->node == NULL) return(NULL);
  ------------------
  |  Branch (7234:6): [True: 0, False: 3]
  ------------------
 7235|      3|	switch (ctxt->context->node->type) {
  ------------------
  |  Branch (7235:10): [True: 0, False: 3]
  ------------------
 7236|      0|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7236:13): [True: 0, False: 3]
  ------------------
 7237|      0|            case XML_TEXT_NODE:
  ------------------
  |  Branch (7237:13): [True: 0, False: 3]
  ------------------
 7238|      0|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (7238:13): [True: 0, False: 3]
  ------------------
 7239|      0|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (7239:13): [True: 0, False: 3]
  ------------------
 7240|      0|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (7240:13): [True: 0, False: 3]
  ------------------
 7241|      0|            case XML_PI_NODE:
  ------------------
  |  Branch (7241:13): [True: 0, False: 3]
  ------------------
 7242|      0|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (7242:13): [True: 0, False: 3]
  ------------------
 7243|      0|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (7243:13): [True: 0, False: 3]
  ------------------
 7244|      0|            case XML_DTD_NODE:
  ------------------
  |  Branch (7244:13): [True: 0, False: 3]
  ------------------
 7245|      0|	    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (7245:6): [True: 0, False: 3]
  ------------------
 7246|      0|	    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (7246:6): [True: 0, False: 3]
  ------------------
 7247|      0|	    case XML_XINCLUDE_START:
  ------------------
  |  Branch (7247:6): [True: 0, False: 3]
  ------------------
 7248|      0|	    case XML_XINCLUDE_END:
  ------------------
  |  Branch (7248:6): [True: 0, False: 3]
  ------------------
 7249|      0|	    case XML_ENTITY_DECL:
  ------------------
  |  Branch (7249:6): [True: 0, False: 3]
  ------------------
 7250|      0|		if (ctxt->context->node->parent == NULL)
  ------------------
  |  Branch (7250:7): [True: 0, False: 0]
  ------------------
 7251|      0|		    return((xmlNodePtr) ctxt->context->doc);
 7252|      0|		if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7252:7): [True: 0, False: 0]
  ------------------
 7253|      0|		    ((ctxt->context->node->parent->name[0] == ' ') ||
  ------------------
  |  Branch (7253:8): [True: 0, False: 0]
  ------------------
 7254|      0|		     (xmlStrEqual(ctxt->context->node->parent->name,
  ------------------
  |  Branch (7254:8): [True: 0, False: 0]
  ------------------
 7255|      0|				 BAD_CAST "fake node libxslt"))))
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 7256|      0|		    return(NULL);
 7257|      0|		return(ctxt->context->node->parent);
 7258|      0|            case XML_ATTRIBUTE_NODE: {
  ------------------
  |  Branch (7258:13): [True: 0, False: 3]
  ------------------
 7259|      0|		xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;
 7260|       |
 7261|      0|		return(att->parent);
 7262|      0|	    }
 7263|      0|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (7263:13): [True: 0, False: 3]
  ------------------
 7264|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (7264:13): [True: 0, False: 3]
  ------------------
 7265|      0|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (7265:13): [True: 0, False: 3]
  ------------------
 7266|      0|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (7266:13): [True: 0, False: 3]
  ------------------
 7267|      0|                return(NULL);
 7268|      3|	    case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (7268:6): [True: 3, False: 0]
  ------------------
 7269|      3|		xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;
 7270|       |
 7271|      3|		if ((ns->next != NULL) &&
  ------------------
  |  Branch (7271:7): [True: 3, False: 0]
  ------------------
 7272|      3|		    (ns->next->type != XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7272:7): [True: 3, False: 0]
  ------------------
 7273|      3|		    return((xmlNodePtr) ns->next);
 7274|      0|                return(NULL);
 7275|      3|	    }
 7276|      3|	}
 7277|      3|    }
 7278|      3|    return(NULL);
 7279|      6|}
xmlXPathNextAncestor:
 7296|     65|xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7297|     65|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7297:9): [True: 0, False: 65]
  |  Branch (7297:27): [True: 0, False: 65]
  ------------------
 7298|       |    /*
 7299|       |     * the parent of an attribute or namespace node is the element
 7300|       |     * to which the attribute or namespace node is attached
 7301|       |     * !!!!!!!!!!!!!
 7302|       |     */
 7303|     65|    if (cur == NULL) {
  ------------------
  |  Branch (7303:9): [True: 14, False: 51]
  ------------------
 7304|     14|	if (ctxt->context->node == NULL) return(NULL);
  ------------------
  |  Branch (7304:6): [True: 0, False: 14]
  ------------------
 7305|     14|	switch (ctxt->context->node->type) {
  ------------------
  |  Branch (7305:10): [True: 0, False: 14]
  ------------------
 7306|     14|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7306:13): [True: 14, False: 0]
  ------------------
 7307|     14|            case XML_TEXT_NODE:
  ------------------
  |  Branch (7307:13): [True: 0, False: 14]
  ------------------
 7308|     14|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (7308:13): [True: 0, False: 14]
  ------------------
 7309|     14|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (7309:13): [True: 0, False: 14]
  ------------------
 7310|     14|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (7310:13): [True: 0, False: 14]
  ------------------
 7311|     14|            case XML_PI_NODE:
  ------------------
  |  Branch (7311:13): [True: 0, False: 14]
  ------------------
 7312|     14|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (7312:13): [True: 0, False: 14]
  ------------------
 7313|     14|	    case XML_DTD_NODE:
  ------------------
  |  Branch (7313:6): [True: 0, False: 14]
  ------------------
 7314|     14|	    case XML_ELEMENT_DECL:
  ------------------
  |  Branch (7314:6): [True: 0, False: 14]
  ------------------
 7315|     14|	    case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (7315:6): [True: 0, False: 14]
  ------------------
 7316|     14|	    case XML_ENTITY_DECL:
  ------------------
  |  Branch (7316:6): [True: 0, False: 14]
  ------------------
 7317|     14|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (7317:13): [True: 0, False: 14]
  ------------------
 7318|     14|	    case XML_XINCLUDE_START:
  ------------------
  |  Branch (7318:6): [True: 0, False: 14]
  ------------------
 7319|     14|	    case XML_XINCLUDE_END:
  ------------------
  |  Branch (7319:6): [True: 0, False: 14]
  ------------------
 7320|     14|		if (ctxt->context->node->parent == NULL)
  ------------------
  |  Branch (7320:7): [True: 0, False: 14]
  ------------------
 7321|      0|		    return((xmlNodePtr) ctxt->context->doc);
 7322|     14|		if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7322:7): [True: 14, False: 0]
  ------------------
 7323|     14|		    ((ctxt->context->node->parent->name[0] == ' ') ||
  ------------------
  |  Branch (7323:8): [True: 0, False: 14]
  ------------------
 7324|     14|		     (xmlStrEqual(ctxt->context->node->parent->name,
  ------------------
  |  Branch (7324:8): [True: 0, False: 14]
  ------------------
 7325|     14|				 BAD_CAST "fake node libxslt"))))
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
 7326|      0|		    return(NULL);
 7327|     14|		return(ctxt->context->node->parent);
 7328|      0|            case XML_ATTRIBUTE_NODE: {
  ------------------
  |  Branch (7328:13): [True: 0, False: 14]
  ------------------
 7329|      0|		xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;
 7330|       |
 7331|      0|		return(tmp->parent);
 7332|     14|	    }
 7333|      0|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (7333:13): [True: 0, False: 14]
  ------------------
 7334|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (7334:13): [True: 0, False: 14]
  ------------------
 7335|      0|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (7335:13): [True: 0, False: 14]
  ------------------
 7336|      0|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (7336:13): [True: 0, False: 14]
  ------------------
 7337|      0|                return(NULL);
 7338|      0|	    case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (7338:6): [True: 0, False: 14]
  ------------------
 7339|      0|		xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;
 7340|       |
 7341|      0|		if ((ns->next != NULL) &&
  ------------------
  |  Branch (7341:7): [True: 0, False: 0]
  ------------------
 7342|      0|		    (ns->next->type != XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7342:7): [True: 0, False: 0]
  ------------------
 7343|      0|		    return((xmlNodePtr) ns->next);
 7344|       |		/* Bad, how did that namespace end up here ? */
 7345|      0|                return(NULL);
 7346|      0|	    }
 7347|     14|	}
 7348|      0|	return(NULL);
 7349|     14|    }
 7350|     51|    if (cur == ctxt->context->doc->children)
  ------------------
  |  Branch (7350:9): [True: 17, False: 34]
  ------------------
 7351|     17|	return((xmlNodePtr) ctxt->context->doc);
 7352|     34|    if (cur == (xmlNodePtr) ctxt->context->doc)
  ------------------
  |  Branch (7352:9): [True: 17, False: 17]
  ------------------
 7353|     17|	return(NULL);
 7354|     17|    switch (cur->type) {
  ------------------
  |  Branch (7354:13): [True: 0, False: 17]
  ------------------
 7355|     14|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7355:2): [True: 14, False: 3]
  ------------------
 7356|     14|	case XML_TEXT_NODE:
  ------------------
  |  Branch (7356:2): [True: 0, False: 17]
  ------------------
 7357|     14|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (7357:2): [True: 0, False: 17]
  ------------------
 7358|     14|	case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (7358:2): [True: 0, False: 17]
  ------------------
 7359|     14|	case XML_ENTITY_NODE:
  ------------------
  |  Branch (7359:2): [True: 0, False: 17]
  ------------------
 7360|     14|	case XML_PI_NODE:
  ------------------
  |  Branch (7360:2): [True: 0, False: 17]
  ------------------
 7361|     14|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (7361:2): [True: 0, False: 17]
  ------------------
 7362|     14|	case XML_NOTATION_NODE:
  ------------------
  |  Branch (7362:2): [True: 0, False: 17]
  ------------------
 7363|     14|	case XML_DTD_NODE:
  ------------------
  |  Branch (7363:2): [True: 0, False: 17]
  ------------------
 7364|     14|        case XML_ELEMENT_DECL:
  ------------------
  |  Branch (7364:9): [True: 0, False: 17]
  ------------------
 7365|     14|        case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (7365:9): [True: 0, False: 17]
  ------------------
 7366|     14|        case XML_ENTITY_DECL:
  ------------------
  |  Branch (7366:9): [True: 0, False: 17]
  ------------------
 7367|     14|	case XML_XINCLUDE_START:
  ------------------
  |  Branch (7367:2): [True: 0, False: 17]
  ------------------
 7368|     14|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (7368:2): [True: 0, False: 17]
  ------------------
 7369|     14|	    if (cur->parent == NULL)
  ------------------
  |  Branch (7369:10): [True: 0, False: 14]
  ------------------
 7370|      0|		return(NULL);
 7371|     14|	    if ((cur->parent->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (7371:10): [True: 14, False: 0]
  ------------------
 7372|     14|		((cur->parent->name[0] == ' ') ||
  ------------------
  |  Branch (7372:4): [True: 0, False: 14]
  ------------------
 7373|     14|		 (xmlStrEqual(cur->parent->name,
  ------------------
  |  Branch (7373:4): [True: 0, False: 14]
  ------------------
 7374|     14|			      BAD_CAST "fake node libxslt"))))
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
 7375|      0|		return(NULL);
 7376|     14|	    return(cur->parent);
 7377|      3|	case XML_ATTRIBUTE_NODE: {
  ------------------
  |  Branch (7377:2): [True: 3, False: 14]
  ------------------
 7378|      3|	    xmlAttrPtr att = (xmlAttrPtr) cur;
 7379|       |
 7380|      3|	    return(att->parent);
 7381|     14|	}
 7382|      0|	case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (7382:2): [True: 0, False: 17]
  ------------------
 7383|      0|	    xmlNsPtr ns = (xmlNsPtr) cur;
 7384|       |
 7385|      0|	    if ((ns->next != NULL) &&
  ------------------
  |  Branch (7385:10): [True: 0, False: 0]
  ------------------
 7386|      0|	        (ns->next->type != XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7386:10): [True: 0, False: 0]
  ------------------
 7387|      0|	        return((xmlNodePtr) ns->next);
 7388|       |	    /* Bad, how did that namespace end up here ? */
 7389|      0|            return(NULL);
 7390|      0|	}
 7391|      0|	case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (7391:2): [True: 0, False: 17]
  ------------------
 7392|      0|	case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (7392:2): [True: 0, False: 17]
  ------------------
 7393|      0|	case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (7393:2): [True: 0, False: 17]
  ------------------
 7394|      0|	case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (7394:2): [True: 0, False: 17]
  ------------------
 7395|      0|	    return(NULL);
 7396|     17|    }
 7397|      0|    return(NULL);
 7398|     17|}
xmlXPathNextAncestorOrSelf:
 7414|     12|xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7415|     12|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7415:9): [True: 0, False: 12]
  |  Branch (7415:27): [True: 0, False: 12]
  ------------------
 7416|     12|    if (cur == NULL)
  ------------------
  |  Branch (7416:9): [True: 3, False: 9]
  ------------------
 7417|      3|        return(ctxt->context->node);
 7418|      9|    return(xmlXPathNextAncestor(ctxt, cur));
 7419|     12|}
xmlXPathNextFollowing:
 7489|     71|xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7490|     71|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7490:9): [True: 0, False: 71]
  |  Branch (7490:27): [True: 0, False: 71]
  ------------------
 7491|     71|    if ((cur != NULL) && (cur->type  != XML_ATTRIBUTE_NODE) &&
  ------------------
  |  Branch (7491:9): [True: 63, False: 8]
  |  Branch (7491:26): [True: 63, False: 0]
  ------------------
 7492|     71|        (cur->type != XML_NAMESPACE_DECL) && (cur->children != NULL))
  ------------------
  |  Branch (7492:9): [True: 63, False: 0]
  |  Branch (7492:46): [True: 19, False: 44]
  ------------------
 7493|     19|        return(cur->children);
 7494|       |
 7495|     52|    if (cur == NULL) {
  ------------------
  |  Branch (7495:9): [True: 8, False: 44]
  ------------------
 7496|      8|        cur = ctxt->context->node;
 7497|      8|        if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (7497:13): [True: 0, False: 8]
  ------------------
 7498|      0|            cur = cur->parent;
 7499|      8|        } else if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (7499:20): [True: 1, False: 7]
  ------------------
 7500|      1|            xmlNsPtr ns = (xmlNsPtr) cur;
 7501|       |
 7502|      1|            if ((ns->next == NULL) ||
  ------------------
  |  Branch (7502:17): [True: 0, False: 1]
  ------------------
 7503|      1|                (ns->next->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7503:17): [True: 0, False: 1]
  ------------------
 7504|      0|                return (NULL);
 7505|      1|            cur = (xmlNodePtr) ns->next;
 7506|      1|        }
 7507|      8|    }
 7508|     52|    if (cur == NULL) return(NULL) ; /* ERROR */
  ------------------
  |  Branch (7508:9): [True: 0, False: 52]
  ------------------
 7509|     52|    if (cur->next != NULL) return(cur->next) ;
  ------------------
  |  Branch (7509:9): [True: 24, False: 28]
  ------------------
 7510|     31|    do {
 7511|     31|        cur = cur->parent;
 7512|     31|        if (cur == NULL) break;
  ------------------
  |  Branch (7512:13): [True: 3, False: 28]
  ------------------
 7513|     28|        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);
  ------------------
  |  Branch (7513:13): [True: 5, False: 23]
  ------------------
 7514|     23|        if (cur->next != NULL) return(cur->next);
  ------------------
  |  Branch (7514:13): [True: 20, False: 3]
  ------------------
 7515|     23|    } while (cur != NULL);
  ------------------
  |  Branch (7515:14): [True: 3, False: 0]
  ------------------
 7516|      3|    return(cur);
 7517|     28|}
xmlXPathNextNamespace:
 7668|     24|xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7669|     24|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7669:9): [True: 0, False: 24]
  |  Branch (7669:27): [True: 0, False: 24]
  ------------------
 7670|     24|    if (ctxt->context->node->type != XML_ELEMENT_NODE) return(NULL);
  ------------------
  |  Branch (7670:9): [True: 0, False: 24]
  ------------------
 7671|     24|    if (cur == NULL) {
  ------------------
  |  Branch (7671:9): [True: 8, False: 16]
  ------------------
 7672|      8|        if (ctxt->context->tmpNsList != NULL)
  ------------------
  |  Branch (7672:13): [True: 0, False: 8]
  ------------------
 7673|      0|	    xmlFree(ctxt->context->tmpNsList);
 7674|      8|	ctxt->context->tmpNsList =
 7675|      8|	    xmlGetNsList(ctxt->context->doc, ctxt->context->node);
 7676|      8|	ctxt->context->tmpNsNr = 0;
 7677|      8|	if (ctxt->context->tmpNsList != NULL) {
  ------------------
  |  Branch (7677:6): [True: 8, False: 0]
  ------------------
 7678|     21|	    while (ctxt->context->tmpNsList[ctxt->context->tmpNsNr] != NULL) {
  ------------------
  |  Branch (7678:13): [True: 13, False: 8]
  ------------------
 7679|     13|		ctxt->context->tmpNsNr++;
 7680|     13|	    }
 7681|      8|	}
 7682|      8|	return((xmlNodePtr) xmlXPathXMLNamespace);
 7683|      8|    }
 7684|     16|    if (ctxt->context->tmpNsNr > 0) {
  ------------------
  |  Branch (7684:9): [True: 12, False: 4]
  ------------------
 7685|     12|	return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];
 7686|     12|    } else {
 7687|      4|	if (ctxt->context->tmpNsList != NULL)
  ------------------
  |  Branch (7687:6): [True: 4, False: 0]
  ------------------
 7688|      4|	    xmlFree(ctxt->context->tmpNsList);
 7689|      4|	ctxt->context->tmpNsList = NULL;
 7690|      4|	return(NULL);
 7691|      4|    }
 7692|     16|}
xmlXPathNextAttribute:
 7705|    347|xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 7706|    347|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7706:9): [True: 0, False: 347]
  |  Branch (7706:27): [True: 0, False: 347]
  ------------------
 7707|    347|    if (ctxt->context->node == NULL)
  ------------------
  |  Branch (7707:9): [True: 0, False: 347]
  ------------------
 7708|      0|	return(NULL);
 7709|    347|    if (ctxt->context->node->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (7709:9): [True: 0, False: 347]
  ------------------
 7710|      0|	return(NULL);
 7711|    347|    if (cur == NULL) {
  ------------------
  |  Branch (7711:9): [True: 234, False: 113]
  ------------------
 7712|    234|        if (ctxt->context->node == (xmlNodePtr) ctxt->context->doc)
  ------------------
  |  Branch (7712:13): [True: 0, False: 234]
  ------------------
 7713|      0|	    return(NULL);
 7714|    234|        return((xmlNodePtr)ctxt->context->node->properties);
 7715|    234|    }
 7716|    113|    return((xmlNodePtr)cur->next);
 7717|    347|}
xmlXPathRoot:
 7741|    138|xmlXPathRoot(xmlXPathParserContextPtr ctxt) {
 7742|    138|    if ((ctxt == NULL) || (ctxt->context == NULL))
  ------------------
  |  Branch (7742:9): [True: 0, False: 138]
  |  Branch (7742:27): [True: 0, False: 138]
  ------------------
 7743|      0|	return;
 7744|    138|    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,
 7745|    138|	(xmlNodePtr) ctxt->context->doc));
 7746|    138|}
xmlXPathLastFunction:
 7766|      6|xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 7767|     18|    CHECK_ARITY(0);
  ------------------
  |  |  298|      6|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  299|      6|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  300|      6|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      6|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  302|      6|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 7768|     18|    if (ctxt->context->contextSize >= 0) {
  ------------------
  |  Branch (7768:9): [True: 6, False: 0]
  ------------------
 7769|      6|	valuePush(ctxt,
 7770|      6|	    xmlXPathCacheNewFloat(ctxt->context,
 7771|      6|		(double) ctxt->context->contextSize));
 7772|      6|    } else {
 7773|      0|	XP_ERROR(XPATH_INVALID_CTXT_SIZE);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 7774|      0|    }
 7775|     18|}
xmlXPathPositionFunction:
 7789|     16|xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 7790|     48|    CHECK_ARITY(0);
  ------------------
  |  |  298|     16|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 16]
  |  |  ------------------
  |  |  299|     16|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 16]
  |  |  ------------------
  |  |  300|     16|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     16|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 16]
  |  |  ------------------
  |  |  302|     16|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 7791|     48|    if (ctxt->context->proximityPosition >= 0) {
  ------------------
  |  Branch (7791:9): [True: 16, False: 0]
  ------------------
 7792|     16|	valuePush(ctxt,
 7793|     16|	      xmlXPathCacheNewFloat(ctxt->context,
 7794|     16|		(double) ctxt->context->proximityPosition));
 7795|     16|    } else {
 7796|      0|	XP_ERROR(XPATH_INVALID_CTXT_POSITION);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 7797|      0|    }
 7798|     48|}
xmlXPathIdFunction:
 7904|     43|xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 7905|     43|    xmlChar *tokens;
 7906|     43|    xmlNodeSetPtr ret;
 7907|     43|    xmlXPathObjectPtr obj;
 7908|       |
 7909|    129|    CHECK_ARITY(1);
  ------------------
  |  |  298|     43|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 43]
  |  |  ------------------
  |  |  299|     43|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 43]
  |  |  ------------------
  |  |  300|     43|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     43|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 43]
  |  |  ------------------
  |  |  302|     43|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 7910|    129|    obj = valuePop(ctxt);
 7911|    129|    if (obj == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  |  Branch (7911:9): [True: 0, False: 43]
  ------------------
 7912|     43|    if ((obj->type == XPATH_NODESET) || (obj->type == XPATH_XSLT_TREE)) {
  ------------------
  |  Branch (7912:9): [True: 0, False: 43]
  |  Branch (7912:41): [True: 0, False: 43]
  ------------------
 7913|      0|	xmlNodeSetPtr ns;
 7914|      0|	int i;
 7915|       |
 7916|       |        /* TODO: Check memory error. */
 7917|      0|	ret = xmlXPathNodeSetCreate(NULL);
 7918|       |
 7919|      0|	if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (7919:6): [True: 0, False: 0]
  ------------------
 7920|      0|	    for (i = 0; i < obj->nodesetval->nodeNr; i++) {
  ------------------
  |  Branch (7920:18): [True: 0, False: 0]
  ------------------
 7921|      0|		tokens =
 7922|      0|		    xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);
 7923|      0|		ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);
 7924|       |                /* TODO: Check memory error. */
 7925|      0|		ret = xmlXPathNodeSetMerge(ret, ns);
 7926|      0|		xmlXPathFreeNodeSet(ns);
 7927|      0|		if (tokens != NULL)
  ------------------
  |  Branch (7927:7): [True: 0, False: 0]
  ------------------
 7928|      0|		    xmlFree(tokens);
 7929|      0|	    }
 7930|      0|	}
 7931|      0|	xmlXPathReleaseObject(ctxt->context, obj);
 7932|      0|	valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));
 7933|      0|	return;
 7934|      0|    }
 7935|     43|    obj = xmlXPathCacheConvertString(ctxt->context, obj);
 7936|     43|    if (obj == NULL) return;
  ------------------
  |  Branch (7936:9): [True: 0, False: 43]
  ------------------
 7937|     43|    ret = xmlXPathGetElementsByIds(ctxt->context->doc, obj->stringval);
 7938|     43|    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));
 7939|     43|    xmlXPathReleaseObject(ctxt->context, obj);
 7940|     43|    return;
 7941|     43|}
xmlXPathStringFunction:
 8170|      7|xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8171|      7|    xmlXPathObjectPtr cur;
 8172|       |
 8173|      7|    if (ctxt == NULL) return;
  ------------------
  |  Branch (8173:9): [True: 0, False: 7]
  ------------------
 8174|      7|    if (nargs == 0) {
  ------------------
  |  Branch (8174:9): [True: 0, False: 7]
  ------------------
 8175|      0|    valuePush(ctxt,
 8176|      0|	xmlXPathCacheWrapString(ctxt->context,
 8177|      0|	    xmlXPathCastNodeToString(ctxt->context->node)));
 8178|      0|	return;
 8179|      0|    }
 8180|       |
 8181|     28|    CHECK_ARITY(1);
  ------------------
  |  |  298|      7|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 7]
  |  |  ------------------
  |  |  299|      7|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 7]
  |  |  ------------------
  |  |  300|      7|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      7|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 7]
  |  |  ------------------
  |  |  302|      7|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8182|     28|    cur = valuePop(ctxt);
 8183|     28|    if (cur == NULL) XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  |  Branch (8183:9): [True: 0, False: 7]
  ------------------
 8184|      7|    valuePush(ctxt, xmlXPathCacheConvertString(ctxt->context, cur));
 8185|      7|}
xmlXPathStringLengthFunction:
 8200|      2|xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8201|      2|    xmlXPathObjectPtr cur;
 8202|       |
 8203|      2|    if (nargs == 0) {
  ------------------
  |  Branch (8203:9): [True: 0, False: 2]
  ------------------
 8204|      0|        if ((ctxt == NULL) || (ctxt->context == NULL))
  ------------------
  |  Branch (8204:13): [True: 0, False: 0]
  |  Branch (8204:31): [True: 0, False: 0]
  ------------------
 8205|      0|	    return;
 8206|      0|	if (ctxt->context->node == NULL) {
  ------------------
  |  Branch (8206:6): [True: 0, False: 0]
  ------------------
 8207|      0|	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0));
 8208|      0|	} else {
 8209|      0|	    xmlChar *content;
 8210|       |
 8211|      0|	    content = xmlXPathCastNodeToString(ctxt->context->node);
 8212|      0|	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,
 8213|      0|		xmlUTF8Strlen(content)));
 8214|      0|	    xmlFree(content);
 8215|      0|	}
 8216|      0|	return;
 8217|      0|    }
 8218|      8|    CHECK_ARITY(1);
  ------------------
  |  |  298|      2|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  299|      2|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  300|      2|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      2|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  302|      2|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8219|      8|    CAST_TO_STRING;
  ------------------
  |  |  310|      2|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 2, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 2]
  |  |  ------------------
  |  |  311|      2|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8220|      8|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|      2|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 2]
  |  |  |  Branch (277:34): [True: 0, False: 2]
  |  |  ------------------
  |  |  278|      2|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8221|      2|    cur = valuePop(ctxt);
 8222|      2|    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,
 8223|      2|	xmlUTF8Strlen(cur->stringval)));
 8224|      2|    xmlXPathReleaseObject(ctxt->context, cur);
 8225|      2|}
xmlXPathConcatFunction:
 8237|      4|xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8238|      4|    xmlXPathObjectPtr cur, newobj;
 8239|      4|    xmlChar *tmp;
 8240|       |
 8241|      4|    if (ctxt == NULL) return;
  ------------------
  |  Branch (8241:9): [True: 0, False: 4]
  ------------------
 8242|      4|    if (nargs < 2) {
  ------------------
  |  Branch (8242:9): [True: 0, False: 4]
  ------------------
 8243|      0|	CHECK_ARITY(2);
  ------------------
  |  |  298|      0|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  299|      0|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  300|      0|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      0|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  302|      0|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8244|      0|    }
 8245|       |
 8246|      4|    CAST_TO_STRING;
  ------------------
  |  |  310|      4|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 4, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  311|      4|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8247|      4|    cur = valuePop(ctxt);
 8248|      4|    if ((cur == NULL) || (cur->type != XPATH_STRING)) {
  ------------------
  |  Branch (8248:9): [True: 0, False: 4]
  |  Branch (8248:26): [True: 0, False: 4]
  ------------------
 8249|      0|	xmlXPathReleaseObject(ctxt->context, cur);
 8250|      0|	return;
 8251|      0|    }
 8252|      4|    nargs--;
 8253|       |
 8254|     11|    while (nargs > 0) {
  ------------------
  |  Branch (8254:12): [True: 7, False: 4]
  ------------------
 8255|      7|	CAST_TO_STRING;
  ------------------
  |  |  310|      7|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 7, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 7]
  |  |  ------------------
  |  |  311|      7|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8256|      7|	newobj = valuePop(ctxt);
 8257|      7|	if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {
  ------------------
  |  Branch (8257:6): [True: 0, False: 7]
  |  Branch (8257:26): [True: 0, False: 7]
  ------------------
 8258|      0|	    xmlXPathReleaseObject(ctxt->context, newobj);
 8259|      0|	    xmlXPathReleaseObject(ctxt->context, cur);
 8260|      0|	    XP_ERROR(XPATH_INVALID_TYPE);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 8261|      0|	}
 8262|      7|	tmp = xmlStrcat(newobj->stringval, cur->stringval);
 8263|      7|	newobj->stringval = cur->stringval;
 8264|      7|	cur->stringval = tmp;
 8265|      7|	xmlXPathReleaseObject(ctxt->context, newobj);
 8266|      7|	nargs--;
 8267|      7|    }
 8268|      4|    valuePush(ctxt, cur);
 8269|      4|}
xmlXPathContainsFunction:
 8282|      4|xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8283|      4|    xmlXPathObjectPtr hay, needle;
 8284|       |
 8285|     12|    CHECK_ARITY(2);
  ------------------
  |  |  298|      4|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 4]
  |  |  ------------------
  |  |  299|      4|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 4]
  |  |  ------------------
  |  |  300|      4|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      4|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 4]
  |  |  ------------------
  |  |  302|      4|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8286|     12|    CAST_TO_STRING;
  ------------------
  |  |  310|      4|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 4, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  311|      4|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8287|     12|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|      4|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 4]
  |  |  |  Branch (277:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  278|      4|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8288|      4|    needle = valuePop(ctxt);
 8289|      4|    CAST_TO_STRING;
  ------------------
  |  |  310|      4|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 4, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  311|      4|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8290|      4|    hay = valuePop(ctxt);
 8291|       |
 8292|      4|    if ((hay == NULL) || (hay->type != XPATH_STRING)) {
  ------------------
  |  Branch (8292:9): [True: 0, False: 4]
  |  Branch (8292:26): [True: 0, False: 4]
  ------------------
 8293|      0|	xmlXPathReleaseObject(ctxt->context, hay);
 8294|      0|	xmlXPathReleaseObject(ctxt->context, needle);
 8295|      0|	XP_ERROR(XPATH_INVALID_TYPE);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 8296|      0|    }
 8297|      4|    if (xmlStrstr(hay->stringval, needle->stringval))
  ------------------
  |  Branch (8297:9): [True: 3, False: 1]
  ------------------
 8298|      3|	valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));
 8299|      1|    else
 8300|      1|	valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));
 8301|      4|    xmlXPathReleaseObject(ctxt->context, hay);
 8302|      4|    xmlXPathReleaseObject(ctxt->context, needle);
 8303|      4|}
xmlXPathStartsWithFunction:
 8316|      2|xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8317|      2|    xmlXPathObjectPtr hay, needle;
 8318|      2|    int n;
 8319|       |
 8320|      6|    CHECK_ARITY(2);
  ------------------
  |  |  298|      2|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  299|      2|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  300|      2|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      2|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 2]
  |  |  ------------------
  |  |  302|      2|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8321|      6|    CAST_TO_STRING;
  ------------------
  |  |  310|      2|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 2, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 2]
  |  |  ------------------
  |  |  311|      2|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8322|      6|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|      2|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 2]
  |  |  |  Branch (277:34): [True: 0, False: 2]
  |  |  ------------------
  |  |  278|      2|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8323|      2|    needle = valuePop(ctxt);
 8324|      2|    CAST_TO_STRING;
  ------------------
  |  |  310|      2|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 2, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 2]
  |  |  ------------------
  |  |  311|      2|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8325|      2|    hay = valuePop(ctxt);
 8326|       |
 8327|      2|    if ((hay == NULL) || (hay->type != XPATH_STRING)) {
  ------------------
  |  Branch (8327:9): [True: 0, False: 2]
  |  Branch (8327:26): [True: 0, False: 2]
  ------------------
 8328|      0|	xmlXPathReleaseObject(ctxt->context, hay);
 8329|      0|	xmlXPathReleaseObject(ctxt->context, needle);
 8330|      0|	XP_ERROR(XPATH_INVALID_TYPE);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 8331|      0|    }
 8332|      2|    n = xmlStrlen(needle->stringval);
 8333|      2|    if (xmlStrncmp(hay->stringval, needle->stringval, n))
  ------------------
  |  Branch (8333:9): [True: 1, False: 1]
  ------------------
 8334|      1|        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));
 8335|      1|    else
 8336|      1|        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));
 8337|      2|    xmlXPathReleaseObject(ctxt->context, hay);
 8338|      2|    xmlXPathReleaseObject(ctxt->context, needle);
 8339|      2|}
xmlXPathSubstringFunction:
 8370|     20|xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8371|     20|    xmlXPathObjectPtr str, start, len;
 8372|     20|    double le=0, in;
 8373|     20|    int i = 1, j = INT_MAX;
 8374|       |
 8375|     20|    if (nargs < 2) {
  ------------------
  |  Branch (8375:9): [True: 0, False: 20]
  ------------------
 8376|      0|	CHECK_ARITY(2);
  ------------------
  |  |  298|      0|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  299|      0|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  300|      0|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      0|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  302|      0|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8377|      0|    }
 8378|     20|    if (nargs > 3) {
  ------------------
  |  Branch (8378:9): [True: 0, False: 20]
  ------------------
 8379|      0|	CHECK_ARITY(3);
  ------------------
  |  |  298|      0|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  299|      0|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  300|      0|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      0|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 0]
  |  |  ------------------
  |  |  302|      0|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8380|      0|    }
 8381|       |    /*
 8382|       |     * take care of possible last (position) argument
 8383|       |    */
 8384|     20|    if (nargs == 3) {
  ------------------
  |  Branch (8384:9): [True: 15, False: 5]
  ------------------
 8385|     15|	CAST_TO_NUMBER;
  ------------------
  |  |  319|     15|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 15, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  320|     15|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 8386|     15|	CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     15|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 15]
  |  |  |  Branch (277:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  278|     15|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8387|     15|	len = valuePop(ctxt);
 8388|     15|	le = len->floatval;
 8389|     15|	xmlXPathReleaseObject(ctxt->context, len);
 8390|     15|    }
 8391|       |
 8392|     20|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     20|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 20, False: 0]
  |  |  |  Branch (319:34): [True: 1, False: 19]
  |  |  ------------------
  |  |  320|     20|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 8393|     20|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     20|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 20]
  |  |  |  Branch (277:34): [True: 0, False: 20]
  |  |  ------------------
  |  |  278|     20|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8394|     20|    start = valuePop(ctxt);
 8395|     20|    in = start->floatval;
 8396|     20|    xmlXPathReleaseObject(ctxt->context, start);
 8397|     20|    CAST_TO_STRING;
  ------------------
  |  |  310|     20|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 20, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 20]
  |  |  ------------------
  |  |  311|     20|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8398|     20|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|     20|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 20]
  |  |  |  Branch (277:34): [True: 0, False: 20]
  |  |  ------------------
  |  |  278|     20|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8399|     20|    str = valuePop(ctxt);
 8400|       |
 8401|     20|    if (!(in < INT_MAX)) { /* Logical NOT to handle NaNs */
  ------------------
  |  Branch (8401:9): [True: 2, False: 18]
  ------------------
 8402|      2|        i = INT_MAX;
 8403|     18|    } else if (in >= 1.0) {
  ------------------
  |  Branch (8403:16): [True: 9, False: 9]
  ------------------
 8404|      9|        i = (int)in;
 8405|      9|        if (in - floor(in) >= 0.5)
  ------------------
  |  Branch (8405:13): [True: 2, False: 7]
  ------------------
 8406|      2|            i += 1;
 8407|      9|    }
 8408|       |
 8409|     20|    if (nargs == 3) {
  ------------------
  |  Branch (8409:9): [True: 15, False: 5]
  ------------------
 8410|     15|        double rin, rle, end;
 8411|       |
 8412|     15|        rin = floor(in);
 8413|     15|        if (in - rin >= 0.5)
  ------------------
  |  Branch (8413:13): [True: 1, False: 14]
  ------------------
 8414|      1|            rin += 1.0;
 8415|       |
 8416|     15|        rle = floor(le);
 8417|     15|        if (le - rle >= 0.5)
  ------------------
  |  Branch (8417:13): [True: 1, False: 14]
  ------------------
 8418|      1|            rle += 1.0;
 8419|       |
 8420|     15|        end = rin + rle;
 8421|     15|        if (!(end >= 1.0)) { /* Logical NOT to handle NaNs */
  ------------------
  |  Branch (8421:13): [True: 6, False: 9]
  ------------------
 8422|      6|            j = 1;
 8423|      9|        } else if (end < INT_MAX) {
  ------------------
  |  Branch (8423:20): [True: 7, False: 2]
  ------------------
 8424|      7|            j = (int)end;
 8425|      7|        }
 8426|     15|    }
 8427|       |
 8428|     20|    if (i < j) {
  ------------------
  |  Branch (8428:9): [True: 13, False: 7]
  ------------------
 8429|     13|        xmlChar *ret = xmlUTF8Strsub(str->stringval, i - 1, j - i);
 8430|     13|	valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, ret));
 8431|     13|	xmlFree(ret);
 8432|     13|    } else {
 8433|      7|	valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, ""));
 8434|      7|    }
 8435|       |
 8436|     20|    xmlXPathReleaseObject(ctxt->context, str);
 8437|     20|}
xmlXPathNormalizeFunction:
 8540|      6|xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8541|      6|    xmlChar *source, *target;
 8542|      6|    int blank;
 8543|       |
 8544|      6|    if (ctxt == NULL) return;
  ------------------
  |  Branch (8544:9): [True: 0, False: 6]
  ------------------
 8545|      6|    if (nargs == 0) {
  ------------------
  |  Branch (8545:9): [True: 0, False: 6]
  ------------------
 8546|       |        /* Use current context node */
 8547|      0|        valuePush(ctxt,
 8548|      0|            xmlXPathCacheWrapString(ctxt->context,
 8549|      0|                xmlXPathCastNodeToString(ctxt->context->node)));
 8550|      0|        nargs = 1;
 8551|      0|    }
 8552|       |
 8553|     18|    CHECK_ARITY(1);
  ------------------
  |  |  298|      6|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  299|      6|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  300|      6|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|      6|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 6]
  |  |  ------------------
  |  |  302|      6|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8554|     18|    CAST_TO_STRING;
  ------------------
  |  |  310|      6|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 6, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 6]
  |  |  ------------------
  |  |  311|      6|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8555|     18|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|      6|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 6]
  |  |  |  Branch (277:34): [True: 0, False: 6]
  |  |  ------------------
  |  |  278|      6|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8556|      6|    source = ctxt->value->stringval;
 8557|      6|    if (source == NULL)
  ------------------
  |  Branch (8557:9): [True: 0, False: 6]
  ------------------
 8558|      0|        return;
 8559|      6|    target = source;
 8560|       |
 8561|       |    /* Skip leading whitespaces */
 8562|      6|    while (IS_BLANK_CH(*source))
 8563|      8|        source++;
 8564|       |
 8565|       |    /* Collapse intermediate whitespaces, and skip trailing whitespaces */
 8566|      6|    blank = 0;
 8567|     56|    while (*source) {
  ------------------
  |  Branch (8567:12): [True: 50, False: 6]
  ------------------
 8568|     50|        if (IS_BLANK_CH(*source)) {
  ------------------
  |  |  151|     50|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|     50|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 14, False: 36]
  |  |  |  |  ------------------
  |  |  |  |   89|     50|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 36, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 36]
  |  |  |  |  ------------------
  |  |  |  |   90|     50|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 36]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 8569|     14|	    blank = 1;
 8570|     36|        } else {
 8571|     36|            if (blank) {
  ------------------
  |  Branch (8571:17): [True: 3, False: 33]
  ------------------
 8572|      3|                *target++ = 0x20;
 8573|      3|                blank = 0;
 8574|      3|            }
 8575|     36|            *target++ = *source;
 8576|     36|        }
 8577|     50|        source++;
 8578|     50|    }
 8579|      6|    *target = 0;
 8580|      6|}
xmlXPathTrueFunction:
 8719|     33|xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8720|     99|    CHECK_ARITY(0);
  ------------------
  |  |  298|     33|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 33]
  |  |  ------------------
  |  |  299|     33|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 33]
  |  |  ------------------
  |  |  300|     33|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     33|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 33]
  |  |  ------------------
  |  |  302|     33|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8721|     99|    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));
 8722|     99|}
xmlXPathFalseFunction:
 8733|    129|xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8734|    387|    CHECK_ARITY(0);
  ------------------
  |  |  298|    129|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 129]
  |  |  ------------------
  |  |  299|    129|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 129]
  |  |  ------------------
  |  |  300|    129|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|    129|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 129]
  |  |  ------------------
  |  |  302|    129|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8735|    387|    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));
 8736|    387|}
xmlXPathLangFunction:
 8760|     76|xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8761|     76|    xmlXPathObjectPtr val = NULL;
 8762|     76|    const xmlChar *theLang = NULL;
 8763|     76|    const xmlChar *lang;
 8764|     76|    int ret = 0;
 8765|     76|    int i;
 8766|       |
 8767|    228|    CHECK_ARITY(1);
  ------------------
  |  |  298|     76|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 76]
  |  |  ------------------
  |  |  299|     76|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 76]
  |  |  ------------------
  |  |  300|     76|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     76|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 76]
  |  |  ------------------
  |  |  302|     76|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8768|    228|    CAST_TO_STRING;
  ------------------
  |  |  310|     76|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
  |  |  ------------------
  |  |  |  Branch (310:9): [True: 76, False: 0]
  |  |  |  Branch (310:34): [True: 0, False: 76]
  |  |  ------------------
  |  |  311|     76|        xmlXPathStringFunction(ctxt, 1);
  ------------------
 8769|    228|    CHECK_TYPE(XPATH_STRING);
  ------------------
  |  |  277|     76|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 76]
  |  |  |  Branch (277:34): [True: 0, False: 76]
  |  |  ------------------
  |  |  278|     76|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8770|     76|    val = valuePop(ctxt);
 8771|     76|    lang = val->stringval;
 8772|     76|    theLang = xmlNodeGetLang(ctxt->context->node);
 8773|     76|    if ((theLang != NULL) && (lang != NULL)) {
  ------------------
  |  Branch (8773:9): [True: 55, False: 21]
  |  Branch (8773:30): [True: 55, False: 0]
  ------------------
 8774|    117|        for (i = 0;lang[i] != 0;i++)
  ------------------
  |  Branch (8774:20): [True: 95, False: 22]
  ------------------
 8775|     95|	    if (toupper(lang[i]) != toupper(theLang[i]))
  ------------------
  |  Branch (8775:10): [True: 33, False: 62]
  ------------------
 8776|     33|	        goto not_equal;
 8777|     22|	if ((theLang[i] == 0) || (theLang[i] == '-'))
  ------------------
  |  Branch (8777:6): [True: 9, False: 13]
  |  Branch (8777:27): [True: 2, False: 11]
  ------------------
 8778|     11|	    ret = 1;
 8779|     22|    }
 8780|     76|not_equal:
 8781|     76|    if (theLang != NULL)
  ------------------
  |  Branch (8781:9): [True: 55, False: 21]
  ------------------
 8782|     55|	xmlFree((void *)theLang);
 8783|       |
 8784|     76|    xmlXPathReleaseObject(ctxt->context, val);
 8785|     76|    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));
 8786|     76|}
xmlXPathNumberFunction:
 8797|     57|xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8798|     57|    xmlXPathObjectPtr cur;
 8799|     57|    double res;
 8800|       |
 8801|     57|    if (ctxt == NULL) return;
  ------------------
  |  Branch (8801:9): [True: 0, False: 57]
  ------------------
 8802|     57|    if (nargs == 0) {
  ------------------
  |  Branch (8802:9): [True: 0, False: 57]
  ------------------
 8803|      0|	if (ctxt->context->node == NULL) {
  ------------------
  |  Branch (8803:6): [True: 0, False: 0]
  ------------------
 8804|      0|	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0.0));
 8805|      0|	} else {
 8806|      0|	    xmlChar* content = xmlNodeGetContent(ctxt->context->node);
 8807|       |
 8808|      0|	    res = xmlXPathStringEvalNumber(content);
 8809|      0|	    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));
 8810|      0|	    xmlFree(content);
 8811|      0|	}
 8812|      0|	return;
 8813|      0|    }
 8814|       |
 8815|    228|    CHECK_ARITY(1);
  ------------------
  |  |  298|     57|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 57]
  |  |  ------------------
  |  |  299|     57|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 57]
  |  |  ------------------
  |  |  300|     57|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     57|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 57]
  |  |  ------------------
  |  |  302|     57|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8816|    228|    cur = valuePop(ctxt);
 8817|    228|    valuePush(ctxt, xmlXPathCacheConvertNumber(ctxt->context, cur));
 8818|    228|}
xmlXPathFloorFunction:
 8863|     15|xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8864|     45|    CHECK_ARITY(1);
  ------------------
  |  |  298|     15|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  299|     15|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  300|     15|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     15|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  302|     15|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8865|     45|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     15|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 15, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  320|     15|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 8866|     45|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     15|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 15]
  |  |  |  Branch (277:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  278|     15|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8867|       |
 8868|     15|    ctxt->value->floatval = floor(ctxt->value->floatval);
 8869|     15|}
xmlXPathCeilingFunction:
 8882|     15|xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8883|     45|    CHECK_ARITY(1);
  ------------------
  |  |  298|     15|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  299|     15|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  300|     15|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     15|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 15]
  |  |  ------------------
  |  |  302|     15|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8884|     45|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     15|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 15, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  320|     15|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 8885|     45|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     15|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 15]
  |  |  |  Branch (277:34): [True: 0, False: 15]
  |  |  ------------------
  |  |  278|     15|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8886|       |
 8887|       |#ifdef _AIX
 8888|       |    /* Work around buggy ceil() function on AIX */
 8889|       |    ctxt->value->floatval = copysign(ceil(ctxt->value->floatval), ctxt->value->floatval);
 8890|       |#else
 8891|     15|    ctxt->value->floatval = ceil(ctxt->value->floatval);
 8892|     15|#endif
 8893|     15|}
xmlXPathRoundFunction:
 8907|     19|xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs) {
 8908|     19|    double f;
 8909|       |
 8910|     57|    CHECK_ARITY(1);
  ------------------
  |  |  298|     19|    if (ctxt == NULL) return;						\
  |  |  ------------------
  |  |  |  Branch (298:9): [True: 0, False: 19]
  |  |  ------------------
  |  |  299|     19|    if (nargs != (x))							\
  |  |  ------------------
  |  |  |  Branch (299:9): [True: 0, False: 19]
  |  |  ------------------
  |  |  300|     19|        XP_ERROR(XPATH_INVALID_ARITY);					\
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  |  |  301|     19|    if (ctxt->valueNr < (x))						\
  |  |  ------------------
  |  |  |  Branch (301:9): [True: 0, False: 19]
  |  |  ------------------
  |  |  302|     19|        XP_ERROR(XPATH_STACK_ERROR);
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8911|     57|    CAST_TO_NUMBER;
  ------------------
  |  |  319|     19|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 19, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 19]
  |  |  ------------------
  |  |  320|     19|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
 8912|     57|    CHECK_TYPE(XPATH_NUMBER);
  ------------------
  |  |  277|     19|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 19]
  |  |  |  Branch (277:34): [True: 0, False: 19]
  |  |  ------------------
  |  |  278|     19|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
 8913|       |
 8914|     19|    f = ctxt->value->floatval;
 8915|       |
 8916|     19|    if ((f >= -0.5) && (f < 0.5)) {
  ------------------
  |  Branch (8916:9): [True: 13, False: 6]
  |  Branch (8916:24): [True: 7, False: 6]
  ------------------
 8917|       |        /* Handles negative zero. */
 8918|      7|        ctxt->value->floatval *= 0.0;
 8919|      7|    }
 8920|     12|    else {
 8921|     12|        double rounded = floor(f);
 8922|     12|        if (f - rounded >= 0.5)
  ------------------
  |  Branch (8922:13): [True: 5, False: 7]
  ------------------
 8923|      5|            rounded += 1.0;
 8924|     12|        ctxt->value->floatval = rounded;
 8925|     12|    }
 8926|     19|}
xmlXPathParseNCName:
 9045|    571|xmlXPathParseNCName(xmlXPathParserContextPtr ctxt) {
 9046|    571|    const xmlChar *in;
 9047|    571|    xmlChar *ret;
 9048|    571|    int count = 0;
 9049|       |
 9050|    571|    if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);
  ------------------
  |  Branch (9050:9): [True: 0, False: 571]
  |  Branch (9050:27): [True: 0, False: 571]
  ------------------
 9051|       |    /*
 9052|       |     * Accelerator for simple ASCII names
 9053|       |     */
 9054|    571|    in = ctxt->cur;
 9055|    571|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9055:10): [True: 525, False: 46]
  |  Branch (9055:27): [True: 524, False: 1]
  ------------------
 9056|    571|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9056:3): [True: 34, False: 13]
  |  Branch (9056:20): [True: 33, False: 1]
  ------------------
 9057|    571|	(*in == '_')) {
  ------------------
  |  Branch (9057:2): [True: 0, False: 14]
  ------------------
 9058|    557|	in++;
 9059|  3.23k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9059:10): [True: 2.39k, False: 840]
  |  Branch (9059:27): [True: 2.38k, False: 8]
  ------------------
 9060|  3.23k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9060:10): [True: 243, False: 605]
  |  Branch (9060:27): [True: 199, False: 44]
  ------------------
 9061|  3.23k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (9061:10): [True: 190, False: 459]
  |  Branch (9061:27): [True: 18, False: 172]
  ------------------
 9062|  3.23k|	       (*in == '_') || (*in == '.') ||
  ------------------
  |  Branch (9062:9): [True: 0, False: 631]
  |  Branch (9062:25): [True: 0, False: 631]
  ------------------
 9063|  3.23k|	       (*in == '-'))
  ------------------
  |  Branch (9063:9): [True: 74, False: 557]
  ------------------
 9064|  2.67k|	    in++;
 9065|    557|	if ((*in == ' ') || (*in == '>') || (*in == '/') ||
  ------------------
  |  Branch (9065:6): [True: 2, False: 555]
  |  Branch (9065:22): [True: 0, False: 555]
  |  Branch (9065:38): [True: 79, False: 476]
  ------------------
 9066|    557|            (*in == '[') || (*in == ']') || (*in == ':') ||
  ------------------
  |  Branch (9066:13): [True: 35, False: 441]
  |  Branch (9066:29): [True: 1, False: 440]
  |  Branch (9066:45): [True: 110, False: 330]
  ------------------
 9067|    557|            (*in == '@') || (*in == '*')) {
  ------------------
  |  Branch (9067:13): [True: 0, False: 330]
  |  Branch (9067:29): [True: 0, False: 330]
  ------------------
 9068|    227|	    count = in - ctxt->cur;
 9069|    227|	    if (count == 0)
  ------------------
  |  Branch (9069:10): [True: 0, False: 227]
  ------------------
 9070|      0|		return(NULL);
 9071|    227|	    ret = xmlStrndup(ctxt->cur, count);
 9072|    227|	    ctxt->cur = in;
 9073|    227|	    return(ret);
 9074|    227|	}
 9075|    557|    }
 9076|    344|    return(xmlXPathParseNameComplex(ctxt, 0));
 9077|    571|}
xmlXPathParseName:
 9126|    788|xmlXPathParseName(xmlXPathParserContextPtr ctxt) {
 9127|    788|    const xmlChar *in;
 9128|    788|    xmlChar *ret;
 9129|    788|    size_t count = 0;
 9130|       |
 9131|    788|    if ((ctxt == NULL) || (ctxt->cur == NULL)) return(NULL);
  ------------------
  |  Branch (9131:9): [True: 0, False: 788]
  |  Branch (9131:27): [True: 0, False: 788]
  ------------------
 9132|       |    /*
 9133|       |     * Accelerator for simple ASCII names
 9134|       |     */
 9135|    788|    in = ctxt->cur;
 9136|    788|    if (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9136:10): [True: 492, False: 296]
  |  Branch (9136:27): [True: 491, False: 1]
  ------------------
 9137|    788|	((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9137:3): [True: 1, False: 296]
  |  Branch (9137:20): [True: 0, False: 1]
  ------------------
 9138|    788|	(*in == '_') || (*in == ':')) {
  ------------------
  |  Branch (9138:2): [True: 0, False: 297]
  |  Branch (9138:18): [True: 0, False: 297]
  ------------------
 9139|    491|	in++;
 9140|  3.81k|	while (((*in >= 0x61) && (*in <= 0x7A)) ||
  ------------------
  |  Branch (9140:10): [True: 3.29k, False: 523]
  |  Branch (9140:27): [True: 3.28k, False: 2]
  ------------------
 9141|  3.81k|	       ((*in >= 0x41) && (*in <= 0x5A)) ||
  ------------------
  |  Branch (9141:10): [True: 3, False: 522]
  |  Branch (9141:27): [True: 1, False: 2]
  ------------------
 9142|  3.81k|	       ((*in >= 0x30) && (*in <= 0x39)) ||
  ------------------
  |  Branch (9142:10): [True: 36, False: 488]
  |  Branch (9142:27): [True: 29, False: 7]
  ------------------
 9143|  3.81k|	       (*in == '_') || (*in == '-') ||
  ------------------
  |  Branch (9143:9): [True: 0, False: 495]
  |  Branch (9143:25): [True: 0, False: 495]
  ------------------
 9144|  3.81k|	       (*in == ':') || (*in == '.'))
  ------------------
  |  Branch (9144:9): [True: 4, False: 491]
  |  Branch (9144:25): [True: 0, False: 491]
  ------------------
 9145|  3.32k|	    in++;
 9146|    491|	if ((*in > 0) && (*in < 0x80)) {
  ------------------
  |  Branch (9146:6): [True: 484, False: 7]
  |  Branch (9146:19): [True: 482, False: 2]
  ------------------
 9147|    482|	    count = in - ctxt->cur;
 9148|    482|            if (count > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|    482|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9148:17): [True: 0, False: 482]
  ------------------
 9149|      0|                ctxt->cur = in;
 9150|      0|                XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9151|      0|            }
 9152|    482|	    ret = xmlStrndup(ctxt->cur, count);
 9153|    482|	    ctxt->cur = in;
 9154|    482|	    return(ret);
 9155|    482|	}
 9156|    491|    }
 9157|    306|    return(xmlXPathParseNameComplex(ctxt, 1));
 9158|    788|}
xmlXPathStringEvalNumber:
 9254|     52|xmlXPathStringEvalNumber(const xmlChar *str) {
 9255|     52|    const xmlChar *cur = str;
 9256|     52|    double ret;
 9257|     52|    int ok = 0;
 9258|     52|    int isneg = 0;
 9259|     52|    int exponent = 0;
 9260|     52|    int is_exponent_negative = 0;
 9261|     52|#ifdef __GNUC__
 9262|     52|    unsigned long tmp = 0;
 9263|     52|    double temp;
 9264|     52|#endif
 9265|     52|    if (cur == NULL) return(0);
  ------------------
  |  Branch (9265:9): [True: 0, False: 52]
  ------------------
 9266|     52|    while (IS_BLANK_CH(*cur)) cur++;
 9267|     52|    if (*cur == '-') {
  ------------------
  |  Branch (9267:9): [True: 5, False: 47]
  ------------------
 9268|      5|	isneg = 1;
 9269|      5|	cur++;
 9270|      5|    }
 9271|     52|    if ((*cur != '.') && ((*cur < '0') || (*cur > '9'))) {
  ------------------
  |  Branch (9271:9): [True: 52, False: 0]
  |  Branch (9271:27): [True: 2, False: 50]
  |  Branch (9271:43): [True: 35, False: 15]
  ------------------
 9272|     37|        return(xmlXPathNAN);
 9273|     37|    }
 9274|       |
 9275|     15|#ifdef __GNUC__
 9276|       |    /*
 9277|       |     * tmp/temp is a workaround against a gcc compiler bug
 9278|       |     * http://veillard.com/gcc.bug
 9279|       |     */
 9280|     15|    ret = 0;
 9281|     30|    while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (9281:12): [True: 15, False: 15]
  |  Branch (9281:29): [True: 15, False: 0]
  ------------------
 9282|     15|	ret = ret * 10;
 9283|     15|	tmp = (*cur - '0');
 9284|     15|	ok = 1;
 9285|     15|	cur++;
 9286|     15|	temp = (double) tmp;
 9287|     15|	ret = ret + temp;
 9288|     15|    }
 9289|       |#else
 9290|       |    ret = 0;
 9291|       |    while ((*cur >= '0') && (*cur <= '9')) {
 9292|       |	ret = ret * 10 + (*cur - '0');
 9293|       |	ok = 1;
 9294|       |	cur++;
 9295|       |    }
 9296|       |#endif
 9297|       |
 9298|     15|    if (*cur == '.') {
  ------------------
  |  Branch (9298:9): [True: 11, False: 4]
  ------------------
 9299|     11|	int v, frac = 0, max;
 9300|     11|	double fraction = 0;
 9301|       |
 9302|     11|        cur++;
 9303|     11|	if (((*cur < '0') || (*cur > '9')) && (!ok)) {
  ------------------
  |  Branch (9303:7): [True: 0, False: 11]
  |  Branch (9303:23): [True: 0, False: 11]
  |  Branch (9303:40): [True: 0, False: 0]
  ------------------
 9304|      0|	    return(xmlXPathNAN);
 9305|      0|	}
 9306|     13|        while (*cur == '0') {
  ------------------
  |  Branch (9306:16): [True: 2, False: 11]
  ------------------
 9307|      2|	    frac = frac + 1;
 9308|      2|	    cur++;
 9309|      2|        }
 9310|     11|        max = frac + MAX_FRAC;
  ------------------
  |  | 9235|     11|#define MAX_FRAC 20
  ------------------
 9311|     20|	while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {
  ------------------
  |  Branch (9311:10): [True: 9, False: 11]
  |  Branch (9311:27): [True: 9, False: 0]
  |  Branch (9311:45): [True: 9, False: 0]
  ------------------
 9312|      9|	    v = (*cur - '0');
 9313|      9|	    fraction = fraction * 10 + v;
 9314|      9|	    frac = frac + 1;
 9315|      9|	    cur++;
 9316|      9|	}
 9317|     11|	fraction /= pow(10.0, frac);
 9318|     11|	ret = ret + fraction;
 9319|     11|	while ((*cur >= '0') && (*cur <= '9'))
  ------------------
  |  Branch (9319:9): [True: 0, False: 11]
  |  Branch (9319:26): [True: 0, False: 0]
  ------------------
 9320|      0|	    cur++;
 9321|     11|    }
 9322|     15|    if ((*cur == 'e') || (*cur == 'E')) {
  ------------------
  |  Branch (9322:9): [True: 0, False: 15]
  |  Branch (9322:26): [True: 0, False: 15]
  ------------------
 9323|      0|      cur++;
 9324|      0|      if (*cur == '-') {
  ------------------
  |  Branch (9324:11): [True: 0, False: 0]
  ------------------
 9325|      0|	is_exponent_negative = 1;
 9326|      0|	cur++;
 9327|      0|      } else if (*cur == '+') {
  ------------------
  |  Branch (9327:18): [True: 0, False: 0]
  ------------------
 9328|      0|        cur++;
 9329|      0|      }
 9330|      0|      while ((*cur >= '0') && (*cur <= '9')) {
  ------------------
  |  Branch (9330:14): [True: 0, False: 0]
  |  Branch (9330:31): [True: 0, False: 0]
  ------------------
 9331|      0|        if (exponent < 1000000)
  ------------------
  |  Branch (9331:13): [True: 0, False: 0]
  ------------------
 9332|      0|	  exponent = exponent * 10 + (*cur - '0');
 9333|      0|	cur++;
 9334|      0|      }
 9335|      0|    }
 9336|     15|    while (IS_BLANK_CH(*cur)) cur++;
 9337|     15|    if (*cur != 0) return(xmlXPathNAN);
  ------------------
  |  Branch (9337:9): [True: 0, False: 15]
  ------------------
 9338|     15|    if (isneg) ret = -ret;
  ------------------
  |  Branch (9338:9): [True: 4, False: 11]
  ------------------
 9339|     15|    if (is_exponent_negative) exponent = -exponent;
  ------------------
  |  Branch (9339:9): [True: 0, False: 15]
  ------------------
 9340|     15|    ret *= pow(10.0, (double)exponent);
 9341|     15|    return(ret);
 9342|     15|}
xmlXPathIsNodeType:
 9601|    228|xmlXPathIsNodeType(const xmlChar *name) {
 9602|    228|    if (name == NULL)
  ------------------
  |  Branch (9602:9): [True: 0, False: 228]
  ------------------
 9603|      0|	return(0);
 9604|       |
 9605|    228|    if (xmlStrEqual(name, BAD_CAST "node"))
  ------------------
  |  |   35|    228|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9605:9): [True: 0, False: 228]
  ------------------
 9606|      0|	return(1);
 9607|    228|    if (xmlStrEqual(name, BAD_CAST "text"))
  ------------------
  |  |   35|    228|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9607:9): [True: 0, False: 228]
  ------------------
 9608|      0|	return(1);
 9609|    228|    if (xmlStrEqual(name, BAD_CAST "comment"))
  ------------------
  |  |   35|    228|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9609:9): [True: 0, False: 228]
  ------------------
 9610|      0|	return(1);
 9611|    228|    if (xmlStrEqual(name, BAD_CAST "processing-instruction"))
  ------------------
  |  |   35|    228|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9611:9): [True: 0, False: 228]
  ------------------
 9612|      0|	return(1);
 9613|    228|    return(0);
 9614|    228|}
xmlXPathEvaluatePredicateResult:
13121|     33|                                xmlXPathObjectPtr res) {
13122|     33|    if ((ctxt == NULL) || (res == NULL)) return(0);
  ------------------
  |  Branch (13122:9): [True: 0, False: 33]
  |  Branch (13122:27): [True: 0, False: 33]
  ------------------
13123|     33|    switch (res->type) {
13124|      0|        case XPATH_BOOLEAN:
  ------------------
  |  Branch (13124:9): [True: 0, False: 33]
  ------------------
13125|      0|	    return(res->boolval);
13126|     29|        case XPATH_NUMBER:
  ------------------
  |  Branch (13126:9): [True: 29, False: 4]
  ------------------
13127|       |#if defined(__BORLANDC__) || (defined(_MSC_VER) && (_MSC_VER == 1200))
13128|       |	    return((res->floatval == ctxt->context->proximityPosition) &&
13129|       |	           (!xmlXPathIsNaN(res->floatval))); /* MSC pbm Mark Vakoc !*/
13130|       |#else
13131|     29|	    return(res->floatval == ctxt->context->proximityPosition);
13132|      0|#endif
13133|      4|        case XPATH_NODESET:
  ------------------
  |  Branch (13133:9): [True: 4, False: 29]
  ------------------
13134|      4|        case XPATH_XSLT_TREE:
  ------------------
  |  Branch (13134:9): [True: 0, False: 33]
  ------------------
13135|      4|	    if (res->nodesetval == NULL)
  ------------------
  |  Branch (13135:10): [True: 0, False: 4]
  ------------------
13136|      0|		return(0);
13137|      4|	    return(res->nodesetval->nodeNr != 0);
13138|      0|        case XPATH_STRING:
  ------------------
  |  Branch (13138:9): [True: 0, False: 33]
  ------------------
13139|      0|	    return((res->stringval != NULL) && (res->stringval[0] != 0));
  ------------------
  |  Branch (13139:13): [True: 0, False: 0]
  |  Branch (13139:41): [True: 0, False: 0]
  ------------------
13140|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
13141|       |	case XPATH_LOCATIONSET:{
13142|       |	    xmlLocationSetPtr ptr = res->user;
13143|       |	    if (ptr == NULL)
13144|       |	        return(0);
13145|       |	    return (ptr->locNr != 0);
13146|       |	    }
13147|       |#endif
13148|      0|        default:
  ------------------
  |  Branch (13148:9): [True: 0, False: 33]
  ------------------
13149|      0|	    STRANGE
  ------------------
  |  | 1230|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1231|      0|	    "Internal error at %s:%d\n",				\
  |  | 1232|      0|            __FILE__, __LINE__);
  ------------------
13150|     33|    }
13151|      0|    return(0);
13152|     33|}
xmlXPathEvalExpr:
13510|    444|xmlXPathEvalExpr(xmlXPathParserContextPtr ctxt) {
13511|    444|#ifdef XPATH_STREAMING
13512|    444|    xmlXPathCompExprPtr comp;
13513|    444|#endif
13514|    444|    int oldDepth = 0;
13515|       |
13516|    444|    if (ctxt == NULL) return;
  ------------------
  |  Branch (13516:9): [True: 0, False: 444]
  ------------------
13517|       |
13518|    444|#ifdef XPATH_STREAMING
13519|    444|    comp = xmlXPathTryStreamCompile(ctxt->context, ctxt->base);
13520|    444|    if (comp != NULL) {
  ------------------
  |  Branch (13520:9): [True: 15, False: 429]
  ------------------
13521|     15|        if (ctxt->comp != NULL)
  ------------------
  |  Branch (13521:13): [True: 15, False: 0]
  ------------------
13522|     15|	    xmlXPathFreeCompExpr(ctxt->comp);
13523|     15|        ctxt->comp = comp;
13524|     15|    } else
13525|    429|#endif
13526|    429|    {
13527|    429|        if (ctxt->context != NULL)
  ------------------
  |  Branch (13527:13): [True: 429, False: 0]
  ------------------
13528|    429|            oldDepth = ctxt->context->depth;
13529|    429|	xmlXPathCompileExpr(ctxt, 1);
13530|    429|        if (ctxt->context != NULL)
  ------------------
  |  Branch (13530:13): [True: 429, False: 0]
  ------------------
13531|    429|            ctxt->context->depth = oldDepth;
13532|    429|        CHECK_ERROR;
  ------------------
  |  |  241|    429|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 22, False: 407]
  |  |  ------------------
  ------------------
13533|       |
13534|       |        /* Check for trailing characters. */
13535|    407|        if (*ctxt->cur != 0)
  ------------------
  |  Branch (13535:13): [True: 6, False: 401]
  ------------------
13536|    401|            XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      6|    { xmlXPathErr(ctxt, X); return; }
  ------------------
13537|       |
13538|    401|	if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {
  ------------------
  |  Branch (13538:6): [True: 382, False: 19]
  |  Branch (13538:34): [True: 382, False: 0]
  ------------------
13539|    382|            if (ctxt->context != NULL)
  ------------------
  |  Branch (13539:17): [True: 382, False: 0]
  ------------------
13540|    382|                oldDepth = ctxt->context->depth;
13541|    382|	    xmlXPathOptimizeExpression(ctxt,
13542|    382|		&ctxt->comp->steps[ctxt->comp->last]);
13543|    382|            if (ctxt->context != NULL)
  ------------------
  |  Branch (13543:17): [True: 382, False: 0]
  ------------------
13544|    382|                ctxt->context->depth = oldDepth;
13545|    382|        }
13546|    401|    }
13547|       |
13548|    416|    xmlXPathRunEval(ctxt, 0);
13549|    416|}
xmlXPathRegisterAllFunctions:
13773|    486|{
13774|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"boolean",
13775|    486|                         xmlXPathBooleanFunction);
13776|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"ceiling",
13777|    486|                         xmlXPathCeilingFunction);
13778|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"count",
13779|    486|                         xmlXPathCountFunction);
13780|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"concat",
13781|    486|                         xmlXPathConcatFunction);
13782|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"contains",
13783|    486|                         xmlXPathContainsFunction);
13784|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"id",
13785|    486|                         xmlXPathIdFunction);
13786|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"false",
13787|    486|                         xmlXPathFalseFunction);
13788|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"floor",
13789|    486|                         xmlXPathFloorFunction);
13790|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"last",
13791|    486|                         xmlXPathLastFunction);
13792|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"lang",
13793|    486|                         xmlXPathLangFunction);
13794|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"local-name",
13795|    486|                         xmlXPathLocalNameFunction);
13796|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"not",
13797|    486|                         xmlXPathNotFunction);
13798|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"name",
13799|    486|                         xmlXPathNameFunction);
13800|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"namespace-uri",
13801|    486|                         xmlXPathNamespaceURIFunction);
13802|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"normalize-space",
13803|    486|                         xmlXPathNormalizeFunction);
13804|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"number",
13805|    486|                         xmlXPathNumberFunction);
13806|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"position",
13807|    486|                         xmlXPathPositionFunction);
13808|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"round",
13809|    486|                         xmlXPathRoundFunction);
13810|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string",
13811|    486|                         xmlXPathStringFunction);
13812|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"string-length",
13813|    486|                         xmlXPathStringLengthFunction);
13814|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"starts-with",
13815|    486|                         xmlXPathStartsWithFunction);
13816|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring",
13817|    486|                         xmlXPathSubstringFunction);
13818|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-before",
13819|    486|                         xmlXPathSubstringBeforeFunction);
13820|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"substring-after",
13821|    486|                         xmlXPathSubstringAfterFunction);
13822|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"sum",
13823|    486|                         xmlXPathSumFunction);
13824|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"true",
13825|    486|                         xmlXPathTrueFunction);
13826|    486|    xmlXPathRegisterFunc(ctxt, (const xmlChar *)"translate",
13827|    486|                         xmlXPathTranslateFunction);
13828|       |
13829|    486|    xmlXPathRegisterFuncNS(ctxt, (const xmlChar *)"escape-uri",
13830|    486|	 (const xmlChar *)"http://www.w3.org/2002/08/xquery-functions",
13831|    486|                         xmlXPathEscapeUriFunction);
13832|    486|}
xpath.c:wrap_cmp:
  561|    451|    {
  562|    451|        int res = xmlXPathCmpNodesExt(x, y);
  563|    451|        return res == -2 ? res : -res;
  ------------------
  |  Branch (563:16): [True: 0, False: 451]
  ------------------
  564|    451|    }
xpath.c:xmlXPathCmpNodesExt:
  262|    451|xmlXPathCmpNodesExt(xmlNodePtr node1, xmlNodePtr node2) {
  263|    451|    int depth1, depth2;
  264|    451|    int misc = 0, precedence1 = 0, precedence2 = 0;
  265|    451|    xmlNodePtr miscNode1 = NULL, miscNode2 = NULL;
  266|    451|    xmlNodePtr cur, root;
  267|    451|    ptrdiff_t l1, l2;
  268|       |
  269|    451|    if ((node1 == NULL) || (node2 == NULL))
  ------------------
  |  Branch (269:9): [True: 0, False: 451]
  |  Branch (269:28): [True: 0, False: 451]
  ------------------
  270|      0|	return(-2);
  271|       |
  272|    451|    if (node1 == node2)
  ------------------
  |  Branch (272:9): [True: 0, False: 451]
  ------------------
  273|      0|	return(0);
  274|       |
  275|       |    /*
  276|       |     * a couple of optimizations which will avoid computations in most cases
  277|       |     */
  278|    451|    switch (node1->type) {
  279|    398|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (279:2): [True: 398, False: 53]
  ------------------
  280|    398|	    if (node2->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (280:10): [True: 374, False: 24]
  ------------------
  281|    374|		if ((0 > (ptrdiff_t) node1->content) &&
  ------------------
  |  Branch (281:7): [True: 0, False: 374]
  ------------------
  282|    374|		    (0 > (ptrdiff_t) node2->content) &&
  ------------------
  |  Branch (282:7): [True: 0, False: 0]
  ------------------
  283|    374|		    (node1->doc == node2->doc))
  ------------------
  |  Branch (283:7): [True: 0, False: 0]
  ------------------
  284|      0|		{
  285|      0|		    l1 = -((ptrdiff_t) node1->content);
  286|      0|		    l2 = -((ptrdiff_t) node2->content);
  287|      0|		    if (l1 < l2)
  ------------------
  |  Branch (287:11): [True: 0, False: 0]
  ------------------
  288|      0|			return(1);
  289|      0|		    if (l1 > l2)
  ------------------
  |  Branch (289:11): [True: 0, False: 0]
  ------------------
  290|      0|			return(-1);
  291|      0|		} else
  292|    374|		    goto turtle_comparison;
  293|    374|	    }
  294|     24|	    break;
  295|     24|	case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (295:2): [True: 4, False: 447]
  ------------------
  296|      4|	    precedence1 = 1; /* element is owner */
  297|      4|	    miscNode1 = node1;
  298|      4|	    node1 = node1->parent;
  299|      4|	    misc = 1;
  300|      4|	    break;
  301|     45|	case XML_TEXT_NODE:
  ------------------
  |  Branch (301:2): [True: 45, False: 406]
  ------------------
  302|     45|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (302:2): [True: 0, False: 451]
  ------------------
  303|     45|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (303:2): [True: 0, False: 451]
  ------------------
  304|     45|	case XML_PI_NODE: {
  ------------------
  |  Branch (304:2): [True: 0, False: 451]
  ------------------
  305|     45|	    miscNode1 = node1;
  306|       |	    /*
  307|       |	    * Find nearest element node.
  308|       |	    */
  309|     45|	    if (node1->prev != NULL) {
  ------------------
  |  Branch (309:10): [True: 18, False: 27]
  ------------------
  310|     18|		do {
  311|     18|		    node1 = node1->prev;
  312|     18|		    if (node1->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (312:11): [True: 18, False: 0]
  ------------------
  313|     18|			precedence1 = 3; /* element in prev-sibl axis */
  314|     18|			break;
  315|     18|		    }
  316|      0|		    if (node1->prev == NULL) {
  ------------------
  |  Branch (316:11): [True: 0, False: 0]
  ------------------
  317|      0|			precedence1 = 2; /* element is parent */
  318|       |			/*
  319|       |			* URGENT TODO: Are there any cases, where the
  320|       |			* parent of such a node is not an element node?
  321|       |			*/
  322|      0|			node1 = node1->parent;
  323|      0|			break;
  324|      0|		    }
  325|      0|		} while (1);
  ------------------
  |  Branch (325:12): [Folded - Ignored]
  ------------------
  326|     27|	    } else {
  327|     27|		precedence1 = 2; /* element is parent */
  328|     27|		node1 = node1->parent;
  329|     27|	    }
  330|     45|	    if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (330:10): [True: 0, False: 45]
  |  Branch (330:29): [True: 0, False: 45]
  ------------------
  331|     45|		(0 <= (ptrdiff_t) node1->content)) {
  ------------------
  |  Branch (331:3): [True: 45, False: 0]
  ------------------
  332|       |		/*
  333|       |		* Fallback for whatever case.
  334|       |		*/
  335|     45|		node1 = miscNode1;
  336|     45|		precedence1 = 0;
  337|     45|	    } else
  338|      0|		misc = 1;
  339|     45|	}
  340|      0|	    break;
  341|      2|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (341:2): [True: 2, False: 449]
  ------------------
  342|       |	    /*
  343|       |	    * TODO: why do we return 1 for namespace nodes?
  344|       |	    */
  345|      2|	    return(1);
  346|      2|	default:
  ------------------
  |  Branch (346:2): [True: 2, False: 449]
  ------------------
  347|      2|	    break;
  348|    451|    }
  349|     75|    switch (node2->type) {
  350|     25|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (350:2): [True: 25, False: 50]
  ------------------
  351|     25|	    break;
  352|      2|	case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (352:2): [True: 2, False: 73]
  ------------------
  353|      2|	    precedence2 = 1; /* element is owner */
  354|      2|	    miscNode2 = node2;
  355|      2|	    node2 = node2->parent;
  356|      2|	    misc = 1;
  357|      2|	    break;
  358|     46|	case XML_TEXT_NODE:
  ------------------
  |  Branch (358:2): [True: 46, False: 29]
  ------------------
  359|     46|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (359:2): [True: 0, False: 75]
  ------------------
  360|     46|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (360:2): [True: 0, False: 75]
  ------------------
  361|     46|	case XML_PI_NODE: {
  ------------------
  |  Branch (361:2): [True: 0, False: 75]
  ------------------
  362|     46|	    miscNode2 = node2;
  363|     46|	    if (node2->prev != NULL) {
  ------------------
  |  Branch (363:10): [True: 21, False: 25]
  ------------------
  364|     21|		do {
  365|     21|		    node2 = node2->prev;
  366|     21|		    if (node2->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (366:11): [True: 21, False: 0]
  ------------------
  367|     21|			precedence2 = 3; /* element in prev-sibl axis */
  368|     21|			break;
  369|     21|		    }
  370|      0|		    if (node2->prev == NULL) {
  ------------------
  |  Branch (370:11): [True: 0, False: 0]
  ------------------
  371|      0|			precedence2 = 2; /* element is parent */
  372|      0|			node2 = node2->parent;
  373|      0|			break;
  374|      0|		    }
  375|      0|		} while (1);
  ------------------
  |  Branch (375:12): [Folded - Ignored]
  ------------------
  376|     25|	    } else {
  377|     25|		precedence2 = 2; /* element is parent */
  378|     25|		node2 = node2->parent;
  379|     25|	    }
  380|     46|	    if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (380:10): [True: 0, False: 46]
  |  Branch (380:29): [True: 0, False: 46]
  ------------------
  381|     46|		(0 <= (ptrdiff_t) node2->content))
  ------------------
  |  Branch (381:3): [True: 46, False: 0]
  ------------------
  382|     46|	    {
  383|     46|		node2 = miscNode2;
  384|     46|		precedence2 = 0;
  385|     46|	    } else
  386|      0|		misc = 1;
  387|     46|	}
  388|      0|	    break;
  389|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (389:2): [True: 0, False: 75]
  ------------------
  390|      0|	    return(1);
  391|      2|	default:
  ------------------
  |  Branch (391:2): [True: 2, False: 73]
  ------------------
  392|      2|	    break;
  393|     75|    }
  394|     75|    if (misc) {
  ------------------
  |  Branch (394:9): [True: 6, False: 69]
  ------------------
  395|      6|	if (node1 == node2) {
  ------------------
  |  Branch (395:6): [True: 4, False: 2]
  ------------------
  396|      4|	    if (precedence1 == precedence2) {
  ------------------
  |  Branch (396:10): [True: 0, False: 4]
  ------------------
  397|       |		/*
  398|       |		* The ugly case; but normally there aren't many
  399|       |		* adjacent non-element nodes around.
  400|       |		*/
  401|      0|		cur = miscNode2->prev;
  402|      0|		while (cur != NULL) {
  ------------------
  |  Branch (402:10): [True: 0, False: 0]
  ------------------
  403|      0|		    if (cur == miscNode1)
  ------------------
  |  Branch (403:11): [True: 0, False: 0]
  ------------------
  404|      0|			return(1);
  405|      0|		    if (cur->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (405:11): [True: 0, False: 0]
  ------------------
  406|      0|			return(-1);
  407|      0|		    cur = cur->prev;
  408|      0|		}
  409|      0|		return (-1);
  410|      4|	    } else {
  411|       |		/*
  412|       |		* Evaluate based on higher precedence wrt to the element.
  413|       |		* TODO: This assumes attributes are sorted before content.
  414|       |		*   Is this 100% correct?
  415|       |		*/
  416|      4|		if (precedence1 < precedence2)
  ------------------
  |  Branch (416:7): [True: 2, False: 2]
  ------------------
  417|      2|		    return(1);
  418|      2|		else
  419|      2|		    return(-1);
  420|      4|	    }
  421|      4|	}
  422|       |	/*
  423|       |	* Special case: One of the helper-elements is contained by the other.
  424|       |	* <foo>
  425|       |	*   <node2>
  426|       |	*     <node1>Text-1(precedence1 == 2)</node1>
  427|       |	*   </node2>
  428|       |	*   Text-6(precedence2 == 3)
  429|       |	* </foo>
  430|       |	*/
  431|      2|	if ((precedence2 == 3) && (precedence1 > 1)) {
  ------------------
  |  Branch (431:6): [True: 0, False: 2]
  |  Branch (431:28): [True: 0, False: 0]
  ------------------
  432|      0|	    cur = node1->parent;
  433|      0|	    while (cur) {
  ------------------
  |  Branch (433:13): [True: 0, False: 0]
  ------------------
  434|      0|		if (cur == node2)
  ------------------
  |  Branch (434:7): [True: 0, False: 0]
  ------------------
  435|      0|		    return(1);
  436|      0|		cur = cur->parent;
  437|      0|	    }
  438|      0|	}
  439|      2|	if ((precedence1 == 3) && (precedence2 > 1)) {
  ------------------
  |  Branch (439:6): [True: 0, False: 2]
  |  Branch (439:28): [True: 0, False: 0]
  ------------------
  440|      0|	    cur = node2->parent;
  441|      0|	    while (cur) {
  ------------------
  |  Branch (441:13): [True: 0, False: 0]
  ------------------
  442|      0|		if (cur == node1)
  ------------------
  |  Branch (442:7): [True: 0, False: 0]
  ------------------
  443|      0|		    return(-1);
  444|      0|		cur = cur->parent;
  445|      0|	    }
  446|      0|	}
  447|      2|    }
  448|       |
  449|       |    /*
  450|       |     * Speedup using document order if available.
  451|       |     */
  452|     71|    if ((node1->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (452:9): [True: 24, False: 47]
  ------------------
  453|     71|	(node2->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (453:2): [True: 0, False: 24]
  ------------------
  454|     71|	(0 > (ptrdiff_t) node1->content) &&
  ------------------
  |  Branch (454:2): [True: 0, False: 0]
  ------------------
  455|     71|	(0 > (ptrdiff_t) node2->content) &&
  ------------------
  |  Branch (455:2): [True: 0, False: 0]
  ------------------
  456|     71|	(node1->doc == node2->doc)) {
  ------------------
  |  Branch (456:2): [True: 0, False: 0]
  ------------------
  457|       |
  458|      0|	l1 = -((ptrdiff_t) node1->content);
  459|      0|	l2 = -((ptrdiff_t) node2->content);
  460|      0|	if (l1 < l2)
  ------------------
  |  Branch (460:6): [True: 0, False: 0]
  ------------------
  461|      0|	    return(1);
  462|      0|	if (l1 > l2)
  ------------------
  |  Branch (462:6): [True: 0, False: 0]
  ------------------
  463|      0|	    return(-1);
  464|      0|    }
  465|       |
  466|    445|turtle_comparison:
  467|       |
  468|    445|    if (node1 == node2->prev)
  ------------------
  |  Branch (468:9): [True: 31, False: 414]
  ------------------
  469|     31|	return(1);
  470|    414|    if (node1 == node2->next)
  ------------------
  |  Branch (470:9): [True: 0, False: 414]
  ------------------
  471|      0|	return(-1);
  472|       |    /*
  473|       |     * compute depth to root
  474|       |     */
  475|  1.13k|    for (depth2 = 0, cur = node2; cur->parent != NULL; cur = cur->parent) {
  ------------------
  |  Branch (475:35): [True: 818, False: 312]
  ------------------
  476|    818|	if (cur->parent == node1)
  ------------------
  |  Branch (476:6): [True: 102, False: 716]
  ------------------
  477|    102|	    return(1);
  478|    716|	depth2++;
  479|    716|    }
  480|    312|    root = cur;
  481|  1.11k|    for (depth1 = 0, cur = node1; cur->parent != NULL; cur = cur->parent) {
  ------------------
  |  Branch (481:35): [True: 811, False: 306]
  ------------------
  482|    811|	if (cur->parent == node2)
  ------------------
  |  Branch (482:6): [True: 6, False: 805]
  ------------------
  483|      6|	    return(-1);
  484|    805|	depth1++;
  485|    805|    }
  486|       |    /*
  487|       |     * Distinct document (or distinct entities :-( ) case.
  488|       |     */
  489|    306|    if (root != cur) {
  ------------------
  |  Branch (489:9): [True: 0, False: 306]
  ------------------
  490|      0|	return(-2);
  491|      0|    }
  492|       |    /*
  493|       |     * get the nearest common ancestor.
  494|       |     */
  495|    408|    while (depth1 > depth2) {
  ------------------
  |  Branch (495:12): [True: 102, False: 306]
  ------------------
  496|    102|	depth1--;
  497|    102|	node1 = node1->parent;
  498|    102|    }
  499|    311|    while (depth2 > depth1) {
  ------------------
  |  Branch (499:12): [True: 5, False: 306]
  ------------------
  500|      5|	depth2--;
  501|      5|	node2 = node2->parent;
  502|      5|    }
  503|    331|    while (node1->parent != node2->parent) {
  ------------------
  |  Branch (503:12): [True: 25, False: 306]
  ------------------
  504|     25|	node1 = node1->parent;
  505|     25|	node2 = node2->parent;
  506|       |	/* should not happen but just in case ... */
  507|     25|	if ((node1 == NULL) || (node2 == NULL))
  ------------------
  |  Branch (507:6): [True: 0, False: 25]
  |  Branch (507:25): [True: 0, False: 25]
  ------------------
  508|      0|	    return(-2);
  509|     25|    }
  510|       |    /*
  511|       |     * Find who's first.
  512|       |     */
  513|    306|    if (node1 == node2->prev)
  ------------------
  |  Branch (513:9): [True: 18, False: 288]
  ------------------
  514|     18|	return(1);
  515|    288|    if (node1 == node2->next)
  ------------------
  |  Branch (515:9): [True: 0, False: 288]
  ------------------
  516|      0|	return(-1);
  517|       |    /*
  518|       |     * Speedup using document order if available.
  519|       |     */
  520|    288|    if ((node1->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (520:9): [True: 288, False: 0]
  ------------------
  521|    288|	(node2->type == XML_ELEMENT_NODE) &&
  ------------------
  |  Branch (521:2): [True: 288, False: 0]
  ------------------
  522|    288|	(0 > (ptrdiff_t) node1->content) &&
  ------------------
  |  Branch (522:2): [True: 0, False: 288]
  ------------------
  523|    288|	(0 > (ptrdiff_t) node2->content) &&
  ------------------
  |  Branch (523:2): [True: 0, False: 0]
  ------------------
  524|    288|	(node1->doc == node2->doc)) {
  ------------------
  |  Branch (524:2): [True: 0, False: 0]
  ------------------
  525|       |
  526|      0|	l1 = -((ptrdiff_t) node1->content);
  527|      0|	l2 = -((ptrdiff_t) node2->content);
  528|      0|	if (l1 < l2)
  ------------------
  |  Branch (528:6): [True: 0, False: 0]
  ------------------
  529|      0|	    return(1);
  530|      0|	if (l1 > l2)
  ------------------
  |  Branch (530:6): [True: 0, False: 0]
  ------------------
  531|      0|	    return(-1);
  532|      0|    }
  533|       |
  534|    708|    for (cur = node1->next;cur != NULL;cur = cur->next)
  ------------------
  |  Branch (534:28): [True: 691, False: 17]
  ------------------
  535|    691|	if (cur == node2)
  ------------------
  |  Branch (535:6): [True: 271, False: 420]
  ------------------
  536|    271|	    return(1);
  537|     17|    return(-1); /* assume there is no sibling list corruption */
  538|    288|}
xpath.c:xmlXPathErrMemory:
  635|     10|{
  636|     10|    if (ctxt != NULL) {
  ------------------
  |  Branch (636:9): [True: 9, False: 1]
  ------------------
  637|      9|        xmlResetError(&ctxt->lastError);
  638|      9|        if (extra) {
  ------------------
  |  Branch (638:13): [True: 9, False: 0]
  ------------------
  639|      9|            xmlChar buf[200];
  640|       |
  641|      9|            xmlStrPrintf(buf, 200,
  642|      9|                         "Memory allocation failed : %s\n",
  643|      9|                         extra);
  644|      9|            ctxt->lastError.message = (char *) xmlStrdup(buf);
  645|      9|        } else {
  646|      0|            ctxt->lastError.message = (char *)
  647|      0|	       xmlStrdup(BAD_CAST "Memory allocation failed\n");
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  648|      0|        }
  649|      9|        ctxt->lastError.domain = XML_FROM_XPATH;
  650|      9|        ctxt->lastError.code = XML_ERR_NO_MEMORY;
  651|      9|	if (ctxt->error != NULL)
  ------------------
  |  Branch (651:6): [True: 0, False: 9]
  ------------------
  652|      0|	    ctxt->error(ctxt->userData, &ctxt->lastError);
  653|      9|    } else {
  654|      1|        if (extra)
  ------------------
  |  Branch (654:13): [True: 1, False: 0]
  ------------------
  655|      1|            __xmlRaiseError(NULL, NULL, NULL,
  656|      1|                            NULL, NULL, XML_FROM_XPATH,
  657|      1|                            XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
  658|      1|                            extra, NULL, NULL, 0, 0,
  659|      1|                            "Memory allocation failed : %s\n", extra);
  660|      0|        else
  661|      0|            __xmlRaiseError(NULL, NULL, NULL,
  662|      0|                            NULL, NULL, XML_FROM_XPATH,
  663|      0|                            XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0,
  664|      0|                            NULL, NULL, NULL, 0, 0,
  665|      0|                            "Memory allocation failed\n");
  666|      1|    }
  667|     10|}
xpath.c:xmlXPathNodeSetDupNs:
 2921|     15|xmlXPathNodeSetDupNs(xmlNodePtr node, xmlNsPtr ns) {
 2922|     15|    xmlNsPtr cur;
 2923|       |
 2924|     15|    if ((ns == NULL) || (ns->type != XML_NAMESPACE_DECL))
  ------------------
  |  Branch (2924:9): [True: 0, False: 15]
  |  Branch (2924:25): [True: 0, False: 15]
  ------------------
 2925|      0|	return(NULL);
 2926|     15|    if ((node == NULL) || (node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (2926:9): [True: 0, False: 15]
  |  Branch (2926:27): [True: 0, False: 15]
  ------------------
 2927|      0|	return((xmlNodePtr) ns);
 2928|       |
 2929|       |    /*
 2930|       |     * Allocate a new Namespace and fill the fields.
 2931|       |     */
 2932|     15|    cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));
 2933|     15|    if (cur == NULL) {
  ------------------
  |  Branch (2933:9): [True: 0, False: 15]
  ------------------
 2934|      0|        xmlXPathErrMemory(NULL, "duplicating namespace\n");
 2935|      0|	return(NULL);
 2936|      0|    }
 2937|     15|    memset(cur, 0, sizeof(xmlNs));
 2938|     15|    cur->type = XML_NAMESPACE_DECL;
 2939|     15|    if (ns->href != NULL)
  ------------------
  |  Branch (2939:9): [True: 15, False: 0]
  ------------------
 2940|     15|	cur->href = xmlStrdup(ns->href);
 2941|     15|    if (ns->prefix != NULL)
  ------------------
  |  Branch (2941:9): [True: 15, False: 0]
  ------------------
 2942|     15|	cur->prefix = xmlStrdup(ns->prefix);
 2943|     15|    cur->next = (xmlNsPtr) node;
 2944|     15|    return((xmlNodePtr) cur);
 2945|     15|}
xpath.c:xmlXPathCacheObjectCopy:
 2179|    938|{
 2180|    938|    if (val == NULL)
  ------------------
  |  Branch (2180:9): [True: 0, False: 938]
  ------------------
 2181|      0|	return(NULL);
 2182|       |
 2183|    938|    if (XP_HAS_CACHE(ctxt)) {
  ------------------
  |  | 1206|    938|#define XP_HAS_CACHE(c) ((c != NULL) && ((c)->cache != NULL))
  |  |  ------------------
  |  |  |  Branch (1206:26): [True: 938, False: 0]
  |  |  |  Branch (1206:41): [True: 0, False: 938]
  |  |  ------------------
  ------------------
 2184|      0|	switch (val->type) {
 2185|      0|	    case XPATH_NODESET:
  ------------------
  |  Branch (2185:6): [True: 0, False: 0]
  ------------------
 2186|      0|		return(xmlXPathCacheWrapNodeSet(ctxt,
 2187|      0|		    xmlXPathNodeSetMerge(NULL, val->nodesetval)));
 2188|      0|	    case XPATH_STRING:
  ------------------
  |  Branch (2188:6): [True: 0, False: 0]
  ------------------
 2189|      0|		return(xmlXPathCacheNewString(ctxt, val->stringval));
 2190|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (2190:6): [True: 0, False: 0]
  ------------------
 2191|      0|		return(xmlXPathCacheNewBoolean(ctxt, val->boolval));
 2192|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (2192:6): [True: 0, False: 0]
  ------------------
 2193|      0|		return(xmlXPathCacheNewFloat(ctxt, val->floatval));
 2194|      0|	    default:
  ------------------
  |  Branch (2194:6): [True: 0, False: 0]
  ------------------
 2195|      0|		break;
 2196|      0|	}
 2197|      0|    }
 2198|    938|    return(xmlXPathObjectCopy(val));
 2199|    938|}
xpath.c:xmlXPathReleaseObject:
 4859|  2.11k|{
 4860|  2.11k|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
 4861|  2.11k|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
 4862|  2.11k|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
 4863|       |
 4864|  2.11k|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
 4865|       |
 4866|  2.11k|    if (obj == NULL)
  ------------------
  |  Branch (4866:9): [True: 0, False: 2.11k]
  ------------------
 4867|      0|	return;
 4868|  2.11k|    if ((ctxt == NULL) || (ctxt->cache == NULL)) {
  ------------------
  |  Branch (4868:9): [True: 0, False: 2.11k]
  |  Branch (4868:27): [True: 2.11k, False: 0]
  ------------------
 4869|  2.11k|	 xmlXPathFreeObject(obj);
 4870|  2.11k|    } else {
 4871|      0|	xmlXPathContextCachePtr cache =
 4872|      0|	    (xmlXPathContextCachePtr) ctxt->cache;
 4873|       |
 4874|      0|	switch (obj->type) {
 4875|      0|	    case XPATH_NODESET:
  ------------------
  |  Branch (4875:6): [True: 0, False: 0]
  ------------------
 4876|      0|	    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (4876:6): [True: 0, False: 0]
  ------------------
 4877|      0|		if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (4877:7): [True: 0, False: 0]
  ------------------
 4878|      0|		    if (obj->boolval) {
  ------------------
  |  Branch (4878:11): [True: 0, False: 0]
  ------------------
 4879|       |			/*
 4880|       |			* It looks like the @boolval is used for
 4881|       |			* evaluation if this an XSLT Result Tree Fragment.
 4882|       |			* TODO: Check if this assumption is correct.
 4883|       |			*/
 4884|      0|			obj->type = XPATH_XSLT_TREE; /* just for debugging */
 4885|      0|			xmlXPathFreeValueTree(obj->nodesetval);
 4886|      0|			obj->nodesetval = NULL;
 4887|      0|		    } else if ((obj->nodesetval->nodeMax <= 40) &&
  ------------------
  |  Branch (4887:18): [True: 0, False: 0]
  ------------------
 4888|      0|			(XP_CACHE_WANTS(cache->nodesetObjs,
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4889|      0|					cache->maxNodeset)))
 4890|      0|		    {
 4891|      0|			XP_CACHE_ADD(cache->nodesetObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4892|      0|			goto obj_cached;
 4893|      0|		    } else {
 4894|      0|			xmlXPathFreeNodeSet(obj->nodesetval);
 4895|      0|			obj->nodesetval = NULL;
 4896|      0|		    }
 4897|      0|		}
 4898|      0|		break;
 4899|      0|	    case XPATH_STRING:
  ------------------
  |  Branch (4899:6): [True: 0, False: 0]
  ------------------
 4900|      0|		if (obj->stringval != NULL)
  ------------------
  |  Branch (4900:7): [True: 0, False: 0]
  ------------------
 4901|      0|		    xmlFree(obj->stringval);
 4902|       |
 4903|      0|		if (XP_CACHE_WANTS(cache->stringObjs, cache->maxString)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4904|      0|		    XP_CACHE_ADD(cache->stringObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4905|      0|		    goto obj_cached;
 4906|      0|		}
 4907|      0|		break;
 4908|      0|	    case XPATH_BOOLEAN:
  ------------------
  |  Branch (4908:6): [True: 0, False: 0]
  ------------------
 4909|      0|		if (XP_CACHE_WANTS(cache->booleanObjs, cache->maxBoolean)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4910|      0|		    XP_CACHE_ADD(cache->booleanObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4911|      0|		    goto obj_cached;
 4912|      0|		}
 4913|      0|		break;
 4914|      0|	    case XPATH_NUMBER:
  ------------------
  |  Branch (4914:6): [True: 0, False: 0]
  ------------------
 4915|      0|		if (XP_CACHE_WANTS(cache->numberObjs, cache->maxNumber)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4916|      0|		    XP_CACHE_ADD(cache->numberObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4917|      0|		    goto obj_cached;
 4918|      0|		}
 4919|      0|		break;
 4920|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 4921|       |	    case XPATH_LOCATIONSET:
 4922|       |		if (obj->user != NULL) {
 4923|       |		    xmlXPtrFreeLocationSet(obj->user);
 4924|       |		}
 4925|       |		goto free_obj;
 4926|       |#endif
 4927|      0|	    default:
  ------------------
  |  Branch (4927:6): [True: 0, False: 0]
  ------------------
 4928|      0|		goto free_obj;
 4929|      0|	}
 4930|       |
 4931|       |	/*
 4932|       |	* Fallback to adding to the misc-objects slot.
 4933|       |	*/
 4934|      0|	if (XP_CACHE_WANTS(cache->miscObjs, cache->maxMisc)) {
  ------------------
  |  | 4864|      0|#define XP_CACHE_WANTS(sl, n) ((sl == NULL) || ((sl)->number < n))
  |  |  ------------------
  |  |  |  Branch (4864:32): [True: 0, False: 0]
  |  |  |  Branch (4864:48): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4935|      0|	    XP_CACHE_ADD(cache->miscObjs, obj);
  ------------------
  |  | 4860|      0|#define XP_CACHE_ADD(sl, o) if (sl == NULL) { \
  |  |  ------------------
  |  |  |  Branch (4860:33): [True: 0, False: 0]
  |  |  ------------------
  |  | 4861|      0|	sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \
  |  |  ------------------
  |  |  |  Branch (4861:37): [True: 0, False: 0]
  |  |  ------------------
  |  | 4862|      0|    if (xmlPointerListAddSize(sl, obj, 0) == -1) goto free_obj;
  |  |  ------------------
  |  |  |  Branch (4862:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 4936|      0|	} else
 4937|      0|	    goto free_obj;
 4938|       |
 4939|      0|obj_cached:
 4940|      0|	if (obj->nodesetval != NULL) {
  ------------------
  |  Branch (4940:6): [True: 0, False: 0]
  ------------------
 4941|      0|	    xmlNodeSetPtr tmpset = obj->nodesetval;
 4942|       |
 4943|       |	    /*
 4944|       |	    * TODO: Due to those nasty ns-nodes, we need to traverse
 4945|       |	    *  the list and free the ns-nodes.
 4946|       |	    * URGENT TODO: Check if it's actually slowing things down.
 4947|       |	    *  Maybe we shouldn't try to preserve the list.
 4948|       |	    */
 4949|      0|	    if (tmpset->nodeNr > 1) {
  ------------------
  |  Branch (4949:10): [True: 0, False: 0]
  ------------------
 4950|      0|		int i;
 4951|      0|		xmlNodePtr node;
 4952|       |
 4953|      0|		for (i = 0; i < tmpset->nodeNr; i++) {
  ------------------
  |  Branch (4953:15): [True: 0, False: 0]
  ------------------
 4954|      0|		    node = tmpset->nodeTab[i];
 4955|      0|		    if ((node != NULL) &&
  ------------------
  |  Branch (4955:11): [True: 0, False: 0]
  ------------------
 4956|      0|			(node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (4956:4): [True: 0, False: 0]
  ------------------
 4957|      0|		    {
 4958|      0|			xmlXPathNodeSetFreeNs((xmlNsPtr) node);
 4959|      0|		    }
 4960|      0|		}
 4961|      0|	    } else if (tmpset->nodeNr == 1) {
  ------------------
  |  Branch (4961:17): [True: 0, False: 0]
  ------------------
 4962|      0|		if ((tmpset->nodeTab[0] != NULL) &&
  ------------------
  |  Branch (4962:7): [True: 0, False: 0]
  ------------------
 4963|      0|		    (tmpset->nodeTab[0]->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (4963:7): [True: 0, False: 0]
  ------------------
 4964|      0|		    xmlXPathNodeSetFreeNs((xmlNsPtr) tmpset->nodeTab[0]);
 4965|      0|	    }
 4966|      0|	    tmpset->nodeNr = 0;
 4967|      0|	    memset(obj, 0, sizeof(xmlXPathObject));
 4968|      0|	    obj->nodesetval = tmpset;
 4969|      0|	} else
 4970|      0|	    memset(obj, 0, sizeof(xmlXPathObject));
 4971|       |
 4972|      0|	return;
 4973|       |
 4974|      0|free_obj:
 4975|       |	/*
 4976|       |	* Cache is full; free the object.
 4977|       |	*/
 4978|      0|	if (obj->nodesetval != NULL)
  ------------------
  |  Branch (4978:6): [True: 0, False: 0]
  ------------------
 4979|      0|	    xmlXPathFreeNodeSet(obj->nodesetval);
 4980|      0|	xmlFree(obj);
 4981|      0|    }
 4982|  2.11k|    return;
 4983|  2.11k|}
xpath.c:xmlXPathFormatNumber:
 2540|      5|{
 2541|      5|    switch (xmlXPathIsInf(number)) {
 2542|      0|    case 1:
  ------------------
  |  Branch (2542:5): [True: 0, False: 5]
  ------------------
 2543|      0|	if (buffersize > (int)sizeof("Infinity"))
  ------------------
  |  Branch (2543:6): [True: 0, False: 0]
  ------------------
 2544|      0|	    snprintf(buffer, buffersize, "Infinity");
 2545|      0|	break;
 2546|      0|    case -1:
  ------------------
  |  Branch (2546:5): [True: 0, False: 5]
  ------------------
 2547|      0|	if (buffersize > (int)sizeof("-Infinity"))
  ------------------
  |  Branch (2547:6): [True: 0, False: 0]
  ------------------
 2548|      0|	    snprintf(buffer, buffersize, "-Infinity");
 2549|      0|	break;
 2550|      5|    default:
  ------------------
  |  Branch (2550:5): [True: 5, False: 0]
  ------------------
 2551|      5|	if (xmlXPathIsNaN(number)) {
  ------------------
  |  Branch (2551:6): [True: 0, False: 5]
  ------------------
 2552|      0|	    if (buffersize > (int)sizeof("NaN"))
  ------------------
  |  Branch (2552:10): [True: 0, False: 0]
  ------------------
 2553|      0|		snprintf(buffer, buffersize, "NaN");
 2554|      5|	} else if (number == 0) {
  ------------------
  |  Branch (2554:13): [True: 0, False: 5]
  ------------------
 2555|       |            /* Omit sign for negative zero. */
 2556|      0|	    snprintf(buffer, buffersize, "0");
 2557|      5|	} else if ((number > INT_MIN) && (number < INT_MAX) &&
  ------------------
  |  Branch (2557:13): [True: 4, False: 1]
  |  Branch (2557:35): [True: 3, False: 1]
  ------------------
 2558|      5|                   (number == (int) number)) {
  ------------------
  |  Branch (2558:20): [True: 1, False: 2]
  ------------------
 2559|      1|	    char work[30];
 2560|      1|	    char *ptr, *cur;
 2561|      1|	    int value = (int) number;
 2562|       |
 2563|      1|            ptr = &buffer[0];
 2564|      1|	    if (value == 0) {
  ------------------
  |  Branch (2564:10): [True: 0, False: 1]
  ------------------
 2565|      0|		*ptr++ = '0';
 2566|      1|	    } else {
 2567|      1|		snprintf(work, 29, "%d", value);
 2568|      1|		cur = &work[0];
 2569|      2|		while ((*cur) && (ptr - buffer < buffersize)) {
  ------------------
  |  Branch (2569:10): [True: 1, False: 1]
  |  Branch (2569:20): [True: 1, False: 0]
  ------------------
 2570|      1|		    *ptr++ = *cur++;
 2571|      1|		}
 2572|      1|	    }
 2573|      1|	    if (ptr - buffer < buffersize) {
  ------------------
  |  Branch (2573:10): [True: 1, False: 0]
  ------------------
 2574|      1|		*ptr = 0;
 2575|      1|	    } else if (buffersize > 0) {
  ------------------
  |  Branch (2575:17): [True: 0, False: 0]
  ------------------
 2576|      0|		ptr--;
 2577|      0|		*ptr = 0;
 2578|      0|	    }
 2579|      4|	} else {
 2580|       |	    /*
 2581|       |	      For the dimension of work,
 2582|       |	          DBL_DIG is number of significant digits
 2583|       |		  EXPONENT is only needed for "scientific notation"
 2584|       |	          3 is sign, decimal point, and terminating zero
 2585|       |		  LOWER_DOUBLE_EXP is max number of leading zeroes in fraction
 2586|       |	      Note that this dimension is slightly (a few characters)
 2587|       |	      larger than actually necessary.
 2588|       |	    */
 2589|      4|	    char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];
 2590|      4|	    int integer_place, fraction_place;
 2591|      4|	    char *ptr;
 2592|      4|	    char *after_fraction;
 2593|      4|	    double absolute_value;
 2594|      4|	    int size;
 2595|       |
 2596|      4|	    absolute_value = fabs(number);
 2597|       |
 2598|       |	    /*
 2599|       |	     * First choose format - scientific or regular floating point.
 2600|       |	     * In either case, result is in work, and after_fraction points
 2601|       |	     * just past the fractional part.
 2602|       |	    */
 2603|      4|	    if ( ((absolute_value > UPPER_DOUBLE) ||
  ------------------
  |  | 2522|      4|#define UPPER_DOUBLE 1E9
  ------------------
  |  Branch (2603:12): [True: 2, False: 2]
  ------------------
 2604|      4|		  (absolute_value < LOWER_DOUBLE)) &&
  ------------------
  |  | 2523|      2|#define LOWER_DOUBLE 1E-5
  ------------------
  |  Branch (2604:5): [True: 0, False: 2]
  ------------------
 2605|      4|		 (absolute_value != 0.0) ) {
  ------------------
  |  Branch (2605:4): [True: 2, False: 0]
  ------------------
 2606|       |		/* Use scientific notation */
 2607|      2|		integer_place = DBL_DIG + EXPONENT_DIGITS + 1;
  ------------------
  |  | 2528|      2|#define EXPONENT_DIGITS (3 + 2)
  ------------------
 2608|      2|		fraction_place = DBL_DIG - 1;
 2609|      2|		size = snprintf(work, sizeof(work),"%*.*e",
 2610|      2|			 integer_place, fraction_place, number);
 2611|     10|		while ((size > 0) && (work[size] != 'e')) size--;
  ------------------
  |  Branch (2611:10): [True: 10, False: 0]
  |  Branch (2611:24): [True: 8, False: 2]
  ------------------
 2612|       |
 2613|      2|	    }
 2614|      2|	    else {
 2615|       |		/* Use regular notation */
 2616|      2|		if (absolute_value > 0.0) {
  ------------------
  |  Branch (2616:7): [True: 2, False: 0]
  ------------------
 2617|      2|		    integer_place = (int)log10(absolute_value);
 2618|      2|		    if (integer_place > 0)
  ------------------
  |  Branch (2618:11): [True: 0, False: 2]
  ------------------
 2619|      0|		        fraction_place = DBL_DIG - integer_place - 1;
 2620|      2|		    else
 2621|      2|		        fraction_place = DBL_DIG - integer_place;
 2622|      2|		} else {
 2623|      0|		    fraction_place = 1;
 2624|      0|		}
 2625|      2|		size = snprintf(work, sizeof(work), "%0.*f",
 2626|      2|				fraction_place, number);
 2627|      2|	    }
 2628|       |
 2629|       |	    /* Remove leading spaces sometimes inserted by snprintf */
 2630|      5|	    while (work[0] == ' ') {
  ------------------
  |  Branch (2630:13): [True: 1, False: 4]
  ------------------
 2631|     21|	        for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);
  ------------------
  |  Branch (2631:30): [True: 20, False: 1]
  ------------------
 2632|      1|		size--;
 2633|      1|	    }
 2634|       |
 2635|       |	    /* Remove fractional trailing zeroes */
 2636|      4|	    after_fraction = work + size;
 2637|      4|	    ptr = after_fraction;
 2638|     32|	    while (*(--ptr) == '0')
  ------------------
  |  Branch (2638:13): [True: 28, False: 4]
  ------------------
 2639|     28|		;
 2640|      4|	    if (*ptr != '.')
  ------------------
  |  Branch (2640:10): [True: 4, False: 0]
  ------------------
 2641|      4|	        ptr++;
 2642|     12|	    while ((*ptr++ = *after_fraction++) != 0);
  ------------------
  |  Branch (2642:13): [True: 8, False: 4]
  ------------------
 2643|       |
 2644|       |	    /* Finally copy result back to caller */
 2645|      4|	    size = strlen(work) + 1;
 2646|      4|	    if (size > buffersize) {
  ------------------
  |  Branch (2646:10): [True: 0, False: 4]
  ------------------
 2647|      0|		work[buffersize - 1] = 0;
 2648|      0|		size = buffersize;
 2649|      0|	    }
 2650|      4|	    memmove(buffer, work, size);
 2651|      4|	}
 2652|      5|	break;
 2653|      5|    }
 2654|      5|}
xpath.c:xmlXPathNewCompExpr:
 1013|    492|xmlXPathNewCompExpr(void) {
 1014|    492|    xmlXPathCompExprPtr cur;
 1015|       |
 1016|    492|    cur = (xmlXPathCompExprPtr) xmlMalloc(sizeof(xmlXPathCompExpr));
 1017|    492|    if (cur == NULL) {
  ------------------
  |  Branch (1017:9): [True: 0, False: 492]
  ------------------
 1018|      0|        xmlXPathErrMemory(NULL, "allocating component\n");
 1019|      0|	return(NULL);
 1020|      0|    }
 1021|    492|    memset(cur, 0, sizeof(xmlXPathCompExpr));
 1022|    492|    cur->maxStep = 10;
 1023|    492|    cur->nbStep = 0;
 1024|    492|    cur->steps = (xmlXPathStepOp *) xmlMalloc(cur->maxStep *
 1025|    492|	                                   sizeof(xmlXPathStepOp));
 1026|    492|    if (cur->steps == NULL) {
  ------------------
  |  Branch (1026:9): [True: 0, False: 492]
  ------------------
 1027|      0|        xmlXPathErrMemory(NULL, "allocating steps\n");
 1028|      0|	xmlFree(cur);
 1029|      0|	return(NULL);
 1030|      0|    }
 1031|    492|    memset(cur->steps, 0, cur->maxStep * sizeof(xmlXPathStepOp));
 1032|    492|    cur->last = -1;
 1033|    492|    return(cur);
 1034|    492|}
xpath.c:xmlXPathNodeValHash:
 5655|     74|xmlXPathNodeValHash(xmlNodePtr node) {
 5656|     74|    int len = 2;
 5657|     74|    const xmlChar * string = NULL;
 5658|     74|    xmlNodePtr tmp = NULL;
 5659|     74|    unsigned int ret = 0;
 5660|       |
 5661|     74|    if (node == NULL)
  ------------------
  |  Branch (5661:9): [True: 0, False: 74]
  ------------------
 5662|      0|	return(0);
 5663|       |
 5664|     74|    if (node->type == XML_DOCUMENT_NODE) {
  ------------------
  |  Branch (5664:9): [True: 0, False: 74]
  ------------------
 5665|      0|	tmp = xmlDocGetRootElement((xmlDocPtr) node);
 5666|      0|	if (tmp == NULL)
  ------------------
  |  Branch (5666:6): [True: 0, False: 0]
  ------------------
 5667|      0|	    node = node->children;
 5668|      0|	else
 5669|      0|	    node = tmp;
 5670|       |
 5671|      0|	if (node == NULL)
  ------------------
  |  Branch (5671:6): [True: 0, False: 0]
  ------------------
 5672|      0|	    return(0);
 5673|      0|    }
 5674|       |
 5675|     74|    switch (node->type) {
 5676|      0|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (5676:2): [True: 0, False: 74]
  ------------------
 5677|      0|	case XML_PI_NODE:
  ------------------
  |  Branch (5677:2): [True: 0, False: 74]
  ------------------
 5678|      0|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5678:2): [True: 0, False: 74]
  ------------------
 5679|      0|	case XML_TEXT_NODE:
  ------------------
  |  Branch (5679:2): [True: 0, False: 74]
  ------------------
 5680|      0|	    string = node->content;
 5681|      0|	    if (string == NULL)
  ------------------
  |  Branch (5681:10): [True: 0, False: 0]
  ------------------
 5682|      0|		return(0);
 5683|      0|	    if (string[0] == 0)
  ------------------
  |  Branch (5683:10): [True: 0, False: 0]
  ------------------
 5684|      0|		return(0);
 5685|      0|	    return(string[0] + (string[1] << 8));
 5686|      0|	case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (5686:2): [True: 0, False: 74]
  ------------------
 5687|      0|	    string = ((xmlNsPtr)node)->href;
 5688|      0|	    if (string == NULL)
  ------------------
  |  Branch (5688:10): [True: 0, False: 0]
  ------------------
 5689|      0|		return(0);
 5690|      0|	    if (string[0] == 0)
  ------------------
  |  Branch (5690:10): [True: 0, False: 0]
  ------------------
 5691|      0|		return(0);
 5692|      0|	    return(string[0] + (string[1] << 8));
 5693|     63|	case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (5693:2): [True: 63, False: 11]
  ------------------
 5694|     63|	    tmp = ((xmlAttrPtr) node)->children;
 5695|     63|	    break;
 5696|     11|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (5696:2): [True: 11, False: 63]
  ------------------
 5697|     11|	    tmp = node->children;
 5698|     11|	    break;
 5699|      0|	default:
  ------------------
  |  Branch (5699:2): [True: 0, False: 74]
  ------------------
 5700|      0|	    return(0);
 5701|     74|    }
 5702|     79|    while (tmp != NULL) {
  ------------------
  |  Branch (5702:12): [True: 79, False: 0]
  ------------------
 5703|     79|	switch (tmp->type) {
 5704|      0|	    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (5704:6): [True: 0, False: 79]
  ------------------
 5705|     75|	    case XML_TEXT_NODE:
  ------------------
  |  Branch (5705:6): [True: 75, False: 4]
  ------------------
 5706|     75|		string = tmp->content;
 5707|     75|		break;
 5708|      4|	    default:
  ------------------
  |  Branch (5708:6): [True: 4, False: 75]
  ------------------
 5709|      4|                string = NULL;
 5710|      4|		break;
 5711|     79|	}
 5712|     79|	if ((string != NULL) && (string[0] != 0)) {
  ------------------
  |  Branch (5712:6): [True: 75, False: 4]
  |  Branch (5712:26): [True: 75, False: 0]
  ------------------
 5713|     75|	    if (len == 1) {
  ------------------
  |  Branch (5713:10): [True: 1, False: 74]
  ------------------
 5714|      1|		return(ret + (string[0] << 8));
 5715|      1|	    }
 5716|     74|	    if (string[1] == 0) {
  ------------------
  |  Branch (5716:10): [True: 1, False: 73]
  ------------------
 5717|      1|		len = 1;
 5718|      1|		ret = string[0];
 5719|     73|	    } else {
 5720|     73|		return(string[0] + (string[1] << 8));
 5721|     73|	    }
 5722|     74|	}
 5723|       |	/*
 5724|       |	 * Skip to next node
 5725|       |	 */
 5726|      5|        if ((tmp->children != NULL) &&
  ------------------
  |  Branch (5726:13): [True: 3, False: 2]
  ------------------
 5727|      5|            (tmp->type != XML_DTD_NODE) &&
  ------------------
  |  Branch (5727:13): [True: 3, False: 0]
  ------------------
 5728|      5|            (tmp->type != XML_ENTITY_REF_NODE) &&
  ------------------
  |  Branch (5728:13): [True: 3, False: 0]
  ------------------
 5729|      5|            (tmp->children->type != XML_ENTITY_DECL)) {
  ------------------
  |  Branch (5729:13): [True: 3, False: 0]
  ------------------
 5730|      3|            tmp = tmp->children;
 5731|      3|            continue;
 5732|      3|	}
 5733|      2|	if (tmp == node)
  ------------------
  |  Branch (5733:6): [True: 0, False: 2]
  ------------------
 5734|      0|	    break;
 5735|       |
 5736|      2|	if (tmp->next != NULL) {
  ------------------
  |  Branch (5736:6): [True: 2, False: 0]
  ------------------
 5737|      2|	    tmp = tmp->next;
 5738|      2|	    continue;
 5739|      2|	}
 5740|       |
 5741|      0|	do {
 5742|      0|	    tmp = tmp->parent;
 5743|      0|	    if (tmp == NULL)
  ------------------
  |  Branch (5743:10): [True: 0, False: 0]
  ------------------
 5744|      0|		break;
 5745|      0|	    if (tmp == node) {
  ------------------
  |  Branch (5745:10): [True: 0, False: 0]
  ------------------
 5746|      0|		tmp = NULL;
 5747|      0|		break;
 5748|      0|	    }
 5749|      0|	    if (tmp->next != NULL) {
  ------------------
  |  Branch (5749:10): [True: 0, False: 0]
  ------------------
 5750|      0|		tmp = tmp->next;
 5751|      0|		break;
 5752|      0|	    }
 5753|      0|	} while (tmp != NULL);
  ------------------
  |  Branch (5753:11): [True: 0, False: 0]
  ------------------
 5754|      0|    }
 5755|      0|    return(ret);
 5756|     74|}
xpath.c:xmlXPathEqualNodeSetString:
 6058|    236|{
 6059|    236|    int i;
 6060|    236|    xmlNodeSetPtr ns;
 6061|    236|    xmlChar *str2;
 6062|    236|    unsigned int hash;
 6063|       |
 6064|    236|    if ((str == NULL) || (arg == NULL) ||
  ------------------
  |  Branch (6064:9): [True: 0, False: 236]
  |  Branch (6064:26): [True: 0, False: 236]
  ------------------
 6065|    236|        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))
  ------------------
  |  Branch (6065:10): [True: 0, False: 236]
  |  Branch (6065:42): [True: 0, False: 0]
  ------------------
 6066|      0|        return (0);
 6067|    236|    ns = arg->nodesetval;
 6068|       |    /*
 6069|       |     * A NULL nodeset compared with a string is always false
 6070|       |     * (since there is no node equal, and no node not equal)
 6071|       |     */
 6072|    236|    if ((ns == NULL) || (ns->nodeNr <= 0) )
  ------------------
  |  Branch (6072:9): [True: 0, False: 236]
  |  Branch (6072:25): [True: 162, False: 74]
  ------------------
 6073|    162|        return (0);
 6074|     74|    hash = xmlXPathStringHash(str);
 6075|    134|    for (i = 0; i < ns->nodeNr; i++) {
  ------------------
  |  Branch (6075:17): [True: 74, False: 60]
  ------------------
 6076|     74|        if (xmlXPathNodeValHash(ns->nodeTab[i]) == hash) {
  ------------------
  |  Branch (6076:13): [True: 47, False: 27]
  ------------------
 6077|     47|            str2 = xmlNodeGetContent(ns->nodeTab[i]);
 6078|     47|            if ((str2 != NULL) && (xmlStrEqual(str, str2))) {
  ------------------
  |  Branch (6078:17): [True: 47, False: 0]
  |  Branch (6078:35): [True: 14, False: 33]
  ------------------
 6079|     14|                xmlFree(str2);
 6080|     14|		if (neq)
  ------------------
  |  Branch (6080:7): [True: 0, False: 14]
  ------------------
 6081|      0|		    continue;
 6082|     14|                return (1);
 6083|     33|	    } else if ((str2 == NULL) && (xmlStrEqual(str, BAD_CAST ""))) {
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (6083:17): [True: 0, False: 33]
  |  Branch (6083:35): [True: 0, False: 0]
  ------------------
 6084|      0|		if (neq)
  ------------------
  |  Branch (6084:7): [True: 0, False: 0]
  ------------------
 6085|      0|		    continue;
 6086|      0|                return (1);
 6087|     33|            } else if (neq) {
  ------------------
  |  Branch (6087:24): [True: 0, False: 33]
  ------------------
 6088|      0|		if (str2 != NULL)
  ------------------
  |  Branch (6088:7): [True: 0, False: 0]
  ------------------
 6089|      0|		    xmlFree(str2);
 6090|      0|		return (1);
 6091|      0|	    }
 6092|     33|            if (str2 != NULL)
  ------------------
  |  Branch (6092:17): [True: 33, False: 0]
  ------------------
 6093|     33|                xmlFree(str2);
 6094|     33|        } else if (neq)
  ------------------
  |  Branch (6094:20): [True: 0, False: 27]
  ------------------
 6095|      0|	    return (1);
 6096|     74|    }
 6097|     60|    return (0);
 6098|     74|}
xpath.c:xmlXPathStringHash:
 5768|     74|xmlXPathStringHash(const xmlChar * string) {
 5769|     74|    if (string == NULL)
  ------------------
  |  Branch (5769:9): [True: 0, False: 74]
  ------------------
 5770|      0|	return(0);
 5771|     74|    if (string[0] == 0)
  ------------------
  |  Branch (5771:9): [True: 0, False: 74]
  ------------------
 5772|      0|	return(0);
 5773|     74|    return(string[0] + (string[1] << 8));
 5774|     74|}
xpath.c:xmlXPathEqualValuesCommon:
 6283|     55|  xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {
 6284|     55|    int ret = 0;
 6285|       |    /*
 6286|       |     *At this point we are assured neither arg1 nor arg2
 6287|       |     *is a nodeset, so we can just pick the appropriate routine.
 6288|       |     */
 6289|     55|    switch (arg1->type) {
  ------------------
  |  Branch (6289:13): [True: 0, False: 55]
  ------------------
 6290|      0|        case XPATH_UNDEFINED:
  ------------------
  |  Branch (6290:9): [True: 0, False: 55]
  ------------------
 6291|      0|	    break;
 6292|     13|        case XPATH_BOOLEAN:
  ------------------
  |  Branch (6292:9): [True: 13, False: 42]
  ------------------
 6293|     13|	    switch (arg2->type) {
  ------------------
  |  Branch (6293:14): [True: 0, False: 13]
  ------------------
 6294|      0|	        case XPATH_UNDEFINED:
  ------------------
  |  Branch (6294:10): [True: 0, False: 13]
  ------------------
 6295|      0|		    break;
 6296|      4|		case XPATH_BOOLEAN:
  ------------------
  |  Branch (6296:3): [True: 4, False: 9]
  ------------------
 6297|      4|		    ret = (arg1->boolval == arg2->boolval);
 6298|      4|		    break;
 6299|      6|		case XPATH_NUMBER:
  ------------------
  |  Branch (6299:3): [True: 6, False: 7]
  ------------------
 6300|      6|		    ret = (arg1->boolval ==
 6301|      6|			   xmlXPathCastNumberToBoolean(arg2->floatval));
 6302|      6|		    break;
 6303|      3|		case XPATH_STRING:
  ------------------
  |  Branch (6303:3): [True: 3, False: 10]
  ------------------
 6304|      3|		    if ((arg2->stringval == NULL) ||
  ------------------
  |  Branch (6304:11): [True: 0, False: 3]
  ------------------
 6305|      3|			(arg2->stringval[0] == 0)) ret = 0;
  ------------------
  |  Branch (6305:4): [True: 0, False: 3]
  ------------------
 6306|      3|		    else
 6307|      3|			ret = 1;
 6308|      3|		    ret = (arg1->boolval == ret);
 6309|      3|		    break;
 6310|      0|		case XPATH_USERS:
  ------------------
  |  Branch (6310:3): [True: 0, False: 13]
  ------------------
 6311|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6312|       |		case XPATH_POINT:
 6313|       |		case XPATH_RANGE:
 6314|       |		case XPATH_LOCATIONSET:
 6315|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6316|      0|		    TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6317|      0|		    break;
 6318|      0|		case XPATH_NODESET:
  ------------------
  |  Branch (6318:3): [True: 0, False: 13]
  ------------------
 6319|      0|		case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6319:3): [True: 0, False: 13]
  ------------------
 6320|      0|		    break;
 6321|     13|	    }
 6322|     13|	    break;
 6323|     34|        case XPATH_NUMBER:
  ------------------
  |  Branch (6323:9): [True: 34, False: 21]
  ------------------
 6324|     34|	    switch (arg2->type) {
  ------------------
  |  Branch (6324:14): [True: 0, False: 34]
  ------------------
 6325|      0|	        case XPATH_UNDEFINED:
  ------------------
  |  Branch (6325:10): [True: 0, False: 34]
  ------------------
 6326|      0|		    break;
 6327|      4|		case XPATH_BOOLEAN:
  ------------------
  |  Branch (6327:3): [True: 4, False: 30]
  ------------------
 6328|      4|		    ret = (arg2->boolval==
 6329|      4|			   xmlXPathCastNumberToBoolean(arg1->floatval));
 6330|      4|		    break;
 6331|      1|		case XPATH_STRING:
  ------------------
  |  Branch (6331:3): [True: 1, False: 33]
  ------------------
 6332|      1|		    valuePush(ctxt, arg2);
 6333|      1|		    xmlXPathNumberFunction(ctxt, 1);
 6334|      1|		    arg2 = valuePop(ctxt);
 6335|      1|                    if (ctxt->error)
  ------------------
  |  Branch (6335:25): [True: 0, False: 1]
  ------------------
 6336|      0|                        break;
 6337|       |                    /* Falls through. */
 6338|     30|		case XPATH_NUMBER:
  ------------------
  |  Branch (6338:3): [True: 29, False: 5]
  ------------------
 6339|       |		    /* Hand check NaN and Infinity equalities */
 6340|     30|		    if (xmlXPathIsNaN(arg1->floatval) ||
  ------------------
  |  Branch (6340:11): [True: 3, False: 27]
  ------------------
 6341|     30|			    xmlXPathIsNaN(arg2->floatval)) {
  ------------------
  |  Branch (6341:8): [True: 0, False: 27]
  ------------------
 6342|      3|		        ret = 0;
 6343|     27|		    } else if (xmlXPathIsInf(arg1->floatval) == 1) {
  ------------------
  |  Branch (6343:18): [True: 4, False: 23]
  ------------------
 6344|      4|		        if (xmlXPathIsInf(arg2->floatval) == 1)
  ------------------
  |  Branch (6344:15): [True: 2, False: 2]
  ------------------
 6345|      2|			    ret = 1;
 6346|      2|			else
 6347|      2|			    ret = 0;
 6348|     23|		    } else if (xmlXPathIsInf(arg1->floatval) == -1) {
  ------------------
  |  Branch (6348:18): [True: 1, False: 22]
  ------------------
 6349|      1|			if (xmlXPathIsInf(arg2->floatval) == -1)
  ------------------
  |  Branch (6349:8): [True: 1, False: 0]
  ------------------
 6350|      1|			    ret = 1;
 6351|      0|			else
 6352|      0|			    ret = 0;
 6353|     22|		    } else if (xmlXPathIsInf(arg2->floatval) == 1) {
  ------------------
  |  Branch (6353:18): [True: 0, False: 22]
  ------------------
 6354|      0|			if (xmlXPathIsInf(arg1->floatval) == 1)
  ------------------
  |  Branch (6354:8): [True: 0, False: 0]
  ------------------
 6355|      0|			    ret = 1;
 6356|      0|			else
 6357|      0|			    ret = 0;
 6358|     22|		    } else if (xmlXPathIsInf(arg2->floatval) == -1) {
  ------------------
  |  Branch (6358:18): [True: 0, False: 22]
  ------------------
 6359|      0|			if (xmlXPathIsInf(arg1->floatval) == -1)
  ------------------
  |  Branch (6359:8): [True: 0, False: 0]
  ------------------
 6360|      0|			    ret = 1;
 6361|      0|			else
 6362|      0|			    ret = 0;
 6363|     22|		    } else {
 6364|     22|		        ret = (arg1->floatval == arg2->floatval);
 6365|     22|		    }
 6366|     30|		    break;
 6367|      0|		case XPATH_USERS:
  ------------------
  |  Branch (6367:3): [True: 0, False: 34]
  ------------------
 6368|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6369|       |		case XPATH_POINT:
 6370|       |		case XPATH_RANGE:
 6371|       |		case XPATH_LOCATIONSET:
 6372|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6373|      0|		    TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6374|      0|		    break;
 6375|      0|		case XPATH_NODESET:
  ------------------
  |  Branch (6375:3): [True: 0, False: 34]
  ------------------
 6376|      0|		case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6376:3): [True: 0, False: 34]
  ------------------
 6377|      0|		    break;
 6378|     34|	    }
 6379|     34|	    break;
 6380|     34|        case XPATH_STRING:
  ------------------
  |  Branch (6380:9): [True: 8, False: 47]
  ------------------
 6381|      8|	    switch (arg2->type) {
  ------------------
  |  Branch (6381:14): [True: 0, False: 8]
  ------------------
 6382|      0|	        case XPATH_UNDEFINED:
  ------------------
  |  Branch (6382:10): [True: 0, False: 8]
  ------------------
 6383|      0|		    break;
 6384|      2|		case XPATH_BOOLEAN:
  ------------------
  |  Branch (6384:3): [True: 2, False: 6]
  ------------------
 6385|      2|		    if ((arg1->stringval == NULL) ||
  ------------------
  |  Branch (6385:11): [True: 0, False: 2]
  ------------------
 6386|      2|			(arg1->stringval[0] == 0)) ret = 0;
  ------------------
  |  Branch (6386:4): [True: 0, False: 2]
  ------------------
 6387|      2|		    else
 6388|      2|			ret = 1;
 6389|      2|		    ret = (arg2->boolval == ret);
 6390|      2|		    break;
 6391|      4|		case XPATH_STRING:
  ------------------
  |  Branch (6391:3): [True: 4, False: 4]
  ------------------
 6392|      4|		    ret = xmlStrEqual(arg1->stringval, arg2->stringval);
 6393|      4|		    break;
 6394|      2|		case XPATH_NUMBER:
  ------------------
  |  Branch (6394:3): [True: 2, False: 6]
  ------------------
 6395|      2|		    valuePush(ctxt, arg1);
 6396|      2|		    xmlXPathNumberFunction(ctxt, 1);
 6397|      2|		    arg1 = valuePop(ctxt);
 6398|      2|                    if (ctxt->error)
  ------------------
  |  Branch (6398:25): [True: 0, False: 2]
  ------------------
 6399|      0|                        break;
 6400|       |		    /* Hand check NaN and Infinity equalities */
 6401|      2|		    if (xmlXPathIsNaN(arg1->floatval) ||
  ------------------
  |  Branch (6401:11): [True: 2, False: 0]
  ------------------
 6402|      2|			    xmlXPathIsNaN(arg2->floatval)) {
  ------------------
  |  Branch (6402:8): [True: 0, False: 0]
  ------------------
 6403|      2|		        ret = 0;
 6404|      2|		    } else if (xmlXPathIsInf(arg1->floatval) == 1) {
  ------------------
  |  Branch (6404:18): [True: 0, False: 0]
  ------------------
 6405|      0|			if (xmlXPathIsInf(arg2->floatval) == 1)
  ------------------
  |  Branch (6405:8): [True: 0, False: 0]
  ------------------
 6406|      0|			    ret = 1;
 6407|      0|			else
 6408|      0|			    ret = 0;
 6409|      0|		    } else if (xmlXPathIsInf(arg1->floatval) == -1) {
  ------------------
  |  Branch (6409:18): [True: 0, False: 0]
  ------------------
 6410|      0|			if (xmlXPathIsInf(arg2->floatval) == -1)
  ------------------
  |  Branch (6410:8): [True: 0, False: 0]
  ------------------
 6411|      0|			    ret = 1;
 6412|      0|			else
 6413|      0|			    ret = 0;
 6414|      0|		    } else if (xmlXPathIsInf(arg2->floatval) == 1) {
  ------------------
  |  Branch (6414:18): [True: 0, False: 0]
  ------------------
 6415|      0|			if (xmlXPathIsInf(arg1->floatval) == 1)
  ------------------
  |  Branch (6415:8): [True: 0, False: 0]
  ------------------
 6416|      0|			    ret = 1;
 6417|      0|			else
 6418|      0|			    ret = 0;
 6419|      0|		    } else if (xmlXPathIsInf(arg2->floatval) == -1) {
  ------------------
  |  Branch (6419:18): [True: 0, False: 0]
  ------------------
 6420|      0|			if (xmlXPathIsInf(arg1->floatval) == -1)
  ------------------
  |  Branch (6420:8): [True: 0, False: 0]
  ------------------
 6421|      0|			    ret = 1;
 6422|      0|			else
 6423|      0|			    ret = 0;
 6424|      0|		    } else {
 6425|      0|		        ret = (arg1->floatval == arg2->floatval);
 6426|      0|		    }
 6427|      2|		    break;
 6428|      0|		case XPATH_USERS:
  ------------------
  |  Branch (6428:3): [True: 0, False: 8]
  ------------------
 6429|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6430|       |		case XPATH_POINT:
 6431|       |		case XPATH_RANGE:
 6432|       |		case XPATH_LOCATIONSET:
 6433|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6434|      0|		    TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6435|      0|		    break;
 6436|      0|		case XPATH_NODESET:
  ------------------
  |  Branch (6436:3): [True: 0, False: 8]
  ------------------
 6437|      0|		case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6437:3): [True: 0, False: 8]
  ------------------
 6438|      0|		    break;
 6439|      8|	    }
 6440|      8|	    break;
 6441|      8|        case XPATH_USERS:
  ------------------
  |  Branch (6441:9): [True: 0, False: 55]
  ------------------
 6442|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 6443|       |	case XPATH_POINT:
 6444|       |	case XPATH_RANGE:
 6445|       |	case XPATH_LOCATIONSET:
 6446|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 6447|      0|	    TODO
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 6448|      0|	    break;
 6449|      0|	case XPATH_NODESET:
  ------------------
  |  Branch (6449:2): [True: 0, False: 55]
  ------------------
 6450|      0|	case XPATH_XSLT_TREE:
  ------------------
  |  Branch (6450:2): [True: 0, False: 55]
  ------------------
 6451|      0|	    break;
 6452|     55|    }
 6453|     55|    xmlXPathReleaseObject(ctxt->context, arg1);
 6454|     55|    xmlXPathReleaseObject(ctxt->context, arg2);
 6455|     55|    return(ret);
 6456|     55|}
xpath.c:xmlXPathCacheNewNodeSet:
 1903|    398|{
 1904|    398|    if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (1904:9): [True: 398, False: 0]
  |  Branch (1904:27): [True: 0, False: 398]
  ------------------
 1905|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 1906|       |
 1907|      0|	if ((cache->nodesetObjs != NULL) &&
  ------------------
  |  Branch (1907:6): [True: 0, False: 0]
  ------------------
 1908|      0|	    (cache->nodesetObjs->number != 0))
  ------------------
  |  Branch (1908:6): [True: 0, False: 0]
  ------------------
 1909|      0|	{
 1910|      0|	    xmlXPathObjectPtr ret;
 1911|       |	    /*
 1912|       |	    * Use the nodeset-cache.
 1913|       |	    */
 1914|      0|	    ret = (xmlXPathObjectPtr)
 1915|      0|		cache->nodesetObjs->items[--cache->nodesetObjs->number];
 1916|      0|	    ret->type = XPATH_NODESET;
 1917|      0|	    ret->boolval = 0;
 1918|      0|	    if (val) {
  ------------------
  |  Branch (1918:10): [True: 0, False: 0]
  ------------------
 1919|      0|		if ((ret->nodesetval->nodeMax == 0) ||
  ------------------
  |  Branch (1919:7): [True: 0, False: 0]
  ------------------
 1920|      0|		    (val->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (1920:7): [True: 0, False: 0]
  ------------------
 1921|      0|		{
 1922|       |                    /* TODO: Check memory error. */
 1923|      0|		    xmlXPathNodeSetAddUnique(ret->nodesetval, val);
 1924|      0|		} else {
 1925|      0|		    ret->nodesetval->nodeTab[0] = val;
 1926|      0|		    ret->nodesetval->nodeNr = 1;
 1927|      0|		}
 1928|      0|	    }
 1929|      0|	    return(ret);
 1930|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1930:13): [True: 0, False: 0]
  ------------------
 1931|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1931:6): [True: 0, False: 0]
  ------------------
 1932|      0|	{
 1933|      0|	    xmlXPathObjectPtr ret;
 1934|      0|            xmlNodeSetPtr set;
 1935|       |	    /*
 1936|       |	    * Fallback to misc-cache.
 1937|       |	    */
 1938|       |
 1939|      0|	    set = xmlXPathNodeSetCreate(val);
 1940|      0|	    if (set == NULL) {
  ------------------
  |  Branch (1940:10): [True: 0, False: 0]
  ------------------
 1941|      0|		ctxt->lastError.domain = XML_FROM_XPATH;
 1942|      0|		ctxt->lastError.code = XML_ERR_NO_MEMORY;
 1943|      0|		return(NULL);
 1944|      0|	    }
 1945|       |
 1946|      0|	    ret = (xmlXPathObjectPtr)
 1947|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 1948|       |
 1949|      0|	    ret->type = XPATH_NODESET;
 1950|      0|	    ret->boolval = 0;
 1951|      0|	    ret->nodesetval = set;
 1952|      0|	    return(ret);
 1953|      0|	}
 1954|      0|    }
 1955|    398|    return(xmlXPathNewNodeSet(val));
 1956|    398|}
xpath.c:xmlXPathCacheNewFloat:
 2088|    562|{
 2089|    562|     if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (2089:10): [True: 562, False: 0]
  |  Branch (2089:28): [True: 0, False: 562]
  ------------------
 2090|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 2091|       |
 2092|      0|	if ((cache->numberObjs != NULL) &&
  ------------------
  |  Branch (2092:6): [True: 0, False: 0]
  ------------------
 2093|      0|	    (cache->numberObjs->number != 0))
  ------------------
  |  Branch (2093:6): [True: 0, False: 0]
  ------------------
 2094|      0|	{
 2095|      0|	    xmlXPathObjectPtr ret;
 2096|       |
 2097|      0|	    ret = (xmlXPathObjectPtr)
 2098|      0|		cache->numberObjs->items[--cache->numberObjs->number];
 2099|      0|	    ret->type = XPATH_NUMBER;
 2100|      0|	    ret->floatval = val;
 2101|      0|	    return(ret);
 2102|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (2102:13): [True: 0, False: 0]
  ------------------
 2103|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (2103:6): [True: 0, False: 0]
  ------------------
 2104|      0|	{
 2105|      0|	    xmlXPathObjectPtr ret;
 2106|       |
 2107|      0|	    ret = (xmlXPathObjectPtr)
 2108|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 2109|       |
 2110|      0|	    ret->type = XPATH_NUMBER;
 2111|      0|	    ret->floatval = val;
 2112|      0|	    return(ret);
 2113|      0|	}
 2114|      0|    }
 2115|    562|    return(xmlXPathNewFloat(val));
 2116|    562|}
xpath.c:xmlXPathGetElementsByIds:
 7837|     43|xmlXPathGetElementsByIds (xmlDocPtr doc, const xmlChar *ids) {
 7838|     43|    xmlNodeSetPtr ret;
 7839|     43|    const xmlChar *cur = ids;
 7840|     43|    xmlChar *ID;
 7841|     43|    xmlAttrPtr attr;
 7842|     43|    xmlNodePtr elem = NULL;
 7843|       |
 7844|     43|    if (ids == NULL) return(NULL);
  ------------------
  |  Branch (7844:9): [True: 0, False: 43]
  ------------------
 7845|       |
 7846|     43|    ret = xmlXPathNodeSetCreate(NULL);
 7847|     43|    if (ret == NULL)
  ------------------
  |  Branch (7847:9): [True: 0, False: 43]
  ------------------
 7848|      0|        return(ret);
 7849|       |
 7850|     43|    while (IS_BLANK_CH(*cur)) cur++;
 7851|     86|    while (*cur != 0) {
  ------------------
  |  Branch (7851:12): [True: 43, False: 43]
  ------------------
 7852|    338|	while ((!IS_BLANK_CH(*cur)) && (*cur != 0))
  ------------------
  |  |  151|    338|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    338|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 338]
  |  |  |  |  ------------------
  |  |  |  |   89|    338|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 295, False: 43]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 295]
  |  |  |  |  ------------------
  |  |  |  |   90|    338|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 338]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (7852:33): [True: 295, False: 43]
  ------------------
 7853|    295|	    cur++;
 7854|       |
 7855|     43|        ID = xmlStrndup(ids, cur - ids);
 7856|     43|	if (ID != NULL) {
  ------------------
  |  Branch (7856:6): [True: 43, False: 0]
  ------------------
 7857|       |	    /*
 7858|       |	     * We used to check the fact that the value passed
 7859|       |	     * was an NCName, but this generated much troubles for
 7860|       |	     * me and Aleksey Sanin, people blatantly violated that
 7861|       |	     * constraint, like Visa3D spec.
 7862|       |	     * if (xmlValidateNCName(ID, 1) == 0)
 7863|       |	     */
 7864|     43|	    attr = xmlGetID(doc, ID);
 7865|     43|	    if (attr != NULL) {
  ------------------
  |  Branch (7865:10): [True: 15, False: 28]
  ------------------
 7866|     15|		if (attr->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (7866:7): [True: 15, False: 0]
  ------------------
 7867|     15|		    elem = attr->parent;
 7868|      0|		else if (attr->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7868:12): [True: 0, False: 0]
  ------------------
 7869|      0|		    elem = (xmlNodePtr) attr;
 7870|      0|		else
 7871|      0|		    elem = NULL;
 7872|       |                /* TODO: Check memory error. */
 7873|     15|		if (elem != NULL)
  ------------------
  |  Branch (7873:7): [True: 15, False: 0]
  ------------------
 7874|     15|		    xmlXPathNodeSetAdd(ret, elem);
 7875|     15|	    }
 7876|     43|	    xmlFree(ID);
 7877|     43|	}
 7878|       |
 7879|     43|	while (IS_BLANK_CH(*cur)) cur++;
 7880|     43|	ids = cur;
 7881|     43|    }
 7882|     43|    return(ret);
 7883|     43|}
xpath.c:xmlXPathCacheWrapNodeSet:
 1823|    536|{
 1824|    536|    if ((ctxt != NULL) && (ctxt->cache != NULL)) {
  ------------------
  |  Branch (1824:9): [True: 536, False: 0]
  |  Branch (1824:27): [True: 0, False: 536]
  ------------------
 1825|      0|	xmlXPathContextCachePtr cache =
 1826|      0|	    (xmlXPathContextCachePtr) ctxt->cache;
 1827|       |
 1828|      0|	if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1828:6): [True: 0, False: 0]
  ------------------
 1829|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1829:6): [True: 0, False: 0]
  ------------------
 1830|      0|	{
 1831|      0|	    xmlXPathObjectPtr ret;
 1832|       |
 1833|      0|	    ret = (xmlXPathObjectPtr)
 1834|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 1835|      0|	    ret->type = XPATH_NODESET;
 1836|      0|	    ret->nodesetval = val;
 1837|      0|	    return(ret);
 1838|      0|	}
 1839|      0|    }
 1840|       |
 1841|    536|    return(xmlXPathWrapNodeSet(val));
 1842|       |
 1843|    536|}
xpath.c:xmlXPathCacheConvertString:
 2131|     50|xmlXPathCacheConvertString(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {
 2132|     50|    xmlChar *res = NULL;
 2133|       |
 2134|     50|    if (val == NULL)
  ------------------
  |  Branch (2134:9): [True: 0, False: 50]
  ------------------
 2135|      0|	return(xmlXPathCacheNewCString(ctxt, ""));
 2136|       |
 2137|     50|    switch (val->type) {
  ------------------
  |  Branch (2137:13): [True: 0, False: 50]
  ------------------
 2138|      0|    case XPATH_UNDEFINED:
  ------------------
  |  Branch (2138:5): [True: 0, False: 50]
  ------------------
 2139|      0|	break;
 2140|      0|    case XPATH_NODESET:
  ------------------
  |  Branch (2140:5): [True: 0, False: 50]
  ------------------
 2141|      0|    case XPATH_XSLT_TREE:
  ------------------
  |  Branch (2141:5): [True: 0, False: 50]
  ------------------
 2142|      0|	res = xmlXPathCastNodeSetToString(val->nodesetval);
 2143|      0|	break;
 2144|     43|    case XPATH_STRING:
  ------------------
  |  Branch (2144:5): [True: 43, False: 7]
  ------------------
 2145|     43|	return(val);
 2146|      2|    case XPATH_BOOLEAN:
  ------------------
  |  Branch (2146:5): [True: 2, False: 48]
  ------------------
 2147|      2|	res = xmlXPathCastBooleanToString(val->boolval);
 2148|      2|	break;
 2149|      5|    case XPATH_NUMBER:
  ------------------
  |  Branch (2149:5): [True: 5, False: 45]
  ------------------
 2150|      5|	res = xmlXPathCastNumberToString(val->floatval);
 2151|      5|	break;
 2152|      0|    case XPATH_USERS:
  ------------------
  |  Branch (2152:5): [True: 0, False: 50]
  ------------------
 2153|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 2154|       |    case XPATH_POINT:
 2155|       |    case XPATH_RANGE:
 2156|       |    case XPATH_LOCATIONSET:
 2157|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
 2158|      0|	TODO;
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
 2159|      0|	break;
 2160|     50|    }
 2161|      7|    xmlXPathReleaseObject(ctxt, val);
 2162|      7|    if (res == NULL)
  ------------------
  |  Branch (2162:9): [True: 0, False: 7]
  ------------------
 2163|      0|	return(xmlXPathCacheNewCString(ctxt, ""));
 2164|      7|    return(xmlXPathCacheWrapString(ctxt, res));
 2165|      7|}
xpath.c:xmlXPathCacheNewCString:
 2030|      7|{
 2031|      7|    return xmlXPathCacheNewString(ctxt, BAD_CAST val);
  ------------------
  |  |   35|      7|#define BAD_CAST (xmlChar *)
  ------------------
 2032|      7|}
xpath.c:xmlXPathCacheNewString:
 1970|    205|{
 1971|    205|    if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (1971:9): [True: 205, False: 0]
  |  Branch (1971:27): [True: 0, False: 205]
  ------------------
 1972|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 1973|       |
 1974|      0|	if ((cache->stringObjs != NULL) &&
  ------------------
  |  Branch (1974:6): [True: 0, False: 0]
  ------------------
 1975|      0|	    (cache->stringObjs->number != 0))
  ------------------
  |  Branch (1975:6): [True: 0, False: 0]
  ------------------
 1976|      0|	{
 1977|      0|	    xmlXPathObjectPtr ret;
 1978|      0|            xmlChar *copy;
 1979|       |
 1980|      0|            if (val == NULL)
  ------------------
  |  Branch (1980:17): [True: 0, False: 0]
  ------------------
 1981|      0|                val = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 1982|      0|            copy = xmlStrdup(val);
 1983|      0|            if (copy == NULL) {
  ------------------
  |  Branch (1983:17): [True: 0, False: 0]
  ------------------
 1984|      0|                xmlXPathErrMemory(ctxt, NULL);
 1985|      0|                return(NULL);
 1986|      0|            }
 1987|       |
 1988|      0|	    ret = (xmlXPathObjectPtr)
 1989|      0|		cache->stringObjs->items[--cache->stringObjs->number];
 1990|      0|	    ret->type = XPATH_STRING;
 1991|      0|            ret->stringval = copy;
 1992|      0|	    return(ret);
 1993|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1993:13): [True: 0, False: 0]
  ------------------
 1994|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1994:6): [True: 0, False: 0]
  ------------------
 1995|      0|	{
 1996|      0|	    xmlXPathObjectPtr ret;
 1997|      0|            xmlChar *copy;
 1998|       |
 1999|      0|            if (val == NULL)
  ------------------
  |  Branch (1999:17): [True: 0, False: 0]
  ------------------
 2000|      0|                val = BAD_CAST "";
  ------------------
  |  |   35|      0|#define BAD_CAST (xmlChar *)
  ------------------
 2001|      0|            copy = xmlStrdup(val);
 2002|      0|            if (copy == NULL) {
  ------------------
  |  Branch (2002:17): [True: 0, False: 0]
  ------------------
 2003|      0|                xmlXPathErrMemory(ctxt, NULL);
 2004|      0|                return(NULL);
 2005|      0|            }
 2006|       |
 2007|      0|	    ret = (xmlXPathObjectPtr)
 2008|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 2009|       |
 2010|      0|	    ret->type = XPATH_STRING;
 2011|      0|            ret->stringval = copy;
 2012|      0|	    return(ret);
 2013|      0|	}
 2014|      0|    }
 2015|    205|    return(xmlXPathNewString(val));
 2016|    205|}
xpath.c:xmlXPathCacheWrapString:
 1857|      7|{
 1858|      7|    if ((ctxt != NULL) && (ctxt->cache != NULL)) {
  ------------------
  |  Branch (1858:9): [True: 7, False: 0]
  |  Branch (1858:27): [True: 0, False: 7]
  ------------------
 1859|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 1860|       |
 1861|      0|	if ((cache->stringObjs != NULL) &&
  ------------------
  |  Branch (1861:6): [True: 0, False: 0]
  ------------------
 1862|      0|	    (cache->stringObjs->number != 0))
  ------------------
  |  Branch (1862:6): [True: 0, False: 0]
  ------------------
 1863|      0|	{
 1864|       |
 1865|      0|	    xmlXPathObjectPtr ret;
 1866|       |
 1867|      0|	    ret = (xmlXPathObjectPtr)
 1868|      0|		cache->stringObjs->items[--cache->stringObjs->number];
 1869|      0|	    ret->type = XPATH_STRING;
 1870|      0|	    ret->stringval = val;
 1871|      0|	    return(ret);
 1872|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (1872:13): [True: 0, False: 0]
  ------------------
 1873|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (1873:6): [True: 0, False: 0]
  ------------------
 1874|      0|	{
 1875|      0|	    xmlXPathObjectPtr ret;
 1876|       |	    /*
 1877|       |	    * Fallback to misc-cache.
 1878|       |	    */
 1879|      0|	    ret = (xmlXPathObjectPtr)
 1880|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 1881|       |
 1882|      0|	    ret->type = XPATH_STRING;
 1883|      0|	    ret->stringval = val;
 1884|      0|	    return(ret);
 1885|      0|	}
 1886|      0|    }
 1887|      7|    return(xmlXPathWrapString(val));
 1888|      7|}
xpath.c:xmlXPathCacheNewBoolean:
 2046|    604|{
 2047|    604|    if ((ctxt != NULL) && (ctxt->cache)) {
  ------------------
  |  Branch (2047:9): [True: 604, False: 0]
  |  Branch (2047:27): [True: 0, False: 604]
  ------------------
 2048|      0|	xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;
 2049|       |
 2050|      0|	if ((cache->booleanObjs != NULL) &&
  ------------------
  |  Branch (2050:6): [True: 0, False: 0]
  ------------------
 2051|      0|	    (cache->booleanObjs->number != 0))
  ------------------
  |  Branch (2051:6): [True: 0, False: 0]
  ------------------
 2052|      0|	{
 2053|      0|	    xmlXPathObjectPtr ret;
 2054|       |
 2055|      0|	    ret = (xmlXPathObjectPtr)
 2056|      0|		cache->booleanObjs->items[--cache->booleanObjs->number];
 2057|      0|	    ret->type = XPATH_BOOLEAN;
 2058|      0|	    ret->boolval = (val != 0);
 2059|      0|	    return(ret);
 2060|      0|	} else if ((cache->miscObjs != NULL) &&
  ------------------
  |  Branch (2060:13): [True: 0, False: 0]
  ------------------
 2061|      0|	    (cache->miscObjs->number != 0))
  ------------------
  |  Branch (2061:6): [True: 0, False: 0]
  ------------------
 2062|      0|	{
 2063|      0|	    xmlXPathObjectPtr ret;
 2064|       |
 2065|      0|	    ret = (xmlXPathObjectPtr)
 2066|      0|		cache->miscObjs->items[--cache->miscObjs->number];
 2067|       |
 2068|      0|	    ret->type = XPATH_BOOLEAN;
 2069|      0|	    ret->boolval = (val != 0);
 2070|      0|	    return(ret);
 2071|      0|	}
 2072|      0|    }
 2073|    604|    return(xmlXPathNewBoolean(val));
 2074|    604|}
xpath.c:xmlXPathCacheConvertNumber:
 2237|     57|xmlXPathCacheConvertNumber(xmlXPathContextPtr ctxt, xmlXPathObjectPtr val) {
 2238|     57|    xmlXPathObjectPtr ret;
 2239|       |
 2240|     57|    if (val == NULL)
  ------------------
  |  Branch (2240:9): [True: 0, False: 57]
  ------------------
 2241|      0|	return(xmlXPathCacheNewFloat(ctxt, 0.0));
 2242|     57|    if (val->type == XPATH_NUMBER)
  ------------------
  |  Branch (2242:9): [True: 0, False: 57]
  ------------------
 2243|      0|	return(val);
 2244|     57|    ret = xmlXPathCacheNewFloat(ctxt, xmlXPathCastToNumber(val));
 2245|     57|    xmlXPathReleaseObject(ctxt, val);
 2246|     57|    return(ret);
 2247|     57|}
xpath.c:xmlXPathParseNameComplex:
 9161|    650|xmlXPathParseNameComplex(xmlXPathParserContextPtr ctxt, int qualified) {
 9162|    650|    xmlChar buf[XML_MAX_NAMELEN + 5];
 9163|    650|    int len = 0, l;
 9164|    650|    int c;
 9165|       |
 9166|       |    /*
 9167|       |     * Handler for more complex cases
 9168|       |     */
 9169|    650|    c = CUR_CHAR(l);
  ------------------
  |  | 2500|    650|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9170|    650|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (9170:9): [True: 0, False: 650]
  |  Branch (9170:23): [True: 0, False: 650]
  |  Branch (9170:37): [True: 0, False: 650]
  ------------------
 9171|    650|        (c == '[') || (c == ']') || (c == '@') || /* accelerators */
  ------------------
  |  Branch (9171:9): [True: 0, False: 650]
  |  Branch (9171:23): [True: 0, False: 650]
  |  Branch (9171:37): [True: 12, False: 638]
  ------------------
 9172|    650|        (c == '*') || /* accelerators */
  ------------------
  |  Branch (9172:9): [True: 0, False: 638]
  ------------------
 9173|    650|	(!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|  1.27k|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    638|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|  1.27k|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 341, False: 297]
  |  |  |  |  |  |  |  Branch (76:28): [True: 636, False: 2]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  1.27k|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    636|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 339, False: 297]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 2, False: 337]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    636|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 337, False: 297]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 337, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    636|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 297]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    636|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 297]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    636|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 297]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|  1.27k|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    297|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    297|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 297]
  |  |  |  |  |  |  |  Branch (184:31): [True: 297, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    297|				 0 :\
  |  |  |  |  |  |  186|    297|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9173:20): [True: 297, False: 0]
  ------------------
 9174|    638|         ((!qualified) || (c != ':')))) {
  ------------------
  |  Branch (9174:11): [True: 1, False: 296]
  |  Branch (9174:27): [True: 296, False: 0]
  ------------------
 9175|    309|	return(NULL);
 9176|    309|    }
 9177|       |
 9178|  2.30k|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (9178:12): [True: 2.30k, False: 0]
  |  Branch (9178:26): [True: 2.30k, False: 0]
  |  Branch (9178:40): [True: 2.30k, False: 0]
  ------------------
 9179|  2.30k|	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|  2.30k|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|  2.30k|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|  4.60k|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 1.89k, False: 401]
  |  |  |  |  |  |  |  Branch (76:28): [True: 2.27k, False: 25]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  4.60k|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|  2.27k|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 1.87k, False: 396]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 18, False: 1.86k]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|  2.27k|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 1.86k, False: 396]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 1.85k, False: 5]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|  2.27k|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 401]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|  2.27k|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 401]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|  2.27k|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 401]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|  4.60k|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    401|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    401|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 401]
  |  |  |  |  |  |  |  Branch (184:31): [True: 401, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    401|				 0 :\
  |  |  |  |  |  |  186|    401|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|    401|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|    401|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 401, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|    401|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|    401|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 25, False: 376]
  |  |  |  |  |  |  |  Branch (144:45): [True: 2, False: 23]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|    401|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (9179:24): [True: 2, False: 399]
  ------------------
 9180|  2.30k|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (9180:13): [True: 0, False: 399]
  |  Branch (9180:27): [True: 58, False: 341]
  ------------------
 9181|  2.30k|	    (c == '_') || ((qualified) && (c == ':')) ||
  ------------------
  |  Branch (9181:6): [True: 0, False: 341]
  |  Branch (9181:21): [True: 10, False: 331]
  |  Branch (9181:36): [True: 0, False: 10]
  ------------------
 9182|  2.30k|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|    341|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|    341|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 341, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|    341|				 0 : \
  |  |  |  |  134|    341|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (9182:6): [True: 0, False: 341]
  ------------------
 9183|  2.30k|	    (IS_EXTENDER(c)))) {
  ------------------
  |  |  210|    341|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|    341|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 341, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|    341|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|    341|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|    341|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (9183:6): [True: 0, False: 341]
  ------------------
 9184|  1.95k|	COPY_BUF(l,buf,len,c);
  ------------------
  |  | 2503|  1.95k|    if (l == 1) b[i++] = v;                                            \
  |  |  ------------------
  |  |  |  Branch (2503:9): [True: 1.93k, False: 25]
  |  |  ------------------
  |  | 2504|  1.95k|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 9185|  1.95k|	NEXTL(l);
  ------------------
  |  | 2506|  1.95k|#define NEXTL(l)  ctxt->cur += l
  ------------------
 9186|  1.95k|	c = CUR_CHAR(l);
  ------------------
  |  | 2500|  1.95k|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9187|  1.95k|	if (len >= XML_MAX_NAMELEN) {
  ------------------
  |  |   89|  1.95k|#define XML_MAX_NAMELEN 100
  ------------------
  |  Branch (9187:6): [True: 0, False: 1.95k]
  ------------------
 9188|       |	    /*
 9189|       |	     * Okay someone managed to make a huge name, so he's ready to pay
 9190|       |	     * for the processing speed.
 9191|       |	     */
 9192|      0|	    xmlChar *buffer;
 9193|      0|	    int max = len * 2;
 9194|       |
 9195|      0|            if (len > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|      0|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9195:17): [True: 0, False: 0]
  ------------------
 9196|      0|                XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9197|      0|            }
 9198|      0|	    buffer = (xmlChar *) xmlMallocAtomic(max);
 9199|      0|	    if (buffer == NULL) {
  ------------------
  |  Branch (9199:10): [True: 0, False: 0]
  ------------------
 9200|      0|		XP_ERRORNULL(XPATH_MEMORY_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9201|      0|	    }
 9202|      0|	    memcpy(buffer, buf, len);
 9203|      0|	    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
  ------------------
  |  |  240|      0|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|      0|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|      0|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (76:28): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|      0|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|      0|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|      0|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|      0|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|      0|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|      0|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|      0|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      0|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      0|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (184:31): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      0|				 0 :\
  |  |  |  |  |  |  186|      0|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	    while ((IS_LETTER(c)) || (IS_DIGIT(c)) || /* test bigname.xml */
  ------------------
  |  |  171|      0|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|      0|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|      0|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|      0|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (144:45): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|      0|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (9203:31): [True: 0, False: 0]
  ------------------
 9204|      0|		   (c == '.') || (c == '-') ||
  ------------------
  |  Branch (9204:6): [True: 0, False: 0]
  |  Branch (9204:20): [True: 0, False: 0]
  ------------------
 9205|      0|		   (c == '_') || ((qualified) && (c == ':')) ||
  ------------------
  |  Branch (9205:6): [True: 0, False: 0]
  |  Branch (9205:21): [True: 0, False: 0]
  |  Branch (9205:36): [True: 0, False: 0]
  ------------------
 9206|      0|		   (IS_COMBINING(c)) ||
  ------------------
  |  |  189|      0|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|      0|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|      0|				 0 : \
  |  |  |  |  134|      0|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (9206:6): [True: 0, False: 0]
  ------------------
 9207|      0|		   (IS_EXTENDER(c))) {
  ------------------
  |  |  210|      0|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|      0|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|      0|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|      0|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|      0|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (9207:6): [True: 0, False: 0]
  ------------------
 9208|      0|		if (len + 10 > max) {
  ------------------
  |  Branch (9208:7): [True: 0, False: 0]
  ------------------
 9209|      0|                    xmlChar *tmp;
 9210|      0|                    if (max > XML_MAX_NAME_LENGTH) {
  ------------------
  |  |   61|      0|#define XML_MAX_NAME_LENGTH 50000
  ------------------
  |  Branch (9210:25): [True: 0, False: 0]
  ------------------
 9211|      0|                        xmlFree(buffer);
 9212|      0|                        XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9213|      0|                    }
 9214|      0|		    max *= 2;
 9215|      0|		    tmp = (xmlChar *) xmlRealloc(buffer, max);
 9216|      0|		    if (tmp == NULL) {
  ------------------
  |  Branch (9216:11): [True: 0, False: 0]
  ------------------
 9217|      0|                        xmlFree(buffer);
 9218|      0|			XP_ERRORNULL(XPATH_MEMORY_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
 9219|      0|		    }
 9220|      0|                    buffer = tmp;
 9221|      0|		}
 9222|      0|		COPY_BUF(l,buffer,len,c);
  ------------------
  |  | 2503|      0|    if (l == 1) b[i++] = v;                                            \
  |  |  ------------------
  |  |  |  Branch (2503:9): [True: 0, False: 0]
  |  |  ------------------
  |  | 2504|      0|    else i += xmlCopyChar(l,&b[i],v)
  ------------------
 9223|      0|		NEXTL(l);
  ------------------
  |  | 2506|      0|#define NEXTL(l)  ctxt->cur += l
  ------------------
 9224|      0|		c = CUR_CHAR(l);
  ------------------
  |  | 2500|      0|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9225|      0|	    }
 9226|      0|	    buffer[len] = 0;
 9227|      0|	    return(buffer);
 9228|      0|	}
 9229|  1.95k|    }
 9230|    341|    if (len == 0)
  ------------------
  |  Branch (9230:9): [True: 0, False: 341]
  ------------------
 9231|      0|	return(NULL);
 9232|    341|    return(xmlStrndup(buf, len));
 9233|    341|}
xpath.c:xmlXPathCurrentChar:
 8958|  4.49k|xmlXPathCurrentChar(xmlXPathParserContextPtr ctxt, int *len) {
 8959|  4.49k|    unsigned char c;
 8960|  4.49k|    unsigned int val;
 8961|  4.49k|    const xmlChar *cur;
 8962|       |
 8963|  4.49k|    if (ctxt == NULL)
  ------------------
  |  Branch (8963:9): [True: 0, False: 4.49k]
  ------------------
 8964|      0|	return(0);
 8965|  4.49k|    cur = ctxt->cur;
 8966|       |
 8967|       |    /*
 8968|       |     * We are supposed to handle UTF8, check it's valid
 8969|       |     * From rfc2044: encoding of the Unicode values on UTF-8:
 8970|       |     *
 8971|       |     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)
 8972|       |     * 0000 0000-0000 007F   0xxxxxxx
 8973|       |     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx
 8974|       |     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx
 8975|       |     *
 8976|       |     * Check for the 0x110000 limit too
 8977|       |     */
 8978|  4.49k|    c = *cur;
 8979|  4.49k|    if (c & 0x80) {
  ------------------
  |  Branch (8979:9): [True: 58, False: 4.43k]
  ------------------
 8980|     58|	if ((cur[1] & 0xc0) != 0x80)
  ------------------
  |  Branch (8980:6): [True: 10, False: 48]
  ------------------
 8981|     10|	    goto encoding_error;
 8982|     48|	if ((c & 0xe0) == 0xe0) {
  ------------------
  |  Branch (8982:6): [True: 0, False: 48]
  ------------------
 8983|       |
 8984|      0|	    if ((cur[2] & 0xc0) != 0x80)
  ------------------
  |  Branch (8984:10): [True: 0, False: 0]
  ------------------
 8985|      0|		goto encoding_error;
 8986|      0|	    if ((c & 0xf0) == 0xf0) {
  ------------------
  |  Branch (8986:10): [True: 0, False: 0]
  ------------------
 8987|      0|		if (((c & 0xf8) != 0xf0) ||
  ------------------
  |  Branch (8987:7): [True: 0, False: 0]
  ------------------
 8988|      0|		    ((cur[3] & 0xc0) != 0x80))
  ------------------
  |  Branch (8988:7): [True: 0, False: 0]
  ------------------
 8989|      0|		    goto encoding_error;
 8990|       |		/* 4-byte code */
 8991|      0|		*len = 4;
 8992|      0|		val = (cur[0] & 0x7) << 18;
 8993|      0|		val |= (cur[1] & 0x3f) << 12;
 8994|      0|		val |= (cur[2] & 0x3f) << 6;
 8995|      0|		val |= cur[3] & 0x3f;
 8996|      0|	    } else {
 8997|       |	      /* 3-byte code */
 8998|      0|		*len = 3;
 8999|      0|		val = (cur[0] & 0xf) << 12;
 9000|      0|		val |= (cur[1] & 0x3f) << 6;
 9001|      0|		val |= cur[2] & 0x3f;
 9002|      0|	    }
 9003|     48|	} else {
 9004|       |	  /* 2-byte code */
 9005|     48|	    *len = 2;
 9006|     48|	    val = (cur[0] & 0x1f) << 6;
 9007|     48|	    val |= cur[1] & 0x3f;
 9008|     48|	}
 9009|     48|	if (!IS_CHAR(val)) {
  ------------------
  |  |  125|     48|#define IS_CHAR(c)   xmlIsCharQ(c)
  |  |  ------------------
  |  |  |  |  118|     48|#define xmlIsCharQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (118:25): [True: 0, False: 48]
  |  |  |  |  ------------------
  |  |  |  |  119|     48|				 xmlIsChar_ch((c)) :\
  |  |  |  |  ------------------
  |  |  |  |  |  |  108|      0|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (108:28): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (108:44): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  109|      0|				 ((c) == 0xd) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (109:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  110|      0|				  (0x20 <= (c)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (110:7): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  120|     48|				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (120:7): [True: 48, False: 0]
  |  |  |  |  |  Branch (120:25): [True: 48, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  121|     48|				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (121:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (121:26): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  122|     48|				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (122:7): [True: 0, False: 0]
  |  |  |  |  |  Branch (122:27): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9009:6): [True: 0, False: 48]
  ------------------
 9010|      0|	    XP_ERROR0(XPATH_INVALID_CHAR_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 9011|      0|	}
 9012|     48|	return(val);
 9013|  4.43k|    } else {
 9014|       |	/* 1-byte code */
 9015|  4.43k|	*len = 1;
 9016|  4.43k|	return(*cur);
 9017|  4.43k|    }
 9018|     10|encoding_error:
 9019|       |    /*
 9020|       |     * If we detect an UTF8 error that probably means that the
 9021|       |     * input encoding didn't get properly advertised in the
 9022|       |     * declaration header. Report the error and switch the encoding
 9023|       |     * to ISO-Latin-1 (if you don't like this policy, just declare the
 9024|       |     * encoding !)
 9025|       |     */
 9026|     10|    *len = 0;
 9027|     10|    XP_ERROR0(XPATH_ENCODING_ERROR);
  ------------------
  |  |  267|     10|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
 9028|      0|}
xpath.c:xmlXPathTryStreamCompile:
13165|    444|xmlXPathTryStreamCompile(xmlXPathContextPtr ctxt, const xmlChar *str) {
13166|       |    /*
13167|       |     * Optimization: use streaming patterns when the XPath expression can
13168|       |     * be compiled to a stream lookup
13169|       |     */
13170|    444|    xmlPatternPtr stream;
13171|    444|    xmlXPathCompExprPtr comp;
13172|    444|    xmlDictPtr dict = NULL;
13173|    444|    const xmlChar **namespaces = NULL;
13174|    444|    xmlNsPtr ns;
13175|    444|    int i, j;
13176|       |
13177|    444|    if ((!xmlStrchr(str, '[')) && (!xmlStrchr(str, '(')) &&
  ------------------
  |  Branch (13177:9): [True: 374, False: 70]
  |  Branch (13177:35): [True: 177, False: 197]
  ------------------
13178|    444|        (!xmlStrchr(str, '@'))) {
  ------------------
  |  Branch (13178:9): [True: 176, False: 1]
  ------------------
13179|    176|	const xmlChar *tmp;
13180|       |
13181|       |	/*
13182|       |	 * We don't try to handle expressions using the verbose axis
13183|       |	 * specifiers ("::"), just the simplified form at this point.
13184|       |	 * Additionally, if there is no list of namespaces available and
13185|       |	 *  there's a ":" in the expression, indicating a prefixed QName,
13186|       |	 *  then we won't try to compile either. xmlPatterncompile() needs
13187|       |	 *  to have a list of namespaces at compilation time in order to
13188|       |	 *  compile prefixed name tests.
13189|       |	 */
13190|    176|	tmp = xmlStrchr(str, ':');
13191|    176|	if ((tmp != NULL) &&
  ------------------
  |  Branch (13191:6): [True: 39, False: 137]
  ------------------
13192|    176|	    ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))
  ------------------
  |  Branch (13192:7): [True: 0, False: 39]
  |  Branch (13192:25): [True: 39, False: 0]
  |  Branch (13192:46): [True: 0, False: 0]
  ------------------
13193|     39|	    return(NULL);
13194|       |
13195|    137|	if (ctxt != NULL) {
  ------------------
  |  Branch (13195:6): [True: 137, False: 0]
  ------------------
13196|    137|	    dict = ctxt->dict;
13197|    137|	    if (ctxt->nsNr > 0) {
  ------------------
  |  Branch (13197:10): [True: 0, False: 137]
  ------------------
13198|      0|		namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));
13199|      0|		if (namespaces == NULL) {
  ------------------
  |  Branch (13199:7): [True: 0, False: 0]
  ------------------
13200|      0|		    xmlXPathErrMemory(ctxt, "allocating namespaces array\n");
13201|      0|		    return(NULL);
13202|      0|		}
13203|      0|		for (i = 0, j = 0; (j < ctxt->nsNr); j++) {
  ------------------
  |  Branch (13203:22): [True: 0, False: 0]
  ------------------
13204|      0|		    ns = ctxt->namespaces[j];
13205|      0|		    namespaces[i++] = ns->href;
13206|      0|		    namespaces[i++] = ns->prefix;
13207|      0|		}
13208|      0|		namespaces[i++] = NULL;
13209|      0|		namespaces[i] = NULL;
13210|      0|	    }
13211|    137|	}
13212|       |
13213|    137|	stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH, namespaces);
13214|    137|	if (namespaces != NULL) {
  ------------------
  |  Branch (13214:6): [True: 0, False: 137]
  ------------------
13215|      0|	    xmlFree((xmlChar **)namespaces);
13216|      0|	}
13217|    137|	if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {
  ------------------
  |  Branch (13217:6): [True: 20, False: 117]
  |  Branch (13217:26): [True: 15, False: 5]
  ------------------
13218|     15|	    comp = xmlXPathNewCompExpr();
13219|     15|	    if (comp == NULL) {
  ------------------
  |  Branch (13219:10): [True: 0, False: 15]
  ------------------
13220|      0|		xmlXPathErrMemory(ctxt, "allocating streamable expression\n");
13221|      0|	        xmlFreePattern(stream);
13222|      0|		return(NULL);
13223|      0|	    }
13224|     15|	    comp->stream = stream;
13225|     15|	    comp->dict = dict;
13226|     15|	    if (comp->dict)
  ------------------
  |  Branch (13226:10): [True: 0, False: 15]
  ------------------
13227|      0|		xmlDictReference(comp->dict);
13228|     15|	    return(comp);
13229|     15|	}
13230|    122|	xmlFreePattern(stream);
13231|    122|    }
13232|    390|    return(NULL);
13233|    444|}
xpath.c:xmlXPathCompileExpr:
10186|    790|xmlXPathCompileExpr(xmlXPathParserContextPtr ctxt, int sort) {
10187|    790|    xmlXPathContextPtr xpctxt = ctxt->context;
10188|       |
10189|    790|    if (xpctxt != NULL) {
  ------------------
  |  Branch (10189:9): [True: 790, False: 0]
  ------------------
10190|    790|        if (xpctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|    790|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (10190:13): [True: 0, False: 790]
  ------------------
10191|    790|            XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10192|       |        /*
10193|       |         * Parsing a single '(' pushes about 10 functions on the call stack
10194|       |         * before recursing!
10195|       |         */
10196|    790|        xpctxt->depth += 10;
10197|    790|    }
10198|       |
10199|    790|    xmlXPathCompAndExpr(ctxt);
10200|    790|    CHECK_ERROR;
  ------------------
  |  |  241|    790|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 767]
  |  |  ------------------
  ------------------
10201|    767|    SKIP_BLANKS;
  ------------------
  |  | 2509|    767|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    790|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10202|    767|    while ((CUR == 'o') && (NXT(1) == 'r')) {
  ------------------
  |  | 2496|    767|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == 'o') && (NXT(1) == 'r')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10202:12): [True: 0, False: 767]
  |  Branch (10202:28): [True: 0, False: 0]
  ------------------
10203|      0|	int op1 = ctxt->comp->last;
10204|      0|        SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10205|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10206|      0|        xmlXPathCompAndExpr(ctxt);
10207|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10208|      0|	PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10209|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10210|      0|    }
10211|    767|    if ((sort) && (ctxt->comp->steps[ctxt->comp->last].op != XPATH_OP_VALUE)) {
  ------------------
  |  Branch (10211:9): [True: 701, False: 66]
  |  Branch (10211:19): [True: 493, False: 208]
  ------------------
10212|       |	/* more ops could be optimized too */
10213|       |	/*
10214|       |	* This is the main place to eliminate sorting for
10215|       |	* operations which don't require a sorted node-set.
10216|       |	* E.g. count().
10217|       |	*/
10218|    493|	PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);
  ------------------
  |  | 1191|    493|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|    493|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
10219|    493|    }
10220|       |
10221|    767|    if (xpctxt != NULL)
  ------------------
  |  Branch (10221:9): [True: 767, False: 0]
  ------------------
10222|    767|        xpctxt->depth -= 10;
10223|    767|}
xpath.c:xmlXPathCompAndExpr:
10160|    790|xmlXPathCompAndExpr(xmlXPathParserContextPtr ctxt) {
10161|    790|    xmlXPathCompEqualityExpr(ctxt);
10162|    790|    CHECK_ERROR;
  ------------------
  |  |  241|    790|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 767]
  |  |  ------------------
  ------------------
10163|    767|    SKIP_BLANKS;
  ------------------
  |  | 2509|    767|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    790|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10164|    767|    while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2496|    767|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                  while ((CUR == 'a') && (NXT(1) == 'n') && (NXT(2) == 'd')) {
  ------------------
  |  | 2498|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10164:12): [True: 0, False: 767]
  |  Branch (10164:28): [True: 0, False: 0]
  |  Branch (10164:47): [True: 0, False: 0]
  ------------------
10165|      0|	int op1 = ctxt->comp->last;
10166|      0|        SKIP(3);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10167|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10168|      0|        xmlXPathCompEqualityExpr(ctxt);
10169|      0|	CHECK_ERROR;
  ------------------
  |  |  241|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10170|      0|	PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      0|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      0|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      0|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10171|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10172|      0|    }
10173|    767|}
xpath.c:xmlXPathCompEqualityExpr:
10129|    790|xmlXPathCompEqualityExpr(xmlXPathParserContextPtr ctxt) {
10130|    790|    xmlXPathCompRelationalExpr(ctxt);
10131|    790|    CHECK_ERROR;
  ------------------
  |  |  241|    790|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 22, False: 768]
  |  |  ------------------
  ------------------
10132|    768|    SKIP_BLANKS;
  ------------------
  |  | 2509|    768|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    790|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10133|    834|    while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2496|    834|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2496|    783|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '=') || ((CUR == '!') && (NXT(1) == '='))) {
  ------------------
  |  | 2498|     17|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10133:12): [True: 51, False: 783]
  |  Branch (10133:29): [True: 17, False: 766]
  |  Branch (10133:45): [True: 16, False: 1]
  ------------------
10134|     67|	int eq;
10135|     67|	int op1 = ctxt->comp->last;
10136|       |
10137|     67|        if (CUR == '=') eq = 1;
  ------------------
  |  | 2496|     67|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10137:13): [True: 51, False: 16]
  ------------------
10138|     16|	else eq = 0;
10139|     67|	NEXT;
  ------------------
  |  | 2512|     67|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 67, False: 0]
  |  |  ------------------
  ------------------
10140|     67|	if (!eq) NEXT;
  ------------------
  |  | 2512|     16|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 16, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10140:6): [True: 16, False: 51]
  ------------------
10141|     67|	SKIP_BLANKS;
  ------------------
  |  | 2509|     67|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     14|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 14, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10142|     67|        xmlXPathCompRelationalExpr(ctxt);
10143|     67|	CHECK_ERROR;
  ------------------
  |  |  241|     67|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 1, False: 66]
  |  |  ------------------
  ------------------
10144|     66|	PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);
  ------------------
  |  | 1194|     66|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|     66|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|     66|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10145|     66|	SKIP_BLANKS;
  ------------------
  |  | 2509|     66|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     66|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10146|     66|    }
10147|    768|}
xpath.c:xmlXPathCompRelationalExpr:
10090|    857|xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
10091|    857|    xmlXPathCompAdditiveExpr(ctxt);
10092|    857|    CHECK_ERROR;
  ------------------
  |  |  241|    857|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 834]
  |  |  ------------------
  ------------------
10093|    834|    SKIP_BLANKS;
  ------------------
  |  | 2509|    834|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    857|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10094|    906|    while ((CUR == '<') || (CUR == '>')) {
  ------------------
  |  | 2496|    906|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '<') || (CUR == '>')) {
  ------------------
  |  | 2496|    870|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10094:12): [True: 36, False: 870]
  |  Branch (10094:28): [True: 36, False: 834]
  ------------------
10095|     72|	int inf, strict;
10096|     72|	int op1 = ctxt->comp->last;
10097|       |
10098|     72|        if (CUR == '<') inf = 1;
  ------------------
  |  | 2496|     72|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10098:13): [True: 36, False: 36]
  ------------------
10099|     36|	else inf = 0;
10100|     72|	if (NXT(1) == '=') strict = 0;
  ------------------
  |  | 2498|     72|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10100:6): [True: 31, False: 41]
  ------------------
10101|     41|	else strict = 1;
10102|     72|	NEXT;
  ------------------
  |  | 2512|     72|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 72, False: 0]
  |  |  ------------------
  ------------------
10103|     72|	if (!strict) NEXT;
  ------------------
  |  | 2512|     31|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 31, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (10103:6): [True: 31, False: 41]
  ------------------
10104|     72|	SKIP_BLANKS;
  ------------------
  |  | 2509|     72|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     39|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 39, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10105|     72|        xmlXPathCompAdditiveExpr(ctxt);
10106|     72|	CHECK_ERROR;
  ------------------
  |  |  241|     72|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 72]
  |  |  ------------------
  ------------------
10107|     72|	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
  ------------------
  |  | 1194|     72|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|     72|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|     72|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10108|     72|	SKIP_BLANKS;
  ------------------
  |  | 2509|     72|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     72|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10109|     72|    }
10110|    834|}
xpath.c:xmlXPathCompAdditiveExpr:
10051|    929|xmlXPathCompAdditiveExpr(xmlXPathParserContextPtr ctxt) {
10052|       |
10053|    929|    xmlXPathCompMultiplicativeExpr(ctxt);
10054|    929|    CHECK_ERROR;
  ------------------
  |  |  241|    929|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 906]
  |  |  ------------------
  ------------------
10055|    906|    SKIP_BLANKS;
  ------------------
  |  | 2509|    906|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    929|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10056|    933|    while ((CUR == '+') || (CUR == '-')) {
  ------------------
  |  | 2496|    933|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR == '+') || (CUR == '-')) {
  ------------------
  |  | 2496|    906|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10056:12): [True: 27, False: 906]
  |  Branch (10056:28): [True: 0, False: 906]
  ------------------
10057|     27|	int plus;
10058|     27|	int op1 = ctxt->comp->last;
10059|       |
10060|     27|        if (CUR == '+') plus = 1;
  ------------------
  |  | 2496|     27|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10060:13): [True: 27, False: 0]
  ------------------
10061|      0|	else plus = 0;
10062|     27|	NEXT;
  ------------------
  |  | 2512|     27|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 27, False: 0]
  |  |  ------------------
  ------------------
10063|     27|	SKIP_BLANKS;
  ------------------
  |  | 2509|     27|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10064|     27|        xmlXPathCompMultiplicativeExpr(ctxt);
10065|     27|	CHECK_ERROR;
  ------------------
  |  |  241|     27|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 27]
  |  |  ------------------
  ------------------
10066|     27|	PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);
  ------------------
  |  | 1194|     27|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|     27|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|     27|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10067|     27|	SKIP_BLANKS;
  ------------------
  |  | 2509|     27|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     27|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10068|     27|    }
10069|    906|}
xpath.c:xmlXPathCompMultiplicativeExpr:
10011|    956|xmlXPathCompMultiplicativeExpr(xmlXPathParserContextPtr ctxt) {
10012|    956|    xmlXPathCompUnaryExpr(ctxt);
10013|    956|    CHECK_ERROR;
  ------------------
  |  |  241|    956|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 22, False: 934]
  |  |  ------------------
  ------------------
10014|    934|    SKIP_BLANKS;
  ------------------
  |  | 2509|    934|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    956|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10015|  1.06k|    while ((CUR == '*') ||
  ------------------
  |  | 2496|  1.06k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10015:12): [True: 26, False: 1.03k]
  ------------------
10016|  1.06k|           ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2496|  1.03k|#define CUR (*ctxt->cur)
  ------------------
                         ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2498|     94|#define NXT(val) ctxt->cur[(val)]
  ------------------
                         ((CUR == 'd') && (NXT(1) == 'i') && (NXT(2) == 'v')) ||
  ------------------
  |  | 2498|     94|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10016:13): [True: 94, False: 940]
  |  Branch (10016:29): [True: 94, False: 0]
  |  Branch (10016:48): [True: 94, False: 0]
  ------------------
10017|  1.06k|           ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2496|    940|#define CUR (*ctxt->cur)
  ------------------
                         ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2498|      7|#define NXT(val) ctxt->cur[(val)]
  ------------------
                         ((CUR == 'm') && (NXT(1) == 'o') && (NXT(2) == 'd'))) {
  ------------------
  |  | 2498|      7|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10017:13): [True: 7, False: 933]
  |  Branch (10017:29): [True: 7, False: 0]
  |  Branch (10017:48): [True: 7, False: 0]
  ------------------
10018|    127|	int op = -1;
10019|    127|	int op1 = ctxt->comp->last;
10020|       |
10021|    127|        if (CUR == '*') {
  ------------------
  |  | 2496|    127|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10021:13): [True: 26, False: 101]
  ------------------
10022|     26|	    op = 0;
10023|     26|	    NEXT;
  ------------------
  |  | 2512|     26|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 26, False: 0]
  |  |  ------------------
  ------------------
10024|    101|	} else if (CUR == 'd') {
  ------------------
  |  | 2496|    101|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10024:13): [True: 94, False: 7]
  ------------------
10025|     94|	    op = 1;
10026|     94|	    SKIP(3);
  ------------------
  |  | 2497|     94|#define SKIP(val) ctxt->cur += (val)
  ------------------
10027|     94|	} else if (CUR == 'm') {
  ------------------
  |  | 2496|      7|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10027:13): [True: 7, False: 0]
  ------------------
10028|      7|	    op = 2;
10029|      7|	    SKIP(3);
  ------------------
  |  | 2497|      7|#define SKIP(val) ctxt->cur += (val)
  ------------------
10030|      7|	}
10031|    127|	SKIP_BLANKS;
  ------------------
  |  | 2509|    127|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    100|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 100, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10032|    127|        xmlXPathCompUnaryExpr(ctxt);
10033|    127|	CHECK_ERROR;
  ------------------
  |  |  241|    127|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 1, False: 126]
  |  |  ------------------
  ------------------
10034|    126|	PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);
  ------------------
  |  | 1194|    126|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|    126|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|    126|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10035|    126|	SKIP_BLANKS;
  ------------------
  |  | 2509|    126|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    126|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10036|    126|    }
10037|    934|}
xpath.c:xmlXPathCompUnaryExpr:
 9975|  1.08k|xmlXPathCompUnaryExpr(xmlXPathParserContextPtr ctxt) {
 9976|  1.08k|    int minus = 0;
 9977|  1.08k|    int found = 0;
 9978|       |
 9979|  1.08k|    SKIP_BLANKS;
  ------------------
  |  | 2509|  1.08k|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9980|  1.14k|    while (CUR == '-') {
  ------------------
  |  | 2496|  1.14k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9980:12): [True: 63, False: 1.08k]
  ------------------
 9981|     63|        minus = 1 - minus;
 9982|     63|	found = 1;
 9983|     63|	NEXT;
  ------------------
  |  | 2512|     63|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 63, False: 0]
  |  |  ------------------
  ------------------
 9984|     63|	SKIP_BLANKS;
  ------------------
  |  | 2509|     63|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9985|     63|    }
 9986|       |
 9987|  1.08k|    xmlXPathCompUnionExpr(ctxt);
 9988|  1.08k|    CHECK_ERROR;
  ------------------
  |  |  241|  1.08k|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 1.06k]
  |  |  ------------------
  ------------------
 9989|  1.06k|    if (found) {
  ------------------
  |  Branch (9989:9): [True: 63, False: 997]
  ------------------
 9990|     63|	if (minus)
  ------------------
  |  Branch (9990:6): [True: 63, False: 0]
  ------------------
 9991|     63|	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);
  ------------------
  |  | 1191|     63|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|     63|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9992|      0|	else
 9993|      0|	    PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);
  ------------------
  |  | 1191|      0|#define PUSH_UNARY_EXPR(op, ch, val, val2)				\
  |  | 1192|      0|xmlXPathCompExprAdd(ctxt, (ch), -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9994|     63|    }
 9995|  1.06k|}
xpath.c:xmlXPathCompUnionExpr:
 9946|  1.08k|xmlXPathCompUnionExpr(xmlXPathParserContextPtr ctxt) {
 9947|  1.08k|    xmlXPathCompPathExpr(ctxt);
 9948|  1.08k|    CHECK_ERROR;
  ------------------
  |  |  241|  1.08k|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 23, False: 1.06k]
  |  |  ------------------
  ------------------
 9949|  1.06k|    SKIP_BLANKS;
  ------------------
  |  | 2509|  1.06k|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|  1.08k|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9950|  1.06k|    while (CUR == '|') {
  ------------------
  |  | 2496|  1.06k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9950:12): [True: 4, False: 1.06k]
  ------------------
 9951|      4|	int op1 = ctxt->comp->last;
 9952|      4|	PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
  ------------------
  |  | 1188|      4|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|      4|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9953|       |
 9954|      4|	NEXT;
  ------------------
  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 4, False: 0]
  |  |  ------------------
  ------------------
 9955|      4|	SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9956|      4|	xmlXPathCompPathExpr(ctxt);
 9957|       |
 9958|      4|	PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      4|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      4|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      4|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
 9959|       |
 9960|      4|	SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9961|      4|    }
 9962|  1.06k|}
xpath.c:xmlXPathCompPathExpr:
 9818|  1.08k|xmlXPathCompPathExpr(xmlXPathParserContextPtr ctxt) {
 9819|  1.08k|    int lc = 1;           /* Should we branch to LocationPath ?         */
 9820|  1.08k|    xmlChar *name = NULL; /* we may have to preparse a name to find out */
 9821|       |
 9822|  1.08k|    SKIP_BLANKS;
  ------------------
  |  | 2509|  1.08k|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9823|  1.08k|    if ((CUR == '$') || (CUR == '(') ||
  ------------------
  |  | 2496|  1.08k|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '$') || (CUR == '(') ||
  ------------------
  |  | 2496|  1.08k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9823:9): [True: 0, False: 1.08k]
  |  Branch (9823:25): [True: 21, False: 1.06k]
  ------------------
 9824|  1.08k|	(IS_ASCII_DIGIT(CUR)) ||
  ------------------
  |  |  268|  1.06k|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 735, False: 331]
  |  |  |  Branch (268:45): [True: 479, False: 256]
  |  |  ------------------
  ------------------
 9825|  1.08k|        (CUR == '\'') || (CUR == '"') ||
  ------------------
  |  | 2496|    587|#define CUR (*ctxt->cur)
  ------------------
                      (CUR == '\'') || (CUR == '"') ||
  ------------------
  |  | 2496|    477|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9825:9): [True: 110, False: 477]
  |  Branch (9825:26): [True: 75, False: 402]
  ------------------
 9826|  1.08k|	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  | 2496|    402|#define CUR (*ctxt->cur)
  ------------------
              	(CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|      3|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 3, False: 0]
  |  |  |  Branch (268:45): [True: 2, False: 1]
  |  |  ------------------
  ------------------
  |  Branch (9826:3): [True: 3, False: 399]
  ------------------
 9827|    687|	lc = 0;
 9828|    687|    } else if (CUR == '*') {
  ------------------
  |  | 2496|    400|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9828:16): [True: 0, False: 400]
  ------------------
 9829|       |	/* relative or absolute location path */
 9830|      0|	lc = 1;
 9831|    400|    } else if (CUR == '/') {
  ------------------
  |  | 2496|    400|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9831:16): [True: 140, False: 260]
  ------------------
 9832|       |	/* relative or absolute location path */
 9833|    140|	lc = 1;
 9834|    260|    } else if (CUR == '@') {
  ------------------
  |  | 2496|    260|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9834:16): [True: 12, False: 248]
  ------------------
 9835|       |	/* relative abbreviated attribute location path */
 9836|     12|	lc = 1;
 9837|    248|    } else if (CUR == '.') {
  ------------------
  |  | 2496|    248|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9837:16): [True: 1, False: 247]
  ------------------
 9838|       |	/* relative abbreviated attribute location path */
 9839|      1|	lc = 1;
 9840|    247|    } else {
 9841|       |	/*
 9842|       |	 * Problem is finding if we have a name here whether it's:
 9843|       |	 *   - a nodetype
 9844|       |	 *   - a function call in which case it's followed by '('
 9845|       |	 *   - an axis in which case it's followed by ':'
 9846|       |	 *   - a element name
 9847|       |	 * We do an a priori analysis here rather than having to
 9848|       |	 * maintain parsed token content through the recursive function
 9849|       |	 * calls. This looks uglier but makes the code easier to
 9850|       |	 * read/write/debug.
 9851|       |	 */
 9852|    247|	SKIP_BLANKS;
  ------------------
  |  | 2509|    247|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9853|    247|	name = xmlXPathScanName(ctxt);
 9854|    247|	if ((name != NULL) && (xmlStrstr(name, (xmlChar *) "::") != NULL)) {
  ------------------
  |  Branch (9854:6): [True: 241, False: 6]
  |  Branch (9854:24): [True: 2, False: 239]
  ------------------
 9855|      2|	    lc = 1;
 9856|      2|	    xmlFree(name);
 9857|    245|	} else if (name != NULL) {
  ------------------
  |  Branch (9857:13): [True: 239, False: 6]
  ------------------
 9858|    239|	    int len =xmlStrlen(name);
 9859|       |
 9860|       |
 9861|    241|	    while (NXT(len) != 0) {
  ------------------
  |  | 2498|    241|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9861:13): [True: 239, False: 2]
  ------------------
 9862|    239|		if (NXT(len) == '/') {
  ------------------
  |  | 2498|    239|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9862:7): [True: 1, False: 238]
  ------------------
 9863|       |		    /* element name */
 9864|      1|		    lc = 1;
 9865|      1|		    break;
 9866|    238|		} else if (IS_BLANK_CH(NXT(len))) {
  ------------------
  |  |  151|    238|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    238|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 2, False: 236]
  |  |  |  |  ------------------
  |  |  |  |   89|    238|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 236, False: 0]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 236]
  |  |  |  |  ------------------
  |  |  |  |   90|    238|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 236]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9867|       |		    /* ignore blanks */
 9868|      2|		    ;
 9869|    236|		} else if (NXT(len) == ':') {
  ------------------
  |  | 2498|    236|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9869:14): [True: 0, False: 236]
  ------------------
 9870|      0|		    lc = 1;
 9871|      0|		    break;
 9872|    236|		} else if ((NXT(len) == '(')) {
  ------------------
  |  | 2498|    236|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9872:14): [True: 228, False: 8]
  ------------------
 9873|       |		    /* Node Type or Function */
 9874|    228|		    if (xmlXPathIsNodeType(name)) {
  ------------------
  |  Branch (9874:11): [True: 0, False: 228]
  ------------------
 9875|      0|			lc = 1;
 9876|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 9877|       |                    } else if (ctxt->xptr &&
 9878|       |                               xmlStrEqual(name, BAD_CAST "range-to")) {
 9879|       |                        lc = 1;
 9880|       |#endif
 9881|    228|		    } else {
 9882|    228|			lc = 0;
 9883|    228|		    }
 9884|    228|                    break;
 9885|    228|		} else if ((NXT(len) == '[')) {
  ------------------
  |  | 2498|      8|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9885:14): [True: 0, False: 8]
  ------------------
 9886|       |		    /* element name */
 9887|      0|		    lc = 1;
 9888|      0|		    break;
 9889|      8|		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
  ------------------
  |  | 2498|      8|#define NXT(val) ctxt->cur[(val)]
  ------------------
              		} else if ((NXT(len) == '<') || (NXT(len) == '>') ||
  ------------------
  |  | 2498|      8|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9889:14): [True: 0, False: 8]
  |  Branch (9889:35): [True: 0, False: 8]
  ------------------
 9890|      8|			   (NXT(len) == '=')) {
  ------------------
  |  | 2498|      8|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9890:7): [True: 0, False: 8]
  ------------------
 9891|      0|		    lc = 1;
 9892|      0|		    break;
 9893|      8|		} else {
 9894|      8|		    lc = 1;
 9895|      8|		    break;
 9896|      8|		}
 9897|      2|		len++;
 9898|      2|	    }
 9899|    239|	    if (NXT(len) == 0) {
  ------------------
  |  | 2498|    239|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9899:10): [True: 2, False: 237]
  ------------------
 9900|       |		/* element name */
 9901|      2|		lc = 1;
 9902|      2|	    }
 9903|    239|	    xmlFree(name);
 9904|    239|	} else {
 9905|       |	    /* make sure all cases are covered explicitly */
 9906|      6|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      6|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9907|      0|	}
 9908|    247|    }
 9909|       |
 9910|  1.08k|    if (lc) {
  ------------------
  |  Branch (9910:9): [True: 166, False: 915]
  ------------------
 9911|    166|	if (CUR == '/') {
  ------------------
  |  | 2496|    166|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9911:6): [True: 140, False: 26]
  ------------------
 9912|    140|	    PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);
  ------------------
  |  | 1188|    140|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|    140|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9913|    140|	} else {
 9914|     26|	    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);
  ------------------
  |  | 1188|     26|#define PUSH_LEAVE_EXPR(op, val, val2)					\
  |  | 1189|     26|xmlXPathCompExprAdd(ctxt, -1, -1, (op), (val), (val2), 0 ,NULL ,NULL)
  ------------------
 9915|     26|	}
 9916|    166|	xmlXPathCompLocationPath(ctxt);
 9917|    915|    } else {
 9918|    915|	xmlXPathCompFilterExpr(ctxt);
 9919|    915|	CHECK_ERROR;
  ------------------
  |  |  241|    915|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 3, False: 912]
  |  |  ------------------
  ------------------
 9920|    912|	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|    912|#define CUR (*ctxt->cur)
  ------------------
              	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|     11|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (9920:6): [True: 11, False: 901]
  |  Branch (9920:22): [True: 2, False: 9]
  ------------------
 9921|      2|	    SKIP(2);
  ------------------
  |  | 2497|      2|#define SKIP(val) ctxt->cur += (val)
  ------------------
 9922|      2|	    SKIP_BLANKS;
  ------------------
  |  | 2509|      2|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9923|       |
 9924|      2|	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      2|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      2|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
 9925|      2|		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
 9926|       |
 9927|      2|	    xmlXPathCompRelativeLocationPath(ctxt);
 9928|    910|	} else if (CUR == '/') {
  ------------------
  |  | 2496|    910|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9928:13): [True: 9, False: 901]
  ------------------
 9929|      9|	    xmlXPathCompRelativeLocationPath(ctxt);
 9930|      9|	}
 9931|    912|    }
 9932|  1.07k|    SKIP_BLANKS;
  ------------------
  |  | 2509|  1.07k|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|  1.08k|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9933|  1.07k|}
xpath.c:xmlXPathScanName:
 9770|    247|xmlXPathScanName(xmlXPathParserContextPtr ctxt) {
 9771|    247|    int l;
 9772|    247|    int c;
 9773|    247|    const xmlChar *cur;
 9774|    247|    xmlChar *ret;
 9775|       |
 9776|    247|    cur = ctxt->cur;
 9777|       |
 9778|    247|    c = CUR_CHAR(l);
  ------------------
  |  | 2500|    247|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9779|    247|    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
  ------------------
  |  Branch (9779:9): [True: 0, False: 247]
  |  Branch (9779:23): [True: 0, False: 247]
  |  Branch (9779:37): [True: 0, False: 247]
  ------------------
 9780|    247|	(!IS_LETTER(c) && (c != '_') &&
  ------------------
  |  |  240|    494|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|    247|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|    494|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 241, False: 6]
  |  |  |  |  |  |  |  Branch (76:28): [True: 246, False: 1]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|    494|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|    246|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 241, False: 5]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 241]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|    246|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 241, False: 5]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 240, False: 1]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|    246|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 6]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|    246|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 6]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|    246|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 6]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|    494|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|      6|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|      6|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 6]
  |  |  |  |  |  |  |  Branch (184:31): [True: 6, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|      6|				 0 :\
  |  |  |  |  |  |  186|      6|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
  |  Branch (9780:20): [True: 6, False: 0]
  ------------------
 9781|    247|         (c != ':'))) {
  ------------------
  |  Branch (9781:10): [True: 6, False: 0]
  ------------------
 9782|      6|	return(NULL);
 9783|      6|    }
 9784|       |
 9785|  1.88k|    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
  ------------------
  |  Branch (9785:12): [True: 1.88k, False: 2]
  |  Branch (9785:26): [True: 1.88k, False: 0]
  |  Branch (9785:40): [True: 1.87k, False: 1]
  ------------------
 9786|  1.88k|	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  240|  1.87k|#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  161|  1.87k|#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |   76|  3.75k|#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (76:27): [True: 1.58k, False: 296]
  |  |  |  |  |  |  |  Branch (76:28): [True: 1.85k, False: 23]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   77|  3.75k|				 xmlIsBaseChar_ch((c)) : \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   64|  1.85k|#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (64:31): [True: 1.56k, False: 292]
  |  |  |  |  |  |  |  |  |  Branch (64:48): [True: 0, False: 1.56k]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   65|  1.85k|				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (65:7): [True: 1.56k, False: 293]
  |  |  |  |  |  |  |  |  |  Branch (65:24): [True: 1.56k, False: 3]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   66|  1.85k|				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (66:7): [True: 0, False: 296]
  |  |  |  |  |  |  |  |  |  Branch (66:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   67|  1.85k|				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (67:7): [True: 0, False: 296]
  |  |  |  |  |  |  |  |  |  Branch (67:24): [True: 0, False: 0]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |   68|  1.85k|				  (0xf8 <= (c)))
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  |  |  Branch (68:7): [True: 0, False: 296]
  |  |  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |   78|  3.75k|				 xmlCharInRange((c), &xmlIsBaseCharGroup))
  |  |  |  |  ------------------
  |  |  ------------------
  |  |               #define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
  |  |  ------------------
  |  |  |  |  229|    296|#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
  |  |  |  |  ------------------
  |  |  |  |  |  |  184|    296|#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (184:30): [True: 0, False: 296]
  |  |  |  |  |  |  |  Branch (184:31): [True: 296, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  185|    296|				 0 :\
  |  |  |  |  |  |  186|    296|				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (186:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (186:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  187|      0|				 ((c) == 0x3007) || \
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (187:6): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  188|      0|				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (188:7): [True: 0, False: 0]
  |  |  |  |  |  |  |  Branch (188:26): [True: 0, False: 0]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
  ------------------
  |  |  171|    296|#define IS_DIGIT(c) xmlIsDigitQ(c)
  |  |  ------------------
  |  |  |  |  152|    296|#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (152:26): [True: 296, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  153|    296|				 xmlIsDigit_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  144|    296|#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
  |  |  |  |  |  |  ------------------
  |  |  |  |  |  |  |  Branch (144:28): [True: 11, False: 285]
  |  |  |  |  |  |  |  Branch (144:45): [True: 3, False: 8]
  |  |  |  |  |  |  ------------------
  |  |  |  |  ------------------
  |  |  |  |  154|    296|				 xmlCharInRange((c), &xmlIsDigitGroup))
  |  |  ------------------
  ------------------
  |  Branch (9786:24): [True: 3, False: 293]
  ------------------
 9787|  1.87k|            (c == '.') || (c == '-') ||
  ------------------
  |  Branch (9787:13): [True: 0, False: 293]
  |  Branch (9787:27): [True: 51, False: 242]
  ------------------
 9788|  1.87k|	    (c == '_') || (c == ':') ||
  ------------------
  |  Branch (9788:6): [True: 0, False: 242]
  |  Branch (9788:20): [True: 4, False: 238]
  ------------------
 9789|  1.87k|	    (IS_COMBINING(c)) ||
  ------------------
  |  |  189|    238|#define IS_COMBINING(c) xmlIsCombiningQ(c)
  |  |  ------------------
  |  |  |  |  132|    238|#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (132:29): [True: 238, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  133|    238|				 0 : \
  |  |  |  |  134|    238|				 xmlCharInRange((c), &xmlIsCombiningGroup))
  |  |  ------------------
  ------------------
  |  Branch (9789:6): [True: 0, False: 238]
  ------------------
 9790|  1.87k|	    (IS_EXTENDER(c)))) {
  ------------------
  |  |  210|    238|#define IS_EXTENDER(c) xmlIsExtenderQ(c)
  |  |  ------------------
  |  |  |  |  172|    238|#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (172:28): [True: 238, False: 0]
  |  |  |  |  ------------------
  |  |  |  |  173|    238|				 xmlIsExtender_ch((c)) : \
  |  |  |  |  ------------------
  |  |  |  |  |  |  164|    238|#define xmlIsExtender_ch(c)	(((c) == 0xb7))
  |  |  |  |  ------------------
  |  |  |  |  174|    238|				 xmlCharInRange((c), &xmlIsExtenderGroup))
  |  |  ------------------
  ------------------
  |  Branch (9790:6): [True: 0, False: 238]
  ------------------
 9791|  1.64k|	NEXTL(l);
  ------------------
  |  | 2506|  1.64k|#define NEXTL(l)  ctxt->cur += l
  ------------------
 9792|  1.64k|	c = CUR_CHAR(l);
  ------------------
  |  | 2500|  1.64k|#define CUR_CHAR(l) xmlXPathCurrentChar(ctxt, &l)
  ------------------
 9793|  1.64k|    }
 9794|    241|    ret = xmlStrndup(cur, ctxt->cur - cur);
 9795|    241|    ctxt->cur = cur;
 9796|    241|    return(ret);
 9797|    247|}
xpath.c:xmlXPathCompLocationPath:
10700|    166|xmlXPathCompLocationPath(xmlXPathParserContextPtr ctxt) {
10701|    166|    SKIP_BLANKS;
  ------------------
  |  | 2509|    166|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10702|    166|    if (CUR != '/') {
  ------------------
  |  | 2496|    166|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10702:9): [True: 26, False: 140]
  ------------------
10703|     26|        xmlXPathCompRelativeLocationPath(ctxt);
10704|    140|    } else {
10705|    271|	while (CUR == '/') {
  ------------------
  |  | 2496|    271|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10705:9): [True: 140, False: 131]
  ------------------
10706|    140|	    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|    140|#define CUR (*ctxt->cur)
  ------------------
              	    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|    140|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10706:10): [True: 140, False: 0]
  |  Branch (10706:26): [True: 83, False: 57]
  ------------------
10707|     83|		SKIP(2);
  ------------------
  |  | 2497|     83|#define SKIP(val) ctxt->cur += (val)
  ------------------
10708|     83|		SKIP_BLANKS;
  ------------------
  |  | 2509|     83|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10709|     83|		PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|     83|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|     83|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10710|     83|			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10711|     83|		xmlXPathCompRelativeLocationPath(ctxt);
10712|     83|	    } else if (CUR == '/') {
  ------------------
  |  | 2496|     57|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10712:17): [True: 57, False: 0]
  ------------------
10713|     57|		NEXT;
  ------------------
  |  | 2512|     57|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 57, False: 0]
  |  |  ------------------
  ------------------
10714|     57|		SKIP_BLANKS;
  ------------------
  |  | 2509|     57|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10715|     57|		if ((CUR != 0 ) &&
  ------------------
  |  | 2496|     57|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10715:7): [True: 57, False: 0]
  ------------------
10716|     57|		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  |  258|     57|#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
  |  |  ------------------
  |  |  |  Branch (258:30): [True: 56, False: 1]
  |  |  |  Branch (258:47): [True: 1, False: 55]
  |  |  ------------------
  |  |  259|     57|				 ((0x61 <= (c)) && ((c) <= 0x7a)))
  |  |  ------------------
  |  |  |  Branch (259:7): [True: 55, False: 1]
  |  |  |  Branch (259:24): [True: 54, False: 1]
  |  |  ------------------
  ------------------
              		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
              		    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||
  ------------------
  |  | 2496|      2|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10716:34): [True: 0, False: 2]
  |  Branch (10716:50): [True: 1, False: 1]
  ------------------
10717|     57|		     (CUR == '@') || (CUR == '*')))
  ------------------
  |  | 2496|      1|#define CUR (*ctxt->cur)
  ------------------
              		     (CUR == '@') || (CUR == '*')))
  ------------------
  |  | 2496|      1|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10717:8): [True: 0, False: 1]
  |  Branch (10717:24): [True: 0, False: 1]
  ------------------
10718|     56|		    xmlXPathCompRelativeLocationPath(ctxt);
10719|     57|	    }
10720|    140|	    CHECK_ERROR;
  ------------------
  |  |  241|    140|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 9, False: 131]
  |  |  ------------------
  ------------------
10721|    140|	}
10722|    140|    }
10723|    166|}
xpath.c:xmlXPathCompFilterExpr:
 9739|    915|xmlXPathCompFilterExpr(xmlXPathParserContextPtr ctxt) {
 9740|    915|    xmlXPathCompPrimaryExpr(ctxt);
 9741|    915|    CHECK_ERROR;
  ------------------
  |  |  241|    915|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 3, False: 912]
  |  |  ------------------
  ------------------
 9742|    912|    SKIP_BLANKS;
  ------------------
  |  | 2509|    912|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    915|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9743|       |
 9744|    920|    while (CUR == '[') {
  ------------------
  |  | 2496|    920|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9744:12): [True: 8, False: 912]
  ------------------
 9745|      8|	xmlXPathCompPredicate(ctxt, 1);
 9746|      8|	SKIP_BLANKS;
  ------------------
  |  | 2509|      8|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9747|      8|    }
 9748|       |
 9749|       |
 9750|    912|}
xpath.c:xmlXPathCompPrimaryExpr:
 9700|    915|xmlXPathCompPrimaryExpr(xmlXPathParserContextPtr ctxt) {
 9701|    915|    SKIP_BLANKS;
  ------------------
  |  | 2509|    915|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9702|    915|    if (CUR == '$') xmlXPathCompVariableReference(ctxt);
  ------------------
  |  | 2496|    915|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9702:9): [True: 0, False: 915]
  ------------------
 9703|    915|    else if (CUR == '(') {
  ------------------
  |  | 2496|    915|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9703:14): [True: 21, False: 894]
  ------------------
 9704|     21|	NEXT;
  ------------------
  |  | 2512|     21|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 21, False: 0]
  |  |  ------------------
  ------------------
 9705|     21|	SKIP_BLANKS;
  ------------------
  |  | 2509|     21|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9706|     21|	xmlXPathCompileExpr(ctxt, 1);
 9707|     21|	CHECK_ERROR;
  ------------------
  |  |  241|     21|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 21]
  |  |  ------------------
  ------------------
 9708|     21|	if (CUR != ')') {
  ------------------
  |  | 2496|     21|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9708:6): [True: 0, False: 21]
  ------------------
 9709|      0|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9710|      0|	}
 9711|     21|	NEXT;
  ------------------
  |  | 2512|     21|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 21, False: 0]
  |  |  ------------------
  ------------------
 9712|     21|	SKIP_BLANKS;
  ------------------
  |  | 2509|     21|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     33|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 12, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9713|    894|    } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|  1.78k|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 707, False: 187]
  |  |  |  Branch (268:45): [True: 479, False: 228]
  |  |  ------------------
  ------------------
                  } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  | 2496|    415|#define CUR (*ctxt->cur)
  ------------------
                  } else if (IS_ASCII_DIGIT(CUR) || (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {
  ------------------
  |  |  268|      2|#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
  |  |  ------------------
  |  |  |  Branch (268:28): [True: 2, False: 0]
  |  |  |  Branch (268:45): [True: 2, False: 0]
  |  |  ------------------
  ------------------
  |  Branch (9713:40): [True: 2, False: 413]
  ------------------
 9714|    481|	xmlXPathCompNumber(ctxt);
 9715|    481|    } else if ((CUR == '\'') || (CUR == '"')) {
  ------------------
  |  | 2496|    413|#define CUR (*ctxt->cur)
  ------------------
                  } else if ((CUR == '\'') || (CUR == '"')) {
  ------------------
  |  | 2496|    303|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9715:16): [True: 110, False: 303]
  |  Branch (9715:33): [True: 75, False: 228]
  ------------------
 9716|    185|	xmlXPathCompLiteral(ctxt);
 9717|    228|    } else {
 9718|    228|	xmlXPathCompFunctionCall(ctxt);
 9719|    228|    }
 9720|    915|    SKIP_BLANKS;
  ------------------
  |  | 2509|    915|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|  1.05k|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 135, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9721|    915|}
xpath.c:xmlXPathParseQName:
 9098|    228|xmlXPathParseQName(xmlXPathParserContextPtr ctxt, xmlChar **prefix) {
 9099|    228|    xmlChar *ret = NULL;
 9100|       |
 9101|    228|    *prefix = NULL;
 9102|    228|    ret = xmlXPathParseNCName(ctxt);
 9103|    228|    if (ret && CUR == ':') {
  ------------------
  |  | 2496|    228|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9103:9): [True: 228, False: 0]
  |  Branch (9103:16): [True: 0, False: 228]
  ------------------
 9104|      0|        *prefix = ret;
 9105|      0|	NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9106|      0|	ret = xmlXPathParseNCName(ctxt);
 9107|      0|    }
 9108|    228|    return(ret);
 9109|    228|}
xpath.c:xmlXPathCompNumber:
 9357|    481|{
 9358|    481|    double ret = 0.0;
 9359|    481|    int ok = 0;
 9360|    481|    int exponent = 0;
 9361|    481|    int is_exponent_negative = 0;
 9362|    481|    xmlXPathObjectPtr num;
 9363|    481|#ifdef __GNUC__
 9364|    481|    unsigned long tmp = 0;
 9365|    481|    double temp;
 9366|    481|#endif
 9367|       |
 9368|    481|    CHECK_ERROR;
  ------------------
  |  |  241|    481|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 481]
  |  |  ------------------
  ------------------
 9369|    481|    if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|    481|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|    479|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR != '.') && ((CUR < '0') || (CUR > '9'))) {
  ------------------
  |  | 2496|    479|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9369:9): [True: 479, False: 2]
  |  Branch (9369:26): [True: 0, False: 479]
  |  Branch (9369:41): [True: 0, False: 479]
  ------------------
 9370|      0|        XP_ERROR(XPATH_NUMBER_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9371|      0|    }
 9372|    481|#ifdef __GNUC__
 9373|       |    /*
 9374|       |     * tmp/temp is a workaround against a gcc compiler bug
 9375|       |     * http://veillard.com/gcc.bug
 9376|       |     */
 9377|    481|    ret = 0;
 9378|  1.25k|    while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|  1.25k|#define CUR (*ctxt->cur)
  ------------------
                  while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|    858|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9378:12): [True: 858, False: 400]
  |  Branch (9378:28): [True: 777, False: 81]
  ------------------
 9379|    777|	ret = ret * 10;
 9380|    777|	tmp = (CUR - '0');
  ------------------
  |  | 2496|    777|#define CUR (*ctxt->cur)
  ------------------
 9381|    777|        ok = 1;
 9382|    777|        NEXT;
  ------------------
  |  | 2512|    777|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 777, False: 0]
  |  |  ------------------
  ------------------
 9383|    777|	temp = (double) tmp;
 9384|    777|	ret = ret + temp;
 9385|    777|    }
 9386|       |#else
 9387|       |    ret = 0;
 9388|       |    while ((CUR >= '0') && (CUR <= '9')) {
 9389|       |	ret = ret * 10 + (CUR - '0');
 9390|       |	ok = 1;
 9391|       |	NEXT;
 9392|       |    }
 9393|       |#endif
 9394|    481|    if (CUR == '.') {
  ------------------
  |  | 2496|    481|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9394:9): [True: 45, False: 436]
  ------------------
 9395|     45|	int v, frac = 0, max;
 9396|     45|	double fraction = 0;
 9397|       |
 9398|     45|        NEXT;
  ------------------
  |  | 2512|     45|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 45, False: 0]
  |  |  ------------------
  ------------------
 9399|     45|        if (((CUR < '0') || (CUR > '9')) && (!ok)) {
  ------------------
  |  | 2496|     45|#define CUR (*ctxt->cur)
  ------------------
                      if (((CUR < '0') || (CUR > '9')) && (!ok)) {
  ------------------
  |  | 2496|     44|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9399:14): [True: 1, False: 44]
  |  Branch (9399:29): [True: 1, False: 43]
  |  Branch (9399:45): [True: 0, False: 2]
  ------------------
 9400|      0|            XP_ERROR(XPATH_NUMBER_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9401|      0|        }
 9402|    147|        while (CUR == '0') {
  ------------------
  |  | 2496|    147|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9402:16): [True: 102, False: 45]
  ------------------
 9403|    102|            frac = frac + 1;
 9404|    102|            NEXT;
  ------------------
  |  | 2512|    102|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 102, False: 0]
  |  |  ------------------
  ------------------
 9405|    102|        }
 9406|     45|        max = frac + MAX_FRAC;
  ------------------
  |  | 9235|     45|#define MAX_FRAC 20
  ------------------
 9407|     91|        while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {
  ------------------
  |  | 2496|     91|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9') && (frac < max)) {
  ------------------
  |  | 2496|     49|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9407:16): [True: 49, False: 42]
  |  Branch (9407:32): [True: 46, False: 3]
  |  Branch (9407:48): [True: 46, False: 0]
  ------------------
 9408|     46|	    v = (CUR - '0');
  ------------------
  |  | 2496|     46|#define CUR (*ctxt->cur)
  ------------------
 9409|     46|	    fraction = fraction * 10 + v;
 9410|     46|	    frac = frac + 1;
 9411|     46|            NEXT;
  ------------------
  |  | 2512|     46|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 46, False: 0]
  |  |  ------------------
  ------------------
 9412|     46|        }
 9413|     45|        fraction /= pow(10.0, frac);
 9414|     45|        ret = ret + fraction;
 9415|     45|        while ((CUR >= '0') && (CUR <= '9'))
  ------------------
  |  | 2496|     45|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9'))
  ------------------
  |  | 2496|      3|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9415:16): [True: 3, False: 42]
  |  Branch (9415:32): [True: 0, False: 3]
  ------------------
 9416|      0|            NEXT;
  ------------------
  |  | 2512|     45|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9417|     45|    }
 9418|    481|    if ((CUR == 'e') || (CUR == 'E')) {
  ------------------
  |  | 2496|    481|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == 'e') || (CUR == 'E')) {
  ------------------
  |  | 2496|    471|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9418:9): [True: 10, False: 471]
  |  Branch (9418:25): [True: 0, False: 471]
  ------------------
 9419|     10|        NEXT;
  ------------------
  |  | 2512|     10|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 10, False: 0]
  |  |  ------------------
  ------------------
 9420|     10|        if (CUR == '-') {
  ------------------
  |  | 2496|     10|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9420:13): [True: 5, False: 5]
  ------------------
 9421|      5|            is_exponent_negative = 1;
 9422|      5|            NEXT;
  ------------------
  |  | 2512|      5|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 5, False: 0]
  |  |  ------------------
  ------------------
 9423|      5|        } else if (CUR == '+') {
  ------------------
  |  | 2496|      5|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9423:20): [True: 0, False: 5]
  ------------------
 9424|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
 9425|      0|	}
 9426|    130|        while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|    130|#define CUR (*ctxt->cur)
  ------------------
                      while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  | 2496|    120|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9426:16): [True: 120, False: 10]
  |  Branch (9426:32): [True: 120, False: 0]
  ------------------
 9427|    120|            if (exponent < 1000000)
  ------------------
  |  Branch (9427:17): [True: 58, False: 62]
  ------------------
 9428|     58|                exponent = exponent * 10 + (CUR - '0');
  ------------------
  |  | 2496|     58|#define CUR (*ctxt->cur)
  ------------------
 9429|    120|            NEXT;
  ------------------
  |  | 2512|    120|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 120, False: 0]
  |  |  ------------------
  ------------------
 9430|    120|        }
 9431|     10|        if (is_exponent_negative)
  ------------------
  |  Branch (9431:13): [True: 5, False: 5]
  ------------------
 9432|      5|            exponent = -exponent;
 9433|     10|        ret *= pow(10.0, (double) exponent);
 9434|     10|    }
 9435|    481|    num = xmlXPathCacheNewFloat(ctxt->context, ret);
 9436|    481|    if (num == NULL) {
  ------------------
  |  Branch (9436:9): [True: 0, False: 481]
  ------------------
 9437|      0|	ctxt->error = XPATH_MEMORY_ERROR;
 9438|    481|    } else if (PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_NUMBER, 0, 0, num,
  ------------------
  |  | 1185|    481|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|    481|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (9438:16): [True: 0, False: 481]
  ------------------
 9439|    481|                              NULL) == -1) {
 9440|      0|        xmlXPathReleaseObject(ctxt->context, num);
 9441|      0|    }
 9442|    481|}
xpath.c:xmlXPathCompLiteral:
 9500|    185|xmlXPathCompLiteral(xmlXPathParserContextPtr ctxt) {
 9501|    185|    const xmlChar *q;
 9502|    185|    xmlChar *ret = NULL;
 9503|    185|    xmlXPathObjectPtr lit;
 9504|       |
 9505|    185|    if (CUR == '"') {
  ------------------
  |  | 2496|    185|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9505:9): [True: 75, False: 110]
  ------------------
 9506|     75|        NEXT;
  ------------------
  |  | 2512|     75|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 75, False: 0]
  |  |  ------------------
  ------------------
 9507|     75|	q = CUR_PTR;
  ------------------
  |  | 2499|     75|#define CUR_PTR ctxt->cur
  ------------------
 9508|    538|	while ((IS_CHAR_CH(CUR)) && (CUR != '"'))
  ------------------
  |  |  133|    538|#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|    538|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 538, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 538]
  |  |  |  |  ------------------
  |  |  |  |  109|    538|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 538]
  |  |  |  |  ------------------
  |  |  |  |  110|    538|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 538, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	while ((IS_CHAR_CH(CUR)) && (CUR != '"'))
  ------------------
  |  | 2496|    538|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9508:30): [True: 463, False: 75]
  ------------------
 9509|    463|	    NEXT;
  ------------------
  |  | 2512|    463|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 463, False: 0]
  |  |  ------------------
  ------------------
 9510|     75|	if (!IS_CHAR_CH(CUR)) {
  ------------------
  |  |  133|     75|#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|     75|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 75, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 75]
  |  |  |  |  ------------------
  |  |  |  |  109|     75|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 75]
  |  |  |  |  ------------------
  |  |  |  |  110|     75|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 75, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9511|      0|	    XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9512|     75|	} else {
 9513|     75|	    ret = xmlStrndup(q, CUR_PTR - q);
  ------------------
  |  | 2499|     75|#define CUR_PTR ctxt->cur
  ------------------
 9514|     75|	    NEXT;
  ------------------
  |  | 2512|     75|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 75, False: 0]
  |  |  ------------------
  ------------------
 9515|     75|        }
 9516|    110|    } else if (CUR == '\'') {
  ------------------
  |  | 2496|    110|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9516:16): [True: 110, False: 0]
  ------------------
 9517|    110|        NEXT;
  ------------------
  |  | 2512|    110|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 110, False: 0]
  |  |  ------------------
  ------------------
 9518|    110|	q = CUR_PTR;
  ------------------
  |  | 2499|    110|#define CUR_PTR ctxt->cur
  ------------------
 9519|    503|	while ((IS_CHAR_CH(CUR)) && (CUR != '\''))
  ------------------
  |  |  133|    503|#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|    503|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 503, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 503]
  |  |  |  |  ------------------
  |  |  |  |  109|    503|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 503]
  |  |  |  |  ------------------
  |  |  |  |  110|    503|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 503, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
              	while ((IS_CHAR_CH(CUR)) && (CUR != '\''))
  ------------------
  |  | 2496|    503|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9519:30): [True: 393, False: 110]
  ------------------
 9520|    393|	    NEXT;
  ------------------
  |  | 2512|    393|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 393, False: 0]
  |  |  ------------------
  ------------------
 9521|    110|	if (!IS_CHAR_CH(CUR)) {
  ------------------
  |  |  133|    110|#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
  |  |  ------------------
  |  |  |  |  108|    110|#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (108:28): [True: 110, False: 0]
  |  |  |  |  |  Branch (108:44): [True: 0, False: 110]
  |  |  |  |  ------------------
  |  |  |  |  109|    110|				 ((c) == 0xd) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (109:6): [True: 0, False: 110]
  |  |  |  |  ------------------
  |  |  |  |  110|    110|				  (0x20 <= (c)))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (110:7): [True: 110, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9522|      0|	    XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9523|    110|	} else {
 9524|    110|	    ret = xmlStrndup(q, CUR_PTR - q);
  ------------------
  |  | 2499|    110|#define CUR_PTR ctxt->cur
  ------------------
 9525|    110|	    NEXT;
  ------------------
  |  | 2512|    110|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 110, False: 0]
  |  |  ------------------
  ------------------
 9526|    110|        }
 9527|    110|    } else {
 9528|      0|	XP_ERROR(XPATH_START_LITERAL_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9529|      0|    }
 9530|    185|    if (ret == NULL) {
  ------------------
  |  Branch (9530:9): [True: 0, False: 185]
  ------------------
 9531|      0|        xmlXPathPErrMemory(ctxt, NULL);
 9532|      0|        return;
 9533|      0|    }
 9534|    185|    lit = xmlXPathCacheNewString(ctxt->context, ret);
 9535|    185|    if (lit == NULL) {
  ------------------
  |  Branch (9535:9): [True: 0, False: 185]
  ------------------
 9536|      0|	ctxt->error = XPATH_MEMORY_ERROR;
 9537|    185|    } else if (PUSH_LONG_EXPR(XPATH_OP_VALUE, XPATH_STRING, 0, 0, lit,
  ------------------
  |  | 1185|    185|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|    185|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (9537:16): [True: 0, False: 185]
  ------------------
 9538|    185|                              NULL) == -1) {
 9539|      0|        xmlXPathReleaseObject(ctxt->context, lit);
 9540|      0|    }
 9541|    185|    xmlFree(ret);
 9542|    185|}
xpath.c:xmlXPathCompFunctionCall:
 9627|    228|xmlXPathCompFunctionCall(xmlXPathParserContextPtr ctxt) {
 9628|    228|    xmlChar *name;
 9629|    228|    xmlChar *prefix;
 9630|    228|    int nbargs = 0;
 9631|    228|    int sort = 1;
 9632|       |
 9633|    228|    name = xmlXPathParseQName(ctxt, &prefix);
 9634|    228|    if (name == NULL) {
  ------------------
  |  Branch (9634:9): [True: 0, False: 228]
  ------------------
 9635|      0|	xmlFree(prefix);
 9636|      0|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9637|      0|    }
 9638|    228|    SKIP_BLANKS;
  ------------------
  |  | 2509|    228|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    228|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9639|       |
 9640|    228|    if (CUR != '(') {
  ------------------
  |  | 2496|    228|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9640:9): [True: 0, False: 228]
  ------------------
 9641|      0|	xmlFree(name);
 9642|      0|	xmlFree(prefix);
 9643|      0|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9644|      0|    }
 9645|    228|    NEXT;
  ------------------
  |  | 2512|    228|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 228, False: 0]
  |  |  ------------------
  ------------------
 9646|    228|    SKIP_BLANKS;
  ------------------
  |  | 2509|    228|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    228|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9647|       |
 9648|       |    /*
 9649|       |    * Optimization for count(): we don't need the node-set to be sorted.
 9650|       |    */
 9651|    228|    if ((prefix == NULL) && (name[0] == 'c') &&
  ------------------
  |  Branch (9651:9): [True: 228, False: 0]
  |  Branch (9651:29): [True: 25, False: 203]
  ------------------
 9652|    228|	xmlStrEqual(name, BAD_CAST "count"))
  ------------------
  |  |   35|     25|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (9652:2): [True: 0, False: 25]
  ------------------
 9653|      0|    {
 9654|      0|	sort = 0;
 9655|      0|    }
 9656|    228|    ctxt->comp->last = -1;
 9657|    228|    if (CUR != ')') {
  ------------------
  |  | 2496|    228|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9657:9): [True: 167, False: 61]
  ------------------
 9658|    266|	while (CUR != 0) {
  ------------------
  |  | 2496|    266|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9658:9): [True: 266, False: 0]
  ------------------
 9659|    266|	    int op1 = ctxt->comp->last;
 9660|    266|	    ctxt->comp->last = -1;
 9661|    266|	    xmlXPathCompileExpr(ctxt, sort);
 9662|    266|	    if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (9662:10): [True: 1, False: 265]
  ------------------
 9663|      1|		xmlFree(name);
 9664|      1|		xmlFree(prefix);
 9665|      1|		return;
 9666|      1|	    }
 9667|    265|	    PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|    265|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|    265|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|    265|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
 9668|    265|	    nbargs++;
 9669|    265|	    if (CUR == ')') break;
  ------------------
  |  | 2496|    265|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9669:10): [True: 164, False: 101]
  ------------------
 9670|    101|	    if (CUR != ',') {
  ------------------
  |  | 2496|    101|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (9670:10): [True: 2, False: 99]
  ------------------
 9671|      2|		xmlFree(name);
 9672|      2|		xmlFree(prefix);
 9673|      2|		XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      2|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 9674|      0|	    }
 9675|     99|	    NEXT;
  ------------------
  |  | 2512|     99|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 99, False: 0]
  |  |  ------------------
  ------------------
 9676|     99|	    SKIP_BLANKS;
  ------------------
  |  | 2509|     99|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    137|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 38, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9677|     99|	}
 9678|    167|    }
 9679|    225|    if (PUSH_LONG_EXPR(XPATH_OP_FUNCTION, nbargs, 0, 0, name, prefix) == -1) {
  ------------------
  |  | 1185|    225|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|    225|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (9679:9): [True: 0, False: 225]
  ------------------
 9680|      0|        xmlFree(prefix);
 9681|      0|        xmlFree(name);
 9682|      0|    }
 9683|    225|    NEXT;
  ------------------
  |  | 2512|    225|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 225, False: 0]
  |  |  ------------------
  ------------------
 9684|    225|    SKIP_BLANKS;
  ------------------
  |  | 2509|    225|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    233|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 8, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 9685|    225|}
xpath.c:xmlXPathCompPredicate:
10236|     74|xmlXPathCompPredicate(xmlXPathParserContextPtr ctxt, int filter) {
10237|     74|    int op1 = ctxt->comp->last;
10238|       |
10239|     74|    SKIP_BLANKS;
  ------------------
  |  | 2509|     74|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10240|     74|    if (CUR != '[') {
  ------------------
  |  | 2496|     74|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10240:9): [True: 0, False: 74]
  ------------------
10241|      0|	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10242|      0|    }
10243|     74|    NEXT;
  ------------------
  |  | 2512|     74|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 74, False: 0]
  |  |  ------------------
  ------------------
10244|     74|    SKIP_BLANKS;
  ------------------
  |  | 2509|     74|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     74|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10245|       |
10246|     74|    ctxt->comp->last = -1;
10247|       |    /*
10248|       |    * This call to xmlXPathCompileExpr() will deactivate sorting
10249|       |    * of the predicate result.
10250|       |    * TODO: Sorting is still activated for filters, since I'm not
10251|       |    *  sure if needed. Normally sorting should not be needed, since
10252|       |    *  a filter can only diminish the number of items in a sequence,
10253|       |    *  but won't change its order; so if the initial sequence is sorted,
10254|       |    *  subsequent sorting is not needed.
10255|       |    */
10256|     74|    if (! filter)
  ------------------
  |  Branch (10256:9): [True: 66, False: 8]
  ------------------
10257|     66|	xmlXPathCompileExpr(ctxt, 0);
10258|      8|    else
10259|      8|	xmlXPathCompileExpr(ctxt, 1);
10260|     74|    CHECK_ERROR;
  ------------------
  |  |  241|     74|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 74]
  |  |  ------------------
  ------------------
10261|       |
10262|     74|    if (CUR != ']') {
  ------------------
  |  | 2496|     74|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10262:9): [True: 1, False: 73]
  ------------------
10263|      1|	XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);
  ------------------
  |  |  258|      1|    { xmlXPathErr(ctxt, X); return; }
  ------------------
10264|      0|    }
10265|       |
10266|     73|    if (filter)
  ------------------
  |  Branch (10266:9): [True: 8, False: 65]
  ------------------
10267|      8|	PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|      8|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|      8|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|      8|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10268|     65|    else
10269|     65|	PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);
  ------------------
  |  | 1194|     65|#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)			\
  |  | 1195|     65|xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),			\
  |  | 1196|     65|			(val), (val2), 0 ,NULL ,NULL)
  ------------------
10270|       |
10271|     73|    NEXT;
  ------------------
  |  | 2512|     73|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 73, False: 0]
  |  |  ------------------
  ------------------
10272|     73|    SKIP_BLANKS;
  ------------------
  |  | 2509|     73|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     73|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10273|     73|}
xpath.c:xmlXPathCompRelativeLocationPath:
10648|    176|(xmlXPathParserContextPtr ctxt) {
10649|    176|    SKIP_BLANKS;
  ------------------
  |  | 2509|    176|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10650|    176|    if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|    176|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|      9|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10650:9): [True: 9, False: 167]
  |  Branch (10650:25): [True: 0, False: 9]
  ------------------
10651|      0|	SKIP(2);
  ------------------
  |  | 2497|      0|#define SKIP(val) ctxt->cur += (val)
  ------------------
10652|      0|	SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10653|      0|	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      0|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      0|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10654|      0|		         NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10655|    176|    } else if (CUR == '/') {
  ------------------
  |  | 2496|    176|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10655:16): [True: 9, False: 167]
  ------------------
10656|      9|	    NEXT;
  ------------------
  |  | 2512|      9|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 9, False: 0]
  |  |  ------------------
  ------------------
10657|      9|	SKIP_BLANKS;
  ------------------
  |  | 2509|      9|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10658|      9|    }
10659|    176|    xmlXPathCompStep(ctxt);
10660|    176|    CHECK_ERROR;
  ------------------
  |  |  241|    176|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 6, False: 170]
  |  |  ------------------
  ------------------
10661|    170|    SKIP_BLANKS;
  ------------------
  |  | 2509|    170|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    176|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10662|    266|    while (CUR == '/') {
  ------------------
  |  | 2496|    266|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10662:12): [True: 96, False: 170]
  ------------------
10663|     96|	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2496|     96|#define CUR (*ctxt->cur)
  ------------------
              	if ((CUR == '/') && (NXT(1) == '/')) {
  ------------------
  |  | 2498|     96|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10663:6): [True: 96, False: 0]
  |  Branch (10663:22): [True: 3, False: 93]
  ------------------
10664|      3|	    SKIP(2);
  ------------------
  |  | 2497|      3|#define SKIP(val) ctxt->cur += (val)
  ------------------
10665|      3|	    SKIP_BLANKS;
  ------------------
  |  | 2509|      3|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10666|      3|	    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,
  ------------------
  |  | 1185|      3|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      3|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10667|      3|			     NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10668|      3|	    xmlXPathCompStep(ctxt);
10669|     93|	} else if (CUR == '/') {
  ------------------
  |  | 2496|     93|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10669:13): [True: 93, False: 0]
  ------------------
10670|     93|	    NEXT;
  ------------------
  |  | 2512|     93|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 93, False: 0]
  |  |  ------------------
  ------------------
10671|     93|	    SKIP_BLANKS;
  ------------------
  |  | 2509|     93|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10672|     93|	    xmlXPathCompStep(ctxt);
10673|     93|	}
10674|     96|	SKIP_BLANKS;
  ------------------
  |  | 2509|     96|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10675|     96|    }
10676|    170|}
xpath.c:xmlXPathCompStep:
10514|    272|xmlXPathCompStep(xmlXPathParserContextPtr ctxt) {
10515|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10516|       |    int rangeto = 0;
10517|       |    int op2 = -1;
10518|       |#endif
10519|       |
10520|    272|    SKIP_BLANKS;
  ------------------
  |  | 2509|    272|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10521|    272|    if ((CUR == '.') && (NXT(1) == '.')) {
  ------------------
  |  | 2496|    272|#define CUR (*ctxt->cur)
  ------------------
                  if ((CUR == '.') && (NXT(1) == '.')) {
  ------------------
  |  | 2498|      5|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10521:9): [True: 5, False: 267]
  |  Branch (10521:25): [True: 1, False: 4]
  ------------------
10522|      1|	SKIP(2);
  ------------------
  |  | 2497|      1|#define SKIP(val) ctxt->cur += (val)
  ------------------
10523|      1|	SKIP_BLANKS;
  ------------------
  |  | 2509|      1|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10524|      1|	PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,
  ------------------
  |  | 1185|      1|    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,		\
  |  | 1186|      1|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
10525|      1|		    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);
10526|    271|    } else if (CUR == '.') {
  ------------------
  |  | 2496|    271|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10526:16): [True: 4, False: 267]
  ------------------
10527|      4|	NEXT;
  ------------------
  |  | 2512|      4|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 4, False: 0]
  |  |  ------------------
  ------------------
10528|      4|	SKIP_BLANKS;
  ------------------
  |  | 2509|      4|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10529|    267|    } else {
10530|    267|	xmlChar *name = NULL;
10531|    267|	xmlChar *prefix = NULL;
10532|    267|	xmlXPathTestVal test = (xmlXPathTestVal) 0;
10533|    267|	xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;
10534|    267|	xmlXPathTypeVal type = (xmlXPathTypeVal) 0;
10535|    267|	int op1;
10536|       |
10537|       |	/*
10538|       |	 * The modification needed for XPointer change to the production
10539|       |	 */
10540|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10541|       |	if (ctxt->xptr) {
10542|       |	    name = xmlXPathParseNCName(ctxt);
10543|       |	    if ((name != NULL) && (xmlStrEqual(name, BAD_CAST "range-to"))) {
10544|       |                op2 = ctxt->comp->last;
10545|       |		xmlFree(name);
10546|       |		SKIP_BLANKS;
10547|       |		if (CUR != '(') {
10548|       |		    XP_ERROR(XPATH_EXPR_ERROR);
10549|       |		}
10550|       |		NEXT;
10551|       |		SKIP_BLANKS;
10552|       |
10553|       |		xmlXPathCompileExpr(ctxt, 1);
10554|       |		/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); */
10555|       |		CHECK_ERROR;
10556|       |
10557|       |		SKIP_BLANKS;
10558|       |		if (CUR != ')') {
10559|       |		    XP_ERROR(XPATH_EXPR_ERROR);
10560|       |		}
10561|       |		NEXT;
10562|       |		rangeto = 1;
10563|       |		goto eval_predicates;
10564|       |	    }
10565|       |	}
10566|       |#endif
10567|    267|	if (CUR == '*') {
  ------------------
  |  | 2496|    267|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10567:6): [True: 27, False: 240]
  ------------------
10568|     27|	    axis = AXIS_CHILD;
10569|    240|	} else {
10570|    240|	    if (name == NULL)
  ------------------
  |  Branch (10570:10): [True: 240, False: 0]
  ------------------
10571|    240|		name = xmlXPathParseNCName(ctxt);
10572|    240|	    if (name != NULL) {
  ------------------
  |  Branch (10572:10): [True: 228, False: 12]
  ------------------
10573|    228|		axis = xmlXPathIsAxisName(name);
10574|    228|		if (axis != 0) {
  ------------------
  |  Branch (10574:7): [True: 104, False: 124]
  ------------------
10575|    104|		    SKIP_BLANKS;
  ------------------
  |  | 2509|    104|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10576|    104|		    if ((CUR == ':') && (NXT(1) == ':')) {
  ------------------
  |  | 2496|    104|#define CUR (*ctxt->cur)
  ------------------
              		    if ((CUR == ':') && (NXT(1) == ':')) {
  ------------------
  |  | 2498|    104|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (10576:11): [True: 104, False: 0]
  |  Branch (10576:27): [True: 104, False: 0]
  ------------------
10577|    104|			SKIP(2);
  ------------------
  |  | 2497|    104|#define SKIP(val) ctxt->cur += (val)
  ------------------
10578|    104|			xmlFree(name);
10579|    104|			name = NULL;
10580|    104|		    } else {
10581|       |			/* an element name can conflict with an axis one :-\ */
10582|      0|			axis = AXIS_CHILD;
10583|      0|		    }
10584|    124|		} else {
10585|    124|		    axis = AXIS_CHILD;
10586|    124|		}
10587|    228|	    } else if (CUR == '@') {
  ------------------
  |  | 2496|     12|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10587:17): [True: 12, False: 0]
  ------------------
10588|     12|		NEXT;
  ------------------
  |  | 2512|     12|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 12, False: 0]
  |  |  ------------------
  ------------------
10589|     12|		axis = AXIS_ATTRIBUTE;
10590|     12|	    } else {
10591|      0|		axis = AXIS_CHILD;
10592|      0|	    }
10593|    240|	}
10594|       |
10595|    267|        if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (10595:13): [True: 4, False: 263]
  ------------------
10596|      4|            xmlFree(name);
10597|      4|            return;
10598|      4|        }
10599|       |
10600|    263|	name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);
10601|    263|	if (test == 0)
  ------------------
  |  Branch (10601:6): [True: 9, False: 254]
  ------------------
10602|      9|	    return;
10603|       |
10604|    254|        if ((prefix != NULL) && (ctxt->context != NULL) &&
  ------------------
  |  Branch (10604:13): [True: 6, False: 248]
  |  Branch (10604:33): [True: 6, False: 0]
  ------------------
10605|    254|	    (ctxt->context->flags & XML_XPATH_CHECKNS)) {
  ------------------
  |  |  275|      6|#define XML_XPATH_CHECKNS (1<<0)
  ------------------
  |  Branch (10605:6): [True: 0, False: 6]
  ------------------
10606|      0|	    if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {
  ------------------
  |  Branch (10606:10): [True: 0, False: 0]
  ------------------
10607|      0|		xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);
10608|      0|	    }
10609|      0|	}
10610|       |
10611|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10612|       |eval_predicates:
10613|       |#endif
10614|    254|	op1 = ctxt->comp->last;
10615|    254|	ctxt->comp->last = -1;
10616|       |
10617|    254|	SKIP_BLANKS;
  ------------------
  |  | 2509|    254|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    254|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10618|    320|	while (CUR == '[') {
  ------------------
  |  | 2496|    320|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10618:9): [True: 66, False: 254]
  ------------------
10619|     66|	    xmlXPathCompPredicate(ctxt, 0);
10620|     66|	}
10621|       |
10622|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
10623|       |	if (rangeto) {
10624|       |	    PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);
10625|       |	} else
10626|       |#endif
10627|    254|        if (PUSH_FULL_EXPR(XPATH_OP_COLLECT, op1, ctxt->comp->last, axis,
  ------------------
  |  | 1182|    254|    xmlXPathCompExprAdd(ctxt, (op1), (op2),			\
  |  | 1183|    254|	                (op), (val), (val2), (val3), (val4), (val5))
  ------------------
  |  Branch (10627:13): [True: 0, False: 254]
  ------------------
10628|    254|                           test, type, (void *)prefix, (void *)name) == -1) {
10629|      0|            xmlFree(prefix);
10630|      0|            xmlFree(name);
10631|      0|        }
10632|    254|    }
10633|    272|}
xpath.c:xmlXPathIsAxisName:
10434|    228|xmlXPathIsAxisName(const xmlChar *name) {
10435|    228|    xmlXPathAxisVal ret = (xmlXPathAxisVal) 0;
10436|    228|    switch (name[0]) {
  ------------------
  |  Branch (10436:13): [True: 39, False: 189]
  ------------------
10437|     19|	case 'a':
  ------------------
  |  Branch (10437:2): [True: 19, False: 209]
  ------------------
10438|     19|	    if (xmlStrEqual(name, BAD_CAST "ancestor"))
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10438:10): [True: 3, False: 16]
  ------------------
10439|      3|		ret = AXIS_ANCESTOR;
10440|     19|	    if (xmlStrEqual(name, BAD_CAST "ancestor-or-self"))
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10440:10): [True: 5, False: 14]
  ------------------
10441|      5|		ret = AXIS_ANCESTOR_OR_SELF;
10442|     19|	    if (xmlStrEqual(name, BAD_CAST "attribute"))
  ------------------
  |  |   35|     19|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10442:10): [True: 11, False: 8]
  ------------------
10443|     11|		ret = AXIS_ATTRIBUTE;
10444|     19|	    break;
10445|     74|	case 'c':
  ------------------
  |  Branch (10445:2): [True: 74, False: 154]
  ------------------
10446|     74|	    if (xmlStrEqual(name, BAD_CAST "child"))
  ------------------
  |  |   35|     74|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10446:10): [True: 54, False: 20]
  ------------------
10447|     54|		ret = AXIS_CHILD;
10448|     74|	    break;
10449|     12|	case 'd':
  ------------------
  |  Branch (10449:2): [True: 12, False: 216]
  ------------------
10450|     12|	    if (xmlStrEqual(name, BAD_CAST "descendant"))
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10450:10): [True: 5, False: 7]
  ------------------
10451|      5|		ret = AXIS_DESCENDANT;
10452|     12|	    if (xmlStrEqual(name, BAD_CAST "descendant-or-self"))
  ------------------
  |  |   35|     12|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10452:10): [True: 3, False: 9]
  ------------------
10453|      3|		ret = AXIS_DESCENDANT_OR_SELF;
10454|     12|	    break;
10455|      9|	case 'f':
  ------------------
  |  Branch (10455:2): [True: 9, False: 219]
  ------------------
10456|      9|	    if (xmlStrEqual(name, BAD_CAST "following"))
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10456:10): [True: 8, False: 1]
  ------------------
10457|      8|		ret = AXIS_FOLLOWING;
10458|      9|	    if (xmlStrEqual(name, BAD_CAST "following-sibling"))
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10458:10): [True: 0, False: 9]
  ------------------
10459|      0|		ret = AXIS_FOLLOWING_SIBLING;
10460|      9|	    break;
10461|      9|	case 'n':
  ------------------
  |  Branch (10461:2): [True: 9, False: 219]
  ------------------
10462|      9|	    if (xmlStrEqual(name, BAD_CAST "namespace"))
  ------------------
  |  |   35|      9|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10462:10): [True: 5, False: 4]
  ------------------
10463|      5|		ret = AXIS_NAMESPACE;
10464|      9|	    break;
10465|     52|	case 'p':
  ------------------
  |  Branch (10465:2): [True: 52, False: 176]
  ------------------
10466|     52|	    if (xmlStrEqual(name, BAD_CAST "parent"))
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10466:10): [True: 0, False: 52]
  ------------------
10467|      0|		ret = AXIS_PARENT;
10468|     52|	    if (xmlStrEqual(name, BAD_CAST "preceding"))
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10468:10): [True: 6, False: 46]
  ------------------
10469|      6|		ret = AXIS_PRECEDING;
10470|     52|	    if (xmlStrEqual(name, BAD_CAST "preceding-sibling"))
  ------------------
  |  |   35|     52|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10470:10): [True: 0, False: 52]
  ------------------
10471|      0|		ret = AXIS_PRECEDING_SIBLING;
10472|     52|	    break;
10473|     14|	case 's':
  ------------------
  |  Branch (10473:2): [True: 14, False: 214]
  ------------------
10474|     14|	    if (xmlStrEqual(name, BAD_CAST "self"))
  ------------------
  |  |   35|     14|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10474:10): [True: 4, False: 10]
  ------------------
10475|      4|		ret = AXIS_SELF;
10476|     14|	    break;
10477|    228|    }
10478|    228|    return(ret);
10479|    228|}
xpath.c:xmlXPathCompNodeTest:
10299|    263|		     xmlChar *name) {
10300|    263|    int blanks;
10301|       |
10302|    263|    if ((test == NULL) || (type == NULL) || (prefix == NULL)) {
  ------------------
  |  Branch (10302:9): [True: 0, False: 263]
  |  Branch (10302:27): [True: 0, False: 263]
  |  Branch (10302:45): [True: 0, False: 263]
  ------------------
10303|      0|	STRANGE;
  ------------------
  |  | 1230|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1231|      0|	    "Internal error at %s:%d\n",				\
  |  | 1232|      0|            __FILE__, __LINE__);
  ------------------
10304|      0|	return(NULL);
10305|      0|    }
10306|    263|    *type = (xmlXPathTypeVal) 0;
10307|    263|    *test = (xmlXPathTestVal) 0;
10308|    263|    *prefix = NULL;
10309|    263|    SKIP_BLANKS;
  ------------------
  |  | 2509|    263|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    265|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 2, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10310|       |
10311|    263|    if ((name == NULL) && (CUR == '*')) {
  ------------------
  |  | 2496|    143|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10311:9): [True: 143, False: 120]
  |  Branch (10311:27): [True: 52, False: 91]
  ------------------
10312|       |	/*
10313|       |	 * All elements
10314|       |	 */
10315|     52|	NEXT;
  ------------------
  |  | 2512|     52|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 52, False: 0]
  |  |  ------------------
  ------------------
10316|     52|	*test = NODE_TEST_ALL;
10317|     52|	return(NULL);
10318|     52|    }
10319|       |
10320|    211|    if (name == NULL)
  ------------------
  |  Branch (10320:9): [True: 91, False: 120]
  ------------------
10321|     91|	name = xmlXPathParseNCName(ctxt);
10322|    211|    if (name == NULL) {
  ------------------
  |  Branch (10322:9): [True: 1, False: 210]
  ------------------
10323|      1|	XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      1|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10324|      0|    }
10325|       |
10326|    210|    blanks = IS_BLANK_CH(CUR);
  ------------------
  |  |  151|    210|#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
  |  |  ------------------
  |  |  |  |   88|    210|#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (88:27): [True: 0, False: 210]
  |  |  |  |  ------------------
  |  |  |  |   89|    210|				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (89:7): [True: 190, False: 20]
  |  |  |  |  |  Branch (89:23): [True: 0, False: 190]
  |  |  |  |  ------------------
  |  |  |  |   90|    210|				 ((c) == 0xd))
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (90:6): [True: 0, False: 210]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10327|    210|    SKIP_BLANKS;
  ------------------
  |  | 2509|    210|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|    210|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10328|    210|    if (CUR == '(') {
  ------------------
  |  | 2496|    210|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10328:9): [True: 32, False: 178]
  ------------------
10329|     32|	NEXT;
  ------------------
  |  | 2512|     32|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 32, False: 0]
  |  |  ------------------
  ------------------
10330|       |	/*
10331|       |	 * NodeType or PI search
10332|       |	 */
10333|     32|	if (xmlStrEqual(name, BAD_CAST "comment"))
  ------------------
  |  |   35|     32|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10333:6): [True: 0, False: 32]
  ------------------
10334|      0|	    *type = NODE_TYPE_COMMENT;
10335|     32|	else if (xmlStrEqual(name, BAD_CAST "node"))
  ------------------
  |  |   35|     32|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10335:11): [True: 10, False: 22]
  ------------------
10336|     10|	    *type = NODE_TYPE_NODE;
10337|     22|	else if (xmlStrEqual(name, BAD_CAST "processing-instruction"))
  ------------------
  |  |   35|     22|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10337:11): [True: 0, False: 22]
  ------------------
10338|      0|	    *type = NODE_TYPE_PI;
10339|     22|	else if (xmlStrEqual(name, BAD_CAST "text"))
  ------------------
  |  |   35|     22|#define BAD_CAST (xmlChar *)
  ------------------
  |  Branch (10339:11): [True: 14, False: 8]
  ------------------
10340|     14|	    *type = NODE_TYPE_TEXT;
10341|      8|	else {
10342|      8|	    if (name != NULL)
  ------------------
  |  Branch (10342:10): [True: 8, False: 0]
  ------------------
10343|      8|		xmlFree(name);
10344|      8|	    XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      8|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10345|      0|	}
10346|       |
10347|     24|	*test = NODE_TEST_TYPE;
10348|       |
10349|     24|	SKIP_BLANKS;
  ------------------
  |  | 2509|     24|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|     24|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10350|     24|	if (*type == NODE_TYPE_PI) {
  ------------------
  |  Branch (10350:6): [True: 0, False: 24]
  ------------------
10351|       |	    /*
10352|       |	     * Specific case: search a PI by name.
10353|       |	     */
10354|      0|	    if (name != NULL)
  ------------------
  |  Branch (10354:10): [True: 0, False: 0]
  ------------------
10355|      0|		xmlFree(name);
10356|      0|	    name = NULL;
10357|      0|	    if (CUR != ')') {
  ------------------
  |  | 2496|      0|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10357:10): [True: 0, False: 0]
  ------------------
10358|      0|		name = xmlXPathParseLiteral(ctxt);
10359|      0|                if (name == NULL) {
  ------------------
  |  Branch (10359:21): [True: 0, False: 0]
  ------------------
10360|      0|	            XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10361|      0|                }
10362|      0|		*test = NODE_TEST_PI;
10363|      0|		SKIP_BLANKS;
  ------------------
  |  | 2509|      0|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
10364|      0|	    }
10365|      0|	}
10366|     24|	if (CUR != ')') {
  ------------------
  |  | 2496|     24|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10366:6): [True: 0, False: 24]
  ------------------
10367|      0|	    if (name != NULL)
  ------------------
  |  Branch (10367:10): [True: 0, False: 0]
  ------------------
10368|      0|		xmlFree(name);
10369|      0|	    XP_ERRORNULL(XPATH_UNCLOSED_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10370|      0|	}
10371|     24|	NEXT;
  ------------------
  |  | 2512|     24|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 24, False: 0]
  |  |  ------------------
  ------------------
10372|     24|	return(name);
10373|     24|    }
10374|    178|    *test = NODE_TEST_NAME;
10375|    178|    if ((!blanks) && (CUR == ':')) {
  ------------------
  |  | 2496|    178|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10375:9): [True: 178, False: 0]
  |  Branch (10375:22): [True: 6, False: 172]
  ------------------
10376|      6|	NEXT;
  ------------------
  |  | 2512|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 6, False: 0]
  |  |  ------------------
  ------------------
10377|       |
10378|       |	/*
10379|       |	 * Since currently the parser context don't have a
10380|       |	 * namespace list associated:
10381|       |	 * The namespace name for this prefix can be computed
10382|       |	 * only at evaluation time. The compilation is done
10383|       |	 * outside of any context.
10384|       |	 */
10385|       |#if 0
10386|       |	*prefix = xmlXPathNsLookup(ctxt->context, name);
10387|       |	if (name != NULL)
10388|       |	    xmlFree(name);
10389|       |	if (*prefix == NULL) {
10390|       |	    XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
10391|       |	}
10392|       |#else
10393|      6|	*prefix = name;
10394|      6|#endif
10395|       |
10396|      6|	if (CUR == '*') {
  ------------------
  |  | 2496|      6|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (10396:6): [True: 0, False: 6]
  ------------------
10397|       |	    /*
10398|       |	     * All elements
10399|       |	     */
10400|      0|	    NEXT;
  ------------------
  |  | 2512|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (2512:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
10401|      0|	    *test = NODE_TEST_ALL;
10402|      0|	    return(NULL);
10403|      0|	}
10404|       |
10405|      6|	name = xmlXPathParseNCName(ctxt);
10406|      6|	if (name == NULL) {
  ------------------
  |  Branch (10406:6): [True: 0, False: 6]
  ------------------
10407|      0|	    XP_ERRORNULL(XPATH_EXPR_ERROR);
  ------------------
  |  |  589|      0|    { xmlXPathErr(ctxt, X); return(NULL); }
  ------------------
10408|      0|	}
10409|      6|    }
10410|    178|    return(name);
10411|    178|}
xpath.c:xmlXPathCompExprAdd:
 1106|  2.59k|   int value2, int value3, void *value4, void *value5) {
 1107|  2.59k|    xmlXPathCompExprPtr comp = ctxt->comp;
 1108|  2.59k|    if (comp->nbStep >= comp->maxStep) {
  ------------------
  |  Branch (1108:9): [True: 37, False: 2.55k]
  ------------------
 1109|     37|	xmlXPathStepOp *real;
 1110|       |
 1111|     37|        if (comp->maxStep >= XPATH_MAX_STEPS) {
  ------------------
  |  |   97|     37|#define XPATH_MAX_STEPS 1000000
  ------------------
  |  Branch (1111:13): [True: 0, False: 37]
  ------------------
 1112|      0|	    xmlXPathPErrMemory(ctxt, "adding step\n");
 1113|      0|	    return(-1);
 1114|      0|        }
 1115|     37|	comp->maxStep *= 2;
 1116|     37|	real = (xmlXPathStepOp *) xmlRealloc(comp->steps,
 1117|     37|		                      comp->maxStep * sizeof(xmlXPathStepOp));
 1118|     37|	if (real == NULL) {
  ------------------
  |  Branch (1118:6): [True: 0, False: 37]
  ------------------
 1119|      0|	    comp->maxStep /= 2;
 1120|      0|	    xmlXPathPErrMemory(ctxt, "adding step\n");
 1121|      0|	    return(-1);
 1122|      0|	}
 1123|     37|	comp->steps = real;
 1124|     37|    }
 1125|  2.59k|    comp->last = comp->nbStep;
 1126|  2.59k|    comp->steps[comp->nbStep].ch1 = ch1;
 1127|  2.59k|    comp->steps[comp->nbStep].ch2 = ch2;
 1128|  2.59k|    comp->steps[comp->nbStep].op = op;
 1129|  2.59k|    comp->steps[comp->nbStep].value = value;
 1130|  2.59k|    comp->steps[comp->nbStep].value2 = value2;
 1131|  2.59k|    comp->steps[comp->nbStep].value3 = value3;
 1132|  2.59k|    if ((comp->dict != NULL) &&
  ------------------
  |  Branch (1132:9): [True: 0, False: 2.59k]
  ------------------
 1133|  2.59k|        ((op == XPATH_OP_FUNCTION) || (op == XPATH_OP_VARIABLE) ||
  ------------------
  |  Branch (1133:10): [True: 0, False: 0]
  |  Branch (1133:39): [True: 0, False: 0]
  ------------------
 1134|      0|	 (op == XPATH_OP_COLLECT))) {
  ------------------
  |  Branch (1134:3): [True: 0, False: 0]
  ------------------
 1135|      0|        if (value4 != NULL) {
  ------------------
  |  Branch (1135:13): [True: 0, False: 0]
  ------------------
 1136|      0|	    comp->steps[comp->nbStep].value4 = (xmlChar *)
 1137|      0|	        (void *)xmlDictLookup(comp->dict, value4, -1);
 1138|      0|	    xmlFree(value4);
 1139|      0|	} else
 1140|      0|	    comp->steps[comp->nbStep].value4 = NULL;
 1141|      0|        if (value5 != NULL) {
  ------------------
  |  Branch (1141:13): [True: 0, False: 0]
  ------------------
 1142|      0|	    comp->steps[comp->nbStep].value5 = (xmlChar *)
 1143|      0|	        (void *)xmlDictLookup(comp->dict, value5, -1);
 1144|      0|	    xmlFree(value5);
 1145|      0|	} else
 1146|      0|	    comp->steps[comp->nbStep].value5 = NULL;
 1147|  2.59k|    } else {
 1148|  2.59k|	comp->steps[comp->nbStep].value4 = value4;
 1149|  2.59k|	comp->steps[comp->nbStep].value5 = value5;
 1150|  2.59k|    }
 1151|  2.59k|    comp->steps[comp->nbStep].cache = NULL;
 1152|  2.59k|    return(comp->nbStep++);
 1153|  2.59k|}
xpath.c:xmlXPathOptimizeExpression:
13239|  2.43k|{
13240|  2.43k|    xmlXPathCompExprPtr comp = pctxt->comp;
13241|  2.43k|    xmlXPathContextPtr ctxt;
13242|       |
13243|       |    /*
13244|       |    * Try to rewrite "descendant-or-self::node()/foo" to an optimized
13245|       |    * internal representation.
13246|       |    */
13247|       |
13248|  2.43k|    if ((op->op == XPATH_OP_COLLECT /* 11 */) &&
  ------------------
  |  Branch (13248:9): [True: 278, False: 2.15k]
  ------------------
13249|  2.43k|        (op->ch1 != -1) &&
  ------------------
  |  Branch (13249:9): [True: 278, False: 0]
  ------------------
13250|  2.43k|        (op->ch2 == -1 /* no predicate */))
  ------------------
  |  Branch (13250:9): [True: 225, False: 53]
  ------------------
13251|    225|    {
13252|    225|        xmlXPathStepOpPtr prevop = &comp->steps[op->ch1];
13253|       |
13254|    225|        if ((prevop->op == XPATH_OP_COLLECT /* 11 */) &&
  ------------------
  |  Branch (13254:13): [True: 111, False: 114]
  ------------------
13255|    225|            ((xmlXPathAxisVal) prevop->value ==
  ------------------
  |  Branch (13255:13): [True: 39, False: 72]
  ------------------
13256|    111|                AXIS_DESCENDANT_OR_SELF) &&
13257|    225|            (prevop->ch2 == -1) &&
  ------------------
  |  Branch (13257:13): [True: 39, False: 0]
  ------------------
13258|    225|            ((xmlXPathTestVal) prevop->value2 == NODE_TEST_TYPE) &&
  ------------------
  |  Branch (13258:13): [True: 39, False: 0]
  ------------------
13259|    225|            ((xmlXPathTypeVal) prevop->value3 == NODE_TYPE_NODE))
  ------------------
  |  Branch (13259:13): [True: 39, False: 0]
  ------------------
13260|     39|        {
13261|       |            /*
13262|       |            * This is a "descendant-or-self::node()" without predicates.
13263|       |            * Try to eliminate it.
13264|       |            */
13265|       |
13266|     39|            switch ((xmlXPathAxisVal) op->value) {
13267|     39|                case AXIS_CHILD:
  ------------------
  |  Branch (13267:17): [True: 39, False: 0]
  ------------------
13268|     39|                case AXIS_DESCENDANT:
  ------------------
  |  Branch (13268:17): [True: 0, False: 39]
  ------------------
13269|       |                    /*
13270|       |                    * Convert "descendant-or-self::node()/child::" or
13271|       |                    * "descendant-or-self::node()/descendant::" to
13272|       |                    * "descendant::"
13273|       |                    */
13274|     39|                    op->ch1   = prevop->ch1;
13275|     39|                    op->value = AXIS_DESCENDANT;
13276|     39|                    break;
13277|      0|                case AXIS_SELF:
  ------------------
  |  Branch (13277:17): [True: 0, False: 39]
  ------------------
13278|      0|                case AXIS_DESCENDANT_OR_SELF:
  ------------------
  |  Branch (13278:17): [True: 0, False: 39]
  ------------------
13279|       |                    /*
13280|       |                    * Convert "descendant-or-self::node()/self::" or
13281|       |                    * "descendant-or-self::node()/descendant-or-self::" to
13282|       |                    * to "descendant-or-self::"
13283|       |                    */
13284|      0|                    op->ch1   = prevop->ch1;
13285|      0|                    op->value = AXIS_DESCENDANT_OR_SELF;
13286|      0|                    break;
13287|      0|                default:
  ------------------
  |  Branch (13287:17): [True: 0, False: 39]
  ------------------
13288|      0|                    break;
13289|     39|            }
13290|     39|	}
13291|    225|    }
13292|       |
13293|       |    /* OP_VALUE has invalid ch1. */
13294|  2.43k|    if (op->op == XPATH_OP_VALUE)
  ------------------
  |  Branch (13294:9): [True: 629, False: 1.80k]
  ------------------
13295|    629|        return;
13296|       |
13297|       |    /* Recurse */
13298|  1.80k|    ctxt = pctxt->context;
13299|  1.80k|    if (ctxt != NULL) {
  ------------------
  |  Branch (13299:9): [True: 1.80k, False: 0]
  ------------------
13300|  1.80k|        if (ctxt->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|  1.80k|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (13300:13): [True: 0, False: 1.80k]
  ------------------
13301|      0|            return;
13302|  1.80k|        ctxt->depth += 1;
13303|  1.80k|    }
13304|  1.80k|    if (op->ch1 != -1)
  ------------------
  |  Branch (13304:9): [True: 1.38k, False: 417]
  ------------------
13305|  1.38k|        xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch1]);
13306|  1.80k|    if (op->ch2 != -1)
  ------------------
  |  Branch (13306:9): [True: 664, False: 1.14k]
  ------------------
13307|    664|	xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);
13308|  1.80k|    if (ctxt != NULL)
  ------------------
  |  Branch (13308:9): [True: 1.80k, False: 0]
  ------------------
13309|  1.80k|        ctxt->depth -= 1;
13310|  1.80k|}
xpath.c:xmlXPathRunEval:
12989|    416|{
12990|    416|    xmlXPathCompExprPtr comp;
12991|    416|    int oldDepth;
12992|       |
12993|    416|    if ((ctxt == NULL) || (ctxt->comp == NULL))
  ------------------
  |  Branch (12993:9): [True: 0, False: 416]
  |  Branch (12993:27): [True: 0, False: 416]
  ------------------
12994|      0|	return(-1);
12995|       |
12996|    416|    if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (12996:9): [True: 0, False: 416]
  ------------------
12997|       |	/* Allocate the value stack */
12998|      0|	ctxt->valueTab = (xmlXPathObjectPtr *)
12999|      0|			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
13000|      0|	if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (13000:6): [True: 0, False: 0]
  ------------------
13001|      0|	    xmlXPathPErrMemory(ctxt, "creating evaluation context\n");
13002|      0|	    return(-1);
13003|      0|	}
13004|      0|	ctxt->valueNr = 0;
13005|      0|	ctxt->valueMax = 10;
13006|      0|	ctxt->value = NULL;
13007|      0|    }
13008|    416|#ifdef XPATH_STREAMING
13009|    416|    if (ctxt->comp->stream) {
  ------------------
  |  Branch (13009:9): [True: 15, False: 401]
  ------------------
13010|     15|	int res;
13011|       |
13012|     15|	if (toBool) {
  ------------------
  |  Branch (13012:6): [True: 0, False: 15]
  ------------------
13013|       |	    /*
13014|       |	    * Evaluation to boolean result.
13015|       |	    */
13016|      0|	    res = xmlXPathRunStreamEval(ctxt->context,
13017|      0|		ctxt->comp->stream, NULL, 1);
13018|      0|	    if (res != -1)
  ------------------
  |  Branch (13018:10): [True: 0, False: 0]
  ------------------
13019|      0|		return(res);
13020|     15|	} else {
13021|     15|	    xmlXPathObjectPtr resObj = NULL;
13022|       |
13023|       |	    /*
13024|       |	    * Evaluation to a sequence.
13025|       |	    */
13026|     15|	    res = xmlXPathRunStreamEval(ctxt->context,
13027|     15|		ctxt->comp->stream, &resObj, 0);
13028|       |
13029|     15|	    if ((res != -1) && (resObj != NULL)) {
  ------------------
  |  Branch (13029:10): [True: 15, False: 0]
  |  Branch (13029:25): [True: 15, False: 0]
  ------------------
13030|     15|		valuePush(ctxt, resObj);
13031|     15|		return(0);
13032|     15|	    }
13033|      0|	    if (resObj != NULL)
  ------------------
  |  Branch (13033:10): [True: 0, False: 0]
  ------------------
13034|      0|		xmlXPathReleaseObject(ctxt->context, resObj);
13035|      0|	}
13036|       |	/*
13037|       |	* QUESTION TODO: This falls back to normal XPath evaluation
13038|       |	* if res == -1. Is this intended?
13039|       |	*/
13040|     15|    }
13041|    401|#endif
13042|    401|    comp = ctxt->comp;
13043|    401|    if (comp->last < 0) {
  ------------------
  |  Branch (13043:9): [True: 0, False: 401]
  ------------------
13044|      0|	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              	xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
13045|      0|	    "xmlXPathRunEval: last is less than zero\n");
13046|      0|	return(-1);
13047|      0|    }
13048|    401|    oldDepth = ctxt->context->depth;
13049|    401|    if (toBool)
  ------------------
  |  Branch (13049:9): [True: 0, False: 401]
  ------------------
13050|      0|	return(xmlXPathCompOpEvalToBoolean(ctxt,
13051|      0|	    &comp->steps[comp->last], 0));
13052|    401|    else
13053|    401|	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);
13054|    401|    ctxt->context->depth = oldDepth;
13055|       |
13056|    401|    return(0);
13057|    401|}
xpath.c:xmlXPathRunStreamEval:
12754|     15|{
12755|     15|    int max_depth, min_depth;
12756|     15|    int from_root;
12757|     15|    int ret, depth;
12758|     15|    int eval_all_nodes;
12759|     15|    xmlNodePtr cur = NULL, limit = NULL;
12760|     15|    xmlStreamCtxtPtr patstream = NULL;
12761|       |
12762|     15|    if ((ctxt == NULL) || (comp == NULL))
  ------------------
  |  Branch (12762:9): [True: 0, False: 15]
  |  Branch (12762:27): [True: 0, False: 15]
  ------------------
12763|      0|        return(-1);
12764|     15|    max_depth = xmlPatternMaxDepth(comp);
12765|     15|    if (max_depth == -1)
  ------------------
  |  Branch (12765:9): [True: 0, False: 15]
  ------------------
12766|      0|        return(-1);
12767|     15|    if (max_depth == -2)
  ------------------
  |  Branch (12767:9): [True: 9, False: 6]
  ------------------
12768|      9|        max_depth = 10000;
12769|     15|    min_depth = xmlPatternMinDepth(comp);
12770|     15|    if (min_depth == -1)
  ------------------
  |  Branch (12770:9): [True: 0, False: 15]
  ------------------
12771|      0|        return(-1);
12772|     15|    from_root = xmlPatternFromRoot(comp);
12773|     15|    if (from_root < 0)
  ------------------
  |  Branch (12773:9): [True: 0, False: 15]
  ------------------
12774|      0|        return(-1);
12775|       |#if 0
12776|       |    printf("stream eval: depth %d from root %d\n", max_depth, from_root);
12777|       |#endif
12778|       |
12779|     15|    if (! toBool) {
  ------------------
  |  Branch (12779:9): [True: 15, False: 0]
  ------------------
12780|     15|	if (resultSeq == NULL)
  ------------------
  |  Branch (12780:6): [True: 0, False: 15]
  ------------------
12781|      0|	    return(-1);
12782|     15|	*resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);
12783|     15|	if (*resultSeq == NULL)
  ------------------
  |  Branch (12783:6): [True: 0, False: 15]
  ------------------
12784|      0|	    return(-1);
12785|     15|    }
12786|       |
12787|       |    /*
12788|       |     * handle the special cases of "/" amd "." being matched
12789|       |     */
12790|     15|    if (min_depth == 0) {
  ------------------
  |  Branch (12790:9): [True: 0, False: 15]
  ------------------
12791|      0|	if (from_root) {
  ------------------
  |  Branch (12791:6): [True: 0, False: 0]
  ------------------
12792|       |	    /* Select "/" */
12793|      0|	    if (toBool)
  ------------------
  |  Branch (12793:10): [True: 0, False: 0]
  ------------------
12794|      0|		return(1);
12795|       |            /* TODO: Check memory error. */
12796|      0|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,
12797|      0|		                     (xmlNodePtr) ctxt->doc);
12798|      0|	} else {
12799|       |	    /* Select "self::node()" */
12800|      0|	    if (toBool)
  ------------------
  |  Branch (12800:10): [True: 0, False: 0]
  ------------------
12801|      0|		return(1);
12802|       |            /* TODO: Check memory error. */
12803|      0|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, ctxt->node);
12804|      0|	}
12805|      0|    }
12806|     15|    if (max_depth == 0) {
  ------------------
  |  Branch (12806:9): [True: 0, False: 15]
  ------------------
12807|      0|	return(0);
12808|      0|    }
12809|       |
12810|     15|    if (from_root) {
  ------------------
  |  Branch (12810:9): [True: 13, False: 2]
  ------------------
12811|     13|        cur = (xmlNodePtr)ctxt->doc;
12812|     13|    } else if (ctxt->node != NULL) {
  ------------------
  |  Branch (12812:16): [True: 2, False: 0]
  ------------------
12813|      2|        switch (ctxt->node->type) {
  ------------------
  |  Branch (12813:17): [True: 0, False: 2]
  ------------------
12814|      0|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (12814:13): [True: 0, False: 2]
  ------------------
12815|      2|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (12815:13): [True: 2, False: 0]
  ------------------
12816|      2|            case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (12816:13): [True: 0, False: 2]
  ------------------
12817|      2|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (12817:13): [True: 0, False: 2]
  ------------------
12818|      2|	        cur = ctxt->node;
12819|      2|		break;
12820|      0|            case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (12820:13): [True: 0, False: 2]
  ------------------
12821|      0|            case XML_TEXT_NODE:
  ------------------
  |  Branch (12821:13): [True: 0, False: 2]
  ------------------
12822|      0|            case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (12822:13): [True: 0, False: 2]
  ------------------
12823|      0|            case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (12823:13): [True: 0, False: 2]
  ------------------
12824|      0|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (12824:13): [True: 0, False: 2]
  ------------------
12825|      0|            case XML_PI_NODE:
  ------------------
  |  Branch (12825:13): [True: 0, False: 2]
  ------------------
12826|      0|            case XML_COMMENT_NODE:
  ------------------
  |  Branch (12826:13): [True: 0, False: 2]
  ------------------
12827|      0|            case XML_NOTATION_NODE:
  ------------------
  |  Branch (12827:13): [True: 0, False: 2]
  ------------------
12828|      0|            case XML_DTD_NODE:
  ------------------
  |  Branch (12828:13): [True: 0, False: 2]
  ------------------
12829|      0|            case XML_DOCUMENT_TYPE_NODE:
  ------------------
  |  Branch (12829:13): [True: 0, False: 2]
  ------------------
12830|      0|            case XML_ELEMENT_DECL:
  ------------------
  |  Branch (12830:13): [True: 0, False: 2]
  ------------------
12831|      0|            case XML_ATTRIBUTE_DECL:
  ------------------
  |  Branch (12831:13): [True: 0, False: 2]
  ------------------
12832|      0|            case XML_ENTITY_DECL:
  ------------------
  |  Branch (12832:13): [True: 0, False: 2]
  ------------------
12833|      0|            case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (12833:13): [True: 0, False: 2]
  ------------------
12834|      0|            case XML_XINCLUDE_START:
  ------------------
  |  Branch (12834:13): [True: 0, False: 2]
  ------------------
12835|      0|            case XML_XINCLUDE_END:
  ------------------
  |  Branch (12835:13): [True: 0, False: 2]
  ------------------
12836|      0|		break;
12837|      2|	}
12838|      2|	limit = cur;
12839|      2|    }
12840|     15|    if (cur == NULL) {
  ------------------
  |  Branch (12840:9): [True: 0, False: 15]
  ------------------
12841|      0|        return(0);
12842|      0|    }
12843|       |
12844|     15|    patstream = xmlPatternGetStreamCtxt(comp);
12845|     15|    if (patstream == NULL) {
  ------------------
  |  Branch (12845:9): [True: 0, False: 15]
  ------------------
12846|       |	/*
12847|       |	* QUESTION TODO: Is this an error?
12848|       |	*/
12849|      0|	return(0);
12850|      0|    }
12851|       |
12852|     15|    eval_all_nodes = xmlStreamWantsAnyNode(patstream);
12853|       |
12854|     15|    if (from_root) {
  ------------------
  |  Branch (12854:9): [True: 13, False: 2]
  ------------------
12855|     13|	ret = xmlStreamPush(patstream, NULL, NULL);
12856|     13|	if (ret < 0) {
  ------------------
  |  Branch (12856:6): [True: 0, False: 13]
  ------------------
12857|     13|	} else if (ret == 1) {
  ------------------
  |  Branch (12857:13): [True: 3, False: 10]
  ------------------
12858|      3|	    if (toBool)
  ------------------
  |  Branch (12858:10): [True: 0, False: 3]
  ------------------
12859|      0|		goto return_1;
12860|       |            /* TODO: Check memory error. */
12861|      3|	    xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur);
12862|      3|	}
12863|     13|    }
12864|     15|    depth = 0;
12865|     15|    goto scan_children;
12866|     81|next_node:
12867|    150|    do {
12868|    150|        if (ctxt->opLimit != 0) {
  ------------------
  |  Branch (12868:13): [True: 150, False: 0]
  ------------------
12869|    150|            if (ctxt->opCount >= ctxt->opLimit) {
  ------------------
  |  Branch (12869:17): [True: 0, False: 150]
  ------------------
12870|      0|                xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                              xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12871|      0|                        "XPath operation limit exceeded\n");
12872|      0|                xmlFreeStreamCtxt(patstream);
12873|      0|                return(-1);
12874|      0|            }
12875|    150|            ctxt->opCount++;
12876|    150|        }
12877|       |
12878|    150|	switch (cur->type) {
12879|     56|	    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (12879:6): [True: 56, False: 94]
  ------------------
12880|    120|	    case XML_TEXT_NODE:
  ------------------
  |  Branch (12880:6): [True: 64, False: 86]
  ------------------
12881|    130|	    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (12881:6): [True: 10, False: 140]
  ------------------
12882|    140|	    case XML_COMMENT_NODE:
  ------------------
  |  Branch (12882:6): [True: 10, False: 140]
  ------------------
12883|    150|	    case XML_PI_NODE:
  ------------------
  |  Branch (12883:6): [True: 10, False: 140]
  ------------------
12884|    150|		if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (12884:7): [True: 56, False: 94]
  ------------------
12885|     56|		    ret = xmlStreamPush(patstream, cur->name,
12886|     56|				(cur->ns ? cur->ns->href : NULL));
  ------------------
  |  Branch (12886:6): [True: 0, False: 56]
  ------------------
12887|     94|		} else if (eval_all_nodes)
  ------------------
  |  Branch (12887:14): [True: 40, False: 54]
  ------------------
12888|     40|		    ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);
12889|     54|		else
12890|     54|		    break;
12891|       |
12892|     96|		if (ret < 0) {
  ------------------
  |  Branch (12892:7): [True: 0, False: 96]
  ------------------
12893|       |		    /* NOP. */
12894|     96|		} else if (ret == 1) {
  ------------------
  |  Branch (12894:14): [True: 61, False: 35]
  ------------------
12895|     61|		    if (toBool)
  ------------------
  |  Branch (12895:11): [True: 0, False: 61]
  ------------------
12896|      0|			goto return_1;
12897|     61|		    if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur)
  ------------------
  |  Branch (12897:11): [True: 0, False: 61]
  ------------------
12898|     61|		        < 0) {
12899|      0|			ctxt->lastError.domain = XML_FROM_XPATH;
12900|      0|			ctxt->lastError.code = XML_ERR_NO_MEMORY;
12901|      0|		    }
12902|     61|		}
12903|     96|		if ((cur->children == NULL) || (depth >= max_depth)) {
  ------------------
  |  Branch (12903:7): [True: 50, False: 46]
  |  Branch (12903:34): [True: 8, False: 38]
  ------------------
12904|     58|		    ret = xmlStreamPop(patstream);
12905|     58|		    while (cur->next != NULL) {
  ------------------
  |  Branch (12905:14): [True: 50, False: 8]
  ------------------
12906|     50|			cur = cur->next;
12907|     50|			if ((cur->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (12907:8): [True: 50, False: 0]
  ------------------
12908|     50|			    (cur->type != XML_DTD_NODE))
  ------------------
  |  Branch (12908:8): [True: 50, False: 0]
  ------------------
12909|     50|			    goto next_node;
12910|     50|		    }
12911|     58|		}
12912|     46|	    default:
  ------------------
  |  Branch (12912:6): [True: 0, False: 150]
  ------------------
12913|     46|		break;
12914|    150|	}
12915|       |
12916|    115|scan_children:
12917|    115|	if (cur->type == XML_NAMESPACE_DECL) break;
  ------------------
  |  Branch (12917:6): [True: 0, False: 115]
  ------------------
12918|    115|	if ((cur->children != NULL) && (depth < max_depth)) {
  ------------------
  |  Branch (12918:6): [True: 55, False: 60]
  |  Branch (12918:33): [True: 53, False: 2]
  ------------------
12919|       |	    /*
12920|       |	     * Do not descend on entities declarations
12921|       |	     */
12922|     53|	    if (cur->children->type != XML_ENTITY_DECL) {
  ------------------
  |  Branch (12922:10): [True: 53, False: 0]
  ------------------
12923|     53|		cur = cur->children;
12924|     53|		depth++;
12925|       |		/*
12926|       |		 * Skip DTDs
12927|       |		 */
12928|     53|		if (cur->type != XML_DTD_NODE)
  ------------------
  |  Branch (12928:7): [True: 53, False: 0]
  ------------------
12929|     53|		    continue;
12930|     53|	    }
12931|     53|	}
12932|       |
12933|     62|	if (cur == limit)
  ------------------
  |  Branch (12933:6): [True: 0, False: 62]
  ------------------
12934|      0|	    break;
12935|       |
12936|     62|	while (cur->next != NULL) {
  ------------------
  |  Branch (12936:9): [True: 31, False: 31]
  ------------------
12937|     31|	    cur = cur->next;
12938|     31|	    if ((cur->type != XML_ENTITY_DECL) &&
  ------------------
  |  Branch (12938:10): [True: 31, False: 0]
  ------------------
12939|     31|		(cur->type != XML_DTD_NODE))
  ------------------
  |  Branch (12939:3): [True: 31, False: 0]
  ------------------
12940|     31|		goto next_node;
12941|     31|	}
12942|       |
12943|     53|	do {
12944|     53|	    cur = cur->parent;
12945|     53|	    depth--;
12946|     53|	    if ((cur == NULL) || (cur == limit) ||
  ------------------
  |  Branch (12946:10): [True: 0, False: 53]
  |  Branch (12946:27): [True: 2, False: 51]
  ------------------
12947|     53|                (cur->type == XML_DOCUMENT_NODE))
  ------------------
  |  Branch (12947:17): [True: 13, False: 38]
  ------------------
12948|     15|	        goto done;
12949|     38|	    if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (12949:10): [True: 38, False: 0]
  ------------------
12950|     38|		ret = xmlStreamPop(patstream);
12951|     38|	    } else if ((eval_all_nodes) &&
  ------------------
  |  Branch (12951:17): [True: 0, False: 0]
  ------------------
12952|      0|		((cur->type == XML_TEXT_NODE) ||
  ------------------
  |  Branch (12952:4): [True: 0, False: 0]
  ------------------
12953|      0|		 (cur->type == XML_CDATA_SECTION_NODE) ||
  ------------------
  |  Branch (12953:4): [True: 0, False: 0]
  ------------------
12954|      0|		 (cur->type == XML_COMMENT_NODE) ||
  ------------------
  |  Branch (12954:4): [True: 0, False: 0]
  ------------------
12955|      0|		 (cur->type == XML_PI_NODE)))
  ------------------
  |  Branch (12955:4): [True: 0, False: 0]
  ------------------
12956|      0|	    {
12957|      0|		ret = xmlStreamPop(patstream);
12958|      0|	    }
12959|     38|	    if (cur->next != NULL) {
  ------------------
  |  Branch (12959:10): [True: 16, False: 22]
  ------------------
12960|     16|		cur = cur->next;
12961|     16|		break;
12962|     16|	    }
12963|     38|	} while (cur != NULL);
  ------------------
  |  Branch (12963:11): [True: 22, False: 0]
  ------------------
12964|       |
12965|     69|    } while ((cur != NULL) && (depth >= 0));
  ------------------
  |  Branch (12965:14): [True: 69, False: 0]
  |  Branch (12965:31): [True: 69, False: 0]
  ------------------
12966|       |
12967|     15|done:
12968|       |
12969|     15|    if (patstream)
  ------------------
  |  Branch (12969:9): [True: 15, False: 0]
  ------------------
12970|     15|	xmlFreeStreamCtxt(patstream);
12971|     15|    return(0);
12972|       |
12973|      0|return_1:
12974|      0|    if (patstream)
  ------------------
  |  Branch (12974:9): [True: 0, False: 0]
  ------------------
12975|      0|	xmlFreeStreamCtxt(patstream);
12976|      0|    return(1);
12977|     81|}
xpath.c:xmlXPathCompOpEvalToBoolean:
12665|    493|{
12666|    493|    xmlXPathObjectPtr resObj = NULL;
12667|       |
12668|    556|start:
12669|    556|    if (OP_LIMIT_EXCEEDED(ctxt, 1))
  ------------------
  |  |  787|    556|    ((ctxt->context->opLimit != 0) && (xmlXPathCheckOpLimit(ctxt, n) < 0))
  |  |  ------------------
  |  |  |  Branch (787:6): [True: 556, False: 0]
  |  |  |  Branch (787:39): [True: 0, False: 556]
  |  |  ------------------
  ------------------
12670|      0|        return(0);
12671|       |    /* comp = ctxt->comp; */
12672|    556|    switch (op->op) {
12673|      0|        case XPATH_OP_END:
  ------------------
  |  Branch (12673:9): [True: 0, False: 556]
  ------------------
12674|      0|            return (0);
12675|     17|	case XPATH_OP_VALUE:
  ------------------
  |  Branch (12675:2): [True: 17, False: 539]
  ------------------
12676|     17|	    resObj = (xmlXPathObjectPtr) op->value4;
12677|     17|	    if (isPredicate)
  ------------------
  |  Branch (12677:10): [True: 17, False: 0]
  ------------------
12678|     17|		return(xmlXPathEvaluatePredicateResult(ctxt, resObj));
12679|      0|	    return(xmlXPathCastToBoolean(resObj));
12680|     63|	case XPATH_OP_SORT:
  ------------------
  |  Branch (12680:2): [True: 63, False: 493]
  ------------------
12681|       |	    /*
12682|       |	    * We don't need sorting for boolean results. Skip this one.
12683|       |	    */
12684|     63|            if (op->ch1 != -1) {
  ------------------
  |  Branch (12684:17): [True: 63, False: 0]
  ------------------
12685|     63|		op = &ctxt->comp->steps[op->ch1];
12686|     63|		goto start;
12687|     63|	    }
12688|      0|	    return(0);
12689|      4|	case XPATH_OP_COLLECT:
  ------------------
  |  Branch (12689:2): [True: 4, False: 552]
  ------------------
12690|      4|	    if (op->ch1 == -1)
  ------------------
  |  Branch (12690:10): [True: 0, False: 4]
  ------------------
12691|      0|		return(0);
12692|       |
12693|      4|            xmlXPathCompOpEval(ctxt, &ctxt->comp->steps[op->ch1]);
12694|      4|	    if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (12694:10): [True: 0, False: 4]
  ------------------
12695|      0|		return(-1);
12696|       |
12697|      4|            xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 1);
12698|      4|	    if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (12698:10): [True: 0, False: 4]
  ------------------
12699|      0|		return(-1);
12700|       |
12701|      4|	    resObj = valuePop(ctxt);
12702|      4|	    if (resObj == NULL)
  ------------------
  |  Branch (12702:10): [True: 0, False: 4]
  ------------------
12703|      0|		return(-1);
12704|      4|	    break;
12705|    472|	default:
  ------------------
  |  Branch (12705:2): [True: 472, False: 84]
  ------------------
12706|       |	    /*
12707|       |	    * Fallback to call xmlXPathCompOpEval().
12708|       |	    */
12709|    472|	    xmlXPathCompOpEval(ctxt, op);
12710|    472|	    if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (12710:10): [True: 0, False: 472]
  ------------------
12711|      0|		return(-1);
12712|       |
12713|    472|	    resObj = valuePop(ctxt);
12714|    472|	    if (resObj == NULL)
  ------------------
  |  Branch (12714:10): [True: 0, False: 472]
  ------------------
12715|      0|		return(-1);
12716|    472|	    break;
12717|    556|    }
12718|       |
12719|    476|    if (resObj) {
  ------------------
  |  Branch (12719:9): [True: 476, False: 0]
  ------------------
12720|    476|	int res;
12721|       |
12722|    476|	if (resObj->type == XPATH_BOOLEAN) {
  ------------------
  |  Branch (12722:6): [True: 460, False: 16]
  ------------------
12723|    460|	    res = resObj->boolval;
12724|    460|	} else if (isPredicate) {
  ------------------
  |  Branch (12724:13): [True: 16, False: 0]
  ------------------
12725|       |	    /*
12726|       |	    * For predicates a result of type "number" is handled
12727|       |	    * differently:
12728|       |	    * SPEC XPath 1.0:
12729|       |	    * "If the result is a number, the result will be converted
12730|       |	    *  to true if the number is equal to the context position
12731|       |	    *  and will be converted to false otherwise;"
12732|       |	    */
12733|     16|	    res = xmlXPathEvaluatePredicateResult(ctxt, resObj);
12734|     16|	} else {
12735|      0|	    res = xmlXPathCastToBoolean(resObj);
12736|      0|	}
12737|    476|	xmlXPathReleaseObject(ctxt->context, resObj);
12738|    476|	return(res);
12739|    476|    }
12740|       |
12741|      0|    return(0);
12742|    476|}
xpath.c:xmlXPathCheckOpLimit:
  772|  11.0k|xmlXPathCheckOpLimit(xmlXPathParserContextPtr ctxt, unsigned long opCount) {
  773|  11.0k|    xmlXPathContextPtr xpctxt = ctxt->context;
  774|       |
  775|  11.0k|    if ((opCount > xpctxt->opLimit) ||
  ------------------
  |  Branch (775:9): [True: 0, False: 11.0k]
  ------------------
  776|  11.0k|        (xpctxt->opCount > xpctxt->opLimit - opCount)) {
  ------------------
  |  Branch (776:9): [True: 0, False: 11.0k]
  ------------------
  777|      0|        xpctxt->opCount = xpctxt->opLimit;
  778|      0|        xmlXPathErr(ctxt, XPATH_OP_LIMIT_EXCEEDED);
  779|      0|        return(-1);
  780|      0|    }
  781|       |
  782|  11.0k|    xpctxt->opCount += opCount;
  783|  11.0k|    return(0);
  784|  11.0k|}
xpath.c:xmlXPathNodeCollectAndTest:
11091|    494|{
11092|       |
11093|    494|#define XP_TEST_HIT \
11094|    494|    if (hasAxisRange != 0) { \
11095|    494|	if (++pos == maxPos) { \
11096|    494|	    if (addNode(seq, cur) < 0) \
11097|    494|	        ctxt->error = XPATH_MEMORY_ERROR; \
11098|    494|	    goto axis_range_end; } \
11099|    494|    } else { \
11100|    494|	if (addNode(seq, cur) < 0) \
11101|    494|	    ctxt->error = XPATH_MEMORY_ERROR; \
11102|    494|	if (breakOnFirstHit) goto first_hit; }
11103|       |
11104|    494|#define XP_TEST_HIT_NS \
11105|    494|    if (hasAxisRange != 0) { \
11106|    494|	if (++pos == maxPos) { \
11107|    494|	    hasNsNodes = 1; \
11108|    494|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
11109|    494|	        ctxt->error = XPATH_MEMORY_ERROR; \
11110|    494|	goto axis_range_end; } \
11111|    494|    } else { \
11112|    494|	hasNsNodes = 1; \
11113|    494|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
11114|    494|	    ctxt->error = XPATH_MEMORY_ERROR; \
11115|    494|	if (breakOnFirstHit) goto first_hit; }
11116|       |
11117|    494|    xmlXPathAxisVal axis = (xmlXPathAxisVal) op->value;
11118|    494|    xmlXPathTestVal test = (xmlXPathTestVal) op->value2;
11119|    494|    xmlXPathTypeVal type = (xmlXPathTypeVal) op->value3;
11120|    494|    const xmlChar *prefix = op->value4;
11121|    494|    const xmlChar *name = op->value5;
11122|    494|    const xmlChar *URI = NULL;
11123|       |
11124|    494|    int total = 0, hasNsNodes = 0;
11125|       |    /* The popped object holding the context nodes */
11126|    494|    xmlXPathObjectPtr obj;
11127|       |    /* The set of context nodes for the node tests */
11128|    494|    xmlNodeSetPtr contextSeq;
11129|    494|    int contextIdx;
11130|    494|    xmlNodePtr contextNode;
11131|       |    /* The final resulting node set wrt to all context nodes */
11132|    494|    xmlNodeSetPtr outSeq;
11133|       |    /*
11134|       |    * The temporary resulting node set wrt 1 context node.
11135|       |    * Used to feed predicate evaluation.
11136|       |    */
11137|    494|    xmlNodeSetPtr seq;
11138|    494|    xmlNodePtr cur;
11139|       |    /* First predicate operator */
11140|    494|    xmlXPathStepOpPtr predOp;
11141|    494|    int maxPos; /* The requested position() (when a "[n]" predicate) */
11142|    494|    int hasPredicateRange, hasAxisRange, pos;
11143|    494|    int breakOnFirstHit;
11144|       |
11145|    494|    xmlXPathTraversalFunction next = NULL;
11146|    494|    int (*addNode) (xmlNodeSetPtr, xmlNodePtr);
11147|    494|    xmlXPathNodeSetMergeFunction mergeAndClear;
11148|    494|    xmlNodePtr oldContextNode;
11149|    494|    xmlXPathContextPtr xpctxt = ctxt->context;
11150|       |
11151|       |
11152|    494|    CHECK_TYPE0(XPATH_NODESET);
  ------------------
  |  |  288|    494|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 494]
  |  |  |  Branch (288:34): [True: 1, False: 493]
  |  |  ------------------
  |  |  289|    494|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      1|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
11153|    493|    obj = valuePop(ctxt);
11154|       |    /*
11155|       |    * Setup namespaces.
11156|       |    */
11157|    493|    if (prefix != NULL) {
  ------------------
  |  Branch (11157:9): [True: 4, False: 489]
  ------------------
11158|      4|        URI = xmlXPathNsLookup(xpctxt, prefix);
11159|      4|        if (URI == NULL) {
  ------------------
  |  Branch (11159:13): [True: 0, False: 4]
  ------------------
11160|      0|	    xmlXPathReleaseObject(xpctxt, obj);
11161|      0|            XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
11162|      0|	}
11163|      4|    }
11164|       |    /*
11165|       |    * Setup axis.
11166|       |    *
11167|       |    * MAYBE FUTURE TODO: merging optimizations:
11168|       |    * - If the nodes to be traversed wrt to the initial nodes and
11169|       |    *   the current axis cannot overlap, then we could avoid searching
11170|       |    *   for duplicates during the merge.
11171|       |    *   But the question is how/when to evaluate if they cannot overlap.
11172|       |    *   Example: if we know that for two initial nodes, the one is
11173|       |    *   not in the ancestor-or-self axis of the other, then we could safely
11174|       |    *   avoid a duplicate-aware merge, if the axis to be traversed is e.g.
11175|       |    *   the descendant-or-self axis.
11176|       |    */
11177|    493|    mergeAndClear = xmlXPathNodeSetMergeAndClear;
11178|    493|    switch (axis) {
  ------------------
  |  Branch (11178:13): [True: 0, False: 493]
  ------------------
11179|      3|        case AXIS_ANCESTOR:
  ------------------
  |  Branch (11179:9): [True: 3, False: 490]
  ------------------
11180|      3|            first = NULL;
11181|      3|            next = xmlXPathNextAncestor;
11182|      3|            break;
11183|      5|        case AXIS_ANCESTOR_OR_SELF:
  ------------------
  |  Branch (11183:9): [True: 5, False: 488]
  ------------------
11184|      5|            first = NULL;
11185|      5|            next = xmlXPathNextAncestorOrSelf;
11186|      5|            break;
11187|    236|        case AXIS_ATTRIBUTE:
  ------------------
  |  Branch (11187:9): [True: 236, False: 257]
  ------------------
11188|    236|            first = NULL;
11189|    236|	    last = NULL;
11190|    236|            next = xmlXPathNextAttribute;
11191|    236|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11192|    236|            break;
11193|    138|        case AXIS_CHILD:
  ------------------
  |  Branch (11193:9): [True: 138, False: 355]
  ------------------
11194|    138|	    last = NULL;
11195|    138|	    if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&
  ------------------
  |  Branch (11195:11): [True: 99, False: 39]
  |  Branch (11195:39): [True: 25, False: 14]
  ------------------
11196|    138|		(type == NODE_TYPE_NODE))
  ------------------
  |  Branch (11196:3): [True: 124, False: 0]
  ------------------
11197|    124|	    {
11198|       |		/*
11199|       |		* Optimization if an element node type is 'element'.
11200|       |		*/
11201|    124|		next = xmlXPathNextChildElement;
11202|    124|	    } else
11203|     14|		next = xmlXPathNextChild;
11204|    138|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11205|    138|            break;
11206|     43|        case AXIS_DESCENDANT:
  ------------------
  |  Branch (11206:9): [True: 43, False: 450]
  ------------------
11207|     43|	    last = NULL;
11208|     43|            next = xmlXPathNextDescendant;
11209|     43|            break;
11210|     42|        case AXIS_DESCENDANT_OR_SELF:
  ------------------
  |  Branch (11210:9): [True: 42, False: 451]
  ------------------
11211|     42|	    last = NULL;
11212|     42|            next = xmlXPathNextDescendantOrSelf;
11213|     42|            break;
11214|      8|        case AXIS_FOLLOWING:
  ------------------
  |  Branch (11214:9): [True: 8, False: 485]
  ------------------
11215|      8|	    last = NULL;
11216|      8|            next = xmlXPathNextFollowing;
11217|      8|            break;
11218|      0|        case AXIS_FOLLOWING_SIBLING:
  ------------------
  |  Branch (11218:9): [True: 0, False: 493]
  ------------------
11219|      0|	    last = NULL;
11220|      0|            next = xmlXPathNextFollowingSibling;
11221|      0|            break;
11222|      8|        case AXIS_NAMESPACE:
  ------------------
  |  Branch (11222:9): [True: 8, False: 485]
  ------------------
11223|      8|            first = NULL;
11224|      8|	    last = NULL;
11225|      8|            next = (xmlXPathTraversalFunction) xmlXPathNextNamespace;
11226|      8|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11227|      8|            break;
11228|      1|        case AXIS_PARENT:
  ------------------
  |  Branch (11228:9): [True: 1, False: 492]
  ------------------
11229|      1|            first = NULL;
11230|      1|            next = xmlXPathNextParent;
11231|      1|            break;
11232|      6|        case AXIS_PRECEDING:
  ------------------
  |  Branch (11232:9): [True: 6, False: 487]
  ------------------
11233|      6|            first = NULL;
11234|      6|            next = xmlXPathNextPrecedingInternal;
11235|      6|            break;
11236|      0|        case AXIS_PRECEDING_SIBLING:
  ------------------
  |  Branch (11236:9): [True: 0, False: 493]
  ------------------
11237|      0|            first = NULL;
11238|      0|            next = xmlXPathNextPrecedingSibling;
11239|      0|            break;
11240|      3|        case AXIS_SELF:
  ------------------
  |  Branch (11240:9): [True: 3, False: 490]
  ------------------
11241|      3|            first = NULL;
11242|      3|	    last = NULL;
11243|      3|            next = xmlXPathNextSelf;
11244|      3|	    mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;
11245|      3|            break;
11246|    493|    }
11247|       |
11248|    493|    if (next == NULL) {
  ------------------
  |  Branch (11248:9): [True: 0, False: 493]
  ------------------
11249|      0|	xmlXPathReleaseObject(xpctxt, obj);
11250|      0|        return(0);
11251|      0|    }
11252|    493|    contextSeq = obj->nodesetval;
11253|    493|    if ((contextSeq == NULL) || (contextSeq->nodeNr <= 0)) {
  ------------------
  |  Branch (11253:9): [True: 2, False: 491]
  |  Branch (11253:33): [True: 7, False: 484]
  ------------------
11254|      9|	xmlXPathReleaseObject(xpctxt, obj);
11255|      9|        valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, NULL));
11256|      9|        return(0);
11257|      9|    }
11258|       |    /*
11259|       |    * Predicate optimization ---------------------------------------------
11260|       |    * If this step has a last predicate, which contains a position(),
11261|       |    * then we'll optimize (although not exactly "position()", but only
11262|       |    * the  short-hand form, i.e., "[n]".
11263|       |    *
11264|       |    * Example - expression "/foo[parent::bar][1]":
11265|       |    *
11266|       |    * COLLECT 'child' 'name' 'node' foo    -- op (we are here)
11267|       |    *   ROOT                               -- op->ch1
11268|       |    *   PREDICATE                          -- op->ch2 (predOp)
11269|       |    *     PREDICATE                          -- predOp->ch1 = [parent::bar]
11270|       |    *       SORT
11271|       |    *         COLLECT  'parent' 'name' 'node' bar
11272|       |    *           NODE
11273|       |    *     ELEM Object is a number : 1        -- predOp->ch2 = [1]
11274|       |    *
11275|       |    */
11276|    484|    maxPos = 0;
11277|    484|    predOp = NULL;
11278|    484|    hasPredicateRange = 0;
11279|    484|    hasAxisRange = 0;
11280|    484|    if (op->ch2 != -1) {
  ------------------
  |  Branch (11280:9): [True: 49, False: 435]
  ------------------
11281|       |	/*
11282|       |	* There's at least one predicate. 16 == XPATH_OP_PREDICATE
11283|       |	*/
11284|     49|	predOp = &ctxt->comp->steps[op->ch2];
11285|     49|	if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {
  ------------------
  |  Branch (11285:6): [True: 18, False: 31]
  ------------------
11286|     18|	    if (predOp->ch1 != -1) {
  ------------------
  |  Branch (11286:10): [True: 1, False: 17]
  ------------------
11287|       |		/*
11288|       |		* Use the next inner predicate operator.
11289|       |		*/
11290|      1|		predOp = &ctxt->comp->steps[predOp->ch1];
11291|      1|		hasPredicateRange = 1;
11292|     17|	    } else {
11293|       |		/*
11294|       |		* There's no other predicate than the [n] predicate.
11295|       |		*/
11296|     17|		predOp = NULL;
11297|     17|		hasAxisRange = 1;
11298|     17|	    }
11299|     18|	}
11300|     49|    }
11301|    484|    breakOnFirstHit = ((toBool) && (predOp == NULL)) ? 1 : 0;
  ------------------
  |  Branch (11301:24): [True: 4, False: 480]
  |  Branch (11301:36): [True: 4, False: 0]
  ------------------
11302|       |    /*
11303|       |    * Axis traversal -----------------------------------------------------
11304|       |    */
11305|       |    /*
11306|       |     * 2.3 Node Tests
11307|       |     *  - For the attribute axis, the principal node type is attribute.
11308|       |     *  - For the namespace axis, the principal node type is namespace.
11309|       |     *  - For other axes, the principal node type is element.
11310|       |     *
11311|       |     * A node test * is true for any node of the
11312|       |     * principal node type. For example, child::* will
11313|       |     * select all element children of the context node
11314|       |     */
11315|    484|    oldContextNode = xpctxt->node;
11316|    484|    addNode = xmlXPathNodeSetAddUnique;
11317|    484|    outSeq = NULL;
11318|    484|    seq = NULL;
11319|    484|    contextNode = NULL;
11320|    484|    contextIdx = 0;
11321|       |
11322|       |
11323|  2.80k|    while (((contextIdx < contextSeq->nodeNr) || (contextNode != NULL)) &&
  ------------------
  |  Branch (11323:13): [True: 2.32k, False: 480]
  |  Branch (11323:50): [True: 0, False: 480]
  ------------------
11324|  2.80k|           (ctxt->error == XPATH_EXPRESSION_OK)) {
  ------------------
  |  Branch (11324:12): [True: 2.32k, False: 0]
  ------------------
11325|  2.32k|	xpctxt->node = contextSeq->nodeTab[contextIdx++];
11326|       |
11327|  2.32k|	if (seq == NULL) {
  ------------------
  |  Branch (11327:6): [True: 519, False: 1.80k]
  ------------------
11328|    519|	    seq = xmlXPathNodeSetCreate(NULL);
11329|    519|	    if (seq == NULL) {
  ------------------
  |  Branch (11329:10): [True: 0, False: 519]
  ------------------
11330|       |                /* TODO: Propagate memory error. */
11331|      0|		total = 0;
11332|      0|		goto error;
11333|      0|	    }
11334|    519|	}
11335|       |	/*
11336|       |	* Traverse the axis and test the nodes.
11337|       |	*/
11338|  2.32k|	pos = 0;
11339|  2.32k|	cur = NULL;
11340|  2.32k|	hasNsNodes = 0;
11341|  6.84k|        do {
11342|  6.84k|            if (OP_LIMIT_EXCEEDED(ctxt, 1))
  ------------------
  |  |  787|  6.84k|    ((ctxt->context->opLimit != 0) && (xmlXPathCheckOpLimit(ctxt, n) < 0))
  |  |  ------------------
  |  |  |  Branch (787:6): [True: 6.84k, False: 0]
  |  |  |  Branch (787:39): [True: 0, False: 6.84k]
  |  |  ------------------
  ------------------
11343|      0|                goto error;
11344|       |
11345|  6.84k|            cur = next(ctxt, cur);
11346|  6.84k|            if (cur == NULL)
  ------------------
  |  Branch (11346:17): [True: 2.30k, False: 4.53k]
  ------------------
11347|  2.30k|                break;
11348|       |
11349|       |	    /*
11350|       |	    * QUESTION TODO: What does the "first" and "last" stuff do?
11351|       |	    */
11352|  4.53k|            if ((first != NULL) && (*first != NULL)) {
  ------------------
  |  Branch (11352:17): [True: 0, False: 4.53k]
  |  Branch (11352:36): [True: 0, False: 0]
  ------------------
11353|      0|		if (*first == cur)
  ------------------
  |  Branch (11353:7): [True: 0, False: 0]
  ------------------
11354|      0|		    break;
11355|      0|		if (((total % 256) == 0) &&
  ------------------
  |  Branch (11355:7): [True: 0, False: 0]
  ------------------
11356|      0|#ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
11357|      0|		    (xmlXPathCmpNodesExt(*first, cur) >= 0))
  ------------------
  |  Branch (11357:7): [True: 0, False: 0]
  ------------------
11358|       |#else
11359|       |		    (xmlXPathCmpNodes(*first, cur) >= 0))
11360|       |#endif
11361|      0|		{
11362|      0|		    break;
11363|      0|		}
11364|      0|	    }
11365|  4.53k|	    if ((last != NULL) && (*last != NULL)) {
  ------------------
  |  Branch (11365:10): [True: 0, False: 4.53k]
  |  Branch (11365:28): [True: 0, False: 0]
  ------------------
11366|      0|		if (*last == cur)
  ------------------
  |  Branch (11366:7): [True: 0, False: 0]
  ------------------
11367|      0|		    break;
11368|      0|		if (((total % 256) == 0) &&
  ------------------
  |  Branch (11368:7): [True: 0, False: 0]
  ------------------
11369|      0|#ifdef XP_OPTIMIZED_NON_ELEM_COMPARISON
11370|      0|		    (xmlXPathCmpNodesExt(cur, *last) >= 0))
  ------------------
  |  Branch (11370:7): [True: 0, False: 0]
  ------------------
11371|       |#else
11372|       |		    (xmlXPathCmpNodes(cur, *last) >= 0))
11373|       |#endif
11374|      0|		{
11375|      0|		    break;
11376|      0|		}
11377|      0|	    }
11378|       |
11379|  4.53k|            total++;
11380|       |
11381|  4.53k|	    switch (test) {
  ------------------
  |  Branch (11381:14): [True: 0, False: 4.53k]
  ------------------
11382|      0|                case NODE_TEST_NONE:
  ------------------
  |  Branch (11382:17): [True: 0, False: 4.53k]
  ------------------
11383|      0|		    total = 0;
11384|      0|                    STRANGE
  ------------------
  |  | 1230|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  | 1231|      0|	    "Internal error at %s:%d\n",				\
  |  | 1232|      0|            __FILE__, __LINE__);
  ------------------
11385|      0|		    goto error;
11386|  2.01k|                case NODE_TEST_TYPE:
  ------------------
  |  Branch (11386:17): [True: 2.01k, False: 2.52k]
  ------------------
11387|  2.01k|		    if (type == NODE_TYPE_NODE) {
  ------------------
  |  Branch (11387:11): [True: 2.00k, False: 15]
  ------------------
11388|  2.00k|			switch (cur->type) {
11389|     41|			    case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (11389:8): [True: 41, False: 1.95k]
  ------------------
11390|     41|			    case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (11390:8): [True: 0, False: 2.00k]
  ------------------
11391|    735|			    case XML_ELEMENT_NODE:
  ------------------
  |  Branch (11391:8): [True: 694, False: 1.30k]
  ------------------
11392|    739|			    case XML_ATTRIBUTE_NODE:
  ------------------
  |  Branch (11392:8): [True: 4, False: 1.99k]
  ------------------
11393|    739|			    case XML_PI_NODE:
  ------------------
  |  Branch (11393:8): [True: 0, False: 2.00k]
  ------------------
11394|    740|			    case XML_COMMENT_NODE:
  ------------------
  |  Branch (11394:8): [True: 1, False: 1.99k]
  ------------------
11395|    740|			    case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (11395:8): [True: 0, False: 2.00k]
  ------------------
11396|  1.99k|			    case XML_TEXT_NODE:
  ------------------
  |  Branch (11396:8): [True: 1.25k, False: 746]
  ------------------
11397|  1.99k|				XP_TEST_HIT
  ------------------
  |  |11094|  1.99k|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 1.99k]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|  1.99k|    } else { \
  |  |11100|  1.99k|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 1.99k]
  |  |  ------------------
  |  |11101|  1.99k|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|  1.99k|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 1.99k]
  |  |  ------------------
  ------------------
11398|  1.99k|				break;
11399|  1.99k|			    case XML_NAMESPACE_DECL: {
  ------------------
  |  Branch (11399:8): [True: 6, False: 1.99k]
  ------------------
11400|      6|				if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11400:9): [True: 3, False: 3]
  ------------------
11401|      3|				    XP_TEST_HIT_NS
  ------------------
  |  |11105|      3|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 3]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      3|    } else { \
  |  |11112|      3|	hasNsNodes = 1; \
  |  |11113|      3|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 3]
  |  |  ------------------
  |  |11114|      3|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      3|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 3]
  |  |  ------------------
  ------------------
11402|      3|				} else {
11403|      3|	                            hasNsNodes = 1;
11404|      3|				    XP_TEST_HIT
  ------------------
  |  |11094|      3|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 3]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      3|    } else { \
  |  |11100|      3|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 3]
  |  |  ------------------
  |  |11101|      3|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      3|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 3]
  |  |  ------------------
  ------------------
11405|      3|				}
11406|      6|				break;
11407|      6|                            }
11408|      6|			    default:
  ------------------
  |  Branch (11408:8): [True: 0, False: 2.00k]
  ------------------
11409|      0|				break;
11410|  2.00k|			}
11411|  2.00k|		    } else if (cur->type == (xmlElementType) type) {
  ------------------
  |  Branch (11411:18): [True: 15, False: 0]
  ------------------
11412|     15|			if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11412:8): [True: 0, False: 15]
  ------------------
11413|      0|			    XP_TEST_HIT_NS
  ------------------
  |  |11105|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      0|    } else { \
  |  |11112|      0|	hasNsNodes = 1; \
  |  |11113|      0|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11114|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11414|     15|			else
11415|     15|			    XP_TEST_HIT
  ------------------
  |  |11094|     15|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 15]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|     15|    } else { \
  |  |11100|     15|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 15]
  |  |  ------------------
  |  |11101|     15|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|     15|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 15]
  |  |  ------------------
  ------------------
11416|     15|		    } else if ((type == NODE_TYPE_TEXT) &&
  ------------------
  |  Branch (11416:18): [True: 0, False: 0]
  ------------------
11417|      0|			 (cur->type == XML_CDATA_SECTION_NODE))
  ------------------
  |  Branch (11417:5): [True: 0, False: 0]
  ------------------
11418|      0|		    {
11419|      0|			XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11420|      0|		    }
11421|  2.01k|		    break;
11422|  2.01k|                case NODE_TEST_PI:
  ------------------
  |  Branch (11422:17): [True: 0, False: 4.53k]
  ------------------
11423|      0|                    if ((cur->type == XML_PI_NODE) &&
  ------------------
  |  Branch (11423:25): [True: 0, False: 0]
  ------------------
11424|      0|                        ((name == NULL) || xmlStrEqual(name, cur->name)))
  ------------------
  |  Branch (11424:26): [True: 0, False: 0]
  |  Branch (11424:44): [True: 0, False: 0]
  ------------------
11425|      0|		    {
11426|      0|			XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11427|      0|                    }
11428|      0|                    break;
11429|    694|                case NODE_TEST_ALL:
  ------------------
  |  Branch (11429:17): [True: 694, False: 3.84k]
  ------------------
11430|    694|                    if (axis == AXIS_ATTRIBUTE) {
  ------------------
  |  Branch (11430:25): [True: 0, False: 694]
  ------------------
11431|      0|                        if (cur->type == XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (11431:29): [True: 0, False: 0]
  ------------------
11432|      0|			{
11433|      0|                            if (prefix == NULL)
  ------------------
  |  Branch (11433:33): [True: 0, False: 0]
  ------------------
11434|      0|			    {
11435|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11436|      0|                            } else if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11436:40): [True: 0, False: 0]
  ------------------
11437|      0|				(xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11437:5): [True: 0, False: 0]
  ------------------
11438|      0|			    {
11439|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11440|      0|                            }
11441|      0|                        }
11442|    694|                    } else if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11442:32): [True: 3, False: 691]
  ------------------
11443|      3|                        if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11443:29): [True: 3, False: 0]
  ------------------
11444|      3|			{
11445|      3|			    XP_TEST_HIT_NS
  ------------------
  |  |11105|      3|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 3]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      3|    } else { \
  |  |11112|      3|	hasNsNodes = 1; \
  |  |11113|      3|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 3]
  |  |  ------------------
  |  |11114|      3|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      3|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 0, False: 3]
  |  |  ------------------
  ------------------
11446|      3|                        }
11447|    691|                    } else {
11448|    691|                        if (cur->type == XML_ELEMENT_NODE) {
  ------------------
  |  Branch (11448:29): [True: 455, False: 236]
  ------------------
11449|    455|                            if (prefix == NULL)
  ------------------
  |  Branch (11449:33): [True: 455, False: 0]
  ------------------
11450|    455|			    {
11451|    455|				XP_TEST_HIT
  ------------------
  |  |11094|    455|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 455]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|    455|    } else { \
  |  |11100|    455|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 455]
  |  |  ------------------
  |  |11101|    455|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|    455|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 455]
  |  |  ------------------
  ------------------
11452|       |
11453|    455|                            } else if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11453:40): [True: 0, False: 0]
  ------------------
11454|      0|				(xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11454:5): [True: 0, False: 0]
  ------------------
11455|      0|			    {
11456|      0|				XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11457|      0|                            }
11458|    455|                        }
11459|    691|                    }
11460|    694|                    break;
11461|    694|                case NODE_TEST_NS:{
  ------------------
  |  Branch (11461:17): [True: 0, False: 4.53k]
  ------------------
11462|      0|                        TODO;
  ------------------
  |  |   59|      0|    xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |                   xmlGenericError(xmlGenericErrorContext,				\
  |  |  ------------------
  |  |  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  |  |  ------------------
  |  |  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  |  |  ------------------
  |  |  ------------------
  |  |   60|      0|	    "Unimplemented block at %s:%d\n",				\
  |  |   61|      0|            __FILE__, __LINE__);
  ------------------
11463|      0|                        break;
11464|    694|                    }
11465|  1.82k|                case NODE_TEST_NAME:
  ------------------
  |  Branch (11465:17): [True: 1.82k, False: 2.70k]
  ------------------
11466|  1.82k|                    if (axis == AXIS_ATTRIBUTE) {
  ------------------
  |  Branch (11466:25): [True: 113, False: 1.71k]
  ------------------
11467|    113|                        if (cur->type != XML_ATTRIBUTE_NODE)
  ------------------
  |  Branch (11467:29): [True: 0, False: 113]
  ------------------
11468|      0|			    break;
11469|  1.71k|		    } else if (axis == AXIS_NAMESPACE) {
  ------------------
  |  Branch (11469:18): [True: 14, False: 1.69k]
  ------------------
11470|     14|                        if (cur->type != XML_NAMESPACE_DECL)
  ------------------
  |  Branch (11470:29): [True: 0, False: 14]
  ------------------
11471|      0|			    break;
11472|  1.69k|		    } else {
11473|  1.69k|		        if (cur->type != XML_ELEMENT_NODE)
  ------------------
  |  Branch (11473:15): [True: 766, False: 933]
  ------------------
11474|    766|			    break;
11475|  1.69k|		    }
11476|  1.06k|                    switch (cur->type) {
11477|    933|                        case XML_ELEMENT_NODE:
  ------------------
  |  Branch (11477:25): [True: 933, False: 127]
  ------------------
11478|    933|                            if (xmlStrEqual(name, cur->name)) {
  ------------------
  |  Branch (11478:33): [True: 390, False: 543]
  ------------------
11479|    390|                                if (prefix == NULL) {
  ------------------
  |  Branch (11479:37): [True: 386, False: 4]
  ------------------
11480|    386|                                    if (cur->ns == NULL)
  ------------------
  |  Branch (11480:41): [True: 386, False: 0]
  ------------------
11481|    386|				    {
11482|    386|					XP_TEST_HIT
  ------------------
  |  |11094|    386|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 24, False: 362]
  |  |  ------------------
  |  |11095|     24|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 16, False: 8]
  |  |  ------------------
  |  |11096|     16|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 16]
  |  |  ------------------
  |  |11097|     16|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|     16|	    goto axis_range_end; } \
  |  |11099|    362|    } else { \
  |  |11100|    362|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 362]
  |  |  ------------------
  |  |11101|    362|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|    362|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 362]
  |  |  ------------------
  ------------------
11483|    386|                                    }
11484|    386|                                } else {
11485|      4|                                    if ((cur->ns != NULL) &&
  ------------------
  |  Branch (11485:41): [True: 4, False: 0]
  ------------------
11486|      4|                                        (xmlStrEqual(URI, cur->ns->href)))
  ------------------
  |  Branch (11486:41): [True: 3, False: 1]
  ------------------
11487|      3|				    {
11488|      3|					XP_TEST_HIT
  ------------------
  |  |11094|      3|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 3]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      3|    } else { \
  |  |11100|      3|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 3]
  |  |  ------------------
  |  |11101|      3|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      3|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 3]
  |  |  ------------------
  ------------------
11489|      3|                                    }
11490|      4|                                }
11491|    390|                            }
11492|    917|                            break;
11493|    917|                        case XML_ATTRIBUTE_NODE:{
  ------------------
  |  Branch (11493:25): [True: 113, False: 947]
  ------------------
11494|    113|                                xmlAttrPtr attr = (xmlAttrPtr) cur;
11495|       |
11496|    113|                                if (xmlStrEqual(name, attr->name)) {
  ------------------
  |  Branch (11496:37): [True: 72, False: 41]
  ------------------
11497|     72|                                    if (prefix == NULL) {
  ------------------
  |  Branch (11497:41): [True: 72, False: 0]
  ------------------
11498|     72|                                        if ((attr->ns == NULL) ||
  ------------------
  |  Branch (11498:45): [True: 72, False: 0]
  ------------------
11499|     72|                                            (attr->ns->prefix == NULL))
  ------------------
  |  Branch (11499:45): [True: 0, False: 0]
  ------------------
11500|     72|					{
11501|     72|					    XP_TEST_HIT
  ------------------
  |  |11094|     72|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 72]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|     72|    } else { \
  |  |11100|     72|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 72]
  |  |  ------------------
  |  |11101|     72|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|     72|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 72]
  |  |  ------------------
  ------------------
11502|     72|                                        }
11503|     72|                                    } else {
11504|      0|                                        if ((attr->ns != NULL) &&
  ------------------
  |  Branch (11504:45): [True: 0, False: 0]
  ------------------
11505|      0|                                            (xmlStrEqual(URI,
  ------------------
  |  Branch (11505:45): [True: 0, False: 0]
  ------------------
11506|      0|					      attr->ns->href)))
11507|      0|					{
11508|      0|					    XP_TEST_HIT
  ------------------
  |  |11094|      0|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11094:9): [True: 0, False: 0]
  |  |  ------------------
  |  |11095|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11095:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11096|      0|	    if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11096:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11097|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11098|      0|	    goto axis_range_end; } \
  |  |11099|      0|    } else { \
  |  |11100|      0|	if (addNode(seq, cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11100:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11101|      0|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11102|      0|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11102:6): [True: 0, False: 0]
  |  |  ------------------
  ------------------
11509|      0|                                        }
11510|      0|                                    }
11511|     72|                                }
11512|    113|                                break;
11513|    113|                            }
11514|    113|                        case XML_NAMESPACE_DECL:
  ------------------
  |  Branch (11514:25): [True: 14, False: 1.04k]
  ------------------
11515|     14|                            if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (11515:33): [True: 14, False: 0]
  ------------------
11516|     14|                                xmlNsPtr ns = (xmlNsPtr) cur;
11517|       |
11518|     14|                                if ((ns->prefix != NULL) && (name != NULL)
  ------------------
  |  Branch (11518:37): [True: 14, False: 0]
  |  Branch (11518:61): [True: 14, False: 0]
  ------------------
11519|     14|                                    && (xmlStrEqual(ns->prefix, name)))
  ------------------
  |  Branch (11519:40): [True: 6, False: 8]
  ------------------
11520|      6|				{
11521|      6|				    XP_TEST_HIT_NS
  ------------------
  |  |11105|      6|    if (hasAxisRange != 0) { \
  |  |  ------------------
  |  |  |  Branch (11105:9): [True: 0, False: 6]
  |  |  ------------------
  |  |11106|      0|	if (++pos == maxPos) { \
  |  |  ------------------
  |  |  |  Branch (11106:6): [True: 0, False: 0]
  |  |  ------------------
  |  |11107|      0|	    hasNsNodes = 1; \
  |  |11108|      0|	    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11108:10): [True: 0, False: 0]
  |  |  ------------------
  |  |11109|      0|	        ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11110|      0|	goto axis_range_end; } \
  |  |11111|      6|    } else { \
  |  |11112|      6|	hasNsNodes = 1; \
  |  |11113|      6|	if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \
  |  |  ------------------
  |  |  |  Branch (11113:6): [True: 0, False: 6]
  |  |  ------------------
  |  |11114|      6|	    ctxt->error = XPATH_MEMORY_ERROR; \
  |  |11115|      6|	if (breakOnFirstHit) goto first_hit; }
  |  |  ------------------
  |  |  |  Branch (11115:6): [True: 4, False: 2]
  |  |  ------------------
  ------------------
11522|      6|                                }
11523|     14|                            }
11524|     10|                            break;
11525|     10|                        default:
  ------------------
  |  Branch (11525:25): [True: 0, False: 1.06k]
  ------------------
11526|      0|                            break;
11527|  1.06k|                    }
11528|  1.04k|                    break;
11529|  4.53k|	    } /* switch(test) */
11530|  4.53k|        } while ((cur != NULL) && (ctxt->error == XPATH_EXPRESSION_OK));
  ------------------
  |  Branch (11530:18): [True: 4.51k, False: 0]
  |  Branch (11530:35): [True: 4.51k, False: 0]
  ------------------
11531|       |
11532|  2.30k|	goto apply_predicates;
11533|       |
11534|  2.30k|axis_range_end: /* ----------------------------------------------------- */
11535|       |	/*
11536|       |	* We have a "/foo[n]", and position() = n was reached.
11537|       |	* Note that we can have as well "/foo/::parent::foo[1]", so
11538|       |	* a duplicate-aware merge is still needed.
11539|       |	* Merge with the result.
11540|       |	*/
11541|     16|	if (outSeq == NULL) {
  ------------------
  |  Branch (11541:6): [True: 12, False: 4]
  ------------------
11542|     12|	    outSeq = seq;
11543|     12|	    seq = NULL;
11544|     12|	} else
11545|       |            /* TODO: Check memory error. */
11546|      4|	    outSeq = mergeAndClear(outSeq, seq);
11547|       |	/*
11548|       |	* Break if only a true/false result was requested.
11549|       |	*/
11550|     16|	if (toBool)
  ------------------
  |  Branch (11550:6): [True: 0, False: 16]
  ------------------
11551|      0|	    break;
11552|     16|	continue;
11553|       |
11554|     16|first_hit: /* ---------------------------------------------------------- */
11555|       |	/*
11556|       |	* Break if only a true/false result was requested and
11557|       |	* no predicates existed and a node test succeeded.
11558|       |	*/
11559|      4|	if (outSeq == NULL) {
  ------------------
  |  Branch (11559:6): [True: 4, False: 0]
  ------------------
11560|      4|	    outSeq = seq;
11561|      4|	    seq = NULL;
11562|      4|	} else
11563|       |            /* TODO: Check memory error. */
11564|      0|	    outSeq = mergeAndClear(outSeq, seq);
11565|      4|	break;
11566|       |
11567|  2.30k|apply_predicates: /* --------------------------------------------------- */
11568|  2.30k|        if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (11568:13): [True: 0, False: 2.30k]
  ------------------
11569|      0|	    goto error;
11570|       |
11571|       |        /*
11572|       |	* Apply predicates.
11573|       |	*/
11574|  2.30k|        if ((predOp != NULL) && (seq->nodeNr > 0)) {
  ------------------
  |  Branch (11574:13): [True: 1.32k, False: 985]
  |  Branch (11574:33): [True: 172, False: 1.15k]
  ------------------
11575|       |	    /*
11576|       |	    * E.g. when we have a "/foo[some expression][n]".
11577|       |	    */
11578|       |	    /*
11579|       |	    * QUESTION TODO: The old predicate evaluation took into
11580|       |	    *  account location-sets.
11581|       |	    *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)
11582|       |	    *  Do we expect such a set here?
11583|       |	    *  All what I learned now from the evaluation semantics
11584|       |	    *  does not indicate that a location-set will be processed
11585|       |	    *  here, so this looks OK.
11586|       |	    */
11587|       |	    /*
11588|       |	    * Iterate over all predicates, starting with the outermost
11589|       |	    * predicate.
11590|       |	    * TODO: Problem: we cannot execute the inner predicates first
11591|       |	    *  since we cannot go back *up* the operator tree!
11592|       |	    *  Options we have:
11593|       |	    *  1) Use of recursive functions (like is it currently done
11594|       |	    *     via xmlXPathCompOpEval())
11595|       |	    *  2) Add a predicate evaluation information stack to the
11596|       |	    *     context struct
11597|       |	    *  3) Change the way the operators are linked; we need a
11598|       |	    *     "parent" field on xmlXPathStepOp
11599|       |	    *
11600|       |	    * For the moment, I'll try to solve this with a recursive
11601|       |	    * function: xmlXPathCompOpEvalPredicate().
11602|       |	    */
11603|    172|	    if (hasPredicateRange != 0)
  ------------------
  |  Branch (11603:10): [True: 1, False: 171]
  ------------------
11604|      1|		xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,
11605|      1|					    hasNsNodes);
11606|    171|	    else
11607|    171|		xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,
11608|    171|					    hasNsNodes);
11609|       |
11610|    172|	    if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (11610:10): [True: 0, False: 172]
  ------------------
11611|      0|		total = 0;
11612|      0|		goto error;
11613|      0|	    }
11614|    172|        }
11615|       |
11616|  2.30k|        if (seq->nodeNr > 0) {
  ------------------
  |  Branch (11616:13): [True: 294, False: 2.01k]
  ------------------
11617|       |	    /*
11618|       |	    * Add to result set.
11619|       |	    */
11620|    294|	    if (outSeq == NULL) {
  ------------------
  |  Branch (11620:10): [True: 270, False: 24]
  ------------------
11621|    270|		outSeq = seq;
11622|    270|		seq = NULL;
11623|    270|	    } else {
11624|       |                /* TODO: Check memory error. */
11625|     24|		outSeq = mergeAndClear(outSeq, seq);
11626|     24|	    }
11627|       |
11628|    294|            if (toBool)
  ------------------
  |  Branch (11628:17): [True: 0, False: 294]
  ------------------
11629|      0|                break;
11630|    294|	}
11631|  2.30k|    }
11632|       |
11633|    484|error:
11634|    484|    if ((obj->boolval) && (obj->user != NULL)) {
  ------------------
  |  Branch (11634:9): [True: 0, False: 484]
  |  Branch (11634:27): [True: 0, False: 0]
  ------------------
11635|       |	/*
11636|       |	* QUESTION TODO: What does this do and why?
11637|       |	* TODO: Do we have to do this also for the "error"
11638|       |	* cleanup further down?
11639|       |	*/
11640|      0|	ctxt->value->boolval = 1;
11641|      0|	ctxt->value->user = obj->user;
11642|      0|	obj->user = NULL;
11643|      0|	obj->boolval = 0;
11644|      0|    }
11645|    484|    xmlXPathReleaseObject(xpctxt, obj);
11646|       |
11647|       |    /*
11648|       |    * Ensure we return at least an empty set.
11649|       |    */
11650|    484|    if (outSeq == NULL) {
  ------------------
  |  Branch (11650:9): [True: 198, False: 286]
  ------------------
11651|    198|	if ((seq != NULL) && (seq->nodeNr == 0))
  ------------------
  |  Branch (11651:6): [True: 198, False: 0]
  |  Branch (11651:23): [True: 198, False: 0]
  ------------------
11652|    198|	    outSeq = seq;
11653|      0|	else
11654|       |            /* TODO: Check memory error. */
11655|      0|	    outSeq = xmlXPathNodeSetCreate(NULL);
11656|    198|    }
11657|    484|    if ((seq != NULL) && (seq != outSeq)) {
  ------------------
  |  Branch (11657:9): [True: 233, False: 251]
  |  Branch (11657:26): [True: 35, False: 198]
  ------------------
11658|     35|	 xmlXPathFreeNodeSet(seq);
11659|     35|    }
11660|       |    /*
11661|       |    * Hand over the result. Better to push the set also in
11662|       |    * case of errors.
11663|       |    */
11664|    484|    valuePush(ctxt, xmlXPathCacheWrapNodeSet(xpctxt, outSeq));
11665|       |    /*
11666|       |    * Reset the context node.
11667|       |    */
11668|    484|    xpctxt->node = oldContextNode;
11669|       |    /*
11670|       |    * When traversing the namespace axis in "toBool" mode, it's
11671|       |    * possible that tmpNsList wasn't freed.
11672|       |    */
11673|    484|    if (xpctxt->tmpNsList != NULL) {
  ------------------
  |  Branch (11673:9): [True: 4, False: 480]
  ------------------
11674|      4|        xmlFree(xpctxt->tmpNsList);
11675|      4|        xpctxt->tmpNsList = NULL;
11676|      4|    }
11677|       |
11678|    484|    return(total);
11679|    484|}
xpath.c:xmlXPathNodeSetMergeAndClear:
 3351|     13|{
 3352|     13|    {
 3353|     13|	int i, j, initNbSet1;
 3354|     13|	xmlNodePtr n1, n2;
 3355|       |
 3356|     13|	initNbSet1 = set1->nodeNr;
 3357|     26|	for (i = 0;i < set2->nodeNr;i++) {
  ------------------
  |  Branch (3357:13): [True: 13, False: 13]
  ------------------
 3358|     13|	    n2 = set2->nodeTab[i];
 3359|       |	    /*
 3360|       |	    * Skip duplicates.
 3361|       |	    */
 3362|     33|	    for (j = 0; j < initNbSet1; j++) {
  ------------------
  |  Branch (3362:18): [True: 25, False: 8]
  ------------------
 3363|     25|		n1 = set1->nodeTab[j];
 3364|     25|		if (n1 == n2) {
  ------------------
  |  Branch (3364:7): [True: 5, False: 20]
  ------------------
 3365|      5|		    goto skip_node;
 3366|     20|		} else if ((n1->type == XML_NAMESPACE_DECL) &&
  ------------------
  |  Branch (3366:14): [True: 0, False: 20]
  ------------------
 3367|     20|		    (n2->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (3367:7): [True: 0, False: 0]
  ------------------
 3368|      0|		{
 3369|      0|		    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&
  ------------------
  |  Branch (3369:11): [True: 0, False: 0]
  ------------------
 3370|      0|			(xmlStrEqual(((xmlNsPtr) n1)->prefix,
  ------------------
  |  Branch (3370:4): [True: 0, False: 0]
  ------------------
 3371|      0|			((xmlNsPtr) n2)->prefix)))
 3372|      0|		    {
 3373|       |			/*
 3374|       |			* Free the namespace node.
 3375|       |			*/
 3376|      0|			xmlXPathNodeSetFreeNs((xmlNsPtr) n2);
 3377|      0|			goto skip_node;
 3378|      0|		    }
 3379|      0|		}
 3380|     25|	    }
 3381|       |	    /*
 3382|       |	    * grow the nodeTab if needed
 3383|       |	    */
 3384|      8|	    if (set1->nodeMax == 0) {
  ------------------
  |  Branch (3384:10): [True: 0, False: 8]
  ------------------
 3385|      0|		set1->nodeTab = (xmlNodePtr *) xmlMalloc(
 3386|      0|		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3387|      0|		if (set1->nodeTab == NULL) {
  ------------------
  |  Branch (3387:7): [True: 0, False: 0]
  ------------------
 3388|      0|		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 3389|      0|		    goto error;
 3390|      0|		}
 3391|      0|		memset(set1->nodeTab, 0,
 3392|      0|		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3393|      0|		set1->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3394|      8|	    } else if (set1->nodeNr >= set1->nodeMax) {
  ------------------
  |  Branch (3394:17): [True: 0, False: 8]
  ------------------
 3395|      0|		xmlNodePtr *temp;
 3396|       |
 3397|      0|                if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3397:21): [True: 0, False: 0]
  ------------------
 3398|      0|                    xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
 3399|      0|                    goto error;
 3400|      0|                }
 3401|      0|		temp = (xmlNodePtr *) xmlRealloc(
 3402|      0|		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
 3403|      0|		if (temp == NULL) {
  ------------------
  |  Branch (3403:7): [True: 0, False: 0]
  ------------------
 3404|      0|		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 3405|      0|		    goto error;
 3406|      0|		}
 3407|      0|		set1->nodeTab = temp;
 3408|      0|		set1->nodeMax *= 2;
 3409|      0|	    }
 3410|      8|	    set1->nodeTab[set1->nodeNr++] = n2;
 3411|     13|skip_node:
 3412|     13|            set2->nodeTab[i] = NULL;
 3413|     13|	}
 3414|     13|    }
 3415|     13|    set2->nodeNr = 0;
 3416|     13|    return(set1);
 3417|       |
 3418|      0|error:
 3419|      0|    xmlXPathFreeNodeSet(set1);
 3420|      0|    xmlXPathNodeSetClear(set2, 1);
 3421|      0|    return(NULL);
 3422|     13|}
xpath.c:xmlXPathNodeSetMergeAndClearNoDupls:
 3438|     15|{
 3439|     15|    {
 3440|     15|	int i;
 3441|     15|	xmlNodePtr n2;
 3442|       |
 3443|     33|	for (i = 0;i < set2->nodeNr;i++) {
  ------------------
  |  Branch (3443:13): [True: 18, False: 15]
  ------------------
 3444|     18|	    n2 = set2->nodeTab[i];
 3445|     18|	    if (set1->nodeMax == 0) {
  ------------------
  |  Branch (3445:10): [True: 0, False: 18]
  ------------------
 3446|      0|		set1->nodeTab = (xmlNodePtr *) xmlMalloc(
 3447|      0|		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3448|      0|		if (set1->nodeTab == NULL) {
  ------------------
  |  Branch (3448:7): [True: 0, False: 0]
  ------------------
 3449|      0|		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 3450|      0|		    goto error;
 3451|      0|		}
 3452|      0|		memset(set1->nodeTab, 0,
 3453|      0|		    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3454|      0|		set1->nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      0|#define XML_NODESET_DEFAULT	10
  ------------------
 3455|     18|	    } else if (set1->nodeNr >= set1->nodeMax) {
  ------------------
  |  Branch (3455:17): [True: 0, False: 18]
  ------------------
 3456|      0|		xmlNodePtr *temp;
 3457|       |
 3458|      0|                if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH) {
  ------------------
  |  |  116|      0|#define XPATH_MAX_NODESET_LENGTH 10000000
  ------------------
  |  Branch (3458:21): [True: 0, False: 0]
  ------------------
 3459|      0|                    xmlXPathErrMemory(NULL, "merging nodeset hit limit\n");
 3460|      0|                    goto error;
 3461|      0|                }
 3462|      0|		temp = (xmlNodePtr *) xmlRealloc(
 3463|      0|		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));
 3464|      0|		if (temp == NULL) {
  ------------------
  |  Branch (3464:7): [True: 0, False: 0]
  ------------------
 3465|      0|		    xmlXPathErrMemory(NULL, "merging nodeset\n");
 3466|      0|		    goto error;
 3467|      0|		}
 3468|      0|		set1->nodeTab = temp;
 3469|      0|		set1->nodeMax *= 2;
 3470|      0|	    }
 3471|     18|	    set1->nodeTab[set1->nodeNr++] = n2;
 3472|     18|            set2->nodeTab[i] = NULL;
 3473|     18|	}
 3474|     15|    }
 3475|     15|    set2->nodeNr = 0;
 3476|     15|    return(set1);
 3477|       |
 3478|      0|error:
 3479|      0|    xmlXPathFreeNodeSet(set1);
 3480|      0|    xmlXPathNodeSetClear(set2, 1);
 3481|      0|    return(NULL);
 3482|     15|}
xpath.c:xmlXPathNextChildElement:
 6991|  2.64k|xmlXPathNextChildElement(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
 6992|  2.64k|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (6992:9): [True: 0, False: 2.64k]
  |  Branch (6992:27): [True: 0, False: 2.64k]
  ------------------
 6993|  2.64k|    if (cur == NULL) {
  ------------------
  |  Branch (6993:9): [True: 1.88k, False: 760]
  ------------------
 6994|  1.88k|	cur = ctxt->context->node;
 6995|  1.88k|	if (cur == NULL) return(NULL);
  ------------------
  |  Branch (6995:6): [True: 0, False: 1.88k]
  ------------------
 6996|       |	/*
 6997|       |	* Get the first element child.
 6998|       |	*/
 6999|  1.88k|	switch (cur->type) {
 7000|    661|            case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7000:13): [True: 661, False: 1.22k]
  ------------------
 7001|    661|	    case XML_DOCUMENT_FRAG_NODE:
  ------------------
  |  Branch (7001:6): [True: 0, False: 1.88k]
  ------------------
 7002|    661|	    case XML_ENTITY_REF_NODE: /* URGENT TODO: entify-refs as well? */
  ------------------
  |  Branch (7002:6): [True: 0, False: 1.88k]
  ------------------
 7003|    661|            case XML_ENTITY_NODE:
  ------------------
  |  Branch (7003:13): [True: 0, False: 1.88k]
  ------------------
 7004|    661|		cur = cur->children;
 7005|    661|		if (cur != NULL) {
  ------------------
  |  Branch (7005:7): [True: 597, False: 64]
  ------------------
 7006|    597|		    if (cur->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7006:11): [True: 8, False: 589]
  ------------------
 7007|      8|			return(cur);
 7008|    590|		    do {
 7009|    590|			cur = cur->next;
 7010|    590|		    } while ((cur != NULL) &&
  ------------------
  |  Branch (7010:16): [True: 239, False: 351]
  ------------------
 7011|    590|			(cur->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (7011:4): [True: 1, False: 238]
  ------------------
 7012|    589|		    return(cur);
 7013|    597|		}
 7014|     64|		return(NULL);
 7015|     87|            case XML_DOCUMENT_NODE:
  ------------------
  |  Branch (7015:13): [True: 87, False: 1.79k]
  ------------------
 7016|     87|            case XML_HTML_DOCUMENT_NODE:
  ------------------
  |  Branch (7016:13): [True: 0, False: 1.88k]
  ------------------
 7017|     87|		return(xmlDocGetRootElement((xmlDocPtr) cur));
 7018|  1.13k|	    default:
  ------------------
  |  Branch (7018:6): [True: 1.13k, False: 748]
  ------------------
 7019|  1.13k|		return(NULL);
 7020|  1.88k|	}
 7021|      0|	return(NULL);
 7022|  1.88k|    }
 7023|       |    /*
 7024|       |    * Get the next sibling element node.
 7025|       |    */
 7026|    760|    switch (cur->type) {
 7027|    760|	case XML_ELEMENT_NODE:
  ------------------
  |  Branch (7027:2): [True: 760, False: 0]
  ------------------
 7028|    760|	case XML_TEXT_NODE:
  ------------------
  |  Branch (7028:2): [True: 0, False: 760]
  ------------------
 7029|    760|	case XML_ENTITY_REF_NODE:
  ------------------
  |  Branch (7029:2): [True: 0, False: 760]
  ------------------
 7030|    760|	case XML_ENTITY_NODE:
  ------------------
  |  Branch (7030:2): [True: 0, False: 760]
  ------------------
 7031|    760|	case XML_CDATA_SECTION_NODE:
  ------------------
  |  Branch (7031:2): [True: 0, False: 760]
  ------------------
 7032|    760|	case XML_PI_NODE:
  ------------------
  |  Branch (7032:2): [True: 0, False: 760]
  ------------------
 7033|    760|	case XML_COMMENT_NODE:
  ------------------
  |  Branch (7033:2): [True: 0, False: 760]
  ------------------
 7034|    760|	case XML_XINCLUDE_END:
  ------------------
  |  Branch (7034:2): [True: 0, False: 760]
  ------------------
 7035|    760|	    break;
 7036|       |	/* case XML_DTD_NODE: */ /* URGENT TODO: DTD-node as well? */
 7037|      0|	default:
  ------------------
  |  Branch (7037:2): [True: 0, False: 760]
  ------------------
 7038|      0|	    return(NULL);
 7039|    760|    }
 7040|    760|    if (cur->next != NULL) {
  ------------------
  |  Branch (7040:9): [True: 666, False: 94]
  ------------------
 7041|    666|	if (cur->next->type == XML_ELEMENT_NODE)
  ------------------
  |  Branch (7041:6): [True: 2, False: 664]
  ------------------
 7042|      2|	    return(cur->next);
 7043|    664|	cur = cur->next;
 7044|    664|	do {
 7045|    664|	    cur = cur->next;
 7046|    664|	} while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));
  ------------------
  |  Branch (7046:11): [True: 442, False: 222]
  |  Branch (7046:28): [True: 0, False: 442]
  ------------------
 7047|    664|	return(cur);
 7048|    666|    }
 7049|     94|    return(NULL);
 7050|    760|}
xpath.c:xmlXPathNextPrecedingInternal:
 7615|     53|{
 7616|     53|    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
  ------------------
  |  Branch (7616:9): [True: 0, False: 53]
  |  Branch (7616:27): [True: 0, False: 53]
  ------------------
 7617|     53|    if (cur == NULL) {
  ------------------
  |  Branch (7617:9): [True: 6, False: 47]
  ------------------
 7618|      6|        cur = ctxt->context->node;
 7619|      6|        if (cur == NULL)
  ------------------
  |  Branch (7619:13): [True: 0, False: 6]
  ------------------
 7620|      0|            return (NULL);
 7621|      6|        if (cur->type == XML_ATTRIBUTE_NODE) {
  ------------------
  |  Branch (7621:13): [True: 1, False: 5]
  ------------------
 7622|      1|            cur = cur->parent;
 7623|      5|        } else if (cur->type == XML_NAMESPACE_DECL) {
  ------------------
  |  Branch (7623:20): [True: 1, False: 4]
  ------------------
 7624|      1|            xmlNsPtr ns = (xmlNsPtr) cur;
 7625|       |
 7626|      1|            if ((ns->next == NULL) ||
  ------------------
  |  Branch (7626:17): [True: 0, False: 1]
  ------------------
 7627|      1|                (ns->next->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (7627:17): [True: 0, False: 1]
  ------------------
 7628|      0|                return (NULL);
 7629|      1|            cur = (xmlNodePtr) ns->next;
 7630|      1|        }
 7631|      6|        ctxt->ancestor = cur->parent;
 7632|      6|    }
 7633|     53|    if (cur->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (7633:9): [True: 0, False: 53]
  ------------------
 7634|      0|        return(NULL);
 7635|     53|    if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
  ------------------
  |  Branch (7635:9): [True: 33, False: 20]
  |  Branch (7635:32): [True: 0, False: 33]
  ------------------
 7636|      0|	cur = cur->prev;
 7637|     56|    while (cur->prev == NULL) {
  ------------------
  |  Branch (7637:12): [True: 22, False: 34]
  ------------------
 7638|     22|        cur = cur->parent;
 7639|     22|        if (cur == NULL)
  ------------------
  |  Branch (7639:13): [True: 3, False: 19]
  ------------------
 7640|      3|            return (NULL);
 7641|     19|        if (cur == ctxt->context->doc->children)
  ------------------
  |  Branch (7641:13): [True: 3, False: 16]
  ------------------
 7642|      3|            return (NULL);
 7643|     16|        if (cur != ctxt->ancestor)
  ------------------
  |  Branch (7643:13): [True: 13, False: 3]
  ------------------
 7644|     13|            return (cur);
 7645|      3|        ctxt->ancestor = cur->parent;
 7646|      3|    }
 7647|     34|    cur = cur->prev;
 7648|     47|    while (cur->last != NULL)
  ------------------
  |  Branch (7648:12): [True: 13, False: 34]
  ------------------
 7649|     13|        cur = cur->last;
 7650|     34|    return (cur);
 7651|     53|}
xpath.c:xmlXPathIsPositionalPredicate:
11034|     49|{
11035|       |
11036|     49|    xmlXPathStepOpPtr exprOp;
11037|       |
11038|       |    /*
11039|       |    * BIG NOTE: This is not intended for XPATH_OP_FILTER yet!
11040|       |    */
11041|       |
11042|       |    /*
11043|       |    * If not -1, then ch1 will point to:
11044|       |    * 1) For predicates (XPATH_OP_PREDICATE):
11045|       |    *    - an inner predicate operator
11046|       |    * 2) For filters (XPATH_OP_FILTER):
11047|       |    *    - an inner filter operator OR
11048|       |    *    - an expression selecting the node set.
11049|       |    *      E.g. "key('a', 'b')" or "(//foo | //bar)".
11050|       |    */
11051|     49|    if ((op->op != XPATH_OP_PREDICATE) && (op->op != XPATH_OP_FILTER))
  ------------------
  |  Branch (11051:9): [True: 0, False: 49]
  |  Branch (11051:43): [True: 0, False: 0]
  ------------------
11052|      0|	return(0);
11053|       |
11054|     49|    if (op->ch2 != -1) {
  ------------------
  |  Branch (11054:9): [True: 49, False: 0]
  ------------------
11055|     49|	exprOp = &ctxt->comp->steps[op->ch2];
11056|     49|    } else
11057|      0|	return(0);
11058|       |
11059|     49|    if ((exprOp != NULL) &&
  ------------------
  |  Branch (11059:9): [True: 49, False: 0]
  ------------------
11060|     49|	(exprOp->op == XPATH_OP_VALUE) &&
  ------------------
  |  Branch (11060:2): [True: 20, False: 29]
  ------------------
11061|     49|	(exprOp->value4 != NULL) &&
  ------------------
  |  Branch (11061:2): [True: 20, False: 0]
  ------------------
11062|     49|	(((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))
  ------------------
  |  Branch (11062:2): [True: 20, False: 0]
  ------------------
11063|     20|    {
11064|     20|        double floatval = ((xmlXPathObjectPtr) exprOp->value4)->floatval;
11065|       |
11066|       |	/*
11067|       |	* We have a "[n]" predicate here.
11068|       |	* TODO: Unfortunately this simplistic test here is not
11069|       |	* able to detect a position() predicate in compound
11070|       |	* expressions like "[@attr = 'a" and position() = 1],
11071|       |	* and even not the usage of position() in
11072|       |	* "[position() = 1]"; thus - obviously - a position-range,
11073|       |	* like it "[position() < 5]", is also not detected.
11074|       |	* Maybe we could rewrite the AST to ease the optimization.
11075|       |	*/
11076|       |
11077|     20|        if ((floatval > INT_MIN) && (floatval < INT_MAX)) {
  ------------------
  |  Branch (11077:13): [True: 20, False: 0]
  |  Branch (11077:37): [True: 18, False: 2]
  ------------------
11078|     18|	    *maxPos = (int) floatval;
11079|     18|            if (floatval == (double) *maxPos)
  ------------------
  |  Branch (11079:17): [True: 18, False: 0]
  ------------------
11080|     18|                return(1);
11081|     18|        }
11082|     20|    }
11083|     31|    return(0);
11084|     49|}
xpath.c:xmlXPathCompOpEvalPredicate:
11006|    176|{
11007|    176|    if (op->ch1 != -1) {
  ------------------
  |  Branch (11007:9): [True: 4, False: 172]
  ------------------
11008|      4|	xmlXPathCompExprPtr comp = ctxt->comp;
11009|       |	/*
11010|       |	* Process inner predicates first.
11011|       |	*/
11012|      4|	if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {
  ------------------
  |  Branch (11012:6): [True: 0, False: 4]
  ------------------
11013|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
11014|      0|                "xmlXPathCompOpEvalPredicate: Expected a predicate\n");
11015|      0|            XP_ERROR(XPATH_INVALID_OPERAND);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
11016|      0|	}
11017|      4|        if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|      4|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (11017:13): [True: 0, False: 4]
  ------------------
11018|      4|            XP_ERROR(XPATH_RECURSION_LIMIT_EXCEEDED);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
11019|      4|        ctxt->context->depth += 1;
11020|      4|	xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,
11021|      4|                                    1, set->nodeNr, hasNsNodes);
11022|      4|        ctxt->context->depth -= 1;
11023|      4|	CHECK_ERROR;
  ------------------
  |  |  241|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
11024|      4|    }
11025|       |
11026|    176|    if (op->ch2 != -1)
  ------------------
  |  Branch (11026:9): [True: 176, False: 0]
  ------------------
11027|    176|        xmlXPathNodeSetFilter(ctxt, set, op->ch2, minPos, maxPos, hasNsNodes);
11028|    176|}
xpath.c:xmlXPathNodeSetFilter:
10753|    180|{
10754|    180|    xmlXPathContextPtr xpctxt;
10755|    180|    xmlNodePtr oldnode;
10756|    180|    xmlDocPtr olddoc;
10757|    180|    xmlXPathStepOpPtr filterOp;
10758|    180|    int oldcs, oldpp;
10759|    180|    int i, j, pos;
10760|       |
10761|    180|    if ((set == NULL) || (set->nodeNr == 0))
  ------------------
  |  Branch (10761:9): [True: 0, False: 180]
  |  Branch (10761:26): [True: 0, False: 180]
  ------------------
10762|      0|        return;
10763|       |
10764|       |    /*
10765|       |    * Check if the node set contains a sufficient number of nodes for
10766|       |    * the requested range.
10767|       |    */
10768|    180|    if (set->nodeNr < minPos) {
  ------------------
  |  Branch (10768:9): [True: 0, False: 180]
  ------------------
10769|      0|        xmlXPathNodeSetClear(set, hasNsNodes);
10770|      0|        return;
10771|      0|    }
10772|       |
10773|    180|    xpctxt = ctxt->context;
10774|    180|    oldnode = xpctxt->node;
10775|    180|    olddoc = xpctxt->doc;
10776|    180|    oldcs = xpctxt->contextSize;
10777|    180|    oldpp = xpctxt->proximityPosition;
10778|    180|    filterOp = &ctxt->comp->steps[filterOpIndex];
10779|       |
10780|    180|    xpctxt->contextSize = set->nodeNr;
10781|       |
10782|    653|    for (i = 0, j = 0, pos = 1; i < set->nodeNr; i++) {
  ------------------
  |  Branch (10782:33): [True: 493, False: 160]
  ------------------
10783|    493|        xmlNodePtr node = set->nodeTab[i];
10784|    493|        int res;
10785|       |
10786|    493|        xpctxt->node = node;
10787|    493|        xpctxt->proximityPosition = i + 1;
10788|       |
10789|       |        /*
10790|       |        * Also set the xpath document in case things like
10791|       |        * key() are evaluated in the predicate.
10792|       |        *
10793|       |        * TODO: Get real doc for namespace nodes.
10794|       |        */
10795|    493|        if ((node->type != XML_NAMESPACE_DECL) &&
  ------------------
  |  Branch (10795:13): [True: 490, False: 3]
  ------------------
10796|    493|            (node->doc != NULL))
  ------------------
  |  Branch (10796:13): [True: 490, False: 0]
  ------------------
10797|    490|            xpctxt->doc = node->doc;
10798|       |
10799|    493|        res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);
10800|       |
10801|    493|        if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (10801:13): [True: 0, False: 493]
  ------------------
10802|      0|            break;
10803|    493|        if (res < 0) {
  ------------------
  |  Branch (10803:13): [True: 0, False: 493]
  ------------------
10804|       |            /* Shouldn't happen */
10805|      0|            xmlXPathErr(ctxt, XPATH_EXPR_ERROR);
10806|      0|            break;
10807|      0|        }
10808|       |
10809|    493|        if ((res != 0) && ((pos >= minPos) && (pos <= maxPos))) {
  ------------------
  |  Branch (10809:13): [True: 58, False: 435]
  |  Branch (10809:28): [True: 57, False: 1]
  |  Branch (10809:47): [True: 57, False: 0]
  ------------------
10810|     57|            if (i != j) {
  ------------------
  |  Branch (10810:17): [True: 24, False: 33]
  ------------------
10811|     24|                set->nodeTab[j] = node;
10812|     24|                set->nodeTab[i] = NULL;
10813|     24|            }
10814|       |
10815|     57|            j += 1;
10816|    436|        } else {
10817|       |            /* Remove the entry from the initial node set. */
10818|    436|            set->nodeTab[i] = NULL;
10819|    436|            if (node->type == XML_NAMESPACE_DECL)
  ------------------
  |  Branch (10819:17): [True: 0, False: 436]
  ------------------
10820|      0|                xmlXPathNodeSetFreeNs((xmlNsPtr) node);
10821|    436|        }
10822|       |
10823|    493|        if (res != 0) {
  ------------------
  |  Branch (10823:13): [True: 58, False: 435]
  ------------------
10824|     58|            if (pos == maxPos) {
  ------------------
  |  Branch (10824:17): [True: 20, False: 38]
  ------------------
10825|     20|                i += 1;
10826|     20|                break;
10827|     20|            }
10828|       |
10829|     38|            pos += 1;
10830|     38|        }
10831|    493|    }
10832|       |
10833|       |    /* Free remaining nodes. */
10834|    180|    if (hasNsNodes) {
  ------------------
  |  Branch (10834:9): [True: 7, False: 173]
  ------------------
10835|      7|        for (; i < set->nodeNr; i++) {
  ------------------
  |  Branch (10835:16): [True: 0, False: 7]
  ------------------
10836|      0|            xmlNodePtr node = set->nodeTab[i];
10837|      0|            if ((node != NULL) && (node->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (10837:17): [True: 0, False: 0]
  |  Branch (10837:35): [True: 0, False: 0]
  ------------------
10838|      0|                xmlXPathNodeSetFreeNs((xmlNsPtr) node);
10839|      0|        }
10840|      7|    }
10841|       |
10842|    180|    set->nodeNr = j;
10843|       |
10844|       |    /* If too many elements were removed, shrink table to preserve memory. */
10845|    180|    if ((set->nodeMax > XML_NODESET_DEFAULT) &&
  ------------------
  |  | 2908|    180|#define XML_NODESET_DEFAULT	10
  ------------------
  |  Branch (10845:9): [True: 2, False: 178]
  ------------------
10846|    180|        (set->nodeNr < set->nodeMax / 2)) {
  ------------------
  |  Branch (10846:9): [True: 2, False: 0]
  ------------------
10847|      2|        xmlNodePtr *tmp;
10848|      2|        int nodeMax = set->nodeNr;
10849|       |
10850|      2|        if (nodeMax < XML_NODESET_DEFAULT)
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
  |  Branch (10850:13): [True: 2, False: 0]
  ------------------
10851|      2|            nodeMax = XML_NODESET_DEFAULT;
  ------------------
  |  | 2908|      2|#define XML_NODESET_DEFAULT	10
  ------------------
10852|      2|        tmp = (xmlNodePtr *) xmlRealloc(set->nodeTab,
10853|      2|                nodeMax * sizeof(xmlNodePtr));
10854|      2|        if (tmp == NULL) {
  ------------------
  |  Branch (10854:13): [True: 0, False: 2]
  ------------------
10855|      0|            xmlXPathPErrMemory(ctxt, "shrinking nodeset\n");
10856|      2|        } else {
10857|      2|            set->nodeTab = tmp;
10858|      2|            set->nodeMax = nodeMax;
10859|      2|        }
10860|      2|    }
10861|       |
10862|    180|    xpctxt->node = oldnode;
10863|    180|    xpctxt->doc = olddoc;
10864|    180|    xpctxt->contextSize = oldcs;
10865|    180|    xpctxt->proximityPosition = oldpp;
10866|    180|}
xpath.c:xmlXPathCompOpEval:
12065|  3.63k|{
12066|  3.63k|    int total = 0;
12067|  3.63k|    int equal, ret;
12068|  3.63k|    xmlXPathCompExprPtr comp;
12069|  3.63k|    xmlXPathObjectPtr arg1, arg2;
12070|       |
12071|  3.63k|    CHECK_ERROR0;
  ------------------
  |  |  249|  3.63k|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 3.63k]
  |  |  ------------------
  ------------------
12072|  3.63k|    if (OP_LIMIT_EXCEEDED(ctxt, 1))
  ------------------
  |  |  787|  3.63k|    ((ctxt->context->opLimit != 0) && (xmlXPathCheckOpLimit(ctxt, n) < 0))
  |  |  ------------------
  |  |  |  Branch (787:6): [True: 3.63k, False: 0]
  |  |  |  Branch (787:39): [True: 0, False: 3.63k]
  |  |  ------------------
  ------------------
12073|      0|        return(0);
12074|  3.63k|    if (ctxt->context->depth >= XPATH_MAX_RECURSION_DEPTH)
  ------------------
  |  |  124|  3.63k|#define XPATH_MAX_RECURSION_DEPTH 500
  ------------------
  |  Branch (12074:9): [True: 0, False: 3.63k]
  ------------------
12075|  3.63k|        XP_ERROR0(XPATH_RECURSION_LIMIT_EXCEEDED);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12076|  3.63k|    ctxt->context->depth += 1;
12077|  3.63k|    comp = ctxt->comp;
12078|  3.63k|    switch (op->op) {
12079|      0|        case XPATH_OP_END:
  ------------------
  |  Branch (12079:9): [True: 0, False: 3.63k]
  ------------------
12080|      0|            break;
12081|      0|        case XPATH_OP_AND:
  ------------------
  |  Branch (12081:9): [True: 0, False: 3.63k]
  ------------------
12082|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12083|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12084|      0|            xmlXPathBooleanFunction(ctxt, 1);
12085|      0|            if ((ctxt->value == NULL) || (ctxt->value->boolval == 0))
  ------------------
  |  Branch (12085:17): [True: 0, False: 0]
  |  Branch (12085:42): [True: 0, False: 0]
  ------------------
12086|      0|                break;
12087|      0|            arg2 = valuePop(ctxt);
12088|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12089|      0|	    if (ctxt->error) {
  ------------------
  |  Branch (12089:10): [True: 0, False: 0]
  ------------------
12090|      0|		xmlXPathFreeObject(arg2);
12091|      0|		break;
12092|      0|	    }
12093|      0|            xmlXPathBooleanFunction(ctxt, 1);
12094|      0|            if (ctxt->value != NULL)
  ------------------
  |  Branch (12094:17): [True: 0, False: 0]
  ------------------
12095|      0|                ctxt->value->boolval &= arg2->boolval;
12096|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
12097|      0|            break;
12098|      0|        case XPATH_OP_OR:
  ------------------
  |  Branch (12098:9): [True: 0, False: 3.63k]
  ------------------
12099|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12100|      0|	    CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12101|      0|            xmlXPathBooleanFunction(ctxt, 1);
12102|      0|            if ((ctxt->value == NULL) || (ctxt->value->boolval == 1))
  ------------------
  |  Branch (12102:17): [True: 0, False: 0]
  |  Branch (12102:42): [True: 0, False: 0]
  ------------------
12103|      0|                break;
12104|      0|            arg2 = valuePop(ctxt);
12105|      0|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12106|      0|	    if (ctxt->error) {
  ------------------
  |  Branch (12106:10): [True: 0, False: 0]
  ------------------
12107|      0|		xmlXPathFreeObject(arg2);
12108|      0|		break;
12109|      0|	    }
12110|      0|            xmlXPathBooleanFunction(ctxt, 1);
12111|      0|            if (ctxt->value != NULL)
  ------------------
  |  Branch (12111:17): [True: 0, False: 0]
  ------------------
12112|      0|                ctxt->value->boolval |= arg2->boolval;
12113|      0|	    xmlXPathReleaseObject(ctxt->context, arg2);
12114|      0|            break;
12115|    291|        case XPATH_OP_EQUAL:
  ------------------
  |  Branch (12115:9): [True: 291, False: 3.34k]
  ------------------
12116|    291|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12117|    291|	    CHECK_ERROR0;
  ------------------
  |  |  249|    291|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 291]
  |  |  ------------------
  ------------------
12118|    291|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12119|    291|	    CHECK_ERROR0;
  ------------------
  |  |  249|    291|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 291]
  |  |  ------------------
  ------------------
12120|    291|	    if (op->value)
  ------------------
  |  Branch (12120:10): [True: 275, False: 16]
  ------------------
12121|    275|		equal = xmlXPathEqualValues(ctxt);
12122|     16|	    else
12123|     16|		equal = xmlXPathNotEqualValues(ctxt);
12124|    291|	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));
12125|    291|            break;
12126|     69|        case XPATH_OP_CMP:
  ------------------
  |  Branch (12126:9): [True: 69, False: 3.56k]
  ------------------
12127|     69|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12128|     69|	    CHECK_ERROR0;
  ------------------
  |  |  249|     69|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 69]
  |  |  ------------------
  ------------------
12129|     69|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12130|     69|	    CHECK_ERROR0;
  ------------------
  |  |  249|     69|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 69]
  |  |  ------------------
  ------------------
12131|     69|            ret = xmlXPathCompareValues(ctxt, op->value, op->value2);
12132|     69|	    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));
12133|     69|            break;
12134|     95|        case XPATH_OP_PLUS:
  ------------------
  |  Branch (12134:9): [True: 95, False: 3.53k]
  ------------------
12135|     95|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12136|     95|	    CHECK_ERROR0;
  ------------------
  |  |  249|     95|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 95]
  |  |  ------------------
  ------------------
12137|     95|            if (op->ch2 != -1) {
  ------------------
  |  Branch (12137:17): [True: 27, False: 68]
  ------------------
12138|     27|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12139|     27|	    }
12140|     95|	    CHECK_ERROR0;
  ------------------
  |  |  249|     95|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 95]
  |  |  ------------------
  ------------------
12141|     95|            if (op->value == 0)
  ------------------
  |  Branch (12141:17): [True: 0, False: 95]
  ------------------
12142|      0|                xmlXPathSubValues(ctxt);
12143|     95|            else if (op->value == 1)
  ------------------
  |  Branch (12143:22): [True: 27, False: 68]
  ------------------
12144|     27|                xmlXPathAddValues(ctxt);
12145|     68|            else if (op->value == 2)
  ------------------
  |  Branch (12145:22): [True: 68, False: 0]
  ------------------
12146|     68|                xmlXPathValueFlipSign(ctxt);
12147|      0|            else if (op->value == 3) {
  ------------------
  |  Branch (12147:22): [True: 0, False: 0]
  ------------------
12148|      0|                CAST_TO_NUMBER;
  ------------------
  |  |  319|      0|    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
  |  |  ------------------
  |  |  |  Branch (319:9): [True: 0, False: 0]
  |  |  |  Branch (319:34): [True: 0, False: 0]
  |  |  ------------------
  |  |  320|      0|        xmlXPathNumberFunction(ctxt, 1);
  ------------------
12149|      0|                CHECK_TYPE0(XPATH_NUMBER);
  ------------------
  |  |  288|      0|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 0]
  |  |  |  Branch (288:34): [True: 0, False: 0]
  |  |  ------------------
  |  |  289|      0|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
12150|      0|            }
12151|     95|            break;
12152|    132|        case XPATH_OP_MULT:
  ------------------
  |  Branch (12152:9): [True: 132, False: 3.50k]
  ------------------
12153|    132|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12154|    132|	    CHECK_ERROR0;
  ------------------
  |  |  249|    132|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 132]
  |  |  ------------------
  ------------------
12155|    132|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12156|    132|	    CHECK_ERROR0;
  ------------------
  |  |  249|    132|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 132]
  |  |  ------------------
  ------------------
12157|    132|            if (op->value == 0)
  ------------------
  |  Branch (12157:17): [True: 25, False: 107]
  ------------------
12158|     25|                xmlXPathMultValues(ctxt);
12159|    107|            else if (op->value == 1)
  ------------------
  |  Branch (12159:22): [True: 96, False: 11]
  ------------------
12160|     96|                xmlXPathDivValues(ctxt);
12161|     11|            else if (op->value == 2)
  ------------------
  |  Branch (12161:22): [True: 11, False: 0]
  ------------------
12162|     11|                xmlXPathModValues(ctxt);
12163|    132|            break;
12164|      4|        case XPATH_OP_UNION:
  ------------------
  |  Branch (12164:9): [True: 4, False: 3.63k]
  ------------------
12165|      4|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12166|      4|	    CHECK_ERROR0;
  ------------------
  |  |  249|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
12167|      4|            total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12168|      4|	    CHECK_ERROR0;
  ------------------
  |  |  249|      4|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 4]
  |  |  ------------------
  ------------------
12169|       |
12170|      4|            arg2 = valuePop(ctxt);
12171|      4|            arg1 = valuePop(ctxt);
12172|      4|            if ((arg1 == NULL) || (arg1->type != XPATH_NODESET) ||
  ------------------
  |  Branch (12172:17): [True: 0, False: 4]
  |  Branch (12172:35): [True: 0, False: 4]
  ------------------
12173|      4|                (arg2 == NULL) || (arg2->type != XPATH_NODESET)) {
  ------------------
  |  Branch (12173:17): [True: 0, False: 4]
  |  Branch (12173:35): [True: 0, False: 4]
  ------------------
12174|      0|	        xmlXPathReleaseObject(ctxt->context, arg1);
12175|      0|	        xmlXPathReleaseObject(ctxt->context, arg2);
12176|      0|                XP_ERROR0(XPATH_INVALID_TYPE);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12177|      0|            }
12178|      4|            if ((ctxt->context->opLimit != 0) &&
  ------------------
  |  Branch (12178:17): [True: 4, False: 0]
  ------------------
12179|      4|                (((arg1->nodesetval != NULL) &&
  ------------------
  |  Branch (12179:19): [True: 4, False: 0]
  ------------------
12180|      4|                  (xmlXPathCheckOpLimit(ctxt,
  ------------------
  |  Branch (12180:19): [True: 0, False: 4]
  ------------------
12181|      4|                                        arg1->nodesetval->nodeNr) < 0)) ||
12182|      4|                 ((arg2->nodesetval != NULL) &&
  ------------------
  |  Branch (12182:19): [True: 4, False: 0]
  ------------------
12183|      4|                  (xmlXPathCheckOpLimit(ctxt,
  ------------------
  |  Branch (12183:19): [True: 0, False: 4]
  ------------------
12184|      4|                                        arg2->nodesetval->nodeNr) < 0)))) {
12185|      0|	        xmlXPathReleaseObject(ctxt->context, arg1);
12186|      0|	        xmlXPathReleaseObject(ctxt->context, arg2);
12187|      0|                break;
12188|      0|            }
12189|       |
12190|      4|	    if ((arg1->nodesetval == NULL) ||
  ------------------
  |  Branch (12190:10): [True: 0, False: 4]
  ------------------
12191|      4|		((arg2->nodesetval != NULL) &&
  ------------------
  |  Branch (12191:4): [True: 4, False: 0]
  ------------------
12192|      4|		 (arg2->nodesetval->nodeNr != 0)))
  ------------------
  |  Branch (12192:4): [True: 2, False: 2]
  ------------------
12193|      2|	    {
12194|       |                /* TODO: Check memory error. */
12195|      2|		arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,
12196|      2|							arg2->nodesetval);
12197|      2|	    }
12198|       |
12199|      4|            valuePush(ctxt, arg1);
12200|      4|	    xmlXPathReleaseObject(ctxt->context, arg2);
12201|      4|            break;
12202|    130|        case XPATH_OP_ROOT:
  ------------------
  |  Branch (12202:9): [True: 130, False: 3.50k]
  ------------------
12203|    130|            xmlXPathRoot(ctxt);
12204|    130|            break;
12205|    245|        case XPATH_OP_NODE:
  ------------------
  |  Branch (12205:9): [True: 245, False: 3.38k]
  ------------------
12206|    245|            if (op->ch1 != -1)
  ------------------
  |  Branch (12206:17): [True: 0, False: 245]
  ------------------
12207|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12208|    245|	    CHECK_ERROR0;
  ------------------
  |  |  249|    245|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 245]
  |  |  ------------------
  ------------------
12209|    245|            if (op->ch2 != -1)
  ------------------
  |  Branch (12209:17): [True: 0, False: 245]
  ------------------
12210|      0|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12211|    245|	    CHECK_ERROR0;
  ------------------
  |  |  249|    245|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 245]
  |  |  ------------------
  ------------------
12212|    245|	    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,
12213|    245|		ctxt->context->node));
12214|    245|            break;
12215|    490|        case XPATH_OP_COLLECT:{
  ------------------
  |  Branch (12215:9): [True: 490, False: 3.14k]
  ------------------
12216|    490|                if (op->ch1 == -1)
  ------------------
  |  Branch (12216:21): [True: 0, False: 490]
  ------------------
12217|      0|                    break;
12218|       |
12219|    490|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12220|    490|		CHECK_ERROR0;
  ------------------
  |  |  249|    490|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 490]
  |  |  ------------------
  ------------------
12221|       |
12222|    490|                total += xmlXPathNodeCollectAndTest(ctxt, op, NULL, NULL, 0);
12223|    490|                break;
12224|    490|            }
12225|    938|        case XPATH_OP_VALUE:
  ------------------
  |  Branch (12225:9): [True: 938, False: 2.69k]
  ------------------
12226|    938|            valuePush(ctxt,
12227|    938|                      xmlXPathCacheObjectCopy(ctxt->context,
12228|    938|			(xmlXPathObjectPtr) op->value4));
12229|    938|            break;
12230|      0|        case XPATH_OP_VARIABLE:{
  ------------------
  |  Branch (12230:9): [True: 0, False: 3.63k]
  ------------------
12231|      0|		xmlXPathObjectPtr val;
12232|       |
12233|      0|                if (op->ch1 != -1)
  ------------------
  |  Branch (12233:21): [True: 0, False: 0]
  ------------------
12234|      0|                    total +=
12235|      0|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12236|      0|                if (op->value5 == NULL) {
  ------------------
  |  Branch (12236:21): [True: 0, False: 0]
  ------------------
12237|      0|		    val = xmlXPathVariableLookup(ctxt->context, op->value4);
12238|      0|		    if (val == NULL)
  ------------------
  |  Branch (12238:11): [True: 0, False: 0]
  ------------------
12239|      0|			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12240|      0|                    valuePush(ctxt, val);
12241|      0|		} else {
12242|      0|                    const xmlChar *URI;
12243|       |
12244|      0|                    URI = xmlXPathNsLookup(ctxt->context, op->value5);
12245|      0|                    if (URI == NULL) {
  ------------------
  |  Branch (12245:25): [True: 0, False: 0]
  ------------------
12246|      0|                        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12247|      0|            "xmlXPathCompOpEval: variable %s bound to undefined prefix %s\n",
12248|      0|                                    (char *) op->value4, (char *)op->value5);
12249|      0|                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
12250|      0|                        break;
12251|      0|                    }
12252|      0|		    val = xmlXPathVariableLookupNS(ctxt->context,
12253|      0|                                                       op->value4, URI);
12254|      0|		    if (val == NULL)
  ------------------
  |  Branch (12254:11): [True: 0, False: 0]
  ------------------
12255|      0|			XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12256|      0|                    valuePush(ctxt, val);
12257|      0|                }
12258|      0|                break;
12259|      0|            }
12260|    417|        case XPATH_OP_FUNCTION:{
  ------------------
  |  Branch (12260:9): [True: 417, False: 3.21k]
  ------------------
12261|    417|                xmlXPathFunction func;
12262|    417|                const xmlChar *oldFunc, *oldFuncURI;
12263|    417|		int i;
12264|    417|                int frame;
12265|       |
12266|    417|                frame = ctxt->valueNr;
12267|    417|                if (op->ch1 != -1) {
  ------------------
  |  Branch (12267:21): [True: 232, False: 185]
  ------------------
12268|    232|                    total +=
12269|    232|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12270|    232|                    if (ctxt->error != XPATH_EXPRESSION_OK)
  ------------------
  |  Branch (12270:25): [True: 9, False: 223]
  ------------------
12271|      9|                        break;
12272|    232|                }
12273|    408|		if (ctxt->valueNr < frame + op->value) {
  ------------------
  |  Branch (12273:7): [True: 0, False: 408]
  ------------------
12274|      0|		    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              		    xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12275|      0|			    "xmlXPathCompOpEval: parameter error\n");
12276|      0|		    ctxt->error = XPATH_INVALID_OPERAND;
12277|      0|		    break;
12278|      0|		}
12279|    729|		for (i = 0; i < op->value; i++) {
  ------------------
  |  Branch (12279:15): [True: 321, False: 408]
  ------------------
12280|    321|		    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {
  ------------------
  |  Branch (12280:11): [True: 0, False: 321]
  ------------------
12281|      0|			xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
              			xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12282|      0|				"xmlXPathCompOpEval: parameter error\n");
12283|      0|			ctxt->error = XPATH_INVALID_OPERAND;
12284|      0|			break;
12285|      0|		    }
12286|    321|                }
12287|    408|                if (op->cache != NULL)
  ------------------
  |  Branch (12287:21): [True: 206, False: 202]
  ------------------
12288|    206|                    func = op->cache;
12289|    202|                else {
12290|    202|                    const xmlChar *URI = NULL;
12291|       |
12292|    202|                    if (op->value5 == NULL)
  ------------------
  |  Branch (12292:25): [True: 202, False: 0]
  ------------------
12293|    202|                        func =
12294|    202|                            xmlXPathFunctionLookup(ctxt->context,
12295|    202|                                                   op->value4);
12296|      0|                    else {
12297|      0|                        URI = xmlXPathNsLookup(ctxt->context, op->value5);
12298|      0|                        if (URI == NULL) {
  ------------------
  |  Branch (12298:29): [True: 0, False: 0]
  ------------------
12299|      0|                            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12300|      0|            "xmlXPathCompOpEval: function %s bound to undefined prefix %s\n",
12301|      0|                                    (char *)op->value4, (char *)op->value5);
12302|      0|                            ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
12303|      0|                            break;
12304|      0|                        }
12305|      0|                        func = xmlXPathFunctionLookupNS(ctxt->context,
12306|      0|                                                        op->value4, URI);
12307|      0|                    }
12308|    202|                    if (func == NULL) {
  ------------------
  |  Branch (12308:25): [True: 28, False: 174]
  ------------------
12309|     28|                        xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|     28|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|     28|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                                      xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|     28|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|     28|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12310|     28|                                "xmlXPathCompOpEval: function %s not found\n",
12311|     28|                                        (char *)op->value4);
12312|     28|                        XP_ERROR0(XPATH_UNKNOWN_FUNC_ERROR);
  ------------------
  |  |  267|     28|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12313|      0|                    }
12314|    174|                    op->cache = func;
12315|    174|                    op->cacheURI = (void *) URI;
12316|    174|                }
12317|    380|                oldFunc = ctxt->context->function;
12318|    380|                oldFuncURI = ctxt->context->functionURI;
12319|    380|                ctxt->context->function = op->value4;
12320|    380|                ctxt->context->functionURI = op->cacheURI;
12321|    380|                func(ctxt, op->value);
12322|    380|                ctxt->context->function = oldFunc;
12323|    380|                ctxt->context->functionURI = oldFuncURI;
12324|    380|                if ((ctxt->error == XPATH_EXPRESSION_OK) &&
  ------------------
  |  Branch (12324:21): [True: 380, False: 0]
  ------------------
12325|    380|                    (ctxt->valueNr != frame + 1))
  ------------------
  |  Branch (12325:21): [True: 0, False: 380]
  ------------------
12326|    380|                    XP_ERROR0(XPATH_STACK_ERROR);
  ------------------
  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  ------------------
12327|    380|                break;
12328|    380|            }
12329|    330|        case XPATH_OP_ARG:
  ------------------
  |  Branch (12329:9): [True: 330, False: 3.30k]
  ------------------
12330|    330|            if (op->ch1 != -1) {
  ------------------
  |  Branch (12330:17): [True: 98, False: 232]
  ------------------
12331|     98|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12332|     98|	        CHECK_ERROR0;
  ------------------
  |  |  249|     98|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 98]
  |  |  ------------------
  ------------------
12333|     98|            }
12334|    330|            if (op->ch2 != -1) {
  ------------------
  |  Branch (12334:17): [True: 330, False: 0]
  ------------------
12335|    330|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch2]);
12336|    330|	        CHECK_ERROR0;
  ------------------
  |  |  249|    330|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 9, False: 321]
  |  |  ------------------
  ------------------
12337|    330|	    }
12338|    321|            break;
12339|    321|        case XPATH_OP_PREDICATE:
  ------------------
  |  Branch (12339:9): [True: 0, False: 3.63k]
  ------------------
12340|      8|        case XPATH_OP_FILTER:{
  ------------------
  |  Branch (12340:9): [True: 8, False: 3.62k]
  ------------------
12341|      8|                xmlXPathObjectPtr obj;
12342|      8|                xmlNodeSetPtr set;
12343|       |
12344|       |                /*
12345|       |                 * Optimization for ()[1] selection i.e. the first elem
12346|       |                 */
12347|      8|                if ((op->ch1 != -1) && (op->ch2 != -1) &&
  ------------------
  |  Branch (12347:21): [True: 8, False: 0]
  |  Branch (12347:40): [True: 8, False: 0]
  ------------------
12348|      8|#ifdef XP_OPTIMIZED_FILTER_FIRST
12349|       |		    /*
12350|       |		    * FILTER TODO: Can we assume that the inner processing
12351|       |		    *  will result in an ordered list if we have an
12352|       |		    *  XPATH_OP_FILTER?
12353|       |		    *  What about an additional field or flag on
12354|       |		    *  xmlXPathObject like @sorted ? This way we wouldn't need
12355|       |		    *  to assume anything, so it would be more robust and
12356|       |		    *  easier to optimize.
12357|       |		    */
12358|      8|                    ((comp->steps[op->ch1].op == XPATH_OP_SORT) || /* 18 */
  ------------------
  |  Branch (12358:22): [True: 4, False: 4]
  ------------------
12359|      8|		     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && /* 17 */
  ------------------
  |  Branch (12359:8): [True: 0, False: 4]
  ------------------
12360|       |#else
12361|       |		    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&
12362|       |#endif
12363|      8|                    (comp->steps[op->ch2].op == XPATH_OP_VALUE)) { /* 12 */
  ------------------
  |  Branch (12363:21): [True: 0, False: 4]
  ------------------
12364|      0|                    xmlXPathObjectPtr val;
12365|       |
12366|      0|                    val = comp->steps[op->ch2].value4;
12367|      0|                    if ((val != NULL) && (val->type == XPATH_NUMBER) &&
  ------------------
  |  Branch (12367:25): [True: 0, False: 0]
  |  Branch (12367:42): [True: 0, False: 0]
  ------------------
12368|      0|                        (val->floatval == 1.0)) {
  ------------------
  |  Branch (12368:25): [True: 0, False: 0]
  ------------------
12369|      0|                        xmlNodePtr first = NULL;
12370|       |
12371|      0|                        total +=
12372|      0|                            xmlXPathCompOpEvalFirst(ctxt,
12373|      0|                                                    &comp->steps[op->ch1],
12374|      0|                                                    &first);
12375|      0|			CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12376|       |                        /*
12377|       |                         * The nodeset should be in document order,
12378|       |                         * Keep only the first value
12379|       |                         */
12380|      0|                        if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12380:29): [True: 0, False: 0]
  ------------------
12381|      0|                            (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12381:29): [True: 0, False: 0]
  ------------------
12382|      0|                            (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12382:29): [True: 0, False: 0]
  ------------------
12383|      0|                            (ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12383:29): [True: 0, False: 0]
  ------------------
12384|      0|                            xmlXPathNodeSetClearFromPos(ctxt->value->nodesetval,
12385|      0|                                                        1, 1);
12386|      0|                        break;
12387|      0|                    }
12388|      0|                }
12389|       |                /*
12390|       |                 * Optimization for ()[last()] selection i.e. the last elem
12391|       |                 */
12392|      8|                if ((op->ch1 != -1) && (op->ch2 != -1) &&
  ------------------
  |  Branch (12392:21): [True: 8, False: 0]
  |  Branch (12392:40): [True: 8, False: 0]
  ------------------
12393|      8|                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&
  ------------------
  |  Branch (12393:21): [True: 4, False: 4]
  ------------------
12394|      8|                    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {
  ------------------
  |  Branch (12394:21): [True: 4, False: 0]
  ------------------
12395|      4|                    int f = comp->steps[op->ch2].ch1;
12396|       |
12397|      4|                    if ((f != -1) &&
  ------------------
  |  Branch (12397:25): [True: 4, False: 0]
  ------------------
12398|      4|                        (comp->steps[f].op == XPATH_OP_FUNCTION) &&
  ------------------
  |  Branch (12398:25): [True: 1, False: 3]
  ------------------
12399|      4|                        (comp->steps[f].value5 == NULL) &&
  ------------------
  |  Branch (12399:25): [True: 1, False: 0]
  ------------------
12400|      4|                        (comp->steps[f].value == 0) &&
  ------------------
  |  Branch (12400:25): [True: 1, False: 0]
  ------------------
12401|      4|                        (comp->steps[f].value4 != NULL) &&
  ------------------
  |  Branch (12401:25): [True: 1, False: 0]
  ------------------
12402|      4|                        (xmlStrEqual
  ------------------
  |  Branch (12402:25): [True: 0, False: 1]
  ------------------
12403|      1|                         (comp->steps[f].value4, BAD_CAST "last"))) {
  ------------------
  |  |   35|      1|#define BAD_CAST (xmlChar *)
  ------------------
12404|      0|                        xmlNodePtr last = NULL;
12405|       |
12406|      0|                        total +=
12407|      0|                            xmlXPathCompOpEvalLast(ctxt,
12408|      0|                                                   &comp->steps[op->ch1],
12409|      0|                                                   &last);
12410|      0|			CHECK_ERROR0;
  ------------------
  |  |  249|      0|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 0, False: 0]
  |  |  ------------------
  ------------------
12411|       |                        /*
12412|       |                         * The nodeset should be in document order,
12413|       |                         * Keep only the last value
12414|       |                         */
12415|      0|                        if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12415:29): [True: 0, False: 0]
  ------------------
12416|      0|                            (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12416:29): [True: 0, False: 0]
  ------------------
12417|      0|                            (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12417:29): [True: 0, False: 0]
  ------------------
12418|      0|                            (ctxt->value->nodesetval->nodeTab != NULL) &&
  ------------------
  |  Branch (12418:29): [True: 0, False: 0]
  ------------------
12419|      0|                            (ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12419:29): [True: 0, False: 0]
  ------------------
12420|      0|                            xmlXPathNodeSetKeepLast(ctxt->value->nodesetval);
12421|      0|                        break;
12422|      0|                    }
12423|      4|                }
12424|       |		/*
12425|       |		* Process inner predicates first.
12426|       |		* Example "index[parent::book][1]":
12427|       |		* ...
12428|       |		*   PREDICATE   <-- we are here "[1]"
12429|       |		*     PREDICATE <-- process "[parent::book]" first
12430|       |		*       SORT
12431|       |		*         COLLECT  'parent' 'name' 'node' book
12432|       |		*           NODE
12433|       |		*     ELEM Object is a number : 1
12434|       |		*/
12435|      8|                if (op->ch1 != -1)
  ------------------
  |  Branch (12435:21): [True: 8, False: 0]
  ------------------
12436|      8|                    total +=
12437|      8|                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12438|      8|		CHECK_ERROR0;
  ------------------
  |  |  249|      8|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 4, False: 4]
  |  |  ------------------
  ------------------
12439|      4|                if (op->ch2 == -1)
  ------------------
  |  Branch (12439:21): [True: 0, False: 4]
  ------------------
12440|      0|                    break;
12441|      4|                if (ctxt->value == NULL)
  ------------------
  |  Branch (12441:21): [True: 0, False: 4]
  ------------------
12442|      0|                    break;
12443|       |
12444|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
12445|       |                /*
12446|       |                 * Hum are we filtering the result of an XPointer expression
12447|       |                 */
12448|       |                if (ctxt->value->type == XPATH_LOCATIONSET) {
12449|       |                    xmlLocationSetPtr locset = ctxt->value->user;
12450|       |                    xmlXPathLocationSetFilter(ctxt, locset, op->ch2,
12451|       |                                              1, locset->locNr);
12452|       |                    break;
12453|       |                }
12454|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
12455|       |
12456|       |                /*
12457|       |                 * In case of errors, xmlXPathNodeSetFilter can pop additional
12458|       |                 * nodes from the stack. We have to temporarily remove the
12459|       |                 * nodeset object from the stack to avoid freeing it
12460|       |                 * prematurely.
12461|       |                 */
12462|      4|                CHECK_TYPE0(XPATH_NODESET);
  ------------------
  |  |  288|      4|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (288:9): [True: 0, False: 4]
  |  |  |  Branch (288:34): [True: 0, False: 4]
  |  |  ------------------
  |  |  289|      4|        XP_ERROR0(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  267|      0|    { xmlXPathErr(ctxt, X); return(0); }
  |  |  ------------------
  ------------------
12463|      4|                obj = valuePop(ctxt);
12464|      4|                set = obj->nodesetval;
12465|      4|                if (set != NULL)
  ------------------
  |  Branch (12465:21): [True: 4, False: 0]
  ------------------
12466|      4|                    xmlXPathNodeSetFilter(ctxt, set, op->ch2,
12467|      4|                                          1, set->nodeNr, 1);
12468|      4|                valuePush(ctxt, obj);
12469|      4|                break;
12470|      4|            }
12471|    485|        case XPATH_OP_SORT:
  ------------------
  |  Branch (12471:9): [True: 485, False: 3.14k]
  ------------------
12472|    485|            if (op->ch1 != -1)
  ------------------
  |  Branch (12472:17): [True: 485, False: 0]
  ------------------
12473|    485|                total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12474|    485|	    CHECK_ERROR0;
  ------------------
  |  |  249|    485|    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
  |  |  ------------------
  |  |  |  Branch (249:9): [True: 38, False: 447]
  |  |  ------------------
  ------------------
12475|    447|            if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (12475:17): [True: 447, False: 0]
  ------------------
12476|    447|                (ctxt->value->type == XPATH_NODESET) &&
  ------------------
  |  Branch (12476:17): [True: 154, False: 293]
  ------------------
12477|    447|                (ctxt->value->nodesetval != NULL) &&
  ------------------
  |  Branch (12477:17): [True: 147, False: 7]
  ------------------
12478|    447|		(ctxt->value->nodesetval->nodeNr > 1))
  ------------------
  |  Branch (12478:3): [True: 57, False: 90]
  ------------------
12479|     57|	    {
12480|     57|                xmlXPathNodeSetSort(ctxt->value->nodesetval);
12481|     57|	    }
12482|    447|            break;
12483|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
12484|       |        case XPATH_OP_RANGETO:{
12485|       |                xmlXPathObjectPtr range;
12486|       |                xmlXPathObjectPtr res, obj;
12487|       |                xmlXPathObjectPtr tmp;
12488|       |                xmlLocationSetPtr newlocset = NULL;
12489|       |		    xmlLocationSetPtr oldlocset;
12490|       |                xmlNodeSetPtr oldset;
12491|       |                xmlNodePtr oldnode = ctxt->context->node;
12492|       |                int oldcs = ctxt->context->contextSize;
12493|       |                int oldpp = ctxt->context->proximityPosition;
12494|       |                int i, j;
12495|       |
12496|       |                if (op->ch1 != -1) {
12497|       |                    total +=
12498|       |                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);
12499|       |                    CHECK_ERROR0;
12500|       |                }
12501|       |                if (ctxt->value == NULL) {
12502|       |                    XP_ERROR0(XPATH_INVALID_OPERAND);
12503|       |                }
12504|       |                if (op->ch2 == -1)
12505|       |                    break;
12506|       |
12507|       |                if (ctxt->value->type == XPATH_LOCATIONSET) {
12508|       |                    /*
12509|       |                     * Extract the old locset, and then evaluate the result of the
12510|       |                     * expression for all the element in the locset. use it to grow
12511|       |                     * up a new locset.
12512|       |                     */
12513|       |                    CHECK_TYPE0(XPATH_LOCATIONSET);
12514|       |
12515|       |                    if ((ctxt->value->user == NULL) ||
12516|       |                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))
12517|       |                        break;
12518|       |
12519|       |                    obj = valuePop(ctxt);
12520|       |                    oldlocset = obj->user;
12521|       |
12522|       |                    newlocset = xmlXPtrLocationSetCreate(NULL);
12523|       |
12524|       |                    for (i = 0; i < oldlocset->locNr; i++) {
12525|       |                        /*
12526|       |                         * Run the evaluation with a node list made of a
12527|       |                         * single item in the nodelocset.
12528|       |                         */
12529|       |                        ctxt->context->node = oldlocset->locTab[i]->user;
12530|       |                        ctxt->context->contextSize = oldlocset->locNr;
12531|       |                        ctxt->context->proximityPosition = i + 1;
12532|       |			tmp = xmlXPathCacheNewNodeSet(ctxt->context,
12533|       |			    ctxt->context->node);
12534|       |                        valuePush(ctxt, tmp);
12535|       |
12536|       |                        if (op->ch2 != -1)
12537|       |                            total +=
12538|       |                                xmlXPathCompOpEval(ctxt,
12539|       |                                                   &comp->steps[op->ch2]);
12540|       |			if (ctxt->error != XPATH_EXPRESSION_OK) {
12541|       |                            xmlXPtrFreeLocationSet(newlocset);
12542|       |                            goto rangeto_error;
12543|       |			}
12544|       |
12545|       |                        res = valuePop(ctxt);
12546|       |			if (res->type == XPATH_LOCATIONSET) {
12547|       |			    xmlLocationSetPtr rloc =
12548|       |			        (xmlLocationSetPtr)res->user;
12549|       |			    for (j=0; j<rloc->locNr; j++) {
12550|       |			        range = xmlXPtrNewRange(
12551|       |				  oldlocset->locTab[i]->user,
12552|       |				  oldlocset->locTab[i]->index,
12553|       |				  rloc->locTab[j]->user2,
12554|       |				  rloc->locTab[j]->index2);
12555|       |				if (range != NULL) {
12556|       |				    xmlXPtrLocationSetAdd(newlocset, range);
12557|       |				}
12558|       |			    }
12559|       |			} else {
12560|       |			    range = xmlXPtrNewRangeNodeObject(
12561|       |				(xmlNodePtr)oldlocset->locTab[i]->user, res);
12562|       |                            if (range != NULL) {
12563|       |                                xmlXPtrLocationSetAdd(newlocset,range);
12564|       |			    }
12565|       |                        }
12566|       |
12567|       |                        /*
12568|       |                         * Cleanup
12569|       |                         */
12570|       |                        if (res != NULL) {
12571|       |			    xmlXPathReleaseObject(ctxt->context, res);
12572|       |			}
12573|       |                        if (ctxt->value == tmp) {
12574|       |                            res = valuePop(ctxt);
12575|       |			    xmlXPathReleaseObject(ctxt->context, res);
12576|       |                        }
12577|       |                    }
12578|       |		} else {	/* Not a location set */
12579|       |                    CHECK_TYPE0(XPATH_NODESET);
12580|       |                    obj = valuePop(ctxt);
12581|       |                    oldset = obj->nodesetval;
12582|       |
12583|       |                    newlocset = xmlXPtrLocationSetCreate(NULL);
12584|       |
12585|       |                    if (oldset != NULL) {
12586|       |                        for (i = 0; i < oldset->nodeNr; i++) {
12587|       |                            /*
12588|       |                             * Run the evaluation with a node list made of a single item
12589|       |                             * in the nodeset.
12590|       |                             */
12591|       |                            ctxt->context->node = oldset->nodeTab[i];
12592|       |			    /*
12593|       |			    * OPTIMIZE TODO: Avoid recreation for every iteration.
12594|       |			    */
12595|       |			    tmp = xmlXPathCacheNewNodeSet(ctxt->context,
12596|       |				ctxt->context->node);
12597|       |                            valuePush(ctxt, tmp);
12598|       |
12599|       |                            if (op->ch2 != -1)
12600|       |                                total +=
12601|       |                                    xmlXPathCompOpEval(ctxt,
12602|       |                                                   &comp->steps[op->ch2]);
12603|       |			    if (ctxt->error != XPATH_EXPRESSION_OK) {
12604|       |                                xmlXPtrFreeLocationSet(newlocset);
12605|       |                                goto rangeto_error;
12606|       |			    }
12607|       |
12608|       |                            res = valuePop(ctxt);
12609|       |                            range =
12610|       |                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],
12611|       |                                                      res);
12612|       |                            if (range != NULL) {
12613|       |                                xmlXPtrLocationSetAdd(newlocset, range);
12614|       |                            }
12615|       |
12616|       |                            /*
12617|       |                             * Cleanup
12618|       |                             */
12619|       |                            if (res != NULL) {
12620|       |				xmlXPathReleaseObject(ctxt->context, res);
12621|       |			    }
12622|       |                            if (ctxt->value == tmp) {
12623|       |                                res = valuePop(ctxt);
12624|       |				xmlXPathReleaseObject(ctxt->context, res);
12625|       |                            }
12626|       |                        }
12627|       |                    }
12628|       |                }
12629|       |
12630|       |                /*
12631|       |                 * The result is used as the new evaluation set.
12632|       |                 */
12633|       |                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));
12634|       |rangeto_error:
12635|       |		xmlXPathReleaseObject(ctxt->context, obj);
12636|       |                ctxt->context->node = oldnode;
12637|       |                ctxt->context->contextSize = oldcs;
12638|       |                ctxt->context->proximityPosition = oldpp;
12639|       |                break;
12640|       |            }
12641|       |#endif /* LIBXML_XPTR_LOCS_ENABLED */
12642|      0|        default:
  ------------------
  |  Branch (12642:9): [True: 0, False: 3.63k]
  ------------------
12643|      0|            xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  875|      0|  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
                          xmlGenericError(xmlGenericErrorContext,
  ------------------
  |  |  876|      0|  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)
  |  |  ------------------
  |  |  |  |  500|      0|  #define XML_GLOBAL_MACRO(name) (*__##name())
  |  |  ------------------
  ------------------
12644|      0|                            "XPath: unknown precompiled operation %d\n", op->op);
12645|      0|            ctxt->error = XPATH_INVALID_OPERAND;
12646|      0|            break;
12647|  3.63k|    }
12648|       |
12649|  3.55k|    ctxt->context->depth -= 1;
12650|  3.55k|    return (total);
12651|  3.63k|}

xmlXPtrEval:
 1343|    486|xmlXPtrEval(const xmlChar *str, xmlXPathContextPtr ctx) {
 1344|    486|    xmlXPathParserContextPtr ctxt;
 1345|    486|    xmlXPathObjectPtr res = NULL, tmp;
 1346|    486|    xmlXPathObjectPtr init = NULL;
 1347|    486|    int stack = 0;
 1348|       |
 1349|    486|    xmlInitParser();
 1350|       |
 1351|    486|    if ((ctx == NULL) || (str == NULL))
  ------------------
  |  Branch (1351:9): [True: 0, False: 486]
  |  Branch (1351:26): [True: 0, False: 486]
  ------------------
 1352|      0|	return(NULL);
 1353|       |
 1354|    486|    ctxt = xmlXPathNewParserContext(str, ctx);
 1355|    486|    if (ctxt == NULL)
  ------------------
  |  Branch (1355:9): [True: 9, False: 477]
  ------------------
 1356|      9|	return(NULL);
 1357|    477|    xmlXPtrEvalXPointer(ctxt);
 1358|       |
 1359|    477|    if ((ctxt->value != NULL) &&
  ------------------
  |  Branch (1359:9): [True: 148, False: 329]
  ------------------
 1360|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1361|       |	(ctxt->value->type != XPATH_LOCATIONSET) &&
 1362|       |#endif
 1363|    477|	(ctxt->value->type != XPATH_NODESET)) {
  ------------------
  |  Branch (1363:2): [True: 27, False: 121]
  ------------------
 1364|     27|        xmlXPtrErr(ctxt, XML_XPTR_EVAL_FAILED,
 1365|     27|		"xmlXPtrEval: evaluation failed to return a node set\n",
 1366|     27|		   NULL);
 1367|    450|    } else {
 1368|    450|	res = valuePop(ctxt);
 1369|    450|    }
 1370|       |
 1371|    554|    do {
 1372|    554|        tmp = valuePop(ctxt);
 1373|    554|	if (tmp != NULL) {
  ------------------
  |  Branch (1373:6): [True: 77, False: 477]
  ------------------
 1374|     77|	    if (tmp != init) {
  ------------------
  |  Branch (1374:10): [True: 77, False: 0]
  ------------------
 1375|     77|		if (tmp->type == XPATH_NODESET) {
  ------------------
  |  Branch (1375:7): [True: 25, False: 52]
  ------------------
 1376|       |		    /*
 1377|       |		     * Evaluation may push a root nodeset which is unused
 1378|       |		     */
 1379|     25|		    xmlNodeSetPtr set;
 1380|     25|		    set = tmp->nodesetval;
 1381|     25|		    if ((set == NULL) || (set->nodeNr != 1) ||
  ------------------
  |  Branch (1381:11): [True: 0, False: 25]
  |  Branch (1381:28): [True: 23, False: 2]
  ------------------
 1382|     25|			(set->nodeTab[0] != (xmlNodePtr) ctx->doc))
  ------------------
  |  Branch (1382:4): [True: 2, False: 0]
  ------------------
 1383|     25|			stack++;
 1384|     25|		} else
 1385|     52|		    stack++;
 1386|     77|	    }
 1387|     77|	    xmlXPathFreeObject(tmp);
 1388|     77|        }
 1389|    554|    } while (tmp != NULL);
  ------------------
  |  Branch (1389:14): [True: 77, False: 477]
  ------------------
 1390|    477|    if (stack != 0) {
  ------------------
  |  Branch (1390:9): [True: 27, False: 450]
  ------------------
 1391|     27|        xmlXPtrErr(ctxt, XML_XPTR_EXTRA_OBJECTS,
 1392|     27|		   "xmlXPtrEval: object(s) left on the eval stack\n",
 1393|     27|		   NULL);
 1394|     27|    }
 1395|    477|    if (ctxt->error != XPATH_EXPRESSION_OK) {
  ------------------
  |  Branch (1395:9): [True: 74, False: 403]
  ------------------
 1396|     74|	xmlXPathFreeObject(res);
 1397|     74|	res = NULL;
 1398|     74|    }
 1399|       |
 1400|    477|    xmlXPathFreeParserContext(ctxt);
 1401|    477|    return(res);
 1402|    486|}
xpointer.c:xmlXPtrEvalXPointer:
 1227|    477|xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {
 1228|    477|    if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (1228:9): [True: 477, False: 0]
  ------------------
 1229|       |	/* Allocate the value stack */
 1230|    477|	ctxt->valueTab = (xmlXPathObjectPtr *)
 1231|    477|			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
 1232|    477|	if (ctxt->valueTab == NULL) {
  ------------------
  |  Branch (1232:6): [True: 0, False: 477]
  ------------------
 1233|      0|	    xmlXPtrErrMemory("allocating evaluation context");
 1234|      0|	    return;
 1235|      0|	}
 1236|    477|	ctxt->valueNr = 0;
 1237|    477|	ctxt->valueMax = 10;
 1238|    477|	ctxt->value = NULL;
 1239|    477|    }
 1240|    477|    SKIP_BLANKS;
  ------------------
  |  |  869|    477|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|    477|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1241|    477|    if (CUR == '/') {
  ------------------
  |  |  864|    477|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1241:9): [True: 4, False: 473]
  ------------------
 1242|      4|	xmlXPathRoot(ctxt);
 1243|      4|        xmlXPtrEvalChildSeq(ctxt, NULL);
 1244|    473|    } else {
 1245|    473|	xmlChar *name;
 1246|       |
 1247|    473|	name = xmlXPathParseName(ctxt);
 1248|    473|	if (name == NULL)
  ------------------
  |  Branch (1248:6): [True: 2, False: 471]
  ------------------
 1249|    471|	    XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      2|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1250|    471|	if (CUR == '(') {
  ------------------
  |  |  864|    471|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1250:6): [True: 456, False: 15]
  ------------------
 1251|    456|	    xmlXPtrEvalFullXPtr(ctxt, name);
 1252|       |	    /* Short evaluation */
 1253|    456|	    return;
 1254|    456|	} else {
 1255|       |	    /* this handle both Bare Names and Child Sequences */
 1256|     15|	    xmlXPtrEvalChildSeq(ctxt, name);
 1257|     15|	}
 1258|    471|    }
 1259|     19|    SKIP_BLANKS;
  ------------------
  |  |  869|     19|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|    477|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1260|     19|    if (CUR != 0)
  ------------------
  |  |  864|     19|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1260:9): [True: 8, False: 11]
  ------------------
 1261|     11|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      8|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1262|     11|}
xpointer.c:xmlXPtrEvalChildSeq:
 1176|     31|xmlXPtrEvalChildSeq(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 1177|       |    /*
 1178|       |     * XPointer don't allow by syntax to address in multirooted trees
 1179|       |     * this might prove useful in some cases, warn about it.
 1180|       |     */
 1181|     31|    if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {
  ------------------
  |  |  864|      8|#define CUR (*ctxt->cur)
  ------------------
                  if ((name == NULL) && (CUR == '/') && (NXT(1) != '1')) {
  ------------------
  |  |  866|      8|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (1181:9): [True: 8, False: 23]
  |  Branch (1181:27): [True: 8, False: 0]
  |  Branch (1181:43): [True: 0, False: 8]
  ------------------
 1182|      0|        xmlXPtrErr(ctxt, XML_XPTR_CHILDSEQ_START,
 1183|      0|		   "warning: ChildSeq not starting by /1\n", NULL);
 1184|      0|    }
 1185|       |
 1186|     31|    if (name != NULL) {
  ------------------
  |  Branch (1186:9): [True: 23, False: 8]
  ------------------
 1187|     23|	valuePush(ctxt, xmlXPathNewString(name));
 1188|     23|	xmlFree(name);
 1189|     23|	xmlXPathIdFunction(ctxt, 1);
 1190|     23|	CHECK_ERROR;
  ------------------
  |  |  241|     23|    if (ctxt->error != XPATH_EXPRESSION_OK) return
  |  |  ------------------
  |  |  |  Branch (241:9): [True: 2, False: 21]
  |  |  ------------------
  ------------------
 1191|     23|    }
 1192|       |
 1193|     63|    while (CUR == '/') {
  ------------------
  |  |  864|     63|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1193:12): [True: 34, False: 29]
  ------------------
 1194|     34|	int child = 0, overflow = 0;
 1195|     34|	NEXT;
  ------------------
  |  |  872|     34|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 34, False: 0]
  |  |  ------------------
  ------------------
 1196|       |
 1197|     65|	while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  864|     65|#define CUR (*ctxt->cur)
  ------------------
              	while ((CUR >= '0') && (CUR <= '9')) {
  ------------------
  |  |  864|     33|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1197:9): [True: 33, False: 32]
  |  Branch (1197:25): [True: 31, False: 2]
  ------------------
 1198|     31|            int d = CUR - '0';
  ------------------
  |  |  864|     31|#define CUR (*ctxt->cur)
  ------------------
 1199|     31|            if (child > INT_MAX / 10)
  ------------------
  |  Branch (1199:17): [True: 0, False: 31]
  ------------------
 1200|      0|                overflow = 1;
 1201|     31|            else
 1202|     31|                child *= 10;
 1203|     31|            if (child > INT_MAX - d)
  ------------------
  |  Branch (1203:17): [True: 0, False: 31]
  ------------------
 1204|      0|                overflow = 1;
 1205|     31|            else
 1206|     31|                child += d;
 1207|     31|	    NEXT;
  ------------------
  |  |  872|     31|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 31, False: 0]
  |  |  ------------------
  ------------------
 1208|     31|	}
 1209|     34|        if (overflow)
  ------------------
  |  Branch (1209:13): [True: 0, False: 34]
  ------------------
 1210|      0|            child = 0;
 1211|     34|	xmlXPtrGetChildNo(ctxt, child);
 1212|     34|    }
 1213|     29|}
xpointer.c:xmlXPtrGetChildNo:
  883|     34|xmlXPtrGetChildNo(xmlXPathParserContextPtr ctxt, int indx) {
  884|     34|    xmlNodePtr cur = NULL;
  885|     34|    xmlXPathObjectPtr obj;
  886|     34|    xmlNodeSetPtr oldset;
  887|       |
  888|     34|    CHECK_TYPE(XPATH_NODESET);
  ------------------
  |  |  277|     34|    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
  |  |  ------------------
  |  |  |  Branch (277:9): [True: 0, False: 34]
  |  |  |  Branch (277:34): [True: 0, False: 34]
  |  |  ------------------
  |  |  278|     34|        XP_ERROR(XPATH_INVALID_TYPE)
  |  |  ------------------
  |  |  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  |  |  ------------------
  ------------------
  889|     34|    obj = valuePop(ctxt);
  890|     34|    oldset = obj->nodesetval;
  891|     34|    if ((indx <= 0) || (oldset == NULL) || (oldset->nodeNr != 1)) {
  ------------------
  |  Branch (891:9): [True: 3, False: 31]
  |  Branch (891:24): [True: 0, False: 31]
  |  Branch (891:44): [True: 5, False: 26]
  ------------------
  892|      8|	xmlXPathFreeObject(obj);
  893|      8|	valuePush(ctxt, xmlXPathNewNodeSet(NULL));
  894|      8|	return;
  895|      8|    }
  896|     26|    cur = xmlXPtrGetNthChild(oldset->nodeTab[0], indx);
  897|     26|    if (cur == NULL) {
  ------------------
  |  Branch (897:9): [True: 1, False: 25]
  ------------------
  898|      1|	xmlXPathFreeObject(obj);
  899|      1|	valuePush(ctxt, xmlXPathNewNodeSet(NULL));
  900|      1|	return;
  901|      1|    }
  902|     25|    oldset->nodeTab[0] = cur;
  903|     25|    valuePush(ctxt, obj);
  904|     25|}
xpointer.c:xmlXPtrGetNthChild:
  185|     26|xmlXPtrGetNthChild(xmlNodePtr cur, int no) {
  186|     26|    int i;
  187|     26|    if ((cur == NULL) || (cur->type == XML_NAMESPACE_DECL))
  ------------------
  |  Branch (187:9): [True: 0, False: 26]
  |  Branch (187:26): [True: 0, False: 26]
  ------------------
  188|      0|	return(cur);
  189|     26|    cur = cur->children;
  190|     99|    for (i = 0;i <= no;cur = cur->next) {
  ------------------
  |  Branch (190:16): [True: 99, False: 0]
  ------------------
  191|     99|	if (cur == NULL)
  ------------------
  |  Branch (191:6): [True: 1, False: 98]
  ------------------
  192|      1|	    return(cur);
  193|     98|	if ((cur->type == XML_ELEMENT_NODE) ||
  ------------------
  |  Branch (193:6): [True: 52, False: 46]
  ------------------
  194|     98|	    (cur->type == XML_DOCUMENT_NODE) ||
  ------------------
  |  Branch (194:6): [True: 0, False: 46]
  ------------------
  195|     98|	    (cur->type == XML_HTML_DOCUMENT_NODE)) {
  ------------------
  |  Branch (195:6): [True: 0, False: 46]
  ------------------
  196|     52|	    i++;
  197|     52|	    if (i == no)
  ------------------
  |  Branch (197:10): [True: 25, False: 27]
  ------------------
  198|     25|		break;
  199|     52|	}
  200|     98|    }
  201|     25|    return(cur);
  202|     26|}
xpointer.c:xmlXPtrEvalFullXPtr:
 1104|    456|xmlXPtrEvalFullXPtr(xmlXPathParserContextPtr ctxt, xmlChar *name) {
 1105|    456|    if (name == NULL)
  ------------------
  |  Branch (1105:9): [True: 0, False: 456]
  ------------------
 1106|      0|    name = xmlXPathParseName(ctxt);
 1107|    456|    if (name == NULL)
  ------------------
  |  Branch (1107:9): [True: 0, False: 456]
  ------------------
 1108|    456|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1109|    763|    while (name != NULL) {
  ------------------
  |  Branch (1109:12): [True: 469, False: 294]
  ------------------
 1110|    469|	ctxt->error = XPATH_EXPRESSION_OK;
 1111|    469|	xmlXPtrEvalXPtrPart(ctxt, name);
 1112|       |
 1113|       |	/* in case of syntax error, break here */
 1114|    469|	if ((ctxt->error != XPATH_EXPRESSION_OK) &&
  ------------------
  |  Branch (1114:6): [True: 64, False: 405]
  ------------------
 1115|    469|            (ctxt->error != XML_XPTR_UNKNOWN_SCHEME))
  ------------------
  |  Branch (1115:13): [True: 60, False: 4]
  ------------------
 1116|     60|	    return;
 1117|       |
 1118|       |	/*
 1119|       |	 * If the returned value is a non-empty nodeset
 1120|       |	 * or location set, return here.
 1121|       |	 */
 1122|    409|	if (ctxt->value != NULL) {
  ------------------
  |  Branch (1122:6): [True: 399, False: 10]
  ------------------
 1123|    399|	    xmlXPathObjectPtr obj = ctxt->value;
 1124|       |
 1125|    399|	    switch (obj->type) {
 1126|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1127|       |		case XPATH_LOCATIONSET: {
 1128|       |		    xmlLocationSetPtr loc = ctxt->value->user;
 1129|       |		    if ((loc != NULL) && (loc->locNr > 0))
 1130|       |			return;
 1131|       |		    break;
 1132|       |		}
 1133|       |#endif
 1134|    151|		case XPATH_NODESET: {
  ------------------
  |  Branch (1134:3): [True: 151, False: 248]
  ------------------
 1135|    151|		    xmlNodeSetPtr loc = ctxt->value->nodesetval;
 1136|    151|		    if ((loc != NULL) && (loc->nodeNr > 0))
  ------------------
  |  Branch (1136:11): [True: 144, False: 7]
  |  Branch (1136:28): [True: 102, False: 42]
  ------------------
 1137|    102|			return;
 1138|     49|		    break;
 1139|    151|		}
 1140|    248|		default:
  ------------------
  |  Branch (1140:3): [True: 248, False: 151]
  ------------------
 1141|    248|		    break;
 1142|    399|	    }
 1143|       |
 1144|       |	    /*
 1145|       |	     * Evaluating to improper values is equivalent to
 1146|       |	     * a sub-resource error, clean-up the stack
 1147|       |	     */
 1148|    594|	    do {
 1149|    594|		obj = valuePop(ctxt);
 1150|    594|		if (obj != NULL) {
  ------------------
  |  Branch (1150:7): [True: 297, False: 297]
  ------------------
 1151|    297|		    xmlXPathFreeObject(obj);
 1152|    297|		}
 1153|    594|	    } while (obj != NULL);
  ------------------
  |  Branch (1153:15): [True: 297, False: 297]
  ------------------
 1154|    297|	}
 1155|       |
 1156|       |	/*
 1157|       |	 * Is there another XPointer part.
 1158|       |	 */
 1159|    307|	SKIP_BLANKS;
  ------------------
  |  |  869|    307|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|    415|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 6, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1160|    307|	name = xmlXPathParseName(ctxt);
 1161|    307|    }
 1162|    456|}
xpointer.c:xmlXPtrEvalXPtrPart:
  941|    469|xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {
  942|    469|    xmlChar *buffer, *cur;
  943|    469|    int len;
  944|    469|    int level;
  945|       |
  946|    469|    if (name == NULL)
  ------------------
  |  Branch (946:9): [True: 0, False: 469]
  ------------------
  947|      0|    name = xmlXPathParseName(ctxt);
  948|    469|    if (name == NULL)
  ------------------
  |  Branch (948:9): [True: 0, False: 469]
  ------------------
  949|    469|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  950|       |
  951|    469|    if (CUR != '(') {
  ------------------
  |  |  864|    469|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (951:9): [True: 0, False: 469]
  ------------------
  952|      0|        xmlFree(name);
  953|      0|	XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  954|      0|    }
  955|    469|    NEXT;
  ------------------
  |  |  872|    469|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 469, False: 0]
  |  |  ------------------
  ------------------
  956|    469|    level = 1;
  957|       |
  958|    469|    len = xmlStrlen(ctxt->cur);
  959|    469|    len++;
  960|    469|    buffer = (xmlChar *) xmlMallocAtomic(len);
  961|    469|    if (buffer == NULL) {
  ------------------
  |  Branch (961:9): [True: 0, False: 469]
  ------------------
  962|      0|        xmlXPtrErrMemory("allocating buffer");
  963|      0|        xmlFree(name);
  964|      0|	return;
  965|      0|    }
  966|       |
  967|    469|    cur = buffer;
  968|  9.13k|    while (CUR != 0) {
  ------------------
  |  |  864|  9.13k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (968:12): [True: 9.13k, False: 3]
  ------------------
  969|  9.13k|	if (CUR == ')') {
  ------------------
  |  |  864|  9.13k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (969:6): [True: 758, False: 8.37k]
  ------------------
  970|    758|	    level--;
  971|    758|	    if (level == 0) {
  ------------------
  |  Branch (971:10): [True: 466, False: 292]
  ------------------
  972|    466|		NEXT;
  ------------------
  |  |  872|    466|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 466, False: 0]
  |  |  ------------------
  ------------------
  973|    466|		break;
  974|    466|	    }
  975|  8.37k|	} else if (CUR == '(') {
  ------------------
  |  |  864|  8.37k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (975:13): [True: 292, False: 8.08k]
  ------------------
  976|    292|	    level++;
  977|  8.08k|	} else if (CUR == '^') {
  ------------------
  |  |  864|  8.08k|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (977:13): [True: 0, False: 8.08k]
  ------------------
  978|      0|            if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                          if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
                          if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
  ------------------
  |  |  866|      0|#define NXT(val) ctxt->cur[(val)]
  ------------------
  |  Branch (978:17): [True: 0, False: 0]
  |  Branch (978:36): [True: 0, False: 0]
  |  Branch (978:55): [True: 0, False: 0]
  ------------------
  979|      0|                NEXT;
  ------------------
  |  |  872|      0|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  ------------------
  ------------------
  980|      0|            }
  981|      0|	}
  982|  8.66k|        *cur++ = CUR;
  ------------------
  |  |  864|  8.66k|#define CUR (*ctxt->cur)
  ------------------
  983|  8.66k|	NEXT;
  ------------------
  |  |  872|  8.66k|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 8.66k, False: 0]
  |  |  ------------------
  ------------------
  984|  8.66k|    }
  985|    469|    *cur = 0;
  986|       |
  987|    469|    if ((level != 0) && (CUR == 0)) {
  ------------------
  |  |  864|      3|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (987:9): [True: 3, False: 466]
  |  Branch (987:25): [True: 3, False: 0]
  ------------------
  988|      3|        xmlFree(name);
  989|      3|	xmlFree(buffer);
  990|      3|	XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      3|    { xmlXPathErr(ctxt, X); return; }
  ------------------
  991|      0|    }
  992|       |
  993|    466|    if (xmlStrEqual(name, (xmlChar *) "xpointer") ||
  ------------------
  |  Branch (993:9): [True: 423, False: 43]
  ------------------
  994|    466|        xmlStrEqual(name, (xmlChar *) "xpath1")) {
  ------------------
  |  Branch (994:9): [True: 21, False: 22]
  ------------------
  995|    444|	const xmlChar *oldBase = ctxt->base;
  996|    444|	const xmlChar *oldCur = ctxt->cur;
  997|       |
  998|    444|	ctxt->cur = ctxt->base = buffer;
  999|       |	/*
 1000|       |	 * To evaluate an xpointer scheme element (4.3) we need:
 1001|       |	 *   context initialized to the root
 1002|       |	 *   context position initialized to 1
 1003|       |	 *   context size initialized to 1
 1004|       |	 */
 1005|    444|	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;
 1006|    444|	ctxt->context->proximityPosition = 1;
 1007|    444|	ctxt->context->contextSize = 1;
 1008|       |#ifdef LIBXML_XPTR_LOCS_ENABLED
 1009|       |        ctxt->xptr = xmlStrEqual(name, (xmlChar *) "xpointer");
 1010|       |#endif
 1011|    444|	xmlXPathEvalExpr(ctxt);
 1012|    444|	ctxt->base = oldBase;
 1013|    444|        ctxt->cur = oldCur;
 1014|    444|    } else if (xmlStrEqual(name, (xmlChar *) "element")) {
  ------------------
  |  Branch (1014:16): [True: 12, False: 10]
  ------------------
 1015|     12|	const xmlChar *oldBase = ctxt->base;
 1016|     12|	const xmlChar *oldCur = ctxt->cur;
 1017|     12|	xmlChar *name2;
 1018|       |
 1019|     12|	ctxt->cur = ctxt->base = buffer;
 1020|     12|	if (buffer[0] == '/') {
  ------------------
  |  Branch (1020:6): [True: 4, False: 8]
  ------------------
 1021|      4|	    xmlXPathRoot(ctxt);
 1022|      4|	    xmlXPtrEvalChildSeq(ctxt, NULL);
 1023|      8|	} else {
 1024|      8|	    name2 = xmlXPathParseName(ctxt);
 1025|      8|	    if (name2 == NULL) {
  ------------------
  |  Branch (1025:10): [True: 0, False: 8]
  ------------------
 1026|      0|                ctxt->base = oldBase;
 1027|      0|                ctxt->cur = oldCur;
 1028|      0|		xmlFree(buffer);
 1029|      0|                xmlFree(name);
 1030|      0|		XP_ERROR(XPATH_EXPR_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1031|      0|	    }
 1032|      8|	    xmlXPtrEvalChildSeq(ctxt, name2);
 1033|      8|	}
 1034|     12|	ctxt->base = oldBase;
 1035|     12|        ctxt->cur = oldCur;
 1036|     12|#ifdef XPTR_XMLNS_SCHEME
 1037|     12|    } else if (xmlStrEqual(name, (xmlChar *) "xmlns")) {
  ------------------
  |  Branch (1037:16): [True: 6, False: 4]
  ------------------
 1038|      6|	const xmlChar *oldBase = ctxt->base;
 1039|      6|	const xmlChar *oldCur = ctxt->cur;
 1040|      6|	xmlChar *prefix;
 1041|       |
 1042|      6|	ctxt->cur = ctxt->base = buffer;
 1043|      6|        prefix = xmlXPathParseNCName(ctxt);
 1044|      6|	if (prefix == NULL) {
  ------------------
  |  Branch (1044:6): [True: 0, False: 6]
  ------------------
 1045|      0|            ctxt->base = oldBase;
 1046|      0|            ctxt->cur = oldCur;
 1047|      0|	    xmlFree(buffer);
 1048|      0|	    xmlFree(name);
 1049|      0|	    XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1050|      0|	}
 1051|      6|	SKIP_BLANKS;
  ------------------
  |  |  869|      6|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1052|      6|	if (CUR != '=') {
  ------------------
  |  |  864|      6|#define CUR (*ctxt->cur)
  ------------------
  |  Branch (1052:6): [True: 0, False: 6]
  ------------------
 1053|      0|            ctxt->base = oldBase;
 1054|      0|            ctxt->cur = oldCur;
 1055|      0|	    xmlFree(prefix);
 1056|      0|	    xmlFree(buffer);
 1057|      0|	    xmlFree(name);
 1058|      0|	    XP_ERROR(XPTR_SYNTAX_ERROR);
  ------------------
  |  |  258|      0|    { xmlXPathErr(ctxt, X); return; }
  ------------------
 1059|      0|	}
 1060|      6|	NEXT;
  ------------------
  |  |  872|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  ------------------
  |  |  |  Branch (872:15): [True: 6, False: 0]
  |  |  ------------------
  ------------------
 1061|      6|	SKIP_BLANKS;
  ------------------
  |  |  869|      6|    while (IS_BLANK_CH(*(ctxt->cur))) NEXT
  |  |  ------------------
  |  |  |  |  872|      6|#define NEXT ((*ctxt->cur) ?  ctxt->cur++: ctxt->cur)
  |  |  |  |  ------------------
  |  |  |  |  |  Branch (872:15): [True: 0, False: 0]
  |  |  |  |  ------------------
  |  |  ------------------
  ------------------
 1062|       |
 1063|      6|	xmlXPathRegisterNs(ctxt->context, prefix, ctxt->cur);
 1064|      6|        ctxt->base = oldBase;
 1065|      6|        ctxt->cur = oldCur;
 1066|      6|	xmlFree(prefix);
 1067|      6|#endif /* XPTR_XMLNS_SCHEME */
 1068|      6|    } else {
 1069|      4|        xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,
 1070|      4|		   "unsupported scheme '%s'\n", name);
 1071|      4|    }
 1072|    466|    xmlFree(buffer);
 1073|    466|    xmlFree(name);
 1074|    466|}
xpointer.c:xmlXPtrErr:
   90|     58|{
   91|     58|    if (ctxt != NULL)
  ------------------
  |  Branch (91:9): [True: 58, False: 0]
  ------------------
   92|     58|        ctxt->error = error;
   93|     58|    if ((ctxt == NULL) || (ctxt->context == NULL)) {
  ------------------
  |  Branch (93:9): [True: 0, False: 58]
  |  Branch (93:27): [True: 0, False: 58]
  ------------------
   94|      0|	__xmlRaiseError(NULL, NULL, NULL,
   95|      0|			NULL, NULL, XML_FROM_XPOINTER, error,
   96|      0|			XML_ERR_ERROR, NULL, 0,
   97|      0|			(const char *) extra, NULL, NULL, 0, 0,
   98|      0|			msg, extra);
   99|      0|	return;
  100|      0|    }
  101|       |
  102|       |    /* cleanup current last error */
  103|     58|    xmlResetError(&ctxt->context->lastError);
  104|       |
  105|     58|    ctxt->context->lastError.domain = XML_FROM_XPOINTER;
  106|     58|    ctxt->context->lastError.code = error;
  107|     58|    ctxt->context->lastError.level = XML_ERR_ERROR;
  108|     58|    ctxt->context->lastError.str1 = (char *) xmlStrdup(ctxt->base);
  109|     58|    ctxt->context->lastError.int1 = ctxt->cur - ctxt->base;
  110|     58|    ctxt->context->lastError.node = ctxt->context->debugNode;
  111|     58|    if (ctxt->context->error != NULL) {
  ------------------
  |  Branch (111:9): [True: 0, False: 58]
  ------------------
  112|      0|	ctxt->context->error(ctxt->context->userData,
  113|      0|	                     &ctxt->context->lastError);
  114|     58|    } else {
  115|     58|	__xmlRaiseError(NULL, NULL, NULL,
  116|     58|			NULL, ctxt->context->debugNode, XML_FROM_XPOINTER,
  117|     58|			error, XML_ERR_ERROR, NULL, 0,
  118|     58|			(const char *) extra, (const char *) ctxt->base, NULL,
  119|     58|			ctxt->cur - ctxt->base, 0,
  120|     58|			msg, extra);
  121|     58|    }
  122|     58|}

